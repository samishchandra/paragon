import { jsxDEV as y, Fragment as fn } from "react/jsx-dev-runtime";
import * as N from "react";
import ot, { createRef as xx, memo as si, createContext as jl, createElement as Aa, version as zh, useState as J, useLayoutEffect as eb, useEffect as ge, useDebugValue as tb, useContext as Yl, useRef as fe, forwardRef as Xl, useMemo as Xi, useCallback as ie, useImperativeHandle as Nx } from "react";
import * as nb from "react-dom";
import rb, { flushSync as Ex, createPortal as ai } from "react-dom";
import { jsx as R, jsxs as ob, Fragment as Hd } from "react/jsx-runtime";
function Sx(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Ps = { exports: {} }, zc = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var $h;
function Tx() {
  if ($h) return zc;
  $h = 1;
  var t = ot;
  function e(d, f) {
    return d === f && (d !== 0 || 1 / d === 1 / f) || d !== d && f !== f;
  }
  var n = typeof Object.is == "function" ? Object.is : e, r = t.useState, o = t.useEffect, i = t.useLayoutEffect, s = t.useDebugValue;
  function a(d, f) {
    var h = f(), m = r({ inst: { value: h, getSnapshot: f } }), p = m[0].inst, g = m[1];
    return i(
      function() {
        p.value = h, p.getSnapshot = f, l(p) && g({ inst: p });
      },
      [d, h, f]
    ), o(
      function() {
        return l(p) && g({ inst: p }), d(function() {
          l(p) && g({ inst: p });
        });
      },
      [d]
    ), s(h), h;
  }
  function l(d) {
    var f = d.getSnapshot;
    d = d.value;
    try {
      var h = f();
      return !n(d, h);
    } catch {
      return !0;
    }
  }
  function c(d, f) {
    return f();
  }
  var u = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? c : a;
  return zc.useSyncExternalStore = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : u, zc;
}
var $c = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Hh;
function Cx() {
  return Hh || (Hh = 1, process.env.NODE_ENV !== "production" && (function() {
    function t(h, m) {
      return h === m && (h !== 0 || 1 / h === 1 / m) || h !== h && m !== m;
    }
    function e(h, m) {
      u || o.startTransition === void 0 || (u = !0, console.error(
        "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
      ));
      var p = m();
      if (!d) {
        var g = m();
        i(p, g) || (console.error(
          "The result of getSnapshot should be cached to avoid an infinite loop"
        ), d = !0);
      }
      g = s({
        inst: { value: p, getSnapshot: m }
      });
      var b = g[0].inst, v = g[1];
      return l(
        function() {
          b.value = p, b.getSnapshot = m, n(b) && v({ inst: b });
        },
        [h, p, m]
      ), a(
        function() {
          return n(b) && v({ inst: b }), h(function() {
            n(b) && v({ inst: b });
          });
        },
        [h]
      ), c(p), p;
    }
    function n(h) {
      var m = h.getSnapshot;
      h = h.value;
      try {
        var p = m();
        return !i(h, p);
      } catch {
        return !0;
      }
    }
    function r(h, m) {
      return m();
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var o = ot, i = typeof Object.is == "function" ? Object.is : t, s = o.useState, a = o.useEffect, l = o.useLayoutEffect, c = o.useDebugValue, u = !1, d = !1, f = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? r : e;
    $c.useSyncExternalStore = o.useSyncExternalStore !== void 0 ? o.useSyncExternalStore : f, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })()), $c;
}
var Fh;
function Fd() {
  return Fh || (Fh = 1, process.env.NODE_ENV === "production" ? Ps.exports = Tx() : Ps.exports = Cx()), Ps.exports;
}
var ib = Fd();
function vt(t) {
  this.content = t;
}
vt.prototype = {
  constructor: vt,
  find: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === t) return e;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(t) {
    var e = this.find(t);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(t, e, n) {
    var r = n && n != t ? this.remove(n) : this, o = r.find(t), i = r.content.slice();
    return o == -1 ? i.push(n || t, e) : (i[o + 1] = e, n && (i[o] = n)), new vt(i);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(t) {
    var e = this.find(t);
    if (e == -1) return this;
    var n = this.content.slice();
    return n.splice(e, 2), new vt(n);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(t, e) {
    return new vt([t, e].concat(this.remove(t).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(t, e) {
    var n = this.remove(t).content.slice();
    return n.push(t, e), new vt(n);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(t, e, n) {
    var r = this.remove(e), o = r.content.slice(), i = r.find(t);
    return o.splice(i == -1 ? o.length : i, 0, e, n), new vt(o);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(t) {
    for (var e = 0; e < this.content.length; e += 2)
      t(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(t) {
    return t = vt.from(t), t.size ? new vt(t.content.concat(this.subtract(t).content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(t) {
    return t = vt.from(t), t.size ? new vt(this.subtract(t).content.concat(t.content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(t) {
    var e = this;
    t = vt.from(t);
    for (var n = 0; n < t.content.length; n += 2)
      e = e.remove(t.content[n]);
    return e;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var t = {};
    return this.forEach(function(e, n) {
      t[e] = n;
    }), t;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
vt.from = function(t) {
  if (t instanceof vt) return t;
  var e = [];
  if (t) for (var n in t) e.push(n, t[n]);
  return new vt(e);
};
function sb(t, e, n) {
  for (let r = 0; ; r++) {
    if (r == t.childCount || r == e.childCount)
      return t.childCount == e.childCount ? null : n;
    let o = t.child(r), i = e.child(r);
    if (o == i) {
      n += o.nodeSize;
      continue;
    }
    if (!o.sameMarkup(i))
      return n;
    if (o.isText && o.text != i.text) {
      for (let s = 0; o.text[s] == i.text[s]; s++)
        n++;
      return n;
    }
    if (o.content.size || i.content.size) {
      let s = sb(o.content, i.content, n + 1);
      if (s != null)
        return s;
    }
    n += o.nodeSize;
  }
}
function ab(t, e, n, r) {
  for (let o = t.childCount, i = e.childCount; ; ) {
    if (o == 0 || i == 0)
      return o == i ? null : { a: n, b: r };
    let s = t.child(--o), a = e.child(--i), l = s.nodeSize;
    if (s == a) {
      n -= l, r -= l;
      continue;
    }
    if (!s.sameMarkup(a))
      return { a: n, b: r };
    if (s.isText && s.text != a.text) {
      let c = 0, u = Math.min(s.text.length, a.text.length);
      for (; c < u && s.text[s.text.length - c - 1] == a.text[a.text.length - c - 1]; )
        c++, n--, r--;
      return { a: n, b: r };
    }
    if (s.content.size || a.content.size) {
      let c = ab(s.content, a.content, n - 1, r - 1);
      if (c)
        return c;
    }
    n -= l, r -= l;
  }
}
class D {
  /**
  @internal
  */
  constructor(e, n) {
    if (this.content = e, this.size = n || 0, n == null)
      for (let r = 0; r < e.length; r++)
        this.size += e[r].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, n, r, o = 0, i) {
    for (let s = 0, a = 0; a < n; s++) {
      let l = this.content[s], c = a + l.nodeSize;
      if (c > e && r(l, o + a, i || null, s) !== !1 && l.content.size) {
        let u = a + 1;
        l.nodesBetween(Math.max(0, e - u), Math.min(l.content.size, n - u), r, o + u);
      }
      a = c;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, n, r, o) {
    let i = "", s = !0;
    return this.nodesBetween(e, n, (a, l) => {
      let c = a.isText ? a.text.slice(Math.max(e, l) - l, n - l) : a.isLeaf ? o ? typeof o == "function" ? o(a) : o : a.type.spec.leafText ? a.type.spec.leafText(a) : "" : "";
      a.isBlock && (a.isLeaf && c || a.isTextblock) && r && (s ? s = !1 : i += r), i += c;
    }, 0), i;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let n = this.lastChild, r = e.firstChild, o = this.content.slice(), i = 0;
    for (n.isText && n.sameMarkup(r) && (o[o.length - 1] = n.withText(n.text + r.text), i = 1); i < e.content.length; i++)
      o.push(e.content[i]);
    return new D(o, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, n = this.size) {
    if (e == 0 && n == this.size)
      return this;
    let r = [], o = 0;
    if (n > e)
      for (let i = 0, s = 0; s < n; i++) {
        let a = this.content[i], l = s + a.nodeSize;
        l > e && ((s < e || l > n) && (a.isText ? a = a.cut(Math.max(0, e - s), Math.min(a.text.length, n - s)) : a = a.cut(Math.max(0, e - s - 1), Math.min(a.content.size, n - s - 1))), r.push(a), o += a.nodeSize), s = l;
      }
    return new D(r, o);
  }
  /**
  @internal
  */
  cutByIndex(e, n) {
    return e == n ? D.empty : e == 0 && n == this.content.length ? this : new D(this.content.slice(e, n));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, n) {
    let r = this.content[e];
    if (r == n)
      return this;
    let o = this.content.slice(), i = this.size + n.nodeSize - r.nodeSize;
    return o[e] = n, new D(o, i);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new D([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new D(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let n = 0; n < this.content.length; n++)
      if (!this.content[n].eq(e.content[n]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let n = this.content[e];
    if (!n)
      throw new RangeError("Index " + e + " out of range for " + this);
    return n;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let n = 0, r = 0; n < this.content.length; n++) {
      let o = this.content[n];
      e(o, r, n), r += o.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, n = 0) {
    return sb(this, e, n);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, n = this.size, r = e.size) {
    return ab(this, e, n, r);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(e) {
    if (e == 0)
      return Bs(0, e);
    if (e == this.size)
      return Bs(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let n = 0, r = 0; ; n++) {
      let o = this.child(n), i = r + o.nodeSize;
      if (i >= e)
        return i == e ? Bs(n + 1, i) : Bs(n, r);
      r = i;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return D.empty;
    if (!Array.isArray(n))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new D(n.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return D.empty;
    let n, r = 0;
    for (let o = 0; o < e.length; o++) {
      let i = e[o];
      r += i.nodeSize, o && i.isText && e[o - 1].sameMarkup(i) ? (n || (n = e.slice(0, o)), n[n.length - 1] = i.withText(n[n.length - 1].text + i.text)) : n && n.push(i);
    }
    return new D(n || e, r);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return D.empty;
    if (e instanceof D)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new D([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
D.empty = new D([], 0);
const Hc = { index: 0, offset: 0 };
function Bs(t, e) {
  return Hc.index = t, Hc.offset = e, Hc;
}
function _a(t, e) {
  if (t === e)
    return !0;
  if (!(t && typeof t == "object") || !(e && typeof e == "object"))
    return !1;
  let n = Array.isArray(t);
  if (Array.isArray(e) != n)
    return !1;
  if (n) {
    if (t.length != e.length)
      return !1;
    for (let r = 0; r < t.length; r++)
      if (!_a(t[r], e[r]))
        return !1;
  } else {
    for (let r in t)
      if (!(r in e) || !_a(t[r], e[r]))
        return !1;
    for (let r in e)
      if (!(r in t))
        return !1;
  }
  return !0;
}
let We = class Lu {
  /**
  @internal
  */
  constructor(e, n) {
    this.type = e, this.attrs = n;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let n, r = !1;
    for (let o = 0; o < e.length; o++) {
      let i = e[o];
      if (this.eq(i))
        return e;
      if (this.type.excludes(i.type))
        n || (n = e.slice(0, o));
      else {
        if (i.type.excludes(this.type))
          return e;
        !r && i.type.rank > this.type.rank && (n || (n = e.slice(0, o)), n.push(this), r = !0), n && n.push(i);
      }
    }
    return n || (n = e.slice()), r || n.push(this), n;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return e.slice(0, n).concat(e.slice(n + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (this.eq(e[n]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && _a(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let r = e.marks[n.type];
    if (!r)
      throw new RangeError(`There is no mark type ${n.type} in this schema`);
    let o = r.create(n.attrs);
    return r.checkAttrs(o.attrs), o;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, n) {
    if (e == n)
      return !0;
    if (e.length != n.length)
      return !1;
    for (let r = 0; r < e.length; r++)
      if (!e[r].eq(n[r]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return Lu.none;
    if (e instanceof Lu)
      return [e];
    let n = e.slice();
    return n.sort((r, o) => r.type.rank - o.type.rank), n;
  }
};
We.none = [];
class Ra extends Error {
}
class Y {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, n, r) {
    this.content = e, this.openStart = n, this.openEnd = r;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, n) {
    let r = cb(this.content, e + this.openStart, n);
    return r && new Y(r, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, n) {
    return new Y(lb(this.content, e + this.openStart, n + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      return Y.empty;
    let r = n.openStart || 0, o = n.openEnd || 0;
    if (typeof r != "number" || typeof o != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new Y(D.fromJSON(e, n.content), r, o);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, n = !0) {
    let r = 0, o = 0;
    for (let i = e.firstChild; i && !i.isLeaf && (n || !i.type.spec.isolating); i = i.firstChild)
      r++;
    for (let i = e.lastChild; i && !i.isLeaf && (n || !i.type.spec.isolating); i = i.lastChild)
      o++;
    return new Y(e, r, o);
  }
}
Y.empty = new Y(D.empty, 0, 0);
function lb(t, e, n) {
  let { index: r, offset: o } = t.findIndex(e), i = t.maybeChild(r), { index: s, offset: a } = t.findIndex(n);
  if (o == e || i.isText) {
    if (a != n && !t.child(s).isText)
      throw new RangeError("Removing non-flat range");
    return t.cut(0, e).append(t.cut(n));
  }
  if (r != s)
    throw new RangeError("Removing non-flat range");
  return t.replaceChild(r, i.copy(lb(i.content, e - o - 1, n - o - 1)));
}
function cb(t, e, n, r) {
  let { index: o, offset: i } = t.findIndex(e), s = t.maybeChild(o);
  if (i == e || s.isText)
    return r && !r.canReplace(o, o, n) ? null : t.cut(0, e).append(n).append(t.cut(e));
  let a = cb(s.content, e - i - 1, n, s);
  return a && t.replaceChild(o, s.copy(a));
}
function Mx(t, e, n) {
  if (n.openStart > t.depth)
    throw new Ra("Inserted content deeper than insertion position");
  if (t.depth - n.openStart != e.depth - n.openEnd)
    throw new Ra("Inconsistent open depths");
  return ub(t, e, n, 0);
}
function ub(t, e, n, r) {
  let o = t.index(r), i = t.node(r);
  if (o == e.index(r) && r < t.depth - n.openStart) {
    let s = ub(t, e, n, r + 1);
    return i.copy(i.content.replaceChild(o, s));
  } else if (n.content.size)
    if (!n.openStart && !n.openEnd && t.depth == r && e.depth == r) {
      let s = t.parent, a = s.content;
      return Gr(s, a.cut(0, t.parentOffset).append(n.content).append(a.cut(e.parentOffset)));
    } else {
      let { start: s, end: a } = Ax(n, t);
      return Gr(i, fb(t, s, a, e, r));
    }
  else return Gr(i, Oa(t, e, r));
}
function db(t, e) {
  if (!e.type.compatibleContent(t.type))
    throw new Ra("Cannot join " + e.type.name + " onto " + t.type.name);
}
function Pu(t, e, n) {
  let r = t.node(n);
  return db(r, e.node(n)), r;
}
function qr(t, e) {
  let n = e.length - 1;
  n >= 0 && t.isText && t.sameMarkup(e[n]) ? e[n] = t.withText(e[n].text + t.text) : e.push(t);
}
function Pi(t, e, n, r) {
  let o = (e || t).node(n), i = 0, s = e ? e.index(n) : o.childCount;
  t && (i = t.index(n), t.depth > n ? i++ : t.textOffset && (qr(t.nodeAfter, r), i++));
  for (let a = i; a < s; a++)
    qr(o.child(a), r);
  e && e.depth == n && e.textOffset && qr(e.nodeBefore, r);
}
function Gr(t, e) {
  return t.type.checkContent(e), t.copy(e);
}
function fb(t, e, n, r, o) {
  let i = t.depth > o && Pu(t, e, o + 1), s = r.depth > o && Pu(n, r, o + 1), a = [];
  return Pi(null, t, o, a), i && s && e.index(o) == n.index(o) ? (db(i, s), qr(Gr(i, fb(t, e, n, r, o + 1)), a)) : (i && qr(Gr(i, Oa(t, e, o + 1)), a), Pi(e, n, o, a), s && qr(Gr(s, Oa(n, r, o + 1)), a)), Pi(r, null, o, a), new D(a);
}
function Oa(t, e, n) {
  let r = [];
  if (Pi(null, t, n, r), t.depth > n) {
    let o = Pu(t, e, n + 1);
    qr(Gr(o, Oa(t, e, n + 1)), r);
  }
  return Pi(e, null, n, r), new D(r);
}
function Ax(t, e) {
  let n = e.depth - t.openStart, o = e.node(n).copy(t.content);
  for (let i = n - 1; i >= 0; i--)
    o = e.node(i).copy(D.from(o));
  return {
    start: o.resolveNoCache(t.openStart + n),
    end: o.resolveNoCache(o.content.size - t.openEnd - n)
  };
}
class Zi {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.pos = e, this.path = n, this.parentOffset = r, this.depth = n.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, n = this.index(this.depth);
    if (n == e.childCount)
      return null;
    let r = this.pos - this.path[this.path.length - 1], o = e.child(n);
    return r ? e.child(n).cut(r) : o;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), n = this.pos - this.path[this.path.length - 1];
    return n ? this.parent.child(e).cut(0, n) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, n) {
    n = this.resolveDepth(n);
    let r = this.path[n * 3], o = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
    for (let i = 0; i < e; i++)
      o += r.child(i).nodeSize;
    return o;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, n = this.index();
    if (e.content.size == 0)
      return We.none;
    if (this.textOffset)
      return e.child(n).marks;
    let r = e.maybeChild(n - 1), o = e.maybeChild(n);
    if (!r) {
      let a = r;
      r = o, o = a;
    }
    let i = r.marks;
    for (var s = 0; s < i.length; s++)
      i[s].type.spec.inclusive === !1 && (!o || !i[s].isInSet(o.marks)) && (i = i[s--].removeFromSet(i));
    return i;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let n = this.parent.maybeChild(this.index());
    if (!n || !n.isInline)
      return null;
    let r = n.marks, o = e.parent.maybeChild(e.index());
    for (var i = 0; i < r.length; i++)
      r[i].type.spec.inclusive === !1 && (!o || !r[i].isInSet(o.marks)) && (r = r[i--].removeFromSet(r));
    return r;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let n = this.depth; n > 0; n--)
      if (this.start(n) <= e && this.end(n) >= e)
        return n;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, n) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)
      if (e.pos <= this.end(r) && (!n || n(this.node(r))))
        return new Ia(this, e, r);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let n = 1; n <= this.depth; n++)
      e += (e ? "/" : "") + this.node(n).type.name + "_" + this.index(n - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, n) {
    if (!(n >= 0 && n <= e.content.size))
      throw new RangeError("Position " + n + " out of range");
    let r = [], o = 0, i = n;
    for (let s = e; ; ) {
      let { index: a, offset: l } = s.content.findIndex(i), c = i - l;
      if (r.push(s, a, o + l), !c || (s = s.child(a), s.isText))
        break;
      i = c - 1, o += l + 1;
    }
    return new Zi(n, r, i);
  }
  /**
  @internal
  */
  static resolveCached(e, n) {
    let r = Uh.get(e);
    if (r)
      for (let i = 0; i < r.elts.length; i++) {
        let s = r.elts[i];
        if (s.pos == n)
          return s;
      }
    else
      Uh.set(e, r = new _x());
    let o = r.elts[r.i] = Zi.resolve(e, n);
    return r.i = (r.i + 1) % Rx, o;
  }
}
class _x {
  constructor() {
    this.elts = [], this.i = 0;
  }
}
const Rx = 12, Uh = /* @__PURE__ */ new WeakMap();
class Ia {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, n, r) {
    this.$from = e, this.$to = n, this.depth = r;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const Ox = /* @__PURE__ */ Object.create(null);
let xr = class Bu {
  /**
  @internal
  */
  constructor(e, n, r, o = We.none) {
    this.type = e, this.attrs = n, this.marks = o, this.content = r || D.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(e, n, r, o = 0) {
    this.content.nodesBetween(e, n, r, o, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec.leafText) will be used.
  */
  textBetween(e, n, r, o) {
    return this.content.textBetween(e, n, r, o);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, n, r) {
    return this.type == e && _a(this.attrs, n || e.defaultAttrs || Ox) && We.sameSet(this.marks, r || We.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new Bu(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new Bu(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, n = this.content.size) {
    return e == 0 && n == this.content.size ? this : this.copy(this.content.cut(e, n));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, n = this.content.size, r = !1) {
    if (e == n)
      return Y.empty;
    let o = this.resolve(e), i = this.resolve(n), s = r ? 0 : o.sharedDepth(n), a = o.start(s), c = o.node(s).content.cut(o.pos - a, i.pos - a);
    return new Y(c, o.depth - s, i.depth - s);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, n, r) {
    return Mx(this.resolve(e), this.resolve(n), r);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let n = this; ; ) {
      let { index: r, offset: o } = n.content.findIndex(e);
      if (n = n.maybeChild(r), !n)
        return null;
      if (o == e || n.isText)
        return n;
      e -= o + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: n, offset: r } = this.content.findIndex(e);
    return { node: this.content.maybeChild(n), index: n, offset: r };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: n, offset: r } = this.content.findIndex(e);
    if (r < e)
      return { node: this.content.child(n), index: n, offset: r };
    let o = this.content.child(n - 1);
    return { node: o, index: n - 1, offset: r - o.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return Zi.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return Zi.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, n, r) {
    let o = !1;
    return n > e && this.nodesBetween(e, n, (i) => (r.isInSet(i.marks) && (o = !0), !o)), o;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), hb(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let n = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!n)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return n;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, n, r = D.empty, o = 0, i = r.childCount) {
    let s = this.contentMatchAt(e).matchFragment(r, o, i), a = s && s.matchFragment(this.content, n);
    if (!a || !a.validEnd)
      return !1;
    for (let l = o; l < i; l++)
      if (!this.type.allowsMarks(r.child(l).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, n, r, o) {
    if (o && !this.type.allowsMarks(o))
      return !1;
    let i = this.contentMatchAt(e).matchType(r), s = i && i.matchFragment(this.content, n);
    return s ? s.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
    let e = We.none;
    for (let n = 0; n < this.marks.length; n++) {
      let r = this.marks[n];
      r.type.checkAttrs(r.attrs), e = r.addToSet(e);
    }
    if (!We.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((n) => n.type.name)}`);
    this.content.forEach((n) => n.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let n in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((n) => n.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, n) {
    if (!n)
      throw new RangeError("Invalid input for Node.fromJSON");
    let r;
    if (n.marks) {
      if (!Array.isArray(n.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      r = n.marks.map(e.markFromJSON);
    }
    if (n.type == "text") {
      if (typeof n.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(n.text, r);
    }
    let o = D.fromJSON(e, n.content), i = e.nodeType(n.type).create(n.attrs, o, r);
    return i.type.checkAttrs(i.attrs), i;
  }
};
xr.prototype.text = void 0;
class Da extends xr {
  /**
  @internal
  */
  constructor(e, n, r, o) {
    if (super(e, n, null, o), !r)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = r;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : hb(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, n) {
    return this.text.slice(e, n);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new Da(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new Da(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, n = this.text.length) {
    return e == 0 && n == this.text.length ? this : this.withText(this.text.slice(e, n));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
}
function hb(t, e) {
  for (let n = t.length - 1; n >= 0; n--)
    e = t[n].type.name + "(" + e + ")";
  return e;
}
class Zr {
  /**
  @internal
  */
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(e, n) {
    let r = new Ix(e, n);
    if (r.next == null)
      return Zr.empty;
    let o = mb(r);
    r.next && r.err("Unexpected trailing text");
    let i = Hx($x(o));
    return Fx(i, r), i;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let n = 0; n < this.next.length; n++)
      if (this.next[n].type == e)
        return this.next[n].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, n = 0, r = e.childCount) {
    let o = this;
    for (let i = n; o && i < r; i++)
      o = o.matchType(e.child(i).type);
    return o;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: n } = this.next[e];
      if (!(n.isText || n.hasRequiredAttrs()))
        return n;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let n = 0; n < this.next.length; n++)
      for (let r = 0; r < e.next.length; r++)
        if (this.next[n].type == e.next[r].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, n = !1, r = 0) {
    let o = [this];
    function i(s, a) {
      let l = s.matchFragment(e, r);
      if (l && (!n || l.validEnd))
        return D.from(a.map((c) => c.createAndFill()));
      for (let c = 0; c < s.next.length; c++) {
        let { type: u, next: d } = s.next[c];
        if (!(u.isText || u.hasRequiredAttrs()) && o.indexOf(d) == -1) {
          o.push(d);
          let f = i(d, a.concat(u));
          if (f)
            return f;
        }
      }
      return null;
    }
    return i(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let r = 0; r < this.wrapCache.length; r += 2)
      if (this.wrapCache[r] == e)
        return this.wrapCache[r + 1];
    let n = this.computeWrapping(e);
    return this.wrapCache.push(e, n), n;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let n = /* @__PURE__ */ Object.create(null), r = [{ match: this, type: null, via: null }];
    for (; r.length; ) {
      let o = r.shift(), i = o.match;
      if (i.matchType(e)) {
        let s = [];
        for (let a = o; a.type; a = a.via)
          s.push(a.type);
        return s.reverse();
      }
      for (let s = 0; s < i.next.length; s++) {
        let { type: a, next: l } = i.next[s];
        !a.isLeaf && !a.hasRequiredAttrs() && !(a.name in n) && (!o.type || l.validEnd) && (r.push({ match: a.contentMatch, type: a, via: o }), n[a.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function n(r) {
      e.push(r);
      for (let o = 0; o < r.next.length; o++)
        e.indexOf(r.next[o].next) == -1 && n(r.next[o].next);
    }
    return n(this), e.map((r, o) => {
      let i = o + (r.validEnd ? "*" : " ") + " ";
      for (let s = 0; s < r.next.length; s++)
        i += (s ? ", " : "") + r.next[s].type.name + "->" + e.indexOf(r.next[s].next);
      return i;
    }).join(`
`);
  }
}
Zr.empty = new Zr(!0);
class Ix {
  constructor(e, n) {
    this.string = e, this.nodeTypes = n, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function mb(t) {
  let e = [];
  do
    e.push(Dx(t));
  while (t.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function Dx(t) {
  let e = [];
  do
    e.push(Lx(t));
  while (t.next && t.next != ")" && t.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function Lx(t) {
  let e = zx(t);
  for (; ; )
    if (t.eat("+"))
      e = { type: "plus", expr: e };
    else if (t.eat("*"))
      e = { type: "star", expr: e };
    else if (t.eat("?"))
      e = { type: "opt", expr: e };
    else if (t.eat("{"))
      e = Px(t, e);
    else
      break;
  return e;
}
function Wh(t) {
  /\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'");
  let e = Number(t.next);
  return t.pos++, e;
}
function Px(t, e) {
  let n = Wh(t), r = n;
  return t.eat(",") && (t.next != "}" ? r = Wh(t) : r = -1), t.eat("}") || t.err("Unclosed braced range"), { type: "range", min: n, max: r, expr: e };
}
function Bx(t, e) {
  let n = t.nodeTypes, r = n[e];
  if (r)
    return [r];
  let o = [];
  for (let i in n) {
    let s = n[i];
    s.isInGroup(e) && o.push(s);
  }
  return o.length == 0 && t.err("No node type or group '" + e + "' found"), o;
}
function zx(t) {
  if (t.eat("(")) {
    let e = mb(t);
    return t.eat(")") || t.err("Missing closing paren"), e;
  } else if (/\W/.test(t.next))
    t.err("Unexpected token '" + t.next + "'");
  else {
    let e = Bx(t, t.next).map((n) => (t.inline == null ? t.inline = n.isInline : t.inline != n.isInline && t.err("Mixing inline and block content"), { type: "name", value: n }));
    return t.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function $x(t) {
  let e = [[]];
  return o(i(t, 0), n()), e;
  function n() {
    return e.push([]) - 1;
  }
  function r(s, a, l) {
    let c = { term: l, to: a };
    return e[s].push(c), c;
  }
  function o(s, a) {
    s.forEach((l) => l.to = a);
  }
  function i(s, a) {
    if (s.type == "choice")
      return s.exprs.reduce((l, c) => l.concat(i(c, a)), []);
    if (s.type == "seq")
      for (let l = 0; ; l++) {
        let c = i(s.exprs[l], a);
        if (l == s.exprs.length - 1)
          return c;
        o(c, a = n());
      }
    else if (s.type == "star") {
      let l = n();
      return r(a, l), o(i(s.expr, l), l), [r(l)];
    } else if (s.type == "plus") {
      let l = n();
      return o(i(s.expr, a), l), o(i(s.expr, l), l), [r(l)];
    } else {
      if (s.type == "opt")
        return [r(a)].concat(i(s.expr, a));
      if (s.type == "range") {
        let l = a;
        for (let c = 0; c < s.min; c++) {
          let u = n();
          o(i(s.expr, l), u), l = u;
        }
        if (s.max == -1)
          o(i(s.expr, l), l);
        else
          for (let c = s.min; c < s.max; c++) {
            let u = n();
            r(l, u), o(i(s.expr, l), u), l = u;
          }
        return [r(l)];
      } else {
        if (s.type == "name")
          return [r(a, void 0, s.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function pb(t, e) {
  return e - t;
}
function Vh(t, e) {
  let n = [];
  return r(e), n.sort(pb);
  function r(o) {
    let i = t[o];
    if (i.length == 1 && !i[0].term)
      return r(i[0].to);
    n.push(o);
    for (let s = 0; s < i.length; s++) {
      let { term: a, to: l } = i[s];
      !a && n.indexOf(l) == -1 && r(l);
    }
  }
}
function Hx(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return n(Vh(t, 0));
  function n(r) {
    let o = [];
    r.forEach((s) => {
      t[s].forEach(({ term: a, to: l }) => {
        if (!a)
          return;
        let c;
        for (let u = 0; u < o.length; u++)
          o[u][0] == a && (c = o[u][1]);
        Vh(t, l).forEach((u) => {
          c || o.push([a, c = []]), c.indexOf(u) == -1 && c.push(u);
        });
      });
    });
    let i = e[r.join(",")] = new Zr(r.indexOf(t.length - 1) > -1);
    for (let s = 0; s < o.length; s++) {
      let a = o[s][1].sort(pb);
      i.next.push({ type: o[s][0], next: e[a.join(",")] || n(a) });
    }
    return i;
  }
}
function Fx(t, e) {
  for (let n = 0, r = [t]; n < r.length; n++) {
    let o = r[n], i = !o.validEnd, s = [];
    for (let a = 0; a < o.next.length; a++) {
      let { type: l, next: c } = o.next[a];
      s.push(l.name), i && !(l.isText || l.hasRequiredAttrs()) && (i = !1), r.indexOf(c) == -1 && r.push(c);
    }
    i && e.err("Only non-generatable nodes (" + s.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function gb(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t) {
    let r = t[n];
    if (!r.hasDefault)
      return null;
    e[n] = r.default;
  }
  return e;
}
function bb(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let r in t) {
    let o = e && e[r];
    if (o === void 0) {
      let i = t[r];
      if (i.hasDefault)
        o = i.default;
      else
        throw new RangeError("No value supplied for attribute " + r);
    }
    n[r] = o;
  }
  return n;
}
function yb(t, e, n, r) {
  for (let o in e)
    if (!(o in t))
      throw new RangeError(`Unsupported attribute ${o} for ${n} of type ${o}`);
  for (let o in t) {
    let i = t[o];
    i.validate && i.validate(e[o]);
  }
}
function vb(t, e) {
  let n = /* @__PURE__ */ Object.create(null);
  if (e)
    for (let r in e)
      n[r] = new Wx(t, r, e[r]);
  return n;
}
let Kh = class wb {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.name = e, this.schema = n, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = vb(e, r.attrs), this.defaultAttrs = gb(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || e == "text"), this.isText = e == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == Zr.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(e) {
    return this.groups.indexOf(e) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : bb(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, n, r) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new xr(this, this.computeAttrs(e), D.from(n), We.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, n, r) {
    return n = D.from(n), this.checkContent(n), new xr(this, this.computeAttrs(e), n, We.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, n, r) {
    if (e = this.computeAttrs(e), n = D.from(n), n.size) {
      let s = this.contentMatch.fillBefore(n);
      if (!s)
        return null;
      n = s.append(n);
    }
    let o = this.contentMatch.matchFragment(n), i = o && o.fillBefore(D.empty, !0);
    return i ? new xr(this, e, n.append(i), We.setFrom(r)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(e) {
    let n = this.contentMatch.matchFragment(e);
    if (!n || !n.validEnd)
      return !1;
    for (let r = 0; r < e.childCount; r++)
      if (!this.allowsMarks(e.child(r).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(e) {
    yb(this.attrs, e, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null)
      return !0;
    for (let n = 0; n < e.length; n++)
      if (!this.allowsMarkType(e[n].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let n;
    for (let r = 0; r < e.length; r++)
      this.allowsMarkType(e[r].type) ? n && n.push(e[r]) : n || (n = e.slice(0, r));
    return n ? n.length ? n : We.none : e;
  }
  /**
  @internal
  */
  static compile(e, n) {
    let r = /* @__PURE__ */ Object.create(null);
    e.forEach((i, s) => r[i] = new wb(i, n, s));
    let o = n.spec.topNode || "doc";
    if (!r[o])
      throw new RangeError("Schema is missing its top node type ('" + o + "')");
    if (!r.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let i in r.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return r;
  }
};
function Ux(t, e, n) {
  let r = n.split("|");
  return (o) => {
    let i = o === null ? "null" : typeof o;
    if (r.indexOf(i) < 0)
      throw new RangeError(`Expected value of type ${r} for attribute ${e} on type ${t}, got ${i}`);
  };
}
class Wx {
  constructor(e, n, r) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default"), this.default = r.default, this.validate = typeof r.validate == "string" ? Ux(e, n, r.validate) : r.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class Zl {
  /**
  @internal
  */
  constructor(e, n, r, o) {
    this.name = e, this.rank = n, this.schema = r, this.spec = o, this.attrs = vb(e, o.attrs), this.excluded = null;
    let i = gb(this.attrs);
    this.instance = i ? new We(this, i) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new We(this, bb(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, n) {
    let r = /* @__PURE__ */ Object.create(null), o = 0;
    return e.forEach((i, s) => r[i] = new Zl(i, o++, n, s)), r;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var n = 0; n < e.length; n++)
      e[n].type == this && (e = e.slice(0, n).concat(e.slice(n + 1)), n--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let n = 0; n < e.length; n++)
      if (e[n].type == this)
        return e[n];
  }
  /**
  @internal
  */
  checkAttrs(e) {
    yb(this.attrs, e, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
class kb {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    this.linebreakReplacement = null, this.cached = /* @__PURE__ */ Object.create(null);
    let n = this.spec = {};
    for (let o in e)
      n[o] = e[o];
    n.nodes = vt.from(e.nodes), n.marks = vt.from(e.marks || {}), this.nodes = Kh.compile(this.spec.nodes, this), this.marks = Zl.compile(this.spec.marks, this);
    let r = /* @__PURE__ */ Object.create(null);
    for (let o in this.nodes) {
      if (o in this.marks)
        throw new RangeError(o + " can not be both a node and a mark");
      let i = this.nodes[o], s = i.spec.content || "", a = i.spec.marks;
      if (i.contentMatch = r[s] || (r[s] = Zr.parse(s, this.nodes)), i.inlineContent = i.contentMatch.inlineContent, i.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!i.isInline || !i.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = i;
      }
      i.markSet = a == "_" ? null : a ? qh(this, a.split(" ")) : a == "" || !i.inlineContent ? [] : null;
    }
    for (let o in this.marks) {
      let i = this.marks[o], s = i.spec.excludes;
      i.excluded = s == null ? [i] : s == "" ? [] : qh(this, s.split(" "));
    }
    this.nodeFromJSON = (o) => xr.fromJSON(this, o), this.markFromJSON = (o) => We.fromJSON(this, o), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, n = null, r, o) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof Kh) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else throw new RangeError("Invalid node type: " + e);
    return e.createChecked(n, r, o);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, n) {
    let r = this.nodes.text;
    return new Da(r, r.defaultAttrs, e, We.setFrom(n));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, n) {
    return typeof e == "string" && (e = this.marks[e]), e.create(n);
  }
  /**
  @internal
  */
  nodeType(e) {
    let n = this.nodes[e];
    if (!n)
      throw new RangeError("Unknown node type: " + e);
    return n;
  }
}
function qh(t, e) {
  let n = [];
  for (let r = 0; r < e.length; r++) {
    let o = e[r], i = t.marks[o], s = i;
    if (i)
      n.push(i);
    else
      for (let a in t.marks) {
        let l = t.marks[a];
        (o == "_" || l.spec.group && l.spec.group.split(" ").indexOf(o) > -1) && n.push(s = l);
      }
    if (!s)
      throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
  }
  return n;
}
function Vx(t) {
  return t.tag != null;
}
function Kx(t) {
  return t.style != null;
}
class Nr {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, n) {
    this.schema = e, this.rules = n, this.tags = [], this.styles = [];
    let r = this.matchedStyles = [];
    n.forEach((o) => {
      if (Vx(o))
        this.tags.push(o);
      else if (Kx(o)) {
        let i = /[^=]*/.exec(o.style)[0];
        r.indexOf(i) < 0 && r.push(i), this.styles.push(o);
      }
    }), this.normalizeLists = !this.tags.some((o) => {
      if (!/^(ul|ol)\b/.test(o.tag) || !o.node)
        return !1;
      let i = e.nodes[o.node];
      return i.contentMatch.matchType(i);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, n = {}) {
    let r = new jh(this, n, !1);
    return r.addAll(e, We.none, n.from, n.to), r.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, n = {}) {
    let r = new jh(this, n, !0);
    return r.addAll(e, We.none, n.from, n.to), Y.maxOpen(r.finish());
  }
  /**
  @internal
  */
  matchTag(e, n, r) {
    for (let o = r ? this.tags.indexOf(r) + 1 : 0; o < this.tags.length; o++) {
      let i = this.tags[o];
      if (jx(e, i.tag) && (i.namespace === void 0 || e.namespaceURI == i.namespace) && (!i.context || n.matchesContext(i.context))) {
        if (i.getAttrs) {
          let s = i.getAttrs(e);
          if (s === !1)
            continue;
          i.attrs = s || void 0;
        }
        return i;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, n, r, o) {
    for (let i = o ? this.styles.indexOf(o) + 1 : 0; i < this.styles.length; i++) {
      let s = this.styles[i], a = s.style;
      if (!(a.indexOf(e) != 0 || s.context && !r.matchesContext(s.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      a.length > e.length && (a.charCodeAt(e.length) != 61 || a.slice(e.length + 1) != n))) {
        if (s.getAttrs) {
          let l = s.getAttrs(n);
          if (l === !1)
            continue;
          s.attrs = l || void 0;
        }
        return s;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let n = [];
    function r(o) {
      let i = o.priority == null ? 50 : o.priority, s = 0;
      for (; s < n.length; s++) {
        let a = n[s];
        if ((a.priority == null ? 50 : a.priority) < i)
          break;
      }
      n.splice(s, 0, o);
    }
    for (let o in e.marks) {
      let i = e.marks[o].spec.parseDOM;
      i && i.forEach((s) => {
        r(s = Yh(s)), s.mark || s.ignore || s.clearMark || (s.mark = o);
      });
    }
    for (let o in e.nodes) {
      let i = e.nodes[o].spec.parseDOM;
      i && i.forEach((s) => {
        r(s = Yh(s)), s.node || s.ignore || s.mark || (s.node = o);
      });
    }
    return n;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.GenericParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new Nr(e, Nr.schemaRules(e)));
  }
}
const xb = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, qx = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, Nb = { ol: !0, ul: !0 }, Ji = 1, zu = 2, Bi = 4;
function Gh(t, e, n) {
  return e != null ? (e ? Ji : 0) | (e === "full" ? zu : 0) : t && t.whitespace == "pre" ? Ji | zu : n & ~Bi;
}
class zs {
  constructor(e, n, r, o, i, s) {
    this.type = e, this.attrs = n, this.marks = r, this.solid = o, this.options = s, this.content = [], this.activeMarks = We.none, this.match = i || (s & Bi ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let n = this.type.contentMatch.fillBefore(D.from(e));
      if (n)
        this.match = this.type.contentMatch.matchFragment(n);
      else {
        let r = this.type.contentMatch, o;
        return (o = r.findWrapping(e.type)) ? (this.match = r, o) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & Ji)) {
      let r = this.content[this.content.length - 1], o;
      if (r && r.isText && (o = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let i = r;
        r.text.length == o[0].length ? this.content.pop() : this.content[this.content.length - 1] = i.withText(i.text.slice(0, i.text.length - o[0].length));
      }
    }
    let n = D.from(this.content);
    return !e && this.match && (n = n.append(this.match.fillBefore(D.empty, !0))), this.type ? this.type.create(this.attrs, n, this.marks) : n;
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !xb.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
class jh {
  constructor(e, n, r) {
    this.parser = e, this.options = n, this.isOpen = r, this.open = 0, this.localPreserveWS = !1;
    let o = n.topNode, i, s = Gh(null, n.preserveWhitespace, 0) | (r ? Bi : 0);
    o ? i = new zs(o.type, o.attrs, We.none, !0, n.topMatch || o.type.contentMatch, s) : r ? i = new zs(null, null, We.none, !0, null, s) : i = new zs(e.schema.topNodeType, null, We.none, !0, null, s), this.nodes = [i], this.find = n.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e, n) {
    e.nodeType == 3 ? this.addTextNode(e, n) : e.nodeType == 1 && this.addElement(e, n);
  }
  addTextNode(e, n) {
    let r = e.nodeValue, o = this.top, i = o.options & zu ? "full" : this.localPreserveWS || (o.options & Ji) > 0, { schema: s } = this.parser;
    if (i === "full" || o.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
      if (i)
        if (i === "full")
          r = r.replace(/\r\n?/g, `
`);
        else if (s.linebreakReplacement && /[\r\n]/.test(r) && this.top.findWrapping(s.linebreakReplacement.create())) {
          let a = r.split(/\r?\n|\r/);
          for (let l = 0; l < a.length; l++)
            l && this.insertNode(s.linebreakReplacement.create(), n, !0), a[l] && this.insertNode(s.text(a[l]), n, !/\S/.test(a[l]));
          r = "";
        } else
          r = r.replace(/\r?\n|\r/g, " ");
      else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) {
        let a = o.content[o.content.length - 1], l = e.previousSibling;
        (!a || l && l.nodeName == "BR" || a.isText && /[ \t\r\n\u000c]$/.test(a.text)) && (r = r.slice(1));
      }
      r && this.insertNode(s.text(r), n, !/\S/.test(r)), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, n, r) {
    let o = this.localPreserveWS, i = this.top;
    (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = !0);
    let s = e.nodeName.toLowerCase(), a;
    Nb.hasOwnProperty(s) && this.parser.normalizeLists && Gx(e);
    let l = this.options.ruleFromNode && this.options.ruleFromNode(e) || (a = this.parser.matchTag(e, this, r));
    e: if (l ? l.ignore : qx.hasOwnProperty(s))
      this.findInside(e), this.ignoreFallback(e, n);
    else if (!l || l.skip || l.closeParent) {
      l && l.closeParent ? this.open = Math.max(0, this.open - 1) : l && l.skip.nodeType && (e = l.skip);
      let c, u = this.needsBlock;
      if (xb.hasOwnProperty(s))
        i.content.length && i.content[0].isInline && this.open && (this.open--, i = this.top), c = !0, i.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e, n);
        break e;
      }
      let d = l && l.skip ? n : this.readStyles(e, n);
      d && this.addAll(e, d), c && this.sync(i), this.needsBlock = u;
    } else {
      let c = this.readStyles(e, n);
      c && this.addElementByRule(e, l, c, l.consuming === !1 ? a : void 0);
    }
    this.localPreserveWS = o;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e, n) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), n);
  }
  // Called for ignored nodes
  ignoreFallback(e, n) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), n, !0);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(e, n) {
    let r = e.style;
    if (r && r.length)
      for (let o = 0; o < this.parser.matchedStyles.length; o++) {
        let i = this.parser.matchedStyles[o], s = r.getPropertyValue(i);
        if (s)
          for (let a = void 0; ; ) {
            let l = this.parser.matchStyle(i, s, this, a);
            if (!l)
              break;
            if (l.ignore)
              return null;
            if (l.clearMark ? n = n.filter((c) => !l.clearMark(c)) : n = n.concat(this.parser.schema.marks[l.mark].create(l.attrs)), l.consuming === !1)
              a = l;
            else
              break;
          }
      }
    return n;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, n, r, o) {
    let i, s;
    if (n.node)
      if (s = this.parser.schema.nodes[n.node], s.isLeaf)
        this.insertNode(s.create(n.attrs), r, e.nodeName == "BR") || this.leafFallback(e, r);
      else {
        let l = this.enter(s, n.attrs || null, r, n.preserveWhitespace);
        l && (i = !0, r = l);
      }
    else {
      let l = this.parser.schema.marks[n.mark];
      r = r.concat(l.create(n.attrs));
    }
    let a = this.top;
    if (s && s.isLeaf)
      this.findInside(e);
    else if (o)
      this.addElement(e, r, o);
    else if (n.getContent)
      this.findInside(e), n.getContent(e, this.parser.schema).forEach((l) => this.insertNode(l, r, !1));
    else {
      let l = e;
      typeof n.contentElement == "string" ? l = e.querySelector(n.contentElement) : typeof n.contentElement == "function" ? l = n.contentElement(e) : n.contentElement && (l = n.contentElement), this.findAround(e, l, !0), this.addAll(l, r), this.findAround(e, l, !1);
    }
    i && this.sync(a) && this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, n, r, o) {
    let i = r || 0;
    for (let s = r ? e.childNodes[r] : e.firstChild, a = o == null ? null : e.childNodes[o]; s != a; s = s.nextSibling, ++i)
      this.findAtPoint(e, i), this.addDOM(s, n);
    this.findAtPoint(e, i);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e, n, r) {
    let o, i;
    for (let s = this.open, a = 0; s >= 0; s--) {
      let l = this.nodes[s], c = l.findWrapping(e);
      if (c && (!o || o.length > c.length + a) && (o = c, i = l, !c.length))
        break;
      if (l.solid) {
        if (r)
          break;
        a += 2;
      }
    }
    if (!o)
      return null;
    this.sync(i);
    for (let s = 0; s < o.length; s++)
      n = this.enterInner(o[s], null, n, !1);
    return n;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e, n, r) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let i = this.textblockFromContext();
      i && (n = this.enterInner(i, null, n));
    }
    let o = this.findPlace(e, n, r);
    if (o) {
      this.closeExtra();
      let i = this.top;
      i.match && (i.match = i.match.matchType(e.type));
      let s = We.none;
      for (let a of o.concat(e.marks))
        (i.type ? i.type.allowsMarkType(a.type) : Xh(a.type, e.type)) && (s = a.addToSet(s));
      return i.content.push(e.mark(s)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, n, r, o) {
    let i = this.findPlace(e.create(n), r, !1);
    return i && (i = this.enterInner(e, n, r, !0, o)), i;
  }
  // Open a node of the given type
  enterInner(e, n, r, o = !1, i) {
    this.closeExtra();
    let s = this.top;
    s.match = s.match && s.match.matchType(e);
    let a = Gh(e, i, s.options);
    s.options & Bi && s.content.length == 0 && (a |= Bi);
    let l = We.none;
    return r = r.filter((c) => (s.type ? s.type.allowsMarkType(c.type) : Xh(c.type, e)) ? (l = c.addToSet(l), !1) : !0), this.nodes.push(new zs(e, n, l, o, null, a)), this.open++, r;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let n = this.nodes.length - 1;
    if (n > this.open) {
      for (; n > this.open; n--)
        this.nodes[n - 1].content.push(this.nodes[n].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(e) {
    for (let n = this.open; n >= 0; n--) {
      if (this.nodes[n] == e)
        return this.open = n, !0;
      this.localPreserveWS && (this.nodes[n].options |= Ji);
    }
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let n = this.open; n >= 0; n--) {
      let r = this.nodes[n].content;
      for (let o = r.length - 1; o >= 0; o--)
        e += r[o].nodeSize;
      n && e++;
    }
    return e;
  }
  findAtPoint(e, n) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == e && this.find[r].offset == n && (this.find[r].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].pos == null && e.nodeType == 1 && e.contains(this.find[n].node) && (this.find[n].pos = this.currentPos);
  }
  findAround(e, n, r) {
    if (e != n && this.find)
      for (let o = 0; o < this.find.length; o++)
        this.find[o].pos == null && e.nodeType == 1 && e.contains(this.find[o].node) && n.compareDocumentPosition(this.find[o].node) & (r ? 2 : 4) && (this.find[o].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let n = 0; n < this.find.length; n++)
        this.find[n].node == e && (this.find[n].pos = this.currentPos - (e.nodeValue.length - this.find[n].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let n = e.split("/"), r = this.options.context, o = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), i = -(r ? r.depth + 1 : 0) + (o ? 0 : 1), s = (a, l) => {
      for (; a >= 0; a--) {
        let c = n[a];
        if (c == "") {
          if (a == n.length - 1 || a == 0)
            continue;
          for (; l >= i; l--)
            if (s(a - 1, l))
              return !0;
          return !1;
        } else {
          let u = l > 0 || l == 0 && o ? this.nodes[l].type : r && l >= i ? r.node(l - i).type : null;
          if (!u || u.name != c && !u.isInGroup(c))
            return !1;
          l--;
        }
      }
      return !0;
    };
    return s(n.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let n = e.depth; n >= 0; n--) {
        let r = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType;
        if (r && r.isTextblock && r.defaultAttrs)
          return r;
      }
    for (let n in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[n];
      if (r.isTextblock && r.defaultAttrs)
        return r;
    }
  }
}
function Gx(t) {
  for (let e = t.firstChild, n = null; e; e = e.nextSibling) {
    let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    r && Nb.hasOwnProperty(r) && n ? (n.appendChild(e), e = n) : r == "li" ? n = e : r && (n = null);
  }
}
function jx(t, e) {
  return (t.matches || t.msMatchesSelector || t.webkitMatchesSelector || t.mozMatchesSelector).call(t, e);
}
function Yh(t) {
  let e = {};
  for (let n in t)
    e[n] = t[n];
  return e;
}
function Xh(t, e) {
  let n = e.schema.nodes;
  for (let r in n) {
    let o = n[r];
    if (!o.allowsMarkType(t))
      continue;
    let i = [], s = (a) => {
      i.push(a);
      for (let l = 0; l < a.edgeCount; l++) {
        let { type: c, next: u } = a.edge(l);
        if (c == e || i.indexOf(u) < 0 && s(u))
          return !0;
      }
    };
    if (s(o.contentMatch))
      return !0;
  }
}
class so {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, n) {
    this.nodes = e, this.marks = n;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, n = {}, r) {
    r || (r = Fc(n).createDocumentFragment());
    let o = r, i = [];
    return e.forEach((s) => {
      if (i.length || s.marks.length) {
        let a = 0, l = 0;
        for (; a < i.length && l < s.marks.length; ) {
          let c = s.marks[l];
          if (!this.marks[c.type.name]) {
            l++;
            continue;
          }
          if (!c.eq(i[a][0]) || c.type.spec.spanning === !1)
            break;
          a++, l++;
        }
        for (; a < i.length; )
          o = i.pop()[1];
        for (; l < s.marks.length; ) {
          let c = s.marks[l++], u = this.serializeMark(c, s.isInline, n);
          u && (i.push([c, o]), o.appendChild(u.dom), o = u.contentDOM || u.dom);
        }
      }
      o.appendChild(this.serializeNodeInner(s, n));
    }), r;
  }
  /**
  @internal
  */
  serializeNodeInner(e, n) {
    let { dom: r, contentDOM: o } = ya(Fc(n), this.nodes[e.type.name](e), null, e.attrs);
    if (o) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, n, o);
    }
    return r;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, n = {}) {
    let r = this.serializeNodeInner(e, n);
    for (let o = e.marks.length - 1; o >= 0; o--) {
      let i = this.serializeMark(e.marks[o], e.isInline, n);
      i && ((i.contentDOM || i.dom).appendChild(r), r = i.dom);
    }
    return r;
  }
  /**
  @internal
  */
  serializeMark(e, n, r = {}) {
    let o = this.marks[e.type.name];
    return o && ya(Fc(r), o(e, n), null, e.attrs);
  }
  static renderSpec(e, n, r = null, o) {
    return ya(e, n, r, o);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new so(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let n = Zh(e.nodes);
    return n.text || (n.text = (r) => r.text), n;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return Zh(e.marks);
  }
}
function Zh(t) {
  let e = {};
  for (let n in t) {
    let r = t[n].spec.toDOM;
    r && (e[n] = r);
  }
  return e;
}
function Fc(t) {
  return t.document || window.document;
}
const Jh = /* @__PURE__ */ new WeakMap();
function Yx(t) {
  let e = Jh.get(t);
  return e === void 0 && Jh.set(t, e = Xx(t)), e;
}
function Xx(t) {
  let e = null;
  function n(r) {
    if (r && typeof r == "object")
      if (Array.isArray(r))
        if (typeof r[0] == "string")
          e || (e = []), e.push(r);
        else
          for (let o = 0; o < r.length; o++)
            n(r[o]);
      else
        for (let o in r)
          n(r[o]);
  }
  return n(t), e;
}
function ya(t, e, n, r) {
  if (typeof e == "string")
    return { dom: t.createTextNode(e) };
  if (e.nodeType != null)
    return { dom: e };
  if (e.dom && e.dom.nodeType != null)
    return e;
  let o = e[0], i;
  if (typeof o != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (r && (i = Yx(r)) && i.indexOf(e) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let s = o.indexOf(" ");
  s > 0 && (n = o.slice(0, s), o = o.slice(s + 1));
  let a, l = n ? t.createElementNS(n, o) : t.createElement(o), c = e[1], u = 1;
  if (c && typeof c == "object" && c.nodeType == null && !Array.isArray(c)) {
    u = 2;
    for (let d in c)
      if (c[d] != null) {
        let f = d.indexOf(" ");
        f > 0 ? l.setAttributeNS(d.slice(0, f), d.slice(f + 1), c[d]) : d == "style" && l.style ? l.style.cssText = c[d] : l.setAttribute(d, c[d]);
      }
  }
  for (let d = u; d < e.length; d++) {
    let f = e[d];
    if (f === 0) {
      if (d < e.length - 1 || d > u)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom: l, contentDOM: l };
    } else {
      let { dom: h, contentDOM: m } = ya(t, f, n, r);
      if (l.appendChild(h), m) {
        if (a)
          throw new RangeError("Multiple content holes");
        a = m;
      }
    }
  }
  return { dom: l, contentDOM: a };
}
const Eb = 65535, Sb = Math.pow(2, 16);
function Zx(t, e) {
  return t + e * Sb;
}
function Qh(t) {
  return t & Eb;
}
function Jx(t) {
  return (t - (t & Eb)) / Sb;
}
const Tb = 1, Cb = 2, va = 4, Mb = 8;
class $u {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.pos = e, this.delInfo = n, this.recover = r;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & Mb) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (Tb | va)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (Cb | va)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & va) > 0;
  }
}
class Wt {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, n = !1) {
    if (this.ranges = e, this.inverted = n, !e.length && Wt.empty)
      return Wt.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let n = 0, r = Qh(e);
    if (!this.inverted)
      for (let o = 0; o < r; o++)
        n += this.ranges[o * 3 + 2] - this.ranges[o * 3 + 1];
    return this.ranges[r * 3] + n + Jx(e);
  }
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  map(e, n = 1) {
    return this._map(e, n, !0);
  }
  /**
  @internal
  */
  _map(e, n, r) {
    let o = 0, i = this.inverted ? 2 : 1, s = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? o : 0);
      if (l > e)
        break;
      let c = this.ranges[a + i], u = this.ranges[a + s], d = l + c;
      if (e <= d) {
        let f = c ? e == l ? -1 : e == d ? 1 : n : n, h = l + o + (f < 0 ? 0 : u);
        if (r)
          return h;
        let m = e == (n < 0 ? l : d) ? null : Zx(a / 3, e - l), p = e == l ? Cb : e == d ? Tb : va;
        return (n < 0 ? e != l : e != d) && (p |= Mb), new $u(h, p, m);
      }
      o += u - c;
    }
    return r ? e + o : new $u(e + o, 0, null);
  }
  /**
  @internal
  */
  touches(e, n) {
    let r = 0, o = Qh(n), i = this.inverted ? 2 : 1, s = this.inverted ? 1 : 2;
    for (let a = 0; a < this.ranges.length; a += 3) {
      let l = this.ranges[a] - (this.inverted ? r : 0);
      if (l > e)
        break;
      let c = this.ranges[a + i], u = l + c;
      if (e <= u && a == o * 3)
        return !0;
      r += this.ranges[a + s] - c;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let n = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
    for (let o = 0, i = 0; o < this.ranges.length; o += 3) {
      let s = this.ranges[o], a = s - (this.inverted ? i : 0), l = s + (this.inverted ? 0 : i), c = this.ranges[o + n], u = this.ranges[o + r];
      e(a, a + c, l, l + u), i += u - c;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new Wt(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? Wt.empty : new Wt(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
Wt.empty = new Wt([]);
class Qi {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e, n, r = 0, o = e ? e.length : 0) {
    this.mirror = n, this.from = r, this.to = o, this._maps = e || [], this.ownData = !(e || n);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, n = this.maps.length) {
    return new Qi(this._maps, this.mirror, e, n);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, n) {
    this.ownData || (this._maps = this._maps.slice(), this.mirror = this.mirror && this.mirror.slice(), this.ownData = !0), this.to = this._maps.push(e), n != null && this.setMirror(this._maps.length - 1, n);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let n = 0, r = this._maps.length; n < e._maps.length; n++) {
      let o = e.getMirror(n);
      this.appendMap(e._maps[n], o != null && o < n ? r + o : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let n = 0; n < this.mirror.length; n++)
        if (this.mirror[n] == e)
          return this.mirror[n + (n % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, n) {
    this.mirror || (this.mirror = []), this.mirror.push(e, n);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let n = e.maps.length - 1, r = this._maps.length + e._maps.length; n >= 0; n--) {
      let o = e.getMirror(n);
      this.appendMap(e._maps[n].invert(), o != null && o > n ? r - o - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new Qi();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, n = 1) {
    if (this.mirror)
      return this._map(e, n, !0);
    for (let r = this.from; r < this.to; r++)
      e = this._maps[r].map(e, n);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, n = 1) {
    return this._map(e, n, !1);
  }
  /**
  @internal
  */
  _map(e, n, r) {
    let o = 0;
    for (let i = this.from; i < this.to; i++) {
      let s = this._maps[i], a = s.mapResult(e, n);
      if (a.recover != null) {
        let l = this.getMirror(i);
        if (l != null && l > i && l < this.to) {
          i = l, e = this._maps[l].recover(a.recover);
          continue;
        }
      }
      o |= a.delInfo, e = a.pos;
    }
    return r ? e : new $u(e, o, null);
  }
}
const Uc = /* @__PURE__ */ Object.create(null);
class _t {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return Wt.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, n) {
    if (!n || !n.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let r = Uc[n.stepType];
    if (!r)
      throw new RangeError(`No step type ${n.stepType} defined`);
    return r.fromJSON(e, n);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, n) {
    if (e in Uc)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return Uc[e] = n, n.prototype.jsonID = e, n;
  }
}
class it {
  /**
  @internal
  */
  constructor(e, n) {
    this.doc = e, this.failed = n;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new it(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new it(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, n, r, o) {
    try {
      return it.ok(e.replace(n, r, o));
    } catch (i) {
      if (i instanceof Ra)
        return it.fail(i.message);
      throw i;
    }
  }
}
function Ud(t, e, n) {
  let r = [];
  for (let o = 0; o < t.childCount; o++) {
    let i = t.child(o);
    i.content.size && (i = i.copy(Ud(i.content, e, i))), i.isInline && (i = e(i, n, o)), r.push(i);
  }
  return D.fromArray(r);
}
class vr extends _t {
  /**
  Create a mark step.
  */
  constructor(e, n, r) {
    super(), this.from = e, this.to = n, this.mark = r;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), r = e.resolve(this.from), o = r.node(r.sharedDepth(this.to)), i = new Y(Ud(n.content, (s, a) => !s.isAtom || !a.type.allowsMarkType(this.mark.type) ? s : s.mark(this.mark.addToSet(s.marks)), o), n.openStart, n.openEnd);
    return it.fromReplace(e, this.from, this.to, i);
  }
  invert() {
    return new mn(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new vr(n.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof vr && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new vr(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new vr(n.from, n.to, e.markFromJSON(n.mark));
  }
}
_t.jsonID("addMark", vr);
class mn extends _t {
  /**
  Create a mark-removing step.
  */
  constructor(e, n, r) {
    super(), this.from = e, this.to = n, this.mark = r;
  }
  apply(e) {
    let n = e.slice(this.from, this.to), r = new Y(Ud(n.content, (o) => o.mark(this.mark.removeFromSet(o.marks)), e), n.openStart, n.openEnd);
    return it.fromReplace(e, this.from, this.to, r);
  }
  invert() {
    return new vr(this.from, this.to, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deleted && r.deleted || n.pos >= r.pos ? null : new mn(n.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof mn && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new mn(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new mn(n.from, n.to, e.markFromJSON(n.mark));
  }
}
_t.jsonID("removeMark", mn);
class wr extends _t {
  /**
  Create a node mark step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return it.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
    return it.fromReplace(e, this.pos, this.pos + 1, new Y(D.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    if (n) {
      let r = this.mark.addToSet(n.marks);
      if (r.length == n.marks.length) {
        for (let o = 0; o < n.marks.length; o++)
          if (!n.marks[o].isInSet(r))
            return new wr(this.pos, n.marks[o]);
        return new wr(this.pos, this.mark);
      }
    }
    return new Jr(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new wr(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new wr(n.pos, e.markFromJSON(n.mark));
  }
}
_t.jsonID("addNodeMark", wr);
class Jr extends _t {
  /**
  Create a mark-removing step.
  */
  constructor(e, n) {
    super(), this.pos = e, this.mark = n;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return it.fail("No node at mark step's position");
    let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
    return it.fromReplace(e, this.pos, this.pos + 1, new Y(D.from(r), 0, n.isLeaf ? 0 : 1));
  }
  invert(e) {
    let n = e.nodeAt(this.pos);
    return !n || !this.mark.isInSet(n.marks) ? this : new wr(this.pos, this.mark);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new Jr(n.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new Jr(n.pos, e.markFromJSON(n.mark));
  }
}
_t.jsonID("removeNodeMark", Jr);
class ft extends _t {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, n, r, o = !1) {
    super(), this.from = e, this.to = n, this.slice = r, this.structure = o;
  }
  apply(e) {
    return this.structure && Hu(e, this.from, this.to) ? it.fail("Structure replace would overwrite content") : it.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new Wt([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new ft(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return n.deletedAcross && r.deletedAcross ? null : new ft(n.pos, Math.max(n.pos, r.pos), this.slice, this.structure);
  }
  merge(e) {
    if (!(e instanceof ft) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let n = this.slice.size + e.slice.size == 0 ? Y.empty : new Y(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new ft(this.from, this.to + (e.to - e.from), n, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let n = this.slice.size + e.slice.size == 0 ? Y.empty : new Y(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new ft(e.from, this.to, n, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new ft(n.from, n.to, Y.fromJSON(e, n.slice), !!n.structure);
  }
}
_t.jsonID("replace", ft);
class mt extends _t {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, n, r, o, i, s, a = !1) {
    super(), this.from = e, this.to = n, this.gapFrom = r, this.gapTo = o, this.slice = i, this.insert = s, this.structure = a;
  }
  apply(e) {
    if (this.structure && (Hu(e, this.from, this.gapFrom) || Hu(e, this.gapTo, this.to)))
      return it.fail("Structure gap-replace would overwrite content");
    let n = e.slice(this.gapFrom, this.gapTo);
    if (n.openStart || n.openEnd)
      return it.fail("Gap is not a flat range");
    let r = this.slice.insertAt(this.insert, n.content);
    return r ? it.fromReplace(e, this.from, this.to, r) : it.fail("Content does not fit in gap");
  }
  getMap() {
    return new Wt([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let n = this.gapTo - this.gapFrom;
    return new mt(this.from, this.from + this.slice.size + n, this.from + this.insert, this.from + this.insert + n, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let n = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1), o = this.from == this.gapFrom ? n.pos : e.map(this.gapFrom, -1), i = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1);
    return n.deletedAcross && r.deletedAcross || o < n.pos || i > r.pos ? null : new mt(n.pos, r.pos, o, i, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.from != "number" || typeof n.to != "number" || typeof n.gapFrom != "number" || typeof n.gapTo != "number" || typeof n.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new mt(n.from, n.to, n.gapFrom, n.gapTo, Y.fromJSON(e, n.slice), n.insert, !!n.structure);
  }
}
_t.jsonID("replaceAround", mt);
function Hu(t, e, n) {
  let r = t.resolve(e), o = n - e, i = r.depth;
  for (; o > 0 && i > 0 && r.indexAfter(i) == r.node(i).childCount; )
    i--, o--;
  if (o > 0) {
    let s = r.node(i).maybeChild(r.indexAfter(i));
    for (; o > 0; ) {
      if (!s || s.isLeaf)
        return !0;
      s = s.firstChild, o--;
    }
  }
  return !1;
}
function Qx(t, e, n, r) {
  let o = [], i = [], s, a;
  t.doc.nodesBetween(e, n, (l, c, u) => {
    if (!l.isInline)
      return;
    let d = l.marks;
    if (!r.isInSet(d) && u.type.allowsMarkType(r.type)) {
      let f = Math.max(c, e), h = Math.min(c + l.nodeSize, n), m = r.addToSet(d);
      for (let p = 0; p < d.length; p++)
        d[p].isInSet(m) || (s && s.to == f && s.mark.eq(d[p]) ? s.to = h : o.push(s = new mn(f, h, d[p])));
      a && a.to == f ? a.to = h : i.push(a = new vr(f, h, r));
    }
  }), o.forEach((l) => t.step(l)), i.forEach((l) => t.step(l));
}
function eN(t, e, n, r) {
  let o = [], i = 0;
  t.doc.nodesBetween(e, n, (s, a) => {
    if (!s.isInline)
      return;
    i++;
    let l = null;
    if (r instanceof Zl) {
      let c = s.marks, u;
      for (; u = r.isInSet(c); )
        (l || (l = [])).push(u), c = u.removeFromSet(c);
    } else r ? r.isInSet(s.marks) && (l = [r]) : l = s.marks;
    if (l && l.length) {
      let c = Math.min(a + s.nodeSize, n);
      for (let u = 0; u < l.length; u++) {
        let d = l[u], f;
        for (let h = 0; h < o.length; h++) {
          let m = o[h];
          m.step == i - 1 && d.eq(o[h].style) && (f = m);
        }
        f ? (f.to = c, f.step = i) : o.push({ style: d, from: Math.max(a, e), to: c, step: i });
      }
    }
  }), o.forEach((s) => t.step(new mn(s.from, s.to, s.style)));
}
function Wd(t, e, n, r = n.contentMatch, o = !0) {
  let i = t.doc.nodeAt(e), s = [], a = e + 1;
  for (let l = 0; l < i.childCount; l++) {
    let c = i.child(l), u = a + c.nodeSize, d = r.matchType(c.type);
    if (!d)
      s.push(new ft(a, u, Y.empty));
    else {
      r = d;
      for (let f = 0; f < c.marks.length; f++)
        n.allowsMarkType(c.marks[f].type) || t.step(new mn(a, u, c.marks[f]));
      if (o && c.isText && n.whitespace != "pre") {
        let f, h = /\r?\n|\r/g, m;
        for (; f = h.exec(c.text); )
          m || (m = new Y(D.from(n.schema.text(" ", n.allowedMarks(c.marks))), 0, 0)), s.push(new ft(a + f.index, a + f.index + f[0].length, m));
      }
    }
    a = u;
  }
  if (!r.validEnd) {
    let l = r.fillBefore(D.empty, !0);
    t.replace(a, a, new Y(l, 0, 0));
  }
  for (let l = s.length - 1; l >= 0; l--)
    t.step(s[l]);
}
function tN(t, e, n) {
  return (e == 0 || t.canReplace(e, t.childCount)) && (n == t.childCount || t.canReplace(0, n));
}
function li(t) {
  let n = t.parent.content.cutByIndex(t.startIndex, t.endIndex);
  for (let r = t.depth, o = 0, i = 0; ; --r) {
    let s = t.$from.node(r), a = t.$from.index(r) + o, l = t.$to.indexAfter(r) - i;
    if (r < t.depth && s.canReplace(a, l, n))
      return r;
    if (r == 0 || s.type.spec.isolating || !tN(s, a, l))
      break;
    a && (o = 1), l < s.childCount && (i = 1);
  }
  return null;
}
function nN(t, e, n) {
  let { $from: r, $to: o, depth: i } = e, s = r.before(i + 1), a = o.after(i + 1), l = s, c = a, u = D.empty, d = 0;
  for (let m = i, p = !1; m > n; m--)
    p || r.index(m) > 0 ? (p = !0, u = D.from(r.node(m).copy(u)), d++) : l--;
  let f = D.empty, h = 0;
  for (let m = i, p = !1; m > n; m--)
    p || o.after(m + 1) < o.end(m) ? (p = !0, f = D.from(o.node(m).copy(f)), h++) : c++;
  t.step(new mt(l, c, s, a, new Y(u.append(f), d, h), u.size - d, !0));
}
function Vd(t, e, n = null, r = t) {
  let o = rN(t, e), i = o && oN(r, e);
  return i ? o.map(em).concat({ type: e, attrs: n }).concat(i.map(em)) : null;
}
function em(t) {
  return { type: t, attrs: null };
}
function rN(t, e) {
  let { parent: n, startIndex: r, endIndex: o } = t, i = n.contentMatchAt(r).findWrapping(e);
  if (!i)
    return null;
  let s = i.length ? i[0] : e;
  return n.canReplaceWith(r, o, s) ? i : null;
}
function oN(t, e) {
  let { parent: n, startIndex: r, endIndex: o } = t, i = n.child(r), s = e.contentMatch.findWrapping(i.type);
  if (!s)
    return null;
  let l = (s.length ? s[s.length - 1] : e).contentMatch;
  for (let c = r; l && c < o; c++)
    l = l.matchType(n.child(c).type);
  return !l || !l.validEnd ? null : s;
}
function iN(t, e, n) {
  let r = D.empty;
  for (let s = n.length - 1; s >= 0; s--) {
    if (r.size) {
      let a = n[s].type.contentMatch.matchFragment(r);
      if (!a || !a.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    r = D.from(n[s].type.create(n[s].attrs, r));
  }
  let o = e.start, i = e.end;
  t.step(new mt(o, i, o, i, new Y(r, 0, 0), n.length, !0));
}
function sN(t, e, n, r, o) {
  if (!r.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let i = t.steps.length;
  t.doc.nodesBetween(e, n, (s, a) => {
    let l = typeof o == "function" ? o(s) : o;
    if (s.isTextblock && !s.hasMarkup(r, l) && aN(t.doc, t.mapping.slice(i).map(a), r)) {
      let c = null;
      if (r.schema.linebreakReplacement) {
        let h = r.whitespace == "pre", m = !!r.contentMatch.matchType(r.schema.linebreakReplacement);
        h && !m ? c = !1 : !h && m && (c = !0);
      }
      c === !1 && _b(t, s, a, i), Wd(t, t.mapping.slice(i).map(a, 1), r, void 0, c === null);
      let u = t.mapping.slice(i), d = u.map(a, 1), f = u.map(a + s.nodeSize, 1);
      return t.step(new mt(d, f, d + 1, f - 1, new Y(D.from(r.create(l, null, s.marks)), 0, 0), 1, !0)), c === !0 && Ab(t, s, a, i), !1;
    }
  });
}
function Ab(t, e, n, r) {
  e.forEach((o, i) => {
    if (o.isText) {
      let s, a = /\r?\n|\r/g;
      for (; s = a.exec(o.text); ) {
        let l = t.mapping.slice(r).map(n + 1 + i + s.index);
        t.replaceWith(l, l + 1, e.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function _b(t, e, n, r) {
  e.forEach((o, i) => {
    if (o.type == o.type.schema.linebreakReplacement) {
      let s = t.mapping.slice(r).map(n + 1 + i);
      t.replaceWith(s, s + 1, e.type.schema.text(`
`));
    }
  });
}
function aN(t, e, n) {
  let r = t.resolve(e), o = r.index();
  return r.parent.canReplaceWith(o, o + 1, n);
}
function lN(t, e, n, r, o) {
  let i = t.doc.nodeAt(e);
  if (!i)
    throw new RangeError("No node at given position");
  n || (n = i.type);
  let s = n.create(r, null, o || i.marks);
  if (i.isLeaf)
    return t.replaceWith(e, e + i.nodeSize, s);
  if (!n.validContent(i.content))
    throw new RangeError("Invalid content for node type " + n.name);
  t.step(new mt(e, e + i.nodeSize, e + 1, e + i.nodeSize - 1, new Y(D.from(s), 0, 0), 1, !0));
}
function Jn(t, e, n = 1, r) {
  let o = t.resolve(e), i = o.depth - n, s = r && r[r.length - 1] || o.parent;
  if (i < 0 || o.parent.type.spec.isolating || !o.parent.canReplace(o.index(), o.parent.childCount) || !s.type.validContent(o.parent.content.cutByIndex(o.index(), o.parent.childCount)))
    return !1;
  for (let c = o.depth - 1, u = n - 2; c > i; c--, u--) {
    let d = o.node(c), f = o.index(c);
    if (d.type.spec.isolating)
      return !1;
    let h = d.content.cutByIndex(f, d.childCount), m = r && r[u + 1];
    m && (h = h.replaceChild(0, m.type.create(m.attrs)));
    let p = r && r[u] || d;
    if (!d.canReplace(f + 1, d.childCount) || !p.type.validContent(h))
      return !1;
  }
  let a = o.indexAfter(i), l = r && r[0];
  return o.node(i).canReplaceWith(a, a, l ? l.type : o.node(i + 1).type);
}
function cN(t, e, n = 1, r) {
  let o = t.doc.resolve(e), i = D.empty, s = D.empty;
  for (let a = o.depth, l = o.depth - n, c = n - 1; a > l; a--, c--) {
    i = D.from(o.node(a).copy(i));
    let u = r && r[c];
    s = D.from(u ? u.type.create(u.attrs, s) : o.node(a).copy(s));
  }
  t.step(new ft(e, e, new Y(i.append(s), n, n), !0));
}
function Or(t, e) {
  let n = t.resolve(e), r = n.index();
  return Rb(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1);
}
function uN(t, e) {
  e.content.size || t.type.compatibleContent(e.type);
  let n = t.contentMatchAt(t.childCount), { linebreakReplacement: r } = t.type.schema;
  for (let o = 0; o < e.childCount; o++) {
    let i = e.child(o), s = i.type == r ? t.type.schema.nodes.text : i.type;
    if (n = n.matchType(s), !n || !t.type.allowsMarks(i.marks))
      return !1;
  }
  return n.validEnd;
}
function Rb(t, e) {
  return !!(t && e && !t.isLeaf && uN(t, e));
}
function Jl(t, e, n = -1) {
  let r = t.resolve(e);
  for (let o = r.depth; ; o--) {
    let i, s, a = r.index(o);
    if (o == r.depth ? (i = r.nodeBefore, s = r.nodeAfter) : n > 0 ? (i = r.node(o + 1), a++, s = r.node(o).maybeChild(a)) : (i = r.node(o).maybeChild(a - 1), s = r.node(o + 1)), i && !i.isTextblock && Rb(i, s) && r.node(o).canReplace(a, a + 1))
      return e;
    if (o == 0)
      break;
    e = n < 0 ? r.before(o) : r.after(o);
  }
}
function dN(t, e, n) {
  let r = null, { linebreakReplacement: o } = t.doc.type.schema, i = t.doc.resolve(e - n), s = i.node().type;
  if (o && s.inlineContent) {
    let u = s.whitespace == "pre", d = !!s.contentMatch.matchType(o);
    u && !d ? r = !1 : !u && d && (r = !0);
  }
  let a = t.steps.length;
  if (r === !1) {
    let u = t.doc.resolve(e + n);
    _b(t, u.node(), u.before(), a);
  }
  s.inlineContent && Wd(t, e + n - 1, s, i.node().contentMatchAt(i.index()), r == null);
  let l = t.mapping.slice(a), c = l.map(e - n);
  if (t.step(new ft(c, l.map(e + n, -1), Y.empty, !0)), r === !0) {
    let u = t.doc.resolve(c);
    Ab(t, u.node(), u.before(), t.steps.length);
  }
  return t;
}
function fN(t, e, n) {
  let r = t.resolve(e);
  if (r.parent.canReplaceWith(r.index(), r.index(), n))
    return e;
  if (r.parentOffset == 0)
    for (let o = r.depth - 1; o >= 0; o--) {
      let i = r.index(o);
      if (r.node(o).canReplaceWith(i, i, n))
        return r.before(o + 1);
      if (i > 0)
        return null;
    }
  if (r.parentOffset == r.parent.content.size)
    for (let o = r.depth - 1; o >= 0; o--) {
      let i = r.indexAfter(o);
      if (r.node(o).canReplaceWith(i, i, n))
        return r.after(o + 1);
      if (i < r.node(o).childCount)
        return null;
    }
  return null;
}
function Ob(t, e, n) {
  let r = t.resolve(e);
  if (!n.content.size)
    return e;
  let o = n.content;
  for (let i = 0; i < n.openStart; i++)
    o = o.firstChild.content;
  for (let i = 1; i <= (n.openStart == 0 && n.size ? 2 : 1); i++)
    for (let s = r.depth; s >= 0; s--) {
      let a = s == r.depth ? 0 : r.pos <= (r.start(s + 1) + r.end(s + 1)) / 2 ? -1 : 1, l = r.index(s) + (a > 0 ? 1 : 0), c = r.node(s), u = !1;
      if (i == 1)
        u = c.canReplace(l, l, o);
      else {
        let d = c.contentMatchAt(l).findWrapping(o.firstChild.type);
        u = d && c.canReplaceWith(l, l, d[0]);
      }
      if (u)
        return a == 0 ? r.pos : a < 0 ? r.before(s + 1) : r.after(s + 1);
    }
  return null;
}
function Ql(t, e, n = e, r = Y.empty) {
  if (e == n && !r.size)
    return null;
  let o = t.resolve(e), i = t.resolve(n);
  return Ib(o, i, r) ? new ft(e, n, r) : new hN(o, i, r).fit();
}
function Ib(t, e, n) {
  return !n.openStart && !n.openEnd && t.start() == e.start() && t.parent.canReplace(t.index(), e.index(), n.content);
}
class hN {
  constructor(e, n, r) {
    this.$from = e, this.$to = n, this.unplaced = r, this.frontier = [], this.placed = D.empty;
    for (let o = 0; o <= e.depth; o++) {
      let i = e.node(o);
      this.frontier.push({
        type: i.type,
        match: i.contentMatchAt(e.indexAfter(o))
      });
    }
    for (let o = e.depth; o > 0; o--)
      this.placed = D.from(e.node(o).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let c = this.findFittable();
      c ? this.placeNodes(c) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), n = this.placed.size - this.depth - this.$from.depth, r = this.$from, o = this.close(e < 0 ? this.$to : r.doc.resolve(e));
    if (!o)
      return null;
    let i = this.placed, s = r.depth, a = o.depth;
    for (; s && a && i.childCount == 1; )
      i = i.firstChild.content, s--, a--;
    let l = new Y(i, s, a);
    return e > -1 ? new mt(r.pos, e, this.$to.pos, this.$to.end(), l, n) : l.size || r.pos != this.$to.pos ? new ft(r.pos, o.pos, l) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let n = this.unplaced.content, r = 0, o = this.unplaced.openEnd; r < e; r++) {
      let i = n.firstChild;
      if (n.childCount > 1 && (o = 0), i.type.spec.isolating && o <= r) {
        e = r;
        break;
      }
      n = i.content;
    }
    for (let n = 1; n <= 2; n++)
      for (let r = n == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
        let o, i = null;
        r ? (i = Wc(this.unplaced.content, r - 1).firstChild, o = i.content) : o = this.unplaced.content;
        let s = o.firstChild;
        for (let a = this.depth; a >= 0; a--) {
          let { type: l, match: c } = this.frontier[a], u, d = null;
          if (n == 1 && (s ? c.matchType(s.type) || (d = c.fillBefore(D.from(s), !1)) : i && l.compatibleContent(i.type)))
            return { sliceDepth: r, frontierDepth: a, parent: i, inject: d };
          if (n == 2 && s && (u = c.findWrapping(s.type)))
            return { sliceDepth: r, frontierDepth: a, parent: i, wrap: u };
          if (i && c.matchType(i.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: n, openEnd: r } = this.unplaced, o = Wc(e, n);
    return !o.childCount || o.firstChild.isLeaf ? !1 : (this.unplaced = new Y(e, n + 1, Math.max(r, o.size + n >= e.size - r ? n + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: n, openEnd: r } = this.unplaced, o = Wc(e, n);
    if (o.childCount <= 1 && n > 0) {
      let i = e.size - n <= n + o.size;
      this.unplaced = new Y(Ti(e, n - 1, 1), n - 1, i ? n - 1 : r);
    } else
      this.unplaced = new Y(Ti(e, n, 1), n, r);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: n, parent: r, inject: o, wrap: i }) {
    for (; this.depth > n; )
      this.closeFrontierNode();
    if (i)
      for (let p = 0; p < i.length; p++)
        this.openFrontierNode(i[p]);
    let s = this.unplaced, a = r ? r.content : s.content, l = s.openStart - e, c = 0, u = [], { match: d, type: f } = this.frontier[n];
    if (o) {
      for (let p = 0; p < o.childCount; p++)
        u.push(o.child(p));
      d = d.matchFragment(o);
    }
    let h = a.size + e - (s.content.size - s.openEnd);
    for (; c < a.childCount; ) {
      let p = a.child(c), g = d.matchType(p.type);
      if (!g)
        break;
      c++, (c > 1 || l == 0 || p.content.size) && (d = g, u.push(Db(p.mark(f.allowedMarks(p.marks)), c == 1 ? l : 0, c == a.childCount ? h : -1)));
    }
    let m = c == a.childCount;
    m || (h = -1), this.placed = Ci(this.placed, n, D.from(u)), this.frontier[n].match = d, m && h < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let p = 0, g = a; p < h; p++) {
      let b = g.lastChild;
      this.frontier.push({ type: b.type, match: b.contentMatchAt(b.childCount) }), g = b.content;
    }
    this.unplaced = m ? e == 0 ? Y.empty : new Y(Ti(s.content, e - 1, 1), e - 1, h < 0 ? s.openEnd : e - 1) : new Y(Ti(s.content, e, c), s.openStart, s.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], n;
    if (!e.type.isTextblock || !Vc(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (n = this.findCloseLevel(this.$to)) && n.depth == this.depth)
      return -1;
    let { depth: r } = this.$to, o = this.$to.after(r);
    for (; r > 1 && o == this.$to.end(--r); )
      ++o;
    return o;
  }
  findCloseLevel(e) {
    e: for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
      let { match: r, type: o } = this.frontier[n], i = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1)), s = Vc(e, n, o, r, i);
      if (s) {
        for (let a = n - 1; a >= 0; a--) {
          let { match: l, type: c } = this.frontier[a], u = Vc(e, a, c, l, !0);
          if (!u || u.childCount)
            continue e;
        }
        return { depth: n, fit: s, move: i ? e.doc.resolve(e.after(n + 1)) : e };
      }
    }
  }
  close(e) {
    let n = this.findCloseLevel(e);
    if (!n)
      return null;
    for (; this.depth > n.depth; )
      this.closeFrontierNode();
    n.fit.childCount && (this.placed = Ci(this.placed, n.depth, n.fit)), e = n.move;
    for (let r = n.depth + 1; r <= e.depth; r++) {
      let o = e.node(r), i = o.type.contentMatch.fillBefore(o.content, !0, e.index(r));
      this.openFrontierNode(o.type, o.attrs, i);
    }
    return e;
  }
  openFrontierNode(e, n = null, r) {
    let o = this.frontier[this.depth];
    o.match = o.match.matchType(e), this.placed = Ci(this.placed, this.depth, D.from(e.create(n, r))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let n = this.frontier.pop().match.fillBefore(D.empty, !0);
    n.childCount && (this.placed = Ci(this.placed, this.frontier.length, n));
  }
}
function Ti(t, e, n) {
  return e == 0 ? t.cutByIndex(n, t.childCount) : t.replaceChild(0, t.firstChild.copy(Ti(t.firstChild.content, e - 1, n)));
}
function Ci(t, e, n) {
  return e == 0 ? t.append(n) : t.replaceChild(t.childCount - 1, t.lastChild.copy(Ci(t.lastChild.content, e - 1, n)));
}
function Wc(t, e) {
  for (let n = 0; n < e; n++)
    t = t.firstChild.content;
  return t;
}
function Db(t, e, n) {
  if (e <= 0)
    return t;
  let r = t.content;
  return e > 1 && (r = r.replaceChild(0, Db(r.firstChild, e - 1, r.childCount == 1 ? n - 1 : 0))), e > 0 && (r = t.type.contentMatch.fillBefore(r).append(r), n <= 0 && (r = r.append(t.type.contentMatch.matchFragment(r).fillBefore(D.empty, !0)))), t.copy(r);
}
function Vc(t, e, n, r, o) {
  let i = t.node(e), s = o ? t.indexAfter(e) : t.index(e);
  if (s == i.childCount && !n.compatibleContent(i.type))
    return null;
  let a = r.fillBefore(i.content, !0, s);
  return a && !mN(n, i.content, s) ? a : null;
}
function mN(t, e, n) {
  for (let r = n; r < e.childCount; r++)
    if (!t.allowsMarks(e.child(r).marks))
      return !0;
  return !1;
}
function pN(t) {
  return t.spec.defining || t.spec.definingForContent;
}
function gN(t, e, n, r) {
  if (!r.size)
    return t.deleteRange(e, n);
  let o = t.doc.resolve(e), i = t.doc.resolve(n);
  if (Ib(o, i, r))
    return t.step(new ft(e, n, r));
  let s = Pb(o, i);
  s[s.length - 1] == 0 && s.pop();
  let a = -(o.depth + 1);
  s.unshift(a);
  for (let f = o.depth, h = o.pos - 1; f > 0; f--, h--) {
    let m = o.node(f).type.spec;
    if (m.defining || m.definingAsContext || m.isolating)
      break;
    s.indexOf(f) > -1 ? a = f : o.before(f) == h && s.splice(1, 0, -f);
  }
  let l = s.indexOf(a), c = [], u = r.openStart;
  for (let f = r.content, h = 0; ; h++) {
    let m = f.firstChild;
    if (c.push(m), h == r.openStart)
      break;
    f = m.content;
  }
  for (let f = u - 1; f >= 0; f--) {
    let h = c[f], m = pN(h.type);
    if (m && !h.sameMarkup(o.node(Math.abs(a) - 1)))
      u = f;
    else if (m || !h.type.isTextblock)
      break;
  }
  for (let f = r.openStart; f >= 0; f--) {
    let h = (f + u + 1) % (r.openStart + 1), m = c[h];
    if (m)
      for (let p = 0; p < s.length; p++) {
        let g = s[(p + l) % s.length], b = !0;
        g < 0 && (b = !1, g = -g);
        let v = o.node(g - 1), k = o.index(g - 1);
        if (v.canReplaceWith(k, k, m.type, m.marks))
          return t.replace(o.before(g), b ? i.after(g) : n, new Y(Lb(r.content, 0, r.openStart, h), h, r.openEnd));
      }
  }
  let d = t.steps.length;
  for (let f = s.length - 1; f >= 0 && (t.replace(e, n, r), !(t.steps.length > d)); f--) {
    let h = s[f];
    h < 0 || (e = o.before(h), n = i.after(h));
  }
}
function Lb(t, e, n, r, o) {
  if (e < n) {
    let i = t.firstChild;
    t = t.replaceChild(0, i.copy(Lb(i.content, e + 1, n, r, i)));
  }
  if (e > r) {
    let i = o.contentMatchAt(0), s = i.fillBefore(t).append(t);
    t = s.append(i.matchFragment(s).fillBefore(D.empty, !0));
  }
  return t;
}
function bN(t, e, n, r) {
  if (!r.isInline && e == n && t.doc.resolve(e).parent.content.size) {
    let o = fN(t.doc, e, r.type);
    o != null && (e = n = o);
  }
  t.replaceRange(e, n, new Y(D.from(r), 0, 0));
}
function yN(t, e, n) {
  let r = t.doc.resolve(e), o = t.doc.resolve(n), i = Pb(r, o);
  for (let s = 0; s < i.length; s++) {
    let a = i[s], l = s == i.length - 1;
    if (l && a == 0 || r.node(a).type.contentMatch.validEnd)
      return t.delete(r.start(a), o.end(a));
    if (a > 0 && (l || r.node(a - 1).canReplace(r.index(a - 1), o.indexAfter(a - 1))))
      return t.delete(r.before(a), o.after(a));
  }
  for (let s = 1; s <= r.depth && s <= o.depth; s++)
    if (e - r.start(s) == r.depth - s && n > r.end(s) && o.end(s) - n != o.depth - s && r.start(s - 1) == o.start(s - 1) && r.node(s - 1).canReplace(r.index(s - 1), o.index(s - 1)))
      return t.delete(r.before(s), n);
  t.delete(e, n);
}
function Pb(t, e) {
  let n = [], r = Math.min(t.depth, e.depth);
  for (let o = r; o >= 0; o--) {
    let i = t.start(o);
    if (i < t.pos - (t.depth - o) || e.end(o) > e.pos + (e.depth - o) || t.node(o).type.spec.isolating || e.node(o).type.spec.isolating)
      break;
    (i == e.start(o) || o == t.depth && o == e.depth && t.parent.inlineContent && e.parent.inlineContent && o && e.start(o - 1) == i - 1) && n.push(o);
  }
  return n;
}
class Fo extends _t {
  /**
  Construct an attribute step.
  */
  constructor(e, n, r) {
    super(), this.pos = e, this.attr = n, this.value = r;
  }
  apply(e) {
    let n = e.nodeAt(this.pos);
    if (!n)
      return it.fail("No node at attribute step's position");
    let r = /* @__PURE__ */ Object.create(null);
    for (let i in n.attrs)
      r[i] = n.attrs[i];
    r[this.attr] = this.value;
    let o = n.type.create(r, null, n.marks);
    return it.fromReplace(e, this.pos, this.pos + 1, new Y(D.from(o), 0, n.isLeaf ? 0 : 1));
  }
  getMap() {
    return Wt.empty;
  }
  invert(e) {
    return new Fo(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let n = e.mapResult(this.pos, 1);
    return n.deletedAfter ? null : new Fo(n.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.pos != "number" || typeof n.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new Fo(n.pos, n.attr, n.value);
  }
}
_t.jsonID("attr", Fo);
class es extends _t {
  /**
  Construct an attribute step.
  */
  constructor(e, n) {
    super(), this.attr = e, this.value = n;
  }
  apply(e) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let o in e.attrs)
      n[o] = e.attrs[o];
    n[this.attr] = this.value;
    let r = e.type.create(n, e.content, e.marks);
    return it.ok(r);
  }
  getMap() {
    return Wt.empty;
  }
  invert(e) {
    return new es(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, n) {
    if (typeof n.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new es(n.attr, n.value);
  }
}
_t.jsonID("docAttr", es);
let Go = class extends Error {
};
Go = function t(e) {
  let n = Error.call(this, e);
  return n.__proto__ = t.prototype, n;
};
Go.prototype = Object.create(Error.prototype);
Go.prototype.constructor = Go;
Go.prototype.name = "TransformError";
class Kd {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new Qi();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let n = this.maybeStep(e);
    if (n.failed)
      throw new Go(n.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let n = e.apply(this.doc);
    return n.failed || this.addStep(e, n.doc), n;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  Return a single range, in post-transform document positions,
  that covers all content changed by this transform. Returns null
  if no replacements are made. Note that this will ignore changes
  that add/remove marks without replacing the underlying content.
  */
  changedRange() {
    let e = 1e9, n = -1e9;
    for (let r = 0; r < this.mapping.maps.length; r++) {
      let o = this.mapping.maps[r];
      r && (e = o.map(e, 1), n = o.map(n, -1)), o.forEach((i, s, a, l) => {
        e = Math.min(e, a), n = Math.max(n, l);
      });
    }
    return e == 1e9 ? null : { from: e, to: n };
  }
  /**
  @internal
  */
  addStep(e, n) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = n;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, n = e, r = Y.empty) {
    let o = Ql(this.doc, e, n, r);
    return o && this.step(o), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, n, r) {
    return this.replace(e, n, new Y(D.from(r), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, n) {
    return this.replace(e, n, Y.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, n) {
    return this.replaceWith(e, e, n);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, n, r) {
    return gN(this, e, n, r), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, n, r) {
    return bN(this, e, n, r), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, n) {
    return yN(this, e, n), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, n) {
    return nN(this, e, n), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, n = 1) {
    return dN(this, e, n), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, n) {
    return iN(this, e, n), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, n = e, r, o = null) {
    return sN(this, e, n, r, o), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, n, r = null, o) {
    return lN(this, e, n, r, o), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(e, n, r) {
    return this.step(new Fo(e, n, r)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(e, n) {
    return this.step(new es(e, n)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, n) {
    return this.step(new wr(e, n)), this;
  }
  /**
  Remove a mark (or all marks of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, n) {
    let r = this.doc.nodeAt(e);
    if (!r)
      throw new RangeError("No node at position " + e);
    if (n instanceof We)
      n.isInSet(r.marks) && this.step(new Jr(e, n));
    else {
      let o = r.marks, i, s = [];
      for (; i = n.isInSet(o); )
        s.push(new Jr(e, i)), o = i.removeFromSet(o);
      for (let a = s.length - 1; a >= 0; a--)
        this.step(s[a]);
    }
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(e, n = 1, r) {
    return cN(this, e, n, r), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, n, r) {
    return Qx(this, e, n, r), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, n, r) {
    return eN(this, e, n, r), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, n, r) {
    return Wd(this, e, n, r), this;
  }
}
const Kc = /* @__PURE__ */ Object.create(null);
class pe {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, n, r) {
    this.$anchor = e, this.$head = n, this.ranges = r || [new Bb(e.min(n), e.max(n))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let n = 0; n < e.length; n++)
      if (e[n].$from.pos != e[n].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, n = Y.empty) {
    let r = n.content.lastChild, o = null;
    for (let a = 0; a < n.openEnd; a++)
      o = r, r = r.lastChild;
    let i = e.steps.length, s = this.ranges;
    for (let a = 0; a < s.length; a++) {
      let { $from: l, $to: c } = s[a], u = e.mapping.slice(i);
      e.replaceRange(u.map(l.pos), u.map(c.pos), a ? Y.empty : n), a == 0 && rm(e, i, (r ? r.isInline : o && o.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, n) {
    let r = e.steps.length, o = this.ranges;
    for (let i = 0; i < o.length; i++) {
      let { $from: s, $to: a } = o[i], l = e.mapping.slice(r), c = l.map(s.pos), u = l.map(a.pos);
      i ? e.deleteRange(c, u) : (e.replaceRangeWith(c, u, n), rm(e, r, n.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, n, r = !1) {
    let o = e.parent.inlineContent ? new ce(e) : Do(e.node(0), e.parent, e.pos, e.index(), n, r);
    if (o)
      return o;
    for (let i = e.depth - 1; i >= 0; i--) {
      let s = n < 0 ? Do(e.node(0), e.node(i), e.before(i + 1), e.index(i), n, r) : Do(e.node(0), e.node(i), e.after(i + 1), e.index(i) + 1, n, r);
      if (s)
        return s;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, n = 1) {
    return this.findFrom(e, n) || this.findFrom(e, -n) || new Kt(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return Do(e, e, 0, 0, 1) || new Kt(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return Do(e, e, e.content.size, e.childCount, -1) || new Kt(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, n) {
    if (!n || !n.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let r = Kc[n.type];
    if (!r)
      throw new RangeError(`No selection type ${n.type} defined`);
    return r.fromJSON(e, n);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, n) {
    if (e in Kc)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return Kc[e] = n, n.prototype.jsonID = e, n;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return ce.between(this.$anchor, this.$head).getBookmark();
  }
}
pe.prototype.visible = !0;
class Bb {
  /**
  Create a range.
  */
  constructor(e, n) {
    this.$from = e, this.$to = n;
  }
}
let tm = !1;
function nm(t) {
  !tm && !t.parent.inlineContent && (tm = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + t.parent.type.name + ")"));
}
class ce extends pe {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, n = e) {
    nm(e), nm(n), super(e, n);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, n) {
    let r = e.resolve(n.map(this.head));
    if (!r.parent.inlineContent)
      return pe.near(r);
    let o = e.resolve(n.map(this.anchor));
    return new ce(o.parent.inlineContent ? o : r, r);
  }
  replace(e, n = Y.empty) {
    if (super.replace(e, n), n == Y.empty) {
      let r = this.$from.marksAcross(this.$to);
      r && e.ensureMarks(r);
    }
  }
  eq(e) {
    return e instanceof ce && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new ec(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number" || typeof n.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new ce(e.resolve(n.anchor), e.resolve(n.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, n, r = n) {
    let o = e.resolve(n);
    return new this(o, r == n ? o : e.resolve(r));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, n, r) {
    let o = e.pos - n.pos;
    if ((!r || o) && (r = o >= 0 ? 1 : -1), !n.parent.inlineContent) {
      let i = pe.findFrom(n, r, !0) || pe.findFrom(n, -r, !0);
      if (i)
        n = i.$head;
      else
        return pe.near(n, r);
    }
    return e.parent.inlineContent || (o == 0 ? e = n : (e = (pe.findFrom(e, -r, !0) || pe.findFrom(e, r, !0)).$anchor, e.pos < n.pos != o < 0 && (e = n))), new ce(e, n);
  }
}
pe.jsonID("text", ce);
class ec {
  constructor(e, n) {
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new ec(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return ce.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class se extends pe {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let n = e.nodeAfter, r = e.node(0).resolve(e.pos + n.nodeSize);
    super(e, r), this.node = n;
  }
  map(e, n) {
    let { deleted: r, pos: o } = n.mapResult(this.anchor), i = e.resolve(o);
    return r ? pe.near(i) : new se(i);
  }
  content() {
    return new Y(D.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof se && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new qd(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new se(e.resolve(n.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, n) {
    return new se(e.resolve(n));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
se.prototype.visible = !1;
pe.jsonID("node", se);
class qd {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: n, pos: r } = e.mapResult(this.anchor);
    return n ? new ec(r, r) : new qd(r);
  }
  resolve(e) {
    let n = e.resolve(this.anchor), r = n.nodeAfter;
    return r && se.isSelectable(r) ? new se(n) : pe.near(n);
  }
}
class Kt extends pe {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, n = Y.empty) {
    if (n == Y.empty) {
      e.delete(0, e.doc.content.size);
      let r = pe.atStart(e.doc);
      r.eq(e.selection) || e.setSelection(r);
    } else
      super.replace(e, n);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new Kt(e);
  }
  map(e) {
    return new Kt(e);
  }
  eq(e) {
    return e instanceof Kt;
  }
  getBookmark() {
    return vN;
  }
}
pe.jsonID("all", Kt);
const vN = {
  map() {
    return this;
  },
  resolve(t) {
    return new Kt(t);
  }
};
function Do(t, e, n, r, o, i = !1) {
  if (e.inlineContent)
    return ce.create(t, n);
  for (let s = r - (o > 0 ? 0 : 1); o > 0 ? s < e.childCount : s >= 0; s += o) {
    let a = e.child(s);
    if (a.isAtom) {
      if (!i && se.isSelectable(a))
        return se.create(t, n - (o < 0 ? a.nodeSize : 0));
    } else {
      let l = Do(t, a, n + o, o < 0 ? a.childCount : 0, o, i);
      if (l)
        return l;
    }
    n += a.nodeSize * o;
  }
  return null;
}
function rm(t, e, n) {
  let r = t.steps.length - 1;
  if (r < e)
    return;
  let o = t.steps[r];
  if (!(o instanceof ft || o instanceof mt))
    return;
  let i = t.mapping.maps[r], s;
  i.forEach((a, l, c, u) => {
    s == null && (s = u);
  }), t.setSelection(pe.near(t.doc.resolve(s), n));
}
const om = 1, $s = 2, im = 4;
class wN extends Kd {
  /**
  @internal
  */
  constructor(e) {
    super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | om) & ~$s, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & om) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(e) {
    return this.storedMarks = e, this.updated |= $s, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(e) {
    return We.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & $s) > 0;
  }
  /**
  @internal
  */
  addStep(e, n) {
    super.addStep(e, n), this.updated = this.updated & ~$s, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(e) {
    return this.time = e, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(e, n = !0) {
    let r = this.selection;
    return n && (e = e.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || We.none))), r.replaceWith(this, e), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(e, n, r) {
    let o = this.doc.type.schema;
    if (n == null)
      return e ? this.replaceSelectionWith(o.text(e), !0) : this.deleteSelection();
    {
      if (r == null && (r = n), !e)
        return this.deleteRange(n, r);
      let i = this.storedMarks;
      if (!i) {
        let s = this.doc.resolve(n);
        i = r == n ? s.marks() : s.marksAcross(this.doc.resolve(r));
      }
      return this.replaceRangeWith(n, r, o.text(e, i)), !this.selection.empty && this.selection.to == n + e.length && this.setSelection(pe.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(e, n) {
    return this.meta[typeof e == "string" ? e : e.key] = n, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let e in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= im, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & im) > 0;
  }
}
function sm(t, e) {
  return !e || !t ? t : t.bind(e);
}
class Mi {
  constructor(e, n, r) {
    this.name = e, this.init = sm(n.init, r), this.apply = sm(n.apply, r);
  }
}
const kN = [
  new Mi("doc", {
    init(t) {
      return t.doc || t.schema.topNodeType.createAndFill();
    },
    apply(t) {
      return t.doc;
    }
  }),
  new Mi("selection", {
    init(t, e) {
      return t.selection || pe.atStart(e.doc);
    },
    apply(t) {
      return t.selection;
    }
  }),
  new Mi("storedMarks", {
    init(t) {
      return t.storedMarks || null;
    },
    apply(t, e, n, r) {
      return r.selection.$cursor ? t.storedMarks : null;
    }
  }),
  new Mi("scrollToSelection", {
    init() {
      return 0;
    },
    apply(t, e) {
      return t.scrolledIntoView ? e + 1 : e;
    }
  })
];
class qc {
  constructor(e, n) {
    this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = kN.slice(), n && n.forEach((r) => {
      if (this.pluginsByKey[r.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
      this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new Mi(r.key, r.spec.state, r));
    });
  }
}
class $o {
  /**
  @internal
  */
  constructor(e) {
    this.config = e;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(e) {
    return this.applyTransaction(e).state;
  }
  /**
  @internal
  */
  filterTransaction(e, n = -1) {
    for (let r = 0; r < this.config.plugins.length; r++)
      if (r != n) {
        let o = this.config.plugins[r];
        if (o.spec.filterTransaction && !o.spec.filterTransaction.call(o, e, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(e) {
    if (!this.filterTransaction(e))
      return { state: this, transactions: [] };
    let n = [e], r = this.applyInner(e), o = null;
    for (; ; ) {
      let i = !1;
      for (let s = 0; s < this.config.plugins.length; s++) {
        let a = this.config.plugins[s];
        if (a.spec.appendTransaction) {
          let l = o ? o[s].n : 0, c = o ? o[s].state : this, u = l < n.length && a.spec.appendTransaction.call(a, l ? n.slice(l) : n, c, r);
          if (u && r.filterTransaction(u, s)) {
            if (u.setMeta("appendedTransaction", e), !o) {
              o = [];
              for (let d = 0; d < this.config.plugins.length; d++)
                o.push(d < s ? { state: r, n: n.length } : { state: this, n: 0 });
            }
            n.push(u), r = r.applyInner(u), i = !0;
          }
          o && (o[s] = { state: r, n: n.length });
        }
      }
      if (!i)
        return { state: r, transactions: n };
    }
  }
  /**
  @internal
  */
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let n = new $o(this.config), r = this.config.fields;
    for (let o = 0; o < r.length; o++) {
      let i = r[o];
      n[i.name] = i.apply(e, this[i.name], this, n);
    }
    return n;
  }
  /**
  Accessor that constructs and returns a new [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new wN(this);
  }
  /**
  Create a new state.
  */
  static create(e) {
    let n = new qc(e.doc ? e.doc.type.schema : e.schema, e.plugins), r = new $o(n);
    for (let o = 0; o < n.fields.length; o++)
      r[n.fields[o].name] = n.fields[o].init(e, r);
    return r;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(e) {
    let n = new qc(this.schema, e.plugins), r = n.fields, o = new $o(n);
    for (let i = 0; i < r.length; i++) {
      let s = r[i].name;
      o[s] = this.hasOwnProperty(s) ? this[s] : r[i].init(e, o);
    }
    return o;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(e) {
    let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (n.storedMarks = this.storedMarks.map((r) => r.toJSON())), e && typeof e == "object")
      for (let r in e) {
        if (r == "doc" || r == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let o = e[r], i = o.spec.state;
        i && i.toJSON && (n[r] = i.toJSON.call(o, this[o.key]));
      }
    return n;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(e, n, r) {
    if (!n)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let o = new qc(e.schema, e.plugins), i = new $o(o);
    return o.fields.forEach((s) => {
      if (s.name == "doc")
        i.doc = xr.fromJSON(e.schema, n.doc);
      else if (s.name == "selection")
        i.selection = pe.fromJSON(i.doc, n.selection);
      else if (s.name == "storedMarks")
        n.storedMarks && (i.storedMarks = n.storedMarks.map(e.schema.markFromJSON));
      else {
        if (r)
          for (let a in r) {
            let l = r[a], c = l.spec.state;
            if (l.key == s.name && c && c.fromJSON && Object.prototype.hasOwnProperty.call(n, a)) {
              i[s.name] = c.fromJSON.call(l, e, n[a], i);
              return;
            }
          }
        i[s.name] = s.init(e, i);
      }
    }), i;
  }
}
function zb(t, e, n) {
  for (let r in t) {
    let o = t[r];
    o instanceof Function ? o = o.bind(e) : r == "handleDOMEvents" && (o = zb(o, e, {})), n[r] = o;
  }
  return n;
}
class Ce {
  /**
  Create a plugin.
  */
  constructor(e) {
    this.spec = e, this.props = {}, e.props && zb(e.props, this, this.props), this.key = e.key ? e.key.key : $b("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const Gc = /* @__PURE__ */ Object.create(null);
function $b(t) {
  return t in Gc ? t + "$" + ++Gc[t] : (Gc[t] = 0, t + "$");
}
class Ie {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = $b(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const Gd = (t, e) => t.selection.empty ? !1 : (e && e(t.tr.deleteSelection().scrollIntoView()), !0);
function Hb(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("backward", t) : n.parentOffset > 0) ? null : n;
}
const Fb = (t, e, n) => {
  let r = Hb(t, n);
  if (!r)
    return !1;
  let o = jd(r);
  if (!o) {
    let s = r.blockRange(), a = s && li(s);
    return a == null ? !1 : (e && e(t.tr.lift(s, a).scrollIntoView()), !0);
  }
  let i = o.nodeBefore;
  if (Xb(t, o, e, -1))
    return !0;
  if (r.parent.content.size == 0 && (jo(i, "end") || se.isSelectable(i)))
    for (let s = r.depth; ; s--) {
      let a = Ql(t.doc, r.before(s), r.after(s), Y.empty);
      if (a && a.slice.size < a.to - a.from) {
        if (e) {
          let l = t.tr.step(a);
          l.setSelection(jo(i, "end") ? pe.findFrom(l.doc.resolve(l.mapping.map(o.pos, -1)), -1) : se.create(l.doc, o.pos - i.nodeSize)), e(l.scrollIntoView());
        }
        return !0;
      }
      if (s == 1 || r.node(s - 1).childCount > 1)
        break;
    }
  return i.isAtom && o.depth == r.depth - 1 ? (e && e(t.tr.delete(o.pos - i.nodeSize, o.pos).scrollIntoView()), !0) : !1;
}, xN = (t, e, n) => {
  let r = Hb(t, n);
  if (!r)
    return !1;
  let o = jd(r);
  return o ? Ub(t, o, e) : !1;
}, NN = (t, e, n) => {
  let r = Vb(t, n);
  if (!r)
    return !1;
  let o = Yd(r);
  return o ? Ub(t, o, e) : !1;
};
function Ub(t, e, n) {
  let r = e.nodeBefore, o = r, i = e.pos - 1;
  for (; !o.isTextblock; i--) {
    if (o.type.spec.isolating)
      return !1;
    let u = o.lastChild;
    if (!u)
      return !1;
    o = u;
  }
  let s = e.nodeAfter, a = s, l = e.pos + 1;
  for (; !a.isTextblock; l++) {
    if (a.type.spec.isolating)
      return !1;
    let u = a.firstChild;
    if (!u)
      return !1;
    a = u;
  }
  let c = Ql(t.doc, i, l, Y.empty);
  if (!c || c.from != i || c instanceof ft && c.slice.size >= l - i)
    return !1;
  if (n) {
    let u = t.tr.step(c);
    u.setSelection(ce.create(u.doc, i)), n(u.scrollIntoView());
  }
  return !0;
}
function jo(t, e, n = !1) {
  for (let r = t; r; r = e == "start" ? r.firstChild : r.lastChild) {
    if (r.isTextblock)
      return !0;
    if (n && r.childCount != 1)
      return !1;
  }
  return !1;
}
const Wb = (t, e, n) => {
  let { $head: r, empty: o } = t.selection, i = r;
  if (!o)
    return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("backward", t) : r.parentOffset > 0)
      return !1;
    i = jd(r);
  }
  let s = i && i.nodeBefore;
  return !s || !se.isSelectable(s) ? !1 : (e && e(t.tr.setSelection(se.create(t.doc, i.pos - s.nodeSize)).scrollIntoView()), !0);
};
function jd(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      if (t.index(e) > 0)
        return t.doc.resolve(t.before(e + 1));
      if (t.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function Vb(t, e) {
  let { $cursor: n } = t.selection;
  return !n || (e ? !e.endOfTextblock("forward", t) : n.parentOffset < n.parent.content.size) ? null : n;
}
const Kb = (t, e, n) => {
  let r = Vb(t, n);
  if (!r)
    return !1;
  let o = Yd(r);
  if (!o)
    return !1;
  let i = o.nodeAfter;
  if (Xb(t, o, e, 1))
    return !0;
  if (r.parent.content.size == 0 && (jo(i, "start") || se.isSelectable(i))) {
    let s = Ql(t.doc, r.before(), r.after(), Y.empty);
    if (s && s.slice.size < s.to - s.from) {
      if (e) {
        let a = t.tr.step(s);
        a.setSelection(jo(i, "start") ? pe.findFrom(a.doc.resolve(a.mapping.map(o.pos)), 1) : se.create(a.doc, a.mapping.map(o.pos))), e(a.scrollIntoView());
      }
      return !0;
    }
  }
  return i.isAtom && o.depth == r.depth - 1 ? (e && e(t.tr.delete(o.pos, o.pos + i.nodeSize).scrollIntoView()), !0) : !1;
}, qb = (t, e, n) => {
  let { $head: r, empty: o } = t.selection, i = r;
  if (!o)
    return !1;
  if (r.parent.isTextblock) {
    if (n ? !n.endOfTextblock("forward", t) : r.parentOffset < r.parent.content.size)
      return !1;
    i = Yd(r);
  }
  let s = i && i.nodeAfter;
  return !s || !se.isSelectable(s) ? !1 : (e && e(t.tr.setSelection(se.create(t.doc, i.pos)).scrollIntoView()), !0);
};
function Yd(t) {
  if (!t.parent.type.spec.isolating)
    for (let e = t.depth - 1; e >= 0; e--) {
      let n = t.node(e);
      if (t.index(e) + 1 < n.childCount)
        return t.doc.resolve(t.after(e + 1));
      if (n.type.spec.isolating)
        break;
    }
  return null;
}
const EN = (t, e) => {
  let n = t.selection, r = n instanceof se, o;
  if (r) {
    if (n.node.isTextblock || !Or(t.doc, n.from))
      return !1;
    o = n.from;
  } else if (o = Jl(t.doc, n.from, -1), o == null)
    return !1;
  if (e) {
    let i = t.tr.join(o);
    r && i.setSelection(se.create(i.doc, o - t.doc.resolve(o).nodeBefore.nodeSize)), e(i.scrollIntoView());
  }
  return !0;
}, SN = (t, e) => {
  let n = t.selection, r;
  if (n instanceof se) {
    if (n.node.isTextblock || !Or(t.doc, n.to))
      return !1;
    r = n.to;
  } else if (r = Jl(t.doc, n.to, 1), r == null)
    return !1;
  return e && e(t.tr.join(r).scrollIntoView()), !0;
}, TN = (t, e) => {
  let { $from: n, $to: r } = t.selection, o = n.blockRange(r), i = o && li(o);
  return i == null ? !1 : (e && e(t.tr.lift(o, i).scrollIntoView()), !0);
}, Gb = (t, e) => {
  let { $head: n, $anchor: r } = t.selection;
  return !n.parent.type.spec.code || !n.sameParent(r) ? !1 : (e && e(t.tr.insertText(`
`).scrollIntoView()), !0);
};
function Xd(t) {
  for (let e = 0; e < t.edgeCount; e++) {
    let { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
const CN = (t, e) => {
  let { $head: n, $anchor: r } = t.selection;
  if (!n.parent.type.spec.code || !n.sameParent(r))
    return !1;
  let o = n.node(-1), i = n.indexAfter(-1), s = Xd(o.contentMatchAt(i));
  if (!s || !o.canReplaceWith(i, i, s))
    return !1;
  if (e) {
    let a = n.after(), l = t.tr.replaceWith(a, a, s.createAndFill());
    l.setSelection(pe.near(l.doc.resolve(a), 1)), e(l.scrollIntoView());
  }
  return !0;
}, jb = (t, e) => {
  let n = t.selection, { $from: r, $to: o } = n;
  if (n instanceof Kt || r.parent.inlineContent || o.parent.inlineContent)
    return !1;
  let i = Xd(o.parent.contentMatchAt(o.indexAfter()));
  if (!i || !i.isTextblock)
    return !1;
  if (e) {
    let s = (!r.parentOffset && o.index() < o.parent.childCount ? r : o).pos, a = t.tr.insert(s, i.createAndFill());
    a.setSelection(ce.create(a.doc, s + 1)), e(a.scrollIntoView());
  }
  return !0;
}, Yb = (t, e) => {
  let { $cursor: n } = t.selection;
  if (!n || n.parent.content.size)
    return !1;
  if (n.depth > 1 && n.after() != n.end(-1)) {
    let i = n.before();
    if (Jn(t.doc, i))
      return e && e(t.tr.split(i).scrollIntoView()), !0;
  }
  let r = n.blockRange(), o = r && li(r);
  return o == null ? !1 : (e && e(t.tr.lift(r, o).scrollIntoView()), !0);
};
function MN(t) {
  return (e, n) => {
    let { $from: r, $to: o } = e.selection;
    if (e.selection instanceof se && e.selection.node.isBlock)
      return !r.parentOffset || !Jn(e.doc, r.pos) ? !1 : (n && n(e.tr.split(r.pos).scrollIntoView()), !0);
    if (!r.depth)
      return !1;
    let i = [], s, a, l = !1, c = !1;
    for (let h = r.depth; ; h--)
      if (r.node(h).isBlock) {
        l = r.end(h) == r.pos + (r.depth - h), c = r.start(h) == r.pos - (r.depth - h), a = Xd(r.node(h - 1).contentMatchAt(r.indexAfter(h - 1))), i.unshift(l && a ? { type: a } : null), s = h;
        break;
      } else {
        if (h == 1)
          return !1;
        i.unshift(null);
      }
    let u = e.tr;
    (e.selection instanceof ce || e.selection instanceof Kt) && u.deleteSelection();
    let d = u.mapping.map(r.pos), f = Jn(u.doc, d, i.length, i);
    if (f || (i[0] = a ? { type: a } : null, f = Jn(u.doc, d, i.length, i)), !f)
      return !1;
    if (u.split(d, i.length, i), !l && c && r.node(s).type != a) {
      let h = u.mapping.map(r.before(s)), m = u.doc.resolve(h);
      a && r.node(s - 1).canReplaceWith(m.index(), m.index() + 1, a) && u.setNodeMarkup(u.mapping.map(r.before(s)), a);
    }
    return n && n(u.scrollIntoView()), !0;
  };
}
const AN = MN(), _N = (t, e) => {
  let { $from: n, to: r } = t.selection, o, i = n.sharedDepth(r);
  return i == 0 ? !1 : (o = n.before(i), e && e(t.tr.setSelection(se.create(t.doc, o))), !0);
};
function RN(t, e, n) {
  let r = e.nodeBefore, o = e.nodeAfter, i = e.index();
  return !r || !o || !r.type.compatibleContent(o.type) ? !1 : !r.content.size && e.parent.canReplace(i - 1, i) ? (n && n(t.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(i, i + 1) || !(o.isTextblock || Or(t.doc, e.pos)) ? !1 : (n && n(t.tr.join(e.pos).scrollIntoView()), !0);
}
function Xb(t, e, n, r) {
  let o = e.nodeBefore, i = e.nodeAfter, s, a, l = o.type.spec.isolating || i.type.spec.isolating;
  if (!l && RN(t, e, n))
    return !0;
  let c = !l && e.parent.canReplace(e.index(), e.index() + 1);
  if (c && (s = (a = o.contentMatchAt(o.childCount)).findWrapping(i.type)) && a.matchType(s[0] || i.type).validEnd) {
    if (n) {
      let h = e.pos + i.nodeSize, m = D.empty;
      for (let b = s.length - 1; b >= 0; b--)
        m = D.from(s[b].create(null, m));
      m = D.from(o.copy(m));
      let p = t.tr.step(new mt(e.pos - 1, h, e.pos, h, new Y(m, 1, 0), s.length, !0)), g = p.doc.resolve(h + 2 * s.length);
      g.nodeAfter && g.nodeAfter.type == o.type && Or(p.doc, g.pos) && p.join(g.pos), n(p.scrollIntoView());
    }
    return !0;
  }
  let u = i.type.spec.isolating || r > 0 && l ? null : pe.findFrom(e, 1), d = u && u.$from.blockRange(u.$to), f = d && li(d);
  if (f != null && f >= e.depth)
    return n && n(t.tr.lift(d, f).scrollIntoView()), !0;
  if (c && jo(i, "start", !0) && jo(o, "end")) {
    let h = o, m = [];
    for (; m.push(h), !h.isTextblock; )
      h = h.lastChild;
    let p = i, g = 1;
    for (; !p.isTextblock; p = p.firstChild)
      g++;
    if (h.canReplace(h.childCount, h.childCount, p.content)) {
      if (n) {
        let b = D.empty;
        for (let k = m.length - 1; k >= 0; k--)
          b = D.from(m[k].copy(b));
        let v = t.tr.step(new mt(e.pos - m.length, e.pos + i.nodeSize, e.pos + g, e.pos + i.nodeSize - g, new Y(b, m.length, 0), 0, !0));
        n(v.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function Zb(t) {
  return function(e, n) {
    let r = e.selection, o = t < 0 ? r.$from : r.$to, i = o.depth;
    for (; o.node(i).isInline; ) {
      if (!i)
        return !1;
      i--;
    }
    return o.node(i).isTextblock ? (n && n(e.tr.setSelection(ce.create(e.doc, t < 0 ? o.start(i) : o.end(i)))), !0) : !1;
  };
}
const ON = Zb(-1), IN = Zb(1);
function DN(t, e = null) {
  return function(n, r) {
    let { $from: o, $to: i } = n.selection, s = o.blockRange(i), a = s && Vd(s, t, e);
    return a ? (r && r(n.tr.wrap(s, a).scrollIntoView()), !0) : !1;
  };
}
function am(t, e = null) {
  return function(n, r) {
    let o = !1;
    for (let i = 0; i < n.selection.ranges.length && !o; i++) {
      let { $from: { pos: s }, $to: { pos: a } } = n.selection.ranges[i];
      n.doc.nodesBetween(s, a, (l, c) => {
        if (o)
          return !1;
        if (!(!l.isTextblock || l.hasMarkup(t, e)))
          if (l.type == t)
            o = !0;
          else {
            let u = n.doc.resolve(c), d = u.index();
            o = u.parent.canReplaceWith(d, d + 1, t);
          }
      });
    }
    if (!o)
      return !1;
    if (r) {
      let i = n.tr;
      for (let s = 0; s < n.selection.ranges.length; s++) {
        let { $from: { pos: a }, $to: { pos: l } } = n.selection.ranges[s];
        i.setBlockType(a, l, t, e);
      }
      r(i.scrollIntoView());
    }
    return !0;
  };
}
function Zd(...t) {
  return function(e, n, r) {
    for (let o = 0; o < t.length; o++)
      if (t[o](e, n, r))
        return !0;
    return !1;
  };
}
Zd(Gd, Fb, Wb);
Zd(Gd, Kb, qb);
Zd(Gb, jb, Yb, AN);
typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin";
function LN(t, e = null) {
  return function(n, r) {
    let { $from: o, $to: i } = n.selection, s = o.blockRange(i);
    if (!s)
      return !1;
    let a = r ? n.tr : null;
    return PN(a, s, t, e) ? (r && r(a.scrollIntoView()), !0) : !1;
  };
}
function PN(t, e, n, r = null) {
  let o = !1, i = e, s = e.$from.doc;
  if (e.depth >= 2 && e.$from.node(e.depth - 1).type.compatibleContent(n) && e.startIndex == 0) {
    if (e.$from.index(e.depth - 1) == 0)
      return !1;
    let l = s.resolve(e.start - 2);
    i = new Ia(l, l, e.depth), e.endIndex < e.parent.childCount && (e = new Ia(e.$from, s.resolve(e.$to.end(e.depth)), e.depth)), o = !0;
  }
  let a = Vd(i, n, r, e);
  return a ? (t && BN(t, e, a, o, n), !0) : !1;
}
function BN(t, e, n, r, o) {
  let i = D.empty;
  for (let u = n.length - 1; u >= 0; u--)
    i = D.from(n[u].type.create(n[u].attrs, i));
  t.step(new mt(e.start - (r ? 2 : 0), e.end, e.start, e.end, new Y(i, 0, 0), n.length, !0));
  let s = 0;
  for (let u = 0; u < n.length; u++)
    n[u].type == o && (s = u + 1);
  let a = n.length - s, l = e.start + n.length - (r ? 2 : 0), c = e.parent;
  for (let u = e.startIndex, d = e.endIndex, f = !0; u < d; u++, f = !1)
    !f && Jn(t.doc, l, a) && (t.split(l, a), l += 2 * a), l += c.child(u).nodeSize;
  return t;
}
function zN(t) {
  return function(e, n) {
    let { $from: r, $to: o } = e.selection, i = r.blockRange(o, (s) => s.childCount > 0 && s.firstChild.type == t);
    return i ? n ? r.node(i.depth - 1).type == t ? $N(e, n, t, i) : HN(e, n, i) : !0 : !1;
  };
}
function $N(t, e, n, r) {
  let o = t.tr, i = r.end, s = r.$to.end(r.depth);
  i < s && (o.step(new mt(i - 1, s, i, s, new Y(D.from(n.create(null, r.parent.copy())), 1, 0), 1, !0)), r = new Ia(o.doc.resolve(r.$from.pos), o.doc.resolve(s), r.depth));
  const a = li(r);
  if (a == null)
    return !1;
  o.lift(r, a);
  let l = o.doc.resolve(o.mapping.map(i, -1) - 1);
  return Or(o.doc, l.pos) && l.nodeBefore.type == l.nodeAfter.type && o.join(l.pos), e(o.scrollIntoView()), !0;
}
function HN(t, e, n) {
  let r = t.tr, o = n.parent;
  for (let h = n.end, m = n.endIndex - 1, p = n.startIndex; m > p; m--)
    h -= o.child(m).nodeSize, r.delete(h - 1, h + 1);
  let i = r.doc.resolve(n.start), s = i.nodeAfter;
  if (r.mapping.map(n.end) != n.start + i.nodeAfter.nodeSize)
    return !1;
  let a = n.startIndex == 0, l = n.endIndex == o.childCount, c = i.node(-1), u = i.index(-1);
  if (!c.canReplace(u + (a ? 0 : 1), u + 1, s.content.append(l ? D.empty : D.from(o))))
    return !1;
  let d = i.pos, f = d + s.nodeSize;
  return r.step(new mt(d - (a ? 1 : 0), f + (l ? 1 : 0), d + 1, f - 1, new Y((a ? D.empty : D.from(o.copy(D.empty))).append(l ? D.empty : D.from(o.copy(D.empty))), a ? 0 : 1, l ? 0 : 1), a ? 0 : 1)), e(r.scrollIntoView()), !0;
}
function FN(t) {
  return function(e, n) {
    let { $from: r, $to: o } = e.selection, i = r.blockRange(o, (c) => c.childCount > 0 && c.firstChild.type == t);
    if (!i)
      return !1;
    let s = i.startIndex;
    if (s == 0)
      return !1;
    let a = i.parent, l = a.child(s - 1);
    if (l.type != t)
      return !1;
    if (n) {
      let c = l.lastChild && l.lastChild.type == a.type, u = D.from(c ? t.create() : null), d = new Y(D.from(t.create(null, D.from(a.type.create(null, u)))), c ? 3 : 1, 0), f = i.start, h = i.end;
      n(e.tr.step(new mt(f - (c ? 3 : 1), h, f, h, d, 1, !0)).scrollIntoView());
    }
    return !0;
  };
}
const wt = function(t) {
  for (var e = 0; ; e++)
    if (t = t.previousSibling, !t)
      return e;
}, Yo = function(t) {
  let e = t.assignedSlot || t.parentNode;
  return e && e.nodeType == 11 ? e.host : e;
};
let Fu = null;
const Yn = function(t, e, n) {
  let r = Fu || (Fu = document.createRange());
  return r.setEnd(t, n ?? t.nodeValue.length), r.setStart(t, e || 0), r;
}, UN = function() {
  Fu = null;
}, Qr = function(t, e, n, r) {
  return n && (lm(t, e, n, r, -1) || lm(t, e, n, r, 1));
}, WN = /^(img|br|input|textarea|hr)$/i;
function lm(t, e, n, r, o) {
  for (var i; ; ) {
    if (t == n && e == r)
      return !0;
    if (e == (o < 0 ? 0 : tn(t))) {
      let s = t.parentNode;
      if (!s || s.nodeType != 1 || ps(t) || WN.test(t.nodeName) || t.contentEditable == "false")
        return !1;
      e = wt(t) + (o < 0 ? 0 : 1), t = s;
    } else if (t.nodeType == 1) {
      let s = t.childNodes[e + (o < 0 ? -1 : 0)];
      if (s.nodeType == 1 && s.contentEditable == "false")
        if (!((i = s.pmViewDesc) === null || i === void 0) && i.ignoreForSelection)
          e += o;
        else
          return !1;
      else
        t = s, e = o < 0 ? tn(t) : 0;
    } else
      return !1;
  }
}
function tn(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function VN(t, e) {
  for (; ; ) {
    if (t.nodeType == 3 && e)
      return t;
    if (t.nodeType == 1 && e > 0) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[e - 1], e = tn(t);
    } else if (t.parentNode && !ps(t))
      e = wt(t), t = t.parentNode;
    else
      return null;
  }
}
function KN(t, e) {
  for (; ; ) {
    if (t.nodeType == 3 && e < t.nodeValue.length)
      return t;
    if (t.nodeType == 1 && e < t.childNodes.length) {
      if (t.contentEditable == "false")
        return null;
      t = t.childNodes[e], e = 0;
    } else if (t.parentNode && !ps(t))
      e = wt(t) + 1, t = t.parentNode;
    else
      return null;
  }
}
function qN(t, e, n) {
  for (let r = e == 0, o = e == tn(t); r || o; ) {
    if (t == n)
      return !0;
    let i = wt(t);
    if (t = t.parentNode, !t)
      return !1;
    r = r && i == 0, o = o && i == tn(t);
  }
}
function ps(t) {
  let e;
  for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t);
}
const tc = function(t) {
  return t.focusNode && Qr(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset);
};
function Fr(t, e) {
  let n = document.createEvent("Event");
  return n.initEvent("keydown", !0, !0), n.keyCode = t, n.key = n.code = e, n;
}
function GN(t) {
  let e = t.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function jN(t, e, n) {
  if (t.caretPositionFromPoint)
    try {
      let r = t.caretPositionFromPoint(e, n);
      if (r)
        return { node: r.offsetNode, offset: Math.min(tn(r.offsetNode), r.offset) };
    } catch {
    }
  if (t.caretRangeFromPoint) {
    let r = t.caretRangeFromPoint(e, n);
    if (r)
      return { node: r.startContainer, offset: Math.min(tn(r.startContainer), r.startOffset) };
  }
}
const In = typeof navigator < "u" ? navigator : null, cm = typeof document < "u" ? document : null, Ir = In && In.userAgent || "", Uu = /Edge\/(\d+)/.exec(Ir), Jb = /MSIE \d/.exec(Ir), Wu = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Ir), $t = !!(Jb || Wu || Uu), Er = Jb ? document.documentMode : Wu ? +Wu[1] : Uu ? +Uu[1] : 0, rn = !$t && /gecko\/(\d+)/i.test(Ir);
rn && +(/Firefox\/(\d+)/.exec(Ir) || [0, 0])[1];
const Vu = !$t && /Chrome\/(\d+)/.exec(Ir), ht = !!Vu, Qb = Vu ? +Vu[1] : 0, xt = !$t && !!In && /Apple Computer/.test(In.vendor), Xo = xt && (/Mobile\/\w+/.test(Ir) || !!In && In.maxTouchPoints > 2), en = Xo || (In ? /Mac/.test(In.platform) : !1), ey = In ? /Win/.test(In.platform) : !1, Xn = /Android \d/.test(Ir), gs = !!cm && "webkitFontSmoothing" in cm.documentElement.style, YN = gs ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function XN(t) {
  let e = t.defaultView && t.defaultView.visualViewport;
  return e ? {
    left: 0,
    right: e.width,
    top: 0,
    bottom: e.height
  } : {
    left: 0,
    right: t.documentElement.clientWidth,
    top: 0,
    bottom: t.documentElement.clientHeight
  };
}
function Fn(t, e) {
  return typeof t == "number" ? t : t[e];
}
function ZN(t) {
  let e = t.getBoundingClientRect(), n = e.width / t.offsetWidth || 1, r = e.height / t.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + t.clientWidth * n,
    top: e.top,
    bottom: e.top + t.clientHeight * r
  };
}
function um(t, e, n) {
  let r = t.someProp("scrollThreshold") || 0, o = t.someProp("scrollMargin") || 5, i = t.dom.ownerDocument;
  for (let s = n || t.dom; s; ) {
    if (s.nodeType != 1) {
      s = Yo(s);
      continue;
    }
    let a = s, l = a == i.body, c = l ? XN(i) : ZN(a), u = 0, d = 0;
    if (e.top < c.top + Fn(r, "top") ? d = -(c.top - e.top + Fn(o, "top")) : e.bottom > c.bottom - Fn(r, "bottom") && (d = e.bottom - e.top > c.bottom - c.top ? e.top + Fn(o, "top") - c.top : e.bottom - c.bottom + Fn(o, "bottom")), e.left < c.left + Fn(r, "left") ? u = -(c.left - e.left + Fn(o, "left")) : e.right > c.right - Fn(r, "right") && (u = e.right - c.right + Fn(o, "right")), u || d)
      if (l)
        i.defaultView.scrollBy(u, d);
      else {
        let h = a.scrollLeft, m = a.scrollTop;
        d && (a.scrollTop += d), u && (a.scrollLeft += u);
        let p = a.scrollLeft - h, g = a.scrollTop - m;
        e = { left: e.left - p, top: e.top - g, right: e.right - p, bottom: e.bottom - g };
      }
    let f = l ? "fixed" : getComputedStyle(s).position;
    if (/^(fixed|sticky)$/.test(f))
      break;
    s = f == "absolute" ? s.offsetParent : Yo(s);
  }
}
function JN(t) {
  let e = t.dom.getBoundingClientRect(), n = Math.max(0, e.top), r, o;
  for (let i = (e.left + e.right) / 2, s = n + 1; s < Math.min(innerHeight, e.bottom); s += 5) {
    let a = t.root.elementFromPoint(i, s);
    if (!a || a == t.dom || !t.dom.contains(a))
      continue;
    let l = a.getBoundingClientRect();
    if (l.top >= n - 20) {
      r = a, o = l.top;
      break;
    }
  }
  return { refDOM: r, refTop: o, stack: ty(t.dom) };
}
function ty(t) {
  let e = [], n = t.ownerDocument;
  for (let r = t; r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), t != n); r = Yo(r))
    ;
  return e;
}
function QN({ refDOM: t, refTop: e, stack: n }) {
  let r = t ? t.getBoundingClientRect().top : 0;
  ny(n, r == 0 ? 0 : r - e);
}
function ny(t, e) {
  for (let n = 0; n < t.length; n++) {
    let { dom: r, top: o, left: i } = t[n];
    r.scrollTop != o + e && (r.scrollTop = o + e), r.scrollLeft != i && (r.scrollLeft = i);
  }
}
let Eo = null;
function e1(t) {
  if (t.setActive)
    return t.setActive();
  if (Eo)
    return t.focus(Eo);
  let e = ty(t);
  t.focus(Eo == null ? {
    get preventScroll() {
      return Eo = { preventScroll: !0 }, !0;
    }
  } : void 0), Eo || (Eo = !1, ny(e, 0));
}
function ry(t, e) {
  let n, r = 2e8, o, i = 0, s = e.top, a = e.top, l, c;
  for (let u = t.firstChild, d = 0; u; u = u.nextSibling, d++) {
    let f;
    if (u.nodeType == 1)
      f = u.getClientRects();
    else if (u.nodeType == 3)
      f = Yn(u).getClientRects();
    else
      continue;
    for (let h = 0; h < f.length; h++) {
      let m = f[h];
      if (m.top <= s && m.bottom >= a) {
        s = Math.max(m.bottom, s), a = Math.min(m.top, a);
        let p = m.left > e.left ? m.left - e.left : m.right < e.left ? e.left - m.right : 0;
        if (p < r) {
          n = u, r = p, o = p && n.nodeType == 3 ? {
            left: m.right < e.left ? m.right : m.left,
            top: e.top
          } : e, u.nodeType == 1 && p && (i = d + (e.left >= (m.left + m.right) / 2 ? 1 : 0));
          continue;
        }
      } else m.top > e.top && !l && m.left <= e.left && m.right >= e.left && (l = u, c = { left: Math.max(m.left, Math.min(m.right, e.left)), top: m.top });
      !n && (e.left >= m.right && e.top >= m.top || e.left >= m.left && e.top >= m.bottom) && (i = d + 1);
    }
  }
  return !n && l && (n = l, o = c, r = 0), n && n.nodeType == 3 ? t1(n, o) : !n || r && n.nodeType == 1 ? { node: t, offset: i } : ry(n, o);
}
function t1(t, e) {
  let n = t.nodeValue.length, r = document.createRange(), o;
  for (let i = 0; i < n; i++) {
    r.setEnd(t, i + 1), r.setStart(t, i);
    let s = dr(r, 1);
    if (s.top != s.bottom && Jd(e, s)) {
      o = { node: t, offset: i + (e.left >= (s.left + s.right) / 2 ? 1 : 0) };
      break;
    }
  }
  return r.detach(), o || { node: t, offset: 0 };
}
function Jd(t, e) {
  return t.left >= e.left - 1 && t.left <= e.right + 1 && t.top >= e.top - 1 && t.top <= e.bottom + 1;
}
function n1(t, e) {
  let n = t.parentNode;
  return n && /^li$/i.test(n.nodeName) && e.left < t.getBoundingClientRect().left ? n : t;
}
function r1(t, e, n) {
  let { node: r, offset: o } = ry(e, n), i = -1;
  if (r.nodeType == 1 && !r.firstChild) {
    let s = r.getBoundingClientRect();
    i = s.left != s.right && n.left > (s.left + s.right) / 2 ? 1 : -1;
  }
  return t.docView.posFromDOM(r, o, i);
}
function o1(t, e, n, r) {
  let o = -1;
  for (let i = e, s = !1; i != t.dom; ) {
    let a = t.docView.nearestDesc(i, !0), l;
    if (!a)
      return null;
    if (a.dom.nodeType == 1 && (a.node.isBlock && a.parent || !a.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((l = a.dom.getBoundingClientRect()).width || l.height) && (a.node.isBlock && a.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(a.dom.nodeName) && (!s && l.left > r.left || l.top > r.top ? o = a.posBefore : (!s && l.right < r.left || l.bottom < r.top) && (o = a.posAfter), s = !0), !a.contentDOM && o < 0 && !a.node.isText))
      return (a.node.isBlock ? r.top < (l.top + l.bottom) / 2 : r.left < (l.left + l.right) / 2) ? a.posBefore : a.posAfter;
    i = a.dom.parentNode;
  }
  return o > -1 ? o : t.docView.posFromDOM(e, n, -1);
}
function oy(t, e, n) {
  let r = t.childNodes.length;
  if (r && n.top < n.bottom)
    for (let o = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - n.top) / (n.bottom - n.top)) - 2)), i = o; ; ) {
      let s = t.childNodes[i];
      if (s.nodeType == 1) {
        let a = s.getClientRects();
        for (let l = 0; l < a.length; l++) {
          let c = a[l];
          if (Jd(e, c))
            return oy(s, e, c);
        }
      }
      if ((i = (i + 1) % r) == o)
        break;
    }
  return t;
}
function i1(t, e) {
  let n = t.dom.ownerDocument, r, o = 0, i = jN(n, e.left, e.top);
  i && ({ node: r, offset: o } = i);
  let s = (t.root.elementFromPoint ? t.root : n).elementFromPoint(e.left, e.top), a;
  if (!s || !t.dom.contains(s.nodeType != 1 ? s.parentNode : s)) {
    let c = t.dom.getBoundingClientRect();
    if (!Jd(e, c) || (s = oy(t.dom, e, c), !s))
      return null;
  }
  if (xt)
    for (let c = s; r && c; c = Yo(c))
      c.draggable && (r = void 0);
  if (s = n1(s, e), r) {
    if (rn && r.nodeType == 1 && (o = Math.min(o, r.childNodes.length), o < r.childNodes.length)) {
      let u = r.childNodes[o], d;
      u.nodeName == "IMG" && (d = u.getBoundingClientRect()).right <= e.left && d.bottom > e.top && o++;
    }
    let c;
    gs && o && r.nodeType == 1 && (c = r.childNodes[o - 1]).nodeType == 1 && c.contentEditable == "false" && c.getBoundingClientRect().top >= e.top && o--, r == t.dom && o == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? a = t.state.doc.content.size : (o == 0 || r.nodeType != 1 || r.childNodes[o - 1].nodeName != "BR") && (a = o1(t, r, o, e));
  }
  a == null && (a = r1(t, s, e));
  let l = t.docView.nearestDesc(s, !0);
  return { pos: a, inside: l ? l.posAtStart - l.border : -1 };
}
function dm(t) {
  return t.top < t.bottom || t.left < t.right;
}
function dr(t, e) {
  let n = t.getClientRects();
  if (n.length) {
    let r = n[e < 0 ? 0 : n.length - 1];
    if (dm(r))
      return r;
  }
  return Array.prototype.find.call(n, dm) || t.getBoundingClientRect();
}
const s1 = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function iy(t, e, n) {
  let { node: r, offset: o, atom: i } = t.docView.domFromPos(e, n < 0 ? -1 : 1), s = gs || rn;
  if (r.nodeType == 3)
    if (s && (s1.test(r.nodeValue) || (n < 0 ? !o : o == r.nodeValue.length))) {
      let l = dr(Yn(r, o, o), n);
      if (rn && o && /\s/.test(r.nodeValue[o - 1]) && o < r.nodeValue.length) {
        let c = dr(Yn(r, o - 1, o - 1), -1);
        if (c.top == l.top) {
          let u = dr(Yn(r, o, o + 1), -1);
          if (u.top != l.top)
            return bi(u, u.left < c.left);
        }
      }
      return l;
    } else {
      let l = o, c = o, u = n < 0 ? 1 : -1;
      return n < 0 && !o ? (c++, u = -1) : n >= 0 && o == r.nodeValue.length ? (l--, u = 1) : n < 0 ? l-- : c++, bi(dr(Yn(r, l, c), u), u < 0);
    }
  if (!t.state.doc.resolve(e - (i || 0)).parent.inlineContent) {
    if (i == null && o && (n < 0 || o == tn(r))) {
      let l = r.childNodes[o - 1];
      if (l.nodeType == 1)
        return jc(l.getBoundingClientRect(), !1);
    }
    if (i == null && o < tn(r)) {
      let l = r.childNodes[o];
      if (l.nodeType == 1)
        return jc(l.getBoundingClientRect(), !0);
    }
    return jc(r.getBoundingClientRect(), n >= 0);
  }
  if (i == null && o && (n < 0 || o == tn(r))) {
    let l = r.childNodes[o - 1], c = l.nodeType == 3 ? Yn(l, tn(l) - (s ? 0 : 1)) : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling) ? l : null;
    if (c)
      return bi(dr(c, 1), !1);
  }
  if (i == null && o < tn(r)) {
    let l = r.childNodes[o];
    for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; )
      l = l.nextSibling;
    let c = l ? l.nodeType == 3 ? Yn(l, 0, s ? 0 : 1) : l.nodeType == 1 ? l : null : null;
    if (c)
      return bi(dr(c, -1), !0);
  }
  return bi(dr(r.nodeType == 3 ? Yn(r) : r, -n), n >= 0);
}
function bi(t, e) {
  if (t.width == 0)
    return t;
  let n = e ? t.left : t.right;
  return { top: t.top, bottom: t.bottom, left: n, right: n };
}
function jc(t, e) {
  if (t.height == 0)
    return t;
  let n = e ? t.top : t.bottom;
  return { top: n, bottom: n, left: t.left, right: t.right };
}
function sy(t, e, n) {
  let r = t.state, o = t.root.activeElement;
  r != e && t.updateState(e), o != t.dom && t.focus();
  try {
    return n();
  } finally {
    r != e && t.updateState(r), o != t.dom && o && o.focus();
  }
}
function a1(t, e, n) {
  let r = e.selection, o = n == "up" ? r.$from : r.$to;
  return sy(t, e, () => {
    let { node: i } = t.docView.domFromPos(o.pos, n == "up" ? -1 : 1);
    for (; ; ) {
      let a = t.docView.nearestDesc(i, !0);
      if (!a)
        break;
      if (a.node.isBlock) {
        i = a.contentDOM || a.dom;
        break;
      }
      i = a.dom.parentNode;
    }
    let s = iy(t, o.pos, 1);
    for (let a = i.firstChild; a; a = a.nextSibling) {
      let l;
      if (a.nodeType == 1)
        l = a.getClientRects();
      else if (a.nodeType == 3)
        l = Yn(a, 0, a.nodeValue.length).getClientRects();
      else
        continue;
      for (let c = 0; c < l.length; c++) {
        let u = l[c];
        if (u.bottom > u.top + 1 && (n == "up" ? s.top - u.top > (u.bottom - s.top) * 2 : u.bottom - s.bottom > (s.bottom - u.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const l1 = /[\u0590-\u08ac]/;
function c1(t, e, n) {
  let { $head: r } = e.selection;
  if (!r.parent.isTextblock)
    return !1;
  let o = r.parentOffset, i = !o, s = o == r.parent.content.size, a = t.domSelection();
  return a ? !l1.test(r.parent.textContent) || !a.modify ? n == "left" || n == "backward" ? i : s : sy(t, e, () => {
    let { focusNode: l, focusOffset: c, anchorNode: u, anchorOffset: d } = t.domSelectionRange(), f = a.caretBidiLevel;
    a.modify("move", n, "character");
    let h = r.depth ? t.docView.domAfterPos(r.before()) : t.dom, { focusNode: m, focusOffset: p } = t.domSelectionRange(), g = m && !h.contains(m.nodeType == 1 ? m : m.parentNode) || l == m && c == p;
    try {
      a.collapse(u, d), l && (l != u || c != d) && a.extend && a.extend(l, c);
    } catch {
    }
    return f != null && (a.caretBidiLevel = f), g;
  }) : r.pos == r.start() || r.pos == r.end();
}
let fm = null, hm = null, mm = !1;
function u1(t, e, n) {
  return fm == e && hm == n ? mm : (fm = e, hm = n, mm = n == "up" || n == "down" ? a1(t, e, n) : c1(t, e, n));
}
const on = 0, pm = 1, Ur = 2, Dn = 3;
class bs {
  constructor(e, n, r, o) {
    this.parent = e, this.children = n, this.dom = r, this.contentDOM = o, this.dirty = on, r.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, n, r) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(e) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let e = 0;
    for (let n = 0; n < this.children.length; n++)
      e += this.children[n].size;
    return e;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++)
      this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let n = 0, r = this.posAtStart; ; n++) {
      let o = this.children[n];
      if (o == e)
        return r;
      r += o.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, n, r) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (r < 0) {
        let i, s;
        if (e == this.contentDOM)
          i = e.childNodes[n - 1];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          i = e.previousSibling;
        }
        for (; i && !((s = i.pmViewDesc) && s.parent == this); )
          i = i.previousSibling;
        return i ? this.posBeforeChild(s) + s.size : this.posAtStart;
      } else {
        let i, s;
        if (e == this.contentDOM)
          i = e.childNodes[n];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          i = e.nextSibling;
        }
        for (; i && !((s = i.pmViewDesc) && s.parent == this); )
          i = i.nextSibling;
        return i ? this.posBeforeChild(s) : this.posAtEnd;
      }
    let o;
    if (e == this.dom && this.contentDOM)
      o = n > wt(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      o = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (n == 0)
        for (let i = e; ; i = i.parentNode) {
          if (i == this.dom) {
            o = !1;
            break;
          }
          if (i.previousSibling)
            break;
        }
      if (o == null && n == e.childNodes.length)
        for (let i = e; ; i = i.parentNode) {
          if (i == this.dom) {
            o = !0;
            break;
          }
          if (i.nextSibling)
            break;
        }
    }
    return o ?? r > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, n = !1) {
    for (let r = !0, o = e; o; o = o.parentNode) {
      let i = this.getDesc(o), s;
      if (i && (!n || i.node))
        if (r && (s = i.nodeDOM) && !(s.nodeType == 1 ? s.contains(e.nodeType == 1 ? e : e.parentNode) : s == e))
          r = !1;
        else
          return i;
    }
  }
  getDesc(e) {
    let n = e.pmViewDesc;
    for (let r = n; r; r = r.parent)
      if (r == this)
        return n;
  }
  posFromDOM(e, n, r) {
    for (let o = e; o; o = o.parentNode) {
      let i = this.getDesc(o);
      if (i)
        return i.localPosFromDOM(e, n, r);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(e) {
    for (let n = 0, r = 0; n < this.children.length; n++) {
      let o = this.children[n], i = r + o.size;
      if (r == e && i != r) {
        for (; !o.border && o.children.length; )
          for (let s = 0; s < o.children.length; s++) {
            let a = o.children[s];
            if (a.size) {
              o = a;
              break;
            }
          }
        return o;
      }
      if (e < i)
        return o.descAt(e - r - o.border);
      r = i;
    }
  }
  domFromPos(e, n) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: e + 1 };
    let r = 0, o = 0;
    for (let i = 0; r < this.children.length; r++) {
      let s = this.children[r], a = i + s.size;
      if (a > e || s instanceof ly) {
        o = e - i;
        break;
      }
      i = a;
    }
    if (o)
      return this.children[r].domFromPos(o - this.children[r].border, n);
    for (let i; r && !(i = this.children[r - 1]).size && i instanceof ay && i.side >= 0; r--)
      ;
    if (n <= 0) {
      let i, s = !0;
      for (; i = r ? this.children[r - 1] : null, !(!i || i.dom.parentNode == this.contentDOM); r--, s = !1)
        ;
      return i && n && s && !i.border && !i.domAtom ? i.domFromPos(i.size, n) : { node: this.contentDOM, offset: i ? wt(i.dom) + 1 : 0 };
    } else {
      let i, s = !0;
      for (; i = r < this.children.length ? this.children[r] : null, !(!i || i.dom.parentNode == this.contentDOM); r++, s = !1)
        ;
      return i && s && !i.border && !i.domAtom ? i.domFromPos(0, n) : { node: this.contentDOM, offset: i ? wt(i.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(e, n, r = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: e, to: n, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let o = -1, i = -1;
    for (let s = r, a = 0; ; a++) {
      let l = this.children[a], c = s + l.size;
      if (o == -1 && e <= c) {
        let u = s + l.border;
        if (e >= u && n <= c - l.border && l.node && l.contentDOM && this.contentDOM.contains(l.contentDOM))
          return l.parseRange(e, n, u);
        e = s;
        for (let d = a; d > 0; d--) {
          let f = this.children[d - 1];
          if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(1)) {
            o = wt(f.dom) + 1;
            break;
          }
          e -= f.size;
        }
        o == -1 && (o = 0);
      }
      if (o > -1 && (c > n || a == this.children.length - 1)) {
        n = c;
        for (let u = a + 1; u < this.children.length; u++) {
          let d = this.children[u];
          if (d.size && d.dom.parentNode == this.contentDOM && !d.emptyChildAt(-1)) {
            i = wt(d.dom);
            break;
          }
          n += d.size;
        }
        i == -1 && (i = this.contentDOM.childNodes.length);
        break;
      }
      s = c;
    }
    return { node: this.contentDOM, from: e, to: n, fromOffset: o, toOffset: i };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let n = this.children[e < 0 ? 0 : this.children.length - 1];
    return n.size == 0 || n.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: n, offset: r } = this.domFromPos(e, 0);
    if (n.nodeType != 1 || r == n.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return n.childNodes[r];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(e, n, r, o = !1) {
    let i = Math.min(e, n), s = Math.max(e, n);
    for (let h = 0, m = 0; h < this.children.length; h++) {
      let p = this.children[h], g = m + p.size;
      if (i > m && s < g)
        return p.setSelection(e - m - p.border, n - m - p.border, r, o);
      m = g;
    }
    let a = this.domFromPos(e, e ? -1 : 1), l = n == e ? a : this.domFromPos(n, n ? -1 : 1), c = r.root.getSelection(), u = r.domSelectionRange(), d = !1;
    if ((rn || xt) && e == n) {
      let { node: h, offset: m } = a;
      if (h.nodeType == 3) {
        if (d = !!(m && h.nodeValue[m - 1] == `
`), d && m == h.nodeValue.length)
          for (let p = h, g; p; p = p.parentNode) {
            if (g = p.nextSibling) {
              g.nodeName == "BR" && (a = l = { node: g.parentNode, offset: wt(g) + 1 });
              break;
            }
            let b = p.pmViewDesc;
            if (b && b.node && b.node.isBlock)
              break;
          }
      } else {
        let p = h.childNodes[m - 1];
        d = p && (p.nodeName == "BR" || p.contentEditable == "false");
      }
    }
    if (rn && u.focusNode && u.focusNode != l.node && u.focusNode.nodeType == 1) {
      let h = u.focusNode.childNodes[u.focusOffset];
      h && h.contentEditable == "false" && (o = !0);
    }
    if (!(o || d && xt) && Qr(a.node, a.offset, u.anchorNode, u.anchorOffset) && Qr(l.node, l.offset, u.focusNode, u.focusOffset))
      return;
    let f = !1;
    if ((c.extend || e == n) && !(d && rn)) {
      c.collapse(a.node, a.offset);
      try {
        e != n && c.extend(l.node, l.offset), f = !0;
      } catch {
      }
    }
    if (!f) {
      if (e > n) {
        let m = a;
        a = l, l = m;
      }
      let h = document.createRange();
      h.setEnd(l.node, l.offset), h.setStart(a.node, a.offset), c.removeAllRanges(), c.addRange(h);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(e, n) {
    for (let r = 0, o = 0; o < this.children.length; o++) {
      let i = this.children[o], s = r + i.size;
      if (r == s ? e <= s && n >= r : e < s && n > r) {
        let a = r + i.border, l = s - i.border;
        if (e >= a && n <= l) {
          this.dirty = e == r || n == s ? Ur : pm, e == a && n == l && (i.contentLost || i.dom.parentNode != this.contentDOM) ? i.dirty = Dn : i.markDirty(e - a, n - a);
          return;
        } else
          i.dirty = i.dom == i.contentDOM && i.dom.parentNode == this.contentDOM && !i.children.length ? Ur : Dn;
      }
      r = s;
    }
    this.dirty = Ur;
  }
  markParentsDirty() {
    let e = 1;
    for (let n = this.parent; n; n = n.parent, e++) {
      let r = e == 1 ? Ur : pm;
      n.dirty < r && (n.dirty = r);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
  get ignoreForSelection() {
    return !1;
  }
  isText(e) {
    return !1;
  }
}
class ay extends bs {
  constructor(e, n, r, o) {
    let i, s = n.type.toDOM;
    if (typeof s == "function" && (s = s(r, () => {
      if (!i)
        return o;
      if (i.parent)
        return i.parent.posBeforeChild(i);
    })), !n.type.spec.raw) {
      if (s.nodeType != 1) {
        let a = document.createElement("span");
        a.appendChild(s), s = a;
      }
      s.contentEditable = "false", s.classList.add("ProseMirror-widget");
    }
    super(e, [], s, null), this.widget = n, this.widget = n, i = this;
  }
  matchesWidget(e) {
    return this.dirty == on && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let n = this.widget.spec.stopEvent;
    return n ? n(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get ignoreForSelection() {
    return !!this.widget.type.spec.relaxedSide;
  }
  get side() {
    return this.widget.type.side;
  }
}
class d1 extends bs {
  constructor(e, n, r, o) {
    super(e, [], n, null), this.textDOM = r, this.text = o;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, n) {
    return e != this.textDOM ? this.posAtStart + (n ? this.size : 0) : this.posAtStart + n;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class eo extends bs {
  constructor(e, n, r, o, i) {
    super(e, [], r, o), this.mark = n, this.spec = i;
  }
  static create(e, n, r, o) {
    let i = o.nodeViews[n.type.name], s = i && i(n, o, r);
    return (!s || !s.dom) && (s = so.renderSpec(document, n.type.spec.toDOM(n, r), null, n.attrs)), new eo(e, n, s.dom, s.contentDOM || s.dom, s);
  }
  parseRule() {
    return this.dirty & Dn || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(e) {
    return this.dirty != Dn && this.mark.eq(e);
  }
  markDirty(e, n) {
    if (super.markDirty(e, n), this.dirty != on) {
      let r = this.parent;
      for (; !r.node; )
        r = r.parent;
      r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = on;
    }
  }
  slice(e, n, r) {
    let o = eo.create(this.parent, this.mark, !0, r), i = this.children, s = this.size;
    n < s && (i = qu(i, n, s, r)), e > 0 && (i = qu(i, 0, e, r));
    for (let a = 0; a < i.length; a++)
      i[a].parent = o;
    return o.children = i, o;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
}
class Sr extends bs {
  constructor(e, n, r, o, i, s, a, l, c) {
    super(e, [], i, s), this.node = n, this.outerDeco = r, this.innerDeco = o, this.nodeDOM = a;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(e, n, r, o, i, s) {
    let a = i.nodeViews[n.type.name], l, c = a && a(n, i, () => {
      if (!l)
        return s;
      if (l.parent)
        return l.parent.posBeforeChild(l);
    }, r, o), u = c && c.dom, d = c && c.contentDOM;
    if (n.isText) {
      if (!u)
        u = document.createTextNode(n.text);
      else if (u.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else u || ({ dom: u, contentDOM: d } = so.renderSpec(document, n.type.spec.toDOM(n), null, n.attrs));
    !d && !n.isText && u.nodeName != "BR" && (u.hasAttribute("contenteditable") || (u.contentEditable = "false"), n.type.spec.draggable && (u.draggable = !0));
    let f = u;
    return u = dy(u, r, n), c ? l = new f1(e, n, r, o, u, d || null, f, c, i, s + 1) : n.isText ? new nc(e, n, r, o, u, f, i) : new Sr(e, n, r, o, u, d || null, f, i, s + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
      e.getContent = () => this.node.content;
    else if (!this.contentLost)
      e.contentElement = this.contentDOM;
    else {
      for (let n = this.children.length - 1; n >= 0; n--) {
        let r = this.children[n];
        if (this.dom.contains(r.dom.parentNode)) {
          e.contentElement = r.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => D.empty);
    }
    return e;
  }
  matchesNode(e, n, r) {
    return this.dirty == on && e.eq(this.node) && La(n, this.outerDeco) && r.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(e, n) {
    let r = this.node.inlineContent, o = n, i = e.composing ? this.localCompositionInfo(e, n) : null, s = i && i.pos > -1 ? i : null, a = i && i.pos < 0, l = new m1(this, s && s.node, e);
    b1(this.node, this.innerDeco, (c, u, d) => {
      c.spec.marks ? l.syncToMarks(c.spec.marks, r, e, u) : c.type.side >= 0 && !d && l.syncToMarks(u == this.node.childCount ? We.none : this.node.child(u).marks, r, e, u), l.placeWidget(c, e, o);
    }, (c, u, d, f) => {
      l.syncToMarks(c.marks, r, e, f);
      let h;
      l.findNodeMatch(c, u, d, f) || a && e.state.selection.from > o && e.state.selection.to < o + c.nodeSize && (h = l.findIndexWithChild(i.node)) > -1 && l.updateNodeAt(c, u, d, h, e) || l.updateNextNode(c, u, d, e, f, o) || l.addNode(c, u, d, e, o), o += c.nodeSize;
    }), l.syncToMarks([], r, e, 0), this.node.isTextblock && l.addTextblockHacks(), l.destroyRest(), (l.changed || this.dirty == Ur) && (s && this.protectLocalComposition(e, s), cy(this.contentDOM, this.children, e), Xo && y1(this.dom));
  }
  localCompositionInfo(e, n) {
    let { from: r, to: o } = e.state.selection;
    if (!(e.state.selection instanceof ce) || r < n || o > n + this.node.content.size)
      return null;
    let i = e.input.compositionNode;
    if (!i || !this.dom.contains(i.parentNode))
      return null;
    if (this.node.inlineContent) {
      let s = i.nodeValue, a = v1(this.node.content, s, r - n, o - n);
      return a < 0 ? null : { node: i, pos: a, text: s };
    } else
      return { node: i, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: n, pos: r, text: o }) {
    if (this.getDesc(n))
      return;
    let i = n;
    for (; i.parentNode != this.contentDOM; i = i.parentNode) {
      for (; i.previousSibling; )
        i.parentNode.removeChild(i.previousSibling);
      for (; i.nextSibling; )
        i.parentNode.removeChild(i.nextSibling);
      i.pmViewDesc && (i.pmViewDesc = void 0);
    }
    let s = new d1(this, i, n, o);
    e.input.compositionNodes.push(s), this.children = qu(this.children, r, r + o.length, e, s);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(e, n, r, o) {
    return this.dirty == Dn || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, n, r, o), !0);
  }
  updateInner(e, n, r, o) {
    this.updateOuterDeco(n), this.node = e, this.innerDeco = r, this.contentDOM && this.updateChildren(o, this.posAtStart), this.dirty = on;
  }
  updateOuterDeco(e) {
    if (La(e, this.outerDeco))
      return;
    let n = this.nodeDOM.nodeType != 1, r = this.dom;
    this.dom = uy(this.dom, this.nodeDOM, Ku(this.outerDeco, this.node, n), Ku(e, this.node, n)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.nodeDOM.draggable = !0));
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.nodeDOM.removeAttribute("draggable"));
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function gm(t, e, n, r, o) {
  dy(r, e, t);
  let i = new Sr(void 0, t, e, n, r, r, r, o, 0);
  return i.contentDOM && i.updateChildren(o, 0), i;
}
class nc extends Sr {
  constructor(e, n, r, o, i, s, a) {
    super(e, n, r, o, i, null, s, a, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; )
      e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, n, r, o) {
    return this.dirty == Dn || this.dirty != on && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(n), (this.dirty != on || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, o.trackWrites == this.nodeDOM && (o.trackWrites = null)), this.node = e, this.dirty = on, !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == e)
        return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, n, r) {
    return e == this.nodeDOM ? this.posAtStart + Math.min(n, this.node.text.length) : super.localPosFromDOM(e, n, r);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, n, r) {
    let o = this.node.cut(e, n), i = document.createTextNode(o.text);
    return new nc(this.parent, o, this.outerDeco, this.innerDeco, i, i, r);
  }
  markDirty(e, n) {
    super.markDirty(e, n), this.dom != this.nodeDOM && (e == 0 || n == this.nodeDOM.nodeValue.length) && (this.dirty = Dn);
  }
  get domAtom() {
    return !1;
  }
  isText(e) {
    return this.node.text == e;
  }
}
class ly extends bs {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == on && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class f1 extends Sr {
  constructor(e, n, r, o, i, s, a, l, c, u) {
    super(e, n, r, o, i, s, a, c, u), this.spec = l;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(e, n, r, o) {
    if (this.dirty == Dn)
      return !1;
    if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) {
      let i = this.spec.update(e, n, r);
      return i && this.updateInner(e, n, r, o), i;
    } else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, n, r, o);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, n, r, o) {
    this.spec.setSelection ? this.spec.setSelection(e, n, r.root) : super.setSelection(e, n, r, o);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
}
function cy(t, e, n) {
  let r = t.firstChild, o = !1;
  for (let i = 0; i < e.length; i++) {
    let s = e[i], a = s.dom;
    if (a.parentNode == t) {
      for (; a != r; )
        r = bm(r), o = !0;
      r = r.nextSibling;
    } else
      o = !0, t.insertBefore(a, r);
    if (s instanceof eo) {
      let l = r ? r.previousSibling : t.lastChild;
      cy(s.contentDOM, s.children, n), r = l ? l.nextSibling : t.firstChild;
    }
  }
  for (; r; )
    r = bm(r), o = !0;
  o && n.trackWrites == t && (n.trackWrites = null);
}
const zi = function(t) {
  t && (this.nodeName = t);
};
zi.prototype = /* @__PURE__ */ Object.create(null);
const Wr = [new zi()];
function Ku(t, e, n) {
  if (t.length == 0)
    return Wr;
  let r = n ? Wr[0] : new zi(), o = [r];
  for (let i = 0; i < t.length; i++) {
    let s = t[i].type.attrs;
    if (s) {
      s.nodeName && o.push(r = new zi(s.nodeName));
      for (let a in s) {
        let l = s[a];
        l != null && (n && o.length == 1 && o.push(r = new zi(e.isInline ? "span" : "div")), a == "class" ? r.class = (r.class ? r.class + " " : "") + l : a == "style" ? r.style = (r.style ? r.style + ";" : "") + l : a != "nodeName" && (r[a] = l));
      }
    }
  }
  return o;
}
function uy(t, e, n, r) {
  if (n == Wr && r == Wr)
    return e;
  let o = e;
  for (let i = 0; i < r.length; i++) {
    let s = r[i], a = n[i];
    if (i) {
      let l;
      a && a.nodeName == s.nodeName && o != t && (l = o.parentNode) && l.nodeName.toLowerCase() == s.nodeName || (l = document.createElement(s.nodeName), l.pmIsDeco = !0, l.appendChild(o), a = Wr[0]), o = l;
    }
    h1(o, a || Wr[0], s);
  }
  return o;
}
function h1(t, e, n) {
  for (let r in e)
    r != "class" && r != "style" && r != "nodeName" && !(r in n) && t.removeAttribute(r);
  for (let r in n)
    r != "class" && r != "style" && r != "nodeName" && n[r] != e[r] && t.setAttribute(r, n[r]);
  if (e.class != n.class) {
    let r = e.class ? e.class.split(" ").filter(Boolean) : [], o = n.class ? n.class.split(" ").filter(Boolean) : [];
    for (let i = 0; i < r.length; i++)
      o.indexOf(r[i]) == -1 && t.classList.remove(r[i]);
    for (let i = 0; i < o.length; i++)
      r.indexOf(o[i]) == -1 && t.classList.add(o[i]);
    t.classList.length == 0 && t.removeAttribute("class");
  }
  if (e.style != n.style) {
    if (e.style) {
      let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, o;
      for (; o = r.exec(e.style); )
        t.style.removeProperty(o[1]);
    }
    n.style && (t.style.cssText += n.style);
  }
}
function dy(t, e, n) {
  return uy(t, t, Wr, Ku(e, n, t.nodeType != 1));
}
function La(t, e) {
  if (t.length != e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (!t[n].type.eq(e[n].type))
      return !1;
  return !0;
}
function bm(t) {
  let e = t.nextSibling;
  return t.parentNode.removeChild(t), e;
}
class m1 {
  constructor(e, n, r) {
    this.lock = n, this.view = r, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = p1(e.node.content, e);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(e, n) {
    if (e != n) {
      for (let r = e; r < n; r++)
        this.top.children[r].destroy();
      this.top.children.splice(e, n - e), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(e, n, r, o) {
    let i = 0, s = this.stack.length >> 1, a = Math.min(s, e.length);
    for (; i < a && (i == s - 1 ? this.top : this.stack[i + 1 << 1]).matchesMark(e[i]) && e[i].type.spec.spanning !== !1; )
      i++;
    for (; i < s; )
      this.destroyRest(), this.top.dirty = on, this.index = this.stack.pop(), this.top = this.stack.pop(), s--;
    for (; s < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let l = -1, c = this.top.children.length;
      o < this.preMatch.index && (c = Math.min(this.index + 3, c));
      for (let u = this.index; u < c; u++) {
        let d = this.top.children[u];
        if (d.matchesMark(e[s]) && !this.isLocked(d.dom)) {
          l = u;
          break;
        }
      }
      if (l > -1)
        l > this.index && (this.changed = !0, this.destroyBetween(this.index, l)), this.top = this.top.children[this.index];
      else {
        let u = eo.create(this.top, e[s], n, r);
        this.top.children.splice(this.index, 0, u), this.top = u, this.changed = !0;
      }
      this.index = 0, s++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(e, n, r, o) {
    let i = -1, s;
    if (o >= this.preMatch.index && (s = this.preMatch.matches[o - this.preMatch.index]).parent == this.top && s.matchesNode(e, n, r))
      i = this.top.children.indexOf(s, this.index);
    else
      for (let a = this.index, l = Math.min(this.top.children.length, a + 5); a < l; a++) {
        let c = this.top.children[a];
        if (c.matchesNode(e, n, r) && !this.preMatch.matched.has(c)) {
          i = a;
          break;
        }
      }
    return i < 0 ? !1 : (this.destroyBetween(this.index, i), this.index++, !0);
  }
  updateNodeAt(e, n, r, o, i) {
    let s = this.top.children[o];
    return s.dirty == Dn && s.dom == s.contentDOM && (s.dirty = Ur), s.update(e, n, r, i) ? (this.destroyBetween(this.index, o), this.index++, !0) : !1;
  }
  findIndexWithChild(e) {
    for (; ; ) {
      let n = e.parentNode;
      if (!n)
        return -1;
      if (n == this.top.contentDOM) {
        let r = e.pmViewDesc;
        if (r) {
          for (let o = this.index; o < this.top.children.length; o++)
            if (this.top.children[o] == r)
              return o;
        }
        return -1;
      }
      e = n;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(e, n, r, o, i, s) {
    for (let a = this.index; a < this.top.children.length; a++) {
      let l = this.top.children[a];
      if (l instanceof Sr) {
        let c = this.preMatch.matched.get(l);
        if (c != null && c != i)
          return !1;
        let u = l.dom, d, f = this.isLocked(u) && !(e.isText && l.node && l.node.isText && l.nodeDOM.nodeValue == e.text && l.dirty != Dn && La(n, l.outerDeco));
        if (!f && l.update(e, n, r, o))
          return this.destroyBetween(this.index, a), l.dom != u && (this.changed = !0), this.index++, !0;
        if (!f && (d = this.recreateWrapper(l, e, n, r, o, s)))
          return this.destroyBetween(this.index, a), this.top.children[this.index] = d, d.contentDOM && (d.dirty = Ur, d.updateChildren(o, s + 1), d.dirty = on), this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(e, n, r, o, i, s) {
    if (e.dirty || n.isAtom || !e.children.length || !e.node.content.eq(n.content) || !La(r, e.outerDeco) || !o.eq(e.innerDeco))
      return null;
    let a = Sr.create(this.top, n, r, o, i, s);
    if (a.contentDOM) {
      a.children = e.children, e.children = [];
      for (let l of a.children)
        l.parent = a;
    }
    return e.destroy(), a;
  }
  // Insert the node as a newly created node desc.
  addNode(e, n, r, o, i) {
    let s = Sr.create(this.top, e, n, r, o, i);
    s.contentDOM && s.updateChildren(o, i + 1), this.top.children.splice(this.index++, 0, s), this.changed = !0;
  }
  placeWidget(e, n, r) {
    let o = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (o && o.matchesWidget(e) && (e == o.widget || !o.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let i = new ay(this.top, e, n, r);
      this.top.children.splice(this.index++, 0, i), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let e = this.top.children[this.index - 1], n = this.top;
    for (; e instanceof eo; )
      n = e, e = n.children[n.children.length - 1];
    (!e || // Empty textblock
    !(e instanceof nc) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((xt || ht) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", n), this.addHackNode("BR", this.top));
  }
  addHackNode(e, n) {
    if (n == this.top && this.index < n.children.length && n.children[this.index].matchesHack(e))
      this.index++;
    else {
      let r = document.createElement(e);
      e == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), e == "BR" && (r.className = "ProseMirror-trailingBreak");
      let o = new ly(this.top, [], r, null);
      n != this.top ? n.children.push(o) : n.children.splice(this.index++, 0, o), this.changed = !0;
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
  }
}
function p1(t, e) {
  let n = e, r = n.children.length, o = t.childCount, i = /* @__PURE__ */ new Map(), s = [];
  e: for (; o > 0; ) {
    let a;
    for (; ; )
      if (r) {
        let c = n.children[r - 1];
        if (c instanceof eo)
          n = c, r = c.children.length;
        else {
          a = c, r--;
          break;
        }
      } else {
        if (n == e)
          break e;
        r = n.parent.children.indexOf(n), n = n.parent;
      }
    let l = a.node;
    if (l) {
      if (l != t.child(o - 1))
        break;
      --o, i.set(a, o), s.push(a);
    }
  }
  return { index: o, matched: i, matches: s.reverse() };
}
function g1(t, e) {
  return t.type.side - e.type.side;
}
function b1(t, e, n, r) {
  let o = e.locals(t), i = 0;
  if (o.length == 0) {
    for (let c = 0; c < t.childCount; c++) {
      let u = t.child(c);
      r(u, o, e.forChild(i, u), c), i += u.nodeSize;
    }
    return;
  }
  let s = 0, a = [], l = null;
  for (let c = 0; ; ) {
    let u, d;
    for (; s < o.length && o[s].to == i; ) {
      let g = o[s++];
      g.widget && (u ? (d || (d = [u])).push(g) : u = g);
    }
    if (u)
      if (d) {
        d.sort(g1);
        for (let g = 0; g < d.length; g++)
          n(d[g], c, !!l);
      } else
        n(u, c, !!l);
    let f, h;
    if (l)
      h = -1, f = l, l = null;
    else if (c < t.childCount)
      h = c, f = t.child(c++);
    else
      break;
    for (let g = 0; g < a.length; g++)
      a[g].to <= i && a.splice(g--, 1);
    for (; s < o.length && o[s].from <= i && o[s].to > i; )
      a.push(o[s++]);
    let m = i + f.nodeSize;
    if (f.isText) {
      let g = m;
      s < o.length && o[s].from < g && (g = o[s].from);
      for (let b = 0; b < a.length; b++)
        a[b].to < g && (g = a[b].to);
      g < m && (l = f.cut(g - i), f = f.cut(0, g - i), m = g, h = -1);
    } else
      for (; s < o.length && o[s].to < m; )
        s++;
    let p = f.isInline && !f.isLeaf ? a.filter((g) => !g.inline) : a.slice();
    r(f, p, e.forChild(i, f), h), i = m;
  }
}
function y1(t) {
  if (t.nodeName == "UL" || t.nodeName == "OL") {
    let e = t.style.cssText;
    t.style.cssText = e + "; list-style: square !important", window.getComputedStyle(t).listStyle, t.style.cssText = e;
  }
}
function v1(t, e, n, r) {
  for (let o = 0, i = 0; o < t.childCount && i <= r; ) {
    let s = t.child(o++), a = i;
    if (i += s.nodeSize, !s.isText)
      continue;
    let l = s.text;
    for (; o < t.childCount; ) {
      let c = t.child(o++);
      if (i += c.nodeSize, !c.isText)
        break;
      l += c.text;
    }
    if (i >= n) {
      if (i >= r && l.slice(r - e.length - a, r - a) == e)
        return r - e.length;
      let c = a < r ? l.lastIndexOf(e, r - a - 1) : -1;
      if (c >= 0 && c + e.length + a >= n)
        return a + c;
      if (n == r && l.length >= r + e.length - a && l.slice(r - a, r - a + e.length) == e)
        return r;
    }
  }
  return -1;
}
function qu(t, e, n, r, o) {
  let i = [];
  for (let s = 0, a = 0; s < t.length; s++) {
    let l = t[s], c = a, u = a += l.size;
    c >= n || u <= e ? i.push(l) : (c < e && i.push(l.slice(0, e - c, r)), o && (i.push(o), o = void 0), u > n && i.push(l.slice(n - c, l.size, r)));
  }
  return i;
}
function Qd(t, e = null) {
  let n = t.domSelectionRange(), r = t.state.doc;
  if (!n.focusNode)
    return null;
  let o = t.docView.nearestDesc(n.focusNode), i = o && o.size == 0, s = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
  if (s < 0)
    return null;
  let a = r.resolve(s), l, c;
  if (tc(n)) {
    for (l = s; o && !o.node; )
      o = o.parent;
    let d = o.node;
    if (o && d.isAtom && se.isSelectable(d) && o.parent && !(d.isInline && qN(n.focusNode, n.focusOffset, o.dom))) {
      let f = o.posBefore;
      c = new se(s == f ? a : r.resolve(f));
    }
  } else {
    if (n instanceof t.dom.ownerDocument.defaultView.Selection && n.rangeCount > 1) {
      let d = s, f = s;
      for (let h = 0; h < n.rangeCount; h++) {
        let m = n.getRangeAt(h);
        d = Math.min(d, t.docView.posFromDOM(m.startContainer, m.startOffset, 1)), f = Math.max(f, t.docView.posFromDOM(m.endContainer, m.endOffset, -1));
      }
      if (d < 0)
        return null;
      [l, s] = f == t.state.selection.anchor ? [f, d] : [d, f], a = r.resolve(s);
    } else
      l = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
    if (l < 0)
      return null;
  }
  let u = r.resolve(l);
  if (!c) {
    let d = e == "pointer" || t.state.selection.head < a.pos && !i ? 1 : -1;
    c = ef(t, u, a, d);
  }
  return c;
}
function fy(t) {
  return t.editable ? t.hasFocus() : my(t) && document.activeElement && document.activeElement.contains(t.dom);
}
function Qn(t, e = !1) {
  let n = t.state.selection;
  if (hy(t, n), !!fy(t)) {
    if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && ht) {
      let r = t.domSelectionRange(), o = t.domObserver.currentSelection;
      if (r.anchorNode && o.anchorNode && Qr(r.anchorNode, r.anchorOffset, o.anchorNode, o.anchorOffset)) {
        t.input.mouseDown.delayedSelectionSync = !0, t.domObserver.setCurSelection();
        return;
      }
    }
    if (t.domObserver.disconnectSelection(), t.cursorWrapper)
      k1(t);
    else {
      let { anchor: r, head: o } = n, i, s;
      ym && !(n instanceof ce) && (n.$from.parent.inlineContent || (i = vm(t, n.from)), !n.empty && !n.$from.parent.inlineContent && (s = vm(t, n.to))), t.docView.setSelection(r, o, t, e), ym && (i && wm(i), s && wm(s)), n.visible ? t.dom.classList.remove("ProseMirror-hideselection") : (t.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && w1(t));
    }
    t.domObserver.setCurSelection(), t.domObserver.connectSelection();
  }
}
const ym = xt || ht && Qb < 63;
function vm(t, e) {
  let { node: n, offset: r } = t.docView.domFromPos(e, 0), o = r < n.childNodes.length ? n.childNodes[r] : null, i = r ? n.childNodes[r - 1] : null;
  if (xt && o && o.contentEditable == "false")
    return Yc(o);
  if ((!o || o.contentEditable == "false") && (!i || i.contentEditable == "false")) {
    if (o)
      return Yc(o);
    if (i)
      return Yc(i);
  }
}
function Yc(t) {
  return t.contentEditable = "true", xt && t.draggable && (t.draggable = !1, t.wasDraggable = !0), t;
}
function wm(t) {
  t.contentEditable = "false", t.wasDraggable && (t.draggable = !0, t.wasDraggable = null);
}
function w1(t) {
  let e = t.dom.ownerDocument;
  e.removeEventListener("selectionchange", t.input.hideSelectionGuard);
  let n = t.domSelectionRange(), r = n.anchorNode, o = n.anchorOffset;
  e.addEventListener("selectionchange", t.input.hideSelectionGuard = () => {
    (n.anchorNode != r || n.anchorOffset != o) && (e.removeEventListener("selectionchange", t.input.hideSelectionGuard), setTimeout(() => {
      (!fy(t) || t.state.selection.visible) && t.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function k1(t) {
  let e = t.domSelection();
  if (!e)
    return;
  let n = t.cursorWrapper.dom, r = n.nodeName == "IMG";
  r ? e.collapse(n.parentNode, wt(n) + 1) : e.collapse(n, 0), !r && !t.state.selection.visible && $t && Er <= 11 && (n.disabled = !0, n.disabled = !1);
}
function hy(t, e) {
  if (e instanceof se) {
    let n = t.docView.descAt(e.from);
    n != t.lastSelectedViewDesc && (km(t), n && n.selectNode(), t.lastSelectedViewDesc = n);
  } else
    km(t);
}
function km(t) {
  t.lastSelectedViewDesc && (t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(), t.lastSelectedViewDesc = void 0);
}
function ef(t, e, n, r) {
  return t.someProp("createSelectionBetween", (o) => o(t, e, n)) || ce.between(e, n, r);
}
function xm(t) {
  return t.editable && !t.hasFocus() ? !1 : my(t);
}
function my(t) {
  let e = t.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return t.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (t.editable || t.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function x1(t) {
  let e = t.docView.domFromPos(t.state.selection.anchor, 0), n = t.domSelectionRange();
  return Qr(e.node, e.offset, n.anchorNode, n.anchorOffset);
}
function Gu(t, e) {
  let { $anchor: n, $head: r } = t.selection, o = e > 0 ? n.max(r) : n.min(r), i = o.parent.inlineContent ? o.depth ? t.doc.resolve(e > 0 ? o.after() : o.before()) : null : o;
  return i && pe.findFrom(i, e);
}
function hr(t, e) {
  return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), !0;
}
function Nm(t, e, n) {
  let r = t.state.selection;
  if (r instanceof ce)
    if (n.indexOf("s") > -1) {
      let { $head: o } = r, i = o.textOffset ? null : e < 0 ? o.nodeBefore : o.nodeAfter;
      if (!i || i.isText || !i.isLeaf)
        return !1;
      let s = t.state.doc.resolve(o.pos + i.nodeSize * (e < 0 ? -1 : 1));
      return hr(t, new ce(r.$anchor, s));
    } else if (r.empty) {
      if (t.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let o = Gu(t.state, e);
        return o && o instanceof se ? hr(t, o) : !1;
      } else if (!(en && n.indexOf("m") > -1)) {
        let o = r.$head, i = o.textOffset ? null : e < 0 ? o.nodeBefore : o.nodeAfter, s;
        if (!i || i.isText)
          return !1;
        let a = e < 0 ? o.pos - i.nodeSize : o.pos;
        return i.isAtom || (s = t.docView.descAt(a)) && !s.contentDOM ? se.isSelectable(i) ? hr(t, new se(e < 0 ? t.state.doc.resolve(o.pos - i.nodeSize) : o)) : gs ? hr(t, new ce(t.state.doc.resolve(e < 0 ? a : a + i.nodeSize))) : !1 : !1;
      }
    } else return !1;
  else {
    if (r instanceof se && r.node.isInline)
      return hr(t, new ce(e > 0 ? r.$to : r.$from));
    {
      let o = Gu(t.state, e);
      return o ? hr(t, o) : !1;
    }
  }
}
function Pa(t) {
  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function $i(t, e) {
  let n = t.pmViewDesc;
  return n && n.size == 0 && (e < 0 || t.nextSibling || t.nodeName != "BR");
}
function So(t, e) {
  return e < 0 ? N1(t) : E1(t);
}
function N1(t) {
  let e = t.domSelectionRange(), n = e.focusNode, r = e.focusOffset;
  if (!n)
    return;
  let o, i, s = !1;
  for (rn && n.nodeType == 1 && r < Pa(n) && $i(n.childNodes[r], -1) && (s = !0); ; )
    if (r > 0) {
      if (n.nodeType != 1)
        break;
      {
        let a = n.childNodes[r - 1];
        if ($i(a, -1))
          o = n, i = --r;
        else if (a.nodeType == 3)
          n = a, r = n.nodeValue.length;
        else
          break;
      }
    } else {
      if (py(n))
        break;
      {
        let a = n.previousSibling;
        for (; a && $i(a, -1); )
          o = n.parentNode, i = wt(a), a = a.previousSibling;
        if (a)
          n = a, r = Pa(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          r = 0;
        }
      }
    }
  s ? ju(t, n, r) : o && ju(t, o, i);
}
function E1(t) {
  let e = t.domSelectionRange(), n = e.focusNode, r = e.focusOffset;
  if (!n)
    return;
  let o = Pa(n), i, s;
  for (; ; )
    if (r < o) {
      if (n.nodeType != 1)
        break;
      let a = n.childNodes[r];
      if ($i(a, 1))
        i = n, s = ++r;
      else
        break;
    } else {
      if (py(n))
        break;
      {
        let a = n.nextSibling;
        for (; a && $i(a, 1); )
          i = a.parentNode, s = wt(a) + 1, a = a.nextSibling;
        if (a)
          n = a, r = 0, o = Pa(n);
        else {
          if (n = n.parentNode, n == t.dom)
            break;
          r = o = 0;
        }
      }
    }
  i && ju(t, i, s);
}
function py(t) {
  let e = t.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function S1(t, e) {
  for (; t && e == t.childNodes.length && !ps(t); )
    e = wt(t) + 1, t = t.parentNode;
  for (; t && e < t.childNodes.length; ) {
    let n = t.childNodes[e];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    t = n, e = 0;
  }
}
function T1(t, e) {
  for (; t && !e && !ps(t); )
    e = wt(t), t = t.parentNode;
  for (; t && e; ) {
    let n = t.childNodes[e - 1];
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && n.contentEditable == "false")
      break;
    t = n, e = t.childNodes.length;
  }
}
function ju(t, e, n) {
  if (e.nodeType != 3) {
    let i, s;
    (s = S1(e, n)) ? (e = s, n = 0) : (i = T1(e, n)) && (e = i, n = i.nodeValue.length);
  }
  let r = t.domSelection();
  if (!r)
    return;
  if (tc(r)) {
    let i = document.createRange();
    i.setEnd(e, n), i.setStart(e, n), r.removeAllRanges(), r.addRange(i);
  } else r.extend && r.extend(e, n);
  t.domObserver.setCurSelection();
  let { state: o } = t;
  setTimeout(() => {
    t.state == o && Qn(t);
  }, 50);
}
function Em(t, e) {
  let n = t.state.doc.resolve(e);
  if (!(ht || ey) && n.parent.inlineContent) {
    let o = t.coordsAtPos(e);
    if (e > n.start()) {
      let i = t.coordsAtPos(e - 1), s = (i.top + i.bottom) / 2;
      if (s > o.top && s < o.bottom && Math.abs(i.left - o.left) > 1)
        return i.left < o.left ? "ltr" : "rtl";
    }
    if (e < n.end()) {
      let i = t.coordsAtPos(e + 1), s = (i.top + i.bottom) / 2;
      if (s > o.top && s < o.bottom && Math.abs(i.left - o.left) > 1)
        return i.left > o.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(t.dom).direction == "rtl" ? "rtl" : "ltr";
}
function Sm(t, e, n) {
  let r = t.state.selection;
  if (r instanceof ce && !r.empty || n.indexOf("s") > -1 || en && n.indexOf("m") > -1)
    return !1;
  let { $from: o, $to: i } = r;
  if (!o.parent.inlineContent || t.endOfTextblock(e < 0 ? "up" : "down")) {
    let s = Gu(t.state, e);
    if (s && s instanceof se)
      return hr(t, s);
  }
  if (!o.parent.inlineContent) {
    let s = e < 0 ? o : i, a = r instanceof Kt ? pe.near(s, e) : pe.findFrom(s, e);
    return a ? hr(t, a) : !1;
  }
  return !1;
}
function Tm(t, e) {
  if (!(t.state.selection instanceof ce))
    return !0;
  let { $head: n, $anchor: r, empty: o } = t.state.selection;
  if (!n.sameParent(r))
    return !0;
  if (!o)
    return !1;
  if (t.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let i = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
  if (i && !i.isText) {
    let s = t.state.tr;
    return e < 0 ? s.delete(n.pos - i.nodeSize, n.pos) : s.delete(n.pos, n.pos + i.nodeSize), t.dispatch(s), !0;
  }
  return !1;
}
function Cm(t, e, n) {
  t.domObserver.stop(), e.contentEditable = n, t.domObserver.start();
}
function C1(t) {
  if (!xt || t.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: n } = t.domSelectionRange();
  if (e && e.nodeType == 1 && n == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let r = e.firstChild;
    Cm(t, r, "true"), setTimeout(() => Cm(t, r, "false"), 20);
  }
  return !1;
}
function M1(t) {
  let e = "";
  return t.ctrlKey && (e += "c"), t.metaKey && (e += "m"), t.altKey && (e += "a"), t.shiftKey && (e += "s"), e;
}
function A1(t, e) {
  let n = e.keyCode, r = M1(e);
  if (n == 8 || en && n == 72 && r == "c")
    return Tm(t, -1) || So(t, -1);
  if (n == 46 && !e.shiftKey || en && n == 68 && r == "c")
    return Tm(t, 1) || So(t, 1);
  if (n == 13 || n == 27)
    return !0;
  if (n == 37 || en && n == 66 && r == "c") {
    let o = n == 37 ? Em(t, t.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return Nm(t, o, r) || So(t, o);
  } else if (n == 39 || en && n == 70 && r == "c") {
    let o = n == 39 ? Em(t, t.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return Nm(t, o, r) || So(t, o);
  } else {
    if (n == 38 || en && n == 80 && r == "c")
      return Sm(t, -1, r) || So(t, -1);
    if (n == 40 || en && n == 78 && r == "c")
      return C1(t) || Sm(t, 1, r) || So(t, 1);
    if (r == (en ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
      return !0;
  }
  return !1;
}
function tf(t, e) {
  t.someProp("transformCopied", (h) => {
    e = h(e, t);
  });
  let n = [], { content: r, openStart: o, openEnd: i } = e;
  for (; o > 1 && i > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
    o--, i--;
    let h = r.firstChild;
    n.push(h.type.name, h.attrs != h.type.defaultAttrs ? h.attrs : null), r = h.content;
  }
  let s = t.someProp("clipboardSerializer") || so.fromSchema(t.state.schema), a = ky(), l = a.createElement("div");
  l.appendChild(s.serializeFragment(r, { document: a }));
  let c = l.firstChild, u, d = 0;
  for (; c && c.nodeType == 1 && (u = wy[c.nodeName.toLowerCase()]); ) {
    for (let h = u.length - 1; h >= 0; h--) {
      let m = a.createElement(u[h]);
      for (; l.firstChild; )
        m.appendChild(l.firstChild);
      l.appendChild(m), d++;
    }
    c = l.firstChild;
  }
  c && c.nodeType == 1 && c.setAttribute("data-pm-slice", `${o} ${i}${d ? ` -${d}` : ""} ${JSON.stringify(n)}`);
  let f = t.someProp("clipboardTextSerializer", (h) => h(e, t)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: l, text: f, slice: e };
}
function gy(t, e, n, r, o) {
  let i = o.parent.type.spec.code, s, a;
  if (!n && !e)
    return null;
  let l = !!e && (r || i || !n);
  if (l) {
    if (t.someProp("transformPastedText", (f) => {
      e = f(e, i || r, t);
    }), i)
      return a = new Y(D.from(t.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0), t.someProp("transformPasted", (f) => {
        a = f(a, t, !0);
      }), a;
    let d = t.someProp("clipboardTextParser", (f) => f(e, o, r, t));
    if (d)
      a = d;
    else {
      let f = o.marks(), { schema: h } = t.state, m = so.fromSchema(h);
      s = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((p) => {
        let g = s.appendChild(document.createElement("p"));
        p && g.appendChild(m.serializeNode(h.text(p, f)));
      });
    }
  } else
    t.someProp("transformPastedHTML", (d) => {
      n = d(n, t);
    }), s = I1(n), gs && D1(s);
  let c = s && s.querySelector("[data-pm-slice]"), u = c && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute("data-pm-slice") || "");
  if (u && u[3])
    for (let d = +u[3]; d > 0; d--) {
      let f = s.firstChild;
      for (; f && f.nodeType != 1; )
        f = f.nextSibling;
      if (!f)
        break;
      s = f;
    }
  if (a || (a = (t.someProp("clipboardParser") || t.someProp("domParser") || Nr.fromSchema(t.state.schema)).parseSlice(s, {
    preserveWhitespace: !!(l || u),
    context: o,
    ruleFromNode(f) {
      return f.nodeName == "BR" && !f.nextSibling && f.parentNode && !_1.test(f.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), u)
    a = L1(Mm(a, +u[1], +u[2]), u[4]);
  else if (a = Y.maxOpen(R1(a.content, o), !0), a.openStart || a.openEnd) {
    let d = 0, f = 0;
    for (let h = a.content.firstChild; d < a.openStart && !h.type.spec.isolating; d++, h = h.firstChild)
      ;
    for (let h = a.content.lastChild; f < a.openEnd && !h.type.spec.isolating; f++, h = h.lastChild)
      ;
    a = Mm(a, d, f);
  }
  return t.someProp("transformPasted", (d) => {
    a = d(a, t, l);
  }), a;
}
const _1 = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function R1(t, e) {
  if (t.childCount < 2)
    return t;
  for (let n = e.depth; n >= 0; n--) {
    let o = e.node(n).contentMatchAt(e.index(n)), i, s = [];
    if (t.forEach((a) => {
      if (!s)
        return;
      let l = o.findWrapping(a.type), c;
      if (!l)
        return s = null;
      if (c = s.length && i.length && yy(l, i, a, s[s.length - 1], 0))
        s[s.length - 1] = c;
      else {
        s.length && (s[s.length - 1] = vy(s[s.length - 1], i.length));
        let u = by(a, l);
        s.push(u), o = o.matchType(u.type), i = l;
      }
    }), s)
      return D.from(s);
  }
  return t;
}
function by(t, e, n = 0) {
  for (let r = e.length - 1; r >= n; r--)
    t = e[r].create(null, D.from(t));
  return t;
}
function yy(t, e, n, r, o) {
  if (o < t.length && o < e.length && t[o] == e[o]) {
    let i = yy(t, e, n, r.lastChild, o + 1);
    if (i)
      return r.copy(r.content.replaceChild(r.childCount - 1, i));
    if (r.contentMatchAt(r.childCount).matchType(o == t.length - 1 ? n.type : t[o + 1]))
      return r.copy(r.content.append(D.from(by(n, t, o + 1))));
  }
}
function vy(t, e) {
  if (e == 0)
    return t;
  let n = t.content.replaceChild(t.childCount - 1, vy(t.lastChild, e - 1)), r = t.contentMatchAt(t.childCount).fillBefore(D.empty, !0);
  return t.copy(n.append(r));
}
function Yu(t, e, n, r, o, i) {
  let s = e < 0 ? t.firstChild : t.lastChild, a = s.content;
  return t.childCount > 1 && (i = 0), o < r - 1 && (a = Yu(a, e, n, r, o + 1, i)), o >= n && (a = e < 0 ? s.contentMatchAt(0).fillBefore(a, i <= o).append(a) : a.append(s.contentMatchAt(s.childCount).fillBefore(D.empty, !0))), t.replaceChild(e < 0 ? 0 : t.childCount - 1, s.copy(a));
}
function Mm(t, e, n) {
  return e < t.openStart && (t = new Y(Yu(t.content, -1, e, t.openStart, 0, t.openEnd), e, t.openEnd)), n < t.openEnd && (t = new Y(Yu(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n)), t;
}
const wy = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let Am = null;
function ky() {
  return Am || (Am = document.implementation.createHTMLDocument("title"));
}
let Xc = null;
function O1(t) {
  let e = window.trustedTypes;
  return e ? (Xc || (Xc = e.defaultPolicy || e.createPolicy("ProseMirrorClipboard", { createHTML: (n) => n })), Xc.createHTML(t)) : t;
}
function I1(t) {
  let e = /^(\s*<meta [^>]*>)*/.exec(t);
  e && (t = t.slice(e[0].length));
  let n = ky().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(t), o;
  if ((o = r && wy[r[1].toLowerCase()]) && (t = o.map((i) => "<" + i + ">").join("") + t + o.map((i) => "</" + i + ">").reverse().join("")), n.innerHTML = O1(t), o)
    for (let i = 0; i < o.length; i++)
      n = n.querySelector(o[i]) || n;
  return n;
}
function D1(t) {
  let e = t.querySelectorAll(ht ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let n = 0; n < e.length; n++) {
    let r = e[n];
    r.childNodes.length == 1 && r.textContent == " " && r.parentNode && r.parentNode.replaceChild(t.ownerDocument.createTextNode(" "), r);
  }
}
function L1(t, e) {
  if (!t.size)
    return t;
  let n = t.content.firstChild.type.schema, r;
  try {
    r = JSON.parse(e);
  } catch {
    return t;
  }
  let { content: o, openStart: i, openEnd: s } = t;
  for (let a = r.length - 2; a >= 0; a -= 2) {
    let l = n.nodes[r[a]];
    if (!l || l.hasRequiredAttrs())
      break;
    o = D.from(l.create(r[a + 1], o)), i++, s++;
  }
  return new Y(o, i, s);
}
const Lt = {}, Pt = {}, P1 = { touchstart: !0, touchmove: !0 };
class B1 {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.badSafariComposition = !1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function z1(t) {
  for (let e in Lt) {
    let n = Lt[e];
    t.dom.addEventListener(e, t.input.eventHandlers[e] = (r) => {
      H1(t, r) && !nf(t, r) && (t.editable || !(r.type in Pt)) && n(t, r);
    }, P1[e] ? { passive: !0 } : void 0);
  }
  xt && t.dom.addEventListener("input", () => null), Xu(t);
}
function kr(t, e) {
  t.input.lastSelectionOrigin = e, t.input.lastSelectionTime = Date.now();
}
function $1(t) {
  t.domObserver.stop();
  for (let e in t.input.eventHandlers)
    t.dom.removeEventListener(e, t.input.eventHandlers[e]);
  clearTimeout(t.input.composingTimeout), clearTimeout(t.input.lastIOSEnterFallbackTimeout);
}
function Xu(t) {
  t.someProp("handleDOMEvents", (e) => {
    for (let n in e)
      t.input.eventHandlers[n] || t.dom.addEventListener(n, t.input.eventHandlers[n] = (r) => nf(t, r));
  });
}
function nf(t, e) {
  return t.someProp("handleDOMEvents", (n) => {
    let r = n[e.type];
    return r ? r(t, e) || e.defaultPrevented : !1;
  });
}
function H1(t, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let n = e.target; n != t.dom; n = n.parentNode)
    if (!n || n.nodeType == 11 || n.pmViewDesc && n.pmViewDesc.stopEvent(e))
      return !1;
  return !0;
}
function F1(t, e) {
  !nf(t, e) && Lt[e.type] && (t.editable || !(e.type in Pt)) && Lt[e.type](t, e);
}
Pt.keydown = (t, e) => {
  let n = e;
  if (t.input.shiftKey = n.keyCode == 16 || n.shiftKey, !Ny(t, n) && (t.input.lastKeyCode = n.keyCode, t.input.lastKeyCodeTime = Date.now(), !(Xn && ht && n.keyCode == 13)))
    if (n.keyCode != 229 && t.domObserver.forceFlush(), Xo && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey) {
      let r = Date.now();
      t.input.lastIOSEnter = r, t.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        t.input.lastIOSEnter == r && (t.someProp("handleKeyDown", (o) => o(t, Fr(13, "Enter"))), t.input.lastIOSEnter = 0);
      }, 200);
    } else t.someProp("handleKeyDown", (r) => r(t, n)) || A1(t, n) ? n.preventDefault() : kr(t, "key");
};
Pt.keyup = (t, e) => {
  e.keyCode == 16 && (t.input.shiftKey = !1);
};
Pt.keypress = (t, e) => {
  let n = e;
  if (Ny(t, n) || !n.charCode || n.ctrlKey && !n.altKey || en && n.metaKey)
    return;
  if (t.someProp("handleKeyPress", (o) => o(t, n))) {
    n.preventDefault();
    return;
  }
  let r = t.state.selection;
  if (!(r instanceof ce) || !r.$from.sameParent(r.$to)) {
    let o = String.fromCharCode(n.charCode), i = () => t.state.tr.insertText(o).scrollIntoView();
    !/[\r\n]/.test(o) && !t.someProp("handleTextInput", (s) => s(t, r.$from.pos, r.$to.pos, o, i)) && t.dispatch(i()), n.preventDefault();
  }
};
function rc(t) {
  return { left: t.clientX, top: t.clientY };
}
function U1(t, e) {
  let n = e.x - t.clientX, r = e.y - t.clientY;
  return n * n + r * r < 100;
}
function rf(t, e, n, r, o) {
  if (r == -1)
    return !1;
  let i = t.state.doc.resolve(r);
  for (let s = i.depth + 1; s > 0; s--)
    if (t.someProp(e, (a) => s > i.depth ? a(t, n, i.nodeAfter, i.before(s), o, !0) : a(t, n, i.node(s), i.before(s), o, !1)))
      return !0;
  return !1;
}
function Uo(t, e, n) {
  if (t.focused || t.focus(), t.state.selection.eq(e))
    return;
  let r = t.state.tr.setSelection(e);
  r.setMeta("pointer", !0), t.dispatch(r);
}
function W1(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.doc.resolve(e), r = n.nodeAfter;
  return r && r.isAtom && se.isSelectable(r) ? (Uo(t, new se(n)), !0) : !1;
}
function V1(t, e) {
  if (e == -1)
    return !1;
  let n = t.state.selection, r, o;
  n instanceof se && (r = n.node);
  let i = t.state.doc.resolve(e);
  for (let s = i.depth + 1; s > 0; s--) {
    let a = s > i.depth ? i.nodeAfter : i.node(s);
    if (se.isSelectable(a)) {
      r && n.$from.depth > 0 && s >= n.$from.depth && i.before(n.$from.depth + 1) == n.$from.pos ? o = i.before(n.$from.depth) : o = i.before(s);
      break;
    }
  }
  return o != null ? (Uo(t, se.create(t.state.doc, o)), !0) : !1;
}
function K1(t, e, n, r, o) {
  return rf(t, "handleClickOn", e, n, r) || t.someProp("handleClick", (i) => i(t, e, r)) || (o ? V1(t, n) : W1(t, n));
}
function q1(t, e, n, r) {
  return rf(t, "handleDoubleClickOn", e, n, r) || t.someProp("handleDoubleClick", (o) => o(t, e, r));
}
function G1(t, e, n, r) {
  return rf(t, "handleTripleClickOn", e, n, r) || t.someProp("handleTripleClick", (o) => o(t, e, r)) || j1(t, n, r);
}
function j1(t, e, n) {
  if (n.button != 0)
    return !1;
  let r = t.state.doc;
  if (e == -1)
    return r.inlineContent ? (Uo(t, ce.create(r, 0, r.content.size)), !0) : !1;
  let o = r.resolve(e);
  for (let i = o.depth + 1; i > 0; i--) {
    let s = i > o.depth ? o.nodeAfter : o.node(i), a = o.before(i);
    if (s.inlineContent)
      Uo(t, ce.create(r, a + 1, a + 1 + s.content.size));
    else if (se.isSelectable(s))
      Uo(t, se.create(r, a));
    else
      continue;
    return !0;
  }
}
function of(t) {
  return Ba(t);
}
const xy = en ? "metaKey" : "ctrlKey";
Lt.mousedown = (t, e) => {
  let n = e;
  t.input.shiftKey = n.shiftKey;
  let r = of(t), o = Date.now(), i = "singleClick";
  o - t.input.lastClick.time < 500 && U1(n, t.input.lastClick) && !n[xy] && t.input.lastClick.button == n.button && (t.input.lastClick.type == "singleClick" ? i = "doubleClick" : t.input.lastClick.type == "doubleClick" && (i = "tripleClick")), t.input.lastClick = { time: o, x: n.clientX, y: n.clientY, type: i, button: n.button };
  let s = t.posAtCoords(rc(n));
  s && (i == "singleClick" ? (t.input.mouseDown && t.input.mouseDown.done(), t.input.mouseDown = new Y1(t, s, n, !!r)) : (i == "doubleClick" ? q1 : G1)(t, s.pos, s.inside, n) ? n.preventDefault() : kr(t, "pointer"));
};
class Y1 {
  constructor(e, n, r, o) {
    this.view = e, this.pos = n, this.event = r, this.flushed = o, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!r[xy], this.allowDefault = r.shiftKey;
    let i, s;
    if (n.inside > -1)
      i = e.state.doc.nodeAt(n.inside), s = n.inside;
    else {
      let u = e.state.doc.resolve(n.pos);
      i = u.parent, s = u.depth ? u.before() : 0;
    }
    const a = o ? null : r.target, l = a ? e.docView.nearestDesc(a, !0) : null;
    this.target = l && l.nodeDOM.nodeType == 1 ? l.nodeDOM : null;
    let { selection: c } = e.state;
    (r.button == 0 && i.type.spec.draggable && i.type.spec.selectable !== !1 || c instanceof se && c.from <= s && c.to > s) && (this.mightDrag = {
      node: i,
      pos: s,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && rn && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), kr(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => Qn(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let n = this.pos;
    this.view.state.doc != this.startDoc && (n = this.view.posAtCoords(rc(e))), this.updateAllowDefault(e), this.allowDefault || !n ? kr(this.view, "pointer") : K1(this.view, n.pos, n.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    xt && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    ht && !this.view.state.selection.visible && Math.min(Math.abs(n.pos - this.view.state.selection.from), Math.abs(n.pos - this.view.state.selection.to)) <= 2) ? (Uo(this.view, pe.near(this.view.state.doc.resolve(n.pos))), e.preventDefault()) : kr(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), kr(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
}
Lt.touchstart = (t) => {
  t.input.lastTouch = Date.now(), of(t), kr(t, "pointer");
};
Lt.touchmove = (t) => {
  t.input.lastTouch = Date.now(), kr(t, "pointer");
};
Lt.contextmenu = (t) => of(t);
function Ny(t, e) {
  return t.composing ? !0 : xt && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500 ? (t.input.compositionEndedAt = -2e8, !0) : !1;
}
const X1 = Xn ? 5e3 : -1;
Pt.compositionstart = Pt.compositionupdate = (t) => {
  if (!t.composing) {
    t.domObserver.flush();
    let { state: e } = t, n = e.selection.$to;
    if (e.selection instanceof ce && (e.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1) || ht && ey && Z1(t)))
      t.markCursor = t.state.storedMarks || n.marks(), Ba(t, !0), t.markCursor = null;
    else if (Ba(t, !e.selection.empty), rn && e.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) {
      let r = t.domSelectionRange();
      for (let o = r.focusNode, i = r.focusOffset; o && o.nodeType == 1 && i != 0; ) {
        let s = i < 0 ? o.lastChild : o.childNodes[i - 1];
        if (!s)
          break;
        if (s.nodeType == 3) {
          let a = t.domSelection();
          a && a.collapse(s, s.nodeValue.length);
          break;
        } else
          o = s, i = -1;
      }
    }
    t.input.composing = !0;
  }
  Ey(t, X1);
};
function Z1(t) {
  let { focusNode: e, focusOffset: n } = t.domSelectionRange();
  if (!e || e.nodeType != 1 || n >= e.childNodes.length)
    return !1;
  let r = e.childNodes[n];
  return r.nodeType == 1 && r.contentEditable == "false";
}
Pt.compositionend = (t, e) => {
  t.composing && (t.input.composing = !1, t.input.compositionEndedAt = e.timeStamp, t.input.compositionPendingChanges = t.domObserver.pendingRecords().length ? t.input.compositionID : 0, t.input.compositionNode = null, t.input.badSafariComposition ? t.domObserver.forceFlush() : t.input.compositionPendingChanges && Promise.resolve().then(() => t.domObserver.flush()), t.input.compositionID++, Ey(t, 20));
};
function Ey(t, e) {
  clearTimeout(t.input.composingTimeout), e > -1 && (t.input.composingTimeout = setTimeout(() => Ba(t), e));
}
function Sy(t) {
  for (t.composing && (t.input.composing = !1, t.input.compositionEndedAt = Q1()); t.input.compositionNodes.length > 0; )
    t.input.compositionNodes.pop().markParentsDirty();
}
function J1(t) {
  let e = t.domSelectionRange();
  if (!e.focusNode)
    return null;
  let n = VN(e.focusNode, e.focusOffset), r = KN(e.focusNode, e.focusOffset);
  if (n && r && n != r) {
    let o = r.pmViewDesc, i = t.domObserver.lastChangedTextNode;
    if (n == i || r == i)
      return i;
    if (!o || !o.isText(r.nodeValue))
      return r;
    if (t.input.compositionNode == r) {
      let s = n.pmViewDesc;
      if (!(!s || !s.isText(n.nodeValue)))
        return r;
    }
  }
  return n || r;
}
function Q1() {
  let t = document.createEvent("Event");
  return t.initEvent("event", !0, !0), t.timeStamp;
}
function Ba(t, e = !1) {
  if (!(Xn && t.domObserver.flushingSoon >= 0)) {
    if (t.domObserver.forceFlush(), Sy(t), e || t.docView && t.docView.dirty) {
      let n = Qd(t), r = t.state.selection;
      return n && !n.eq(r) ? t.dispatch(t.state.tr.setSelection(n)) : (t.markCursor || e) && !r.$from.node(r.$from.sharedDepth(r.to)).inlineContent ? t.dispatch(t.state.tr.deleteSelection()) : t.updateState(t.state), !0;
    }
    return !1;
  }
}
function eE(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.dom.parentNode.appendChild(document.createElement("div"));
  n.appendChild(e), n.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let r = getSelection(), o = document.createRange();
  o.selectNodeContents(e), t.dom.blur(), r.removeAllRanges(), r.addRange(o), setTimeout(() => {
    n.parentNode && n.parentNode.removeChild(n), t.focus();
  }, 50);
}
const ts = $t && Er < 15 || Xo && YN < 604;
Lt.copy = Pt.cut = (t, e) => {
  let n = e, r = t.state.selection, o = n.type == "cut";
  if (r.empty)
    return;
  let i = ts ? null : n.clipboardData, s = r.content(), { dom: a, text: l } = tf(t, s);
  i ? (n.preventDefault(), i.clearData(), i.setData("text/html", a.innerHTML), i.setData("text/plain", l)) : eE(t, a), o && t.dispatch(t.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function tE(t) {
  return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1 ? t.content.firstChild : null;
}
function nE(t, e) {
  if (!t.dom.parentNode)
    return;
  let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code, r = t.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div"));
  n || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus();
  let o = t.input.shiftKey && t.input.lastKeyCode != 45;
  setTimeout(() => {
    t.focus(), r.parentNode && r.parentNode.removeChild(r), n ? ns(t, r.value, null, o, e) : ns(t, r.textContent, r.innerHTML, o, e);
  }, 50);
}
function ns(t, e, n, r, o) {
  let i = gy(t, e, n, r, t.state.selection.$from);
  if (t.someProp("handlePaste", (l) => l(t, o, i || Y.empty)))
    return !0;
  if (!i)
    return !1;
  let s = tE(i), a = s ? t.state.tr.replaceSelectionWith(s, r) : t.state.tr.replaceSelection(i);
  return t.dispatch(a.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
function Ty(t) {
  let e = t.getData("text/plain") || t.getData("Text");
  if (e)
    return e;
  let n = t.getData("text/uri-list");
  return n ? n.replace(/\r?\n/g, " ") : "";
}
Pt.paste = (t, e) => {
  let n = e;
  if (t.composing && !Xn)
    return;
  let r = ts ? null : n.clipboardData, o = t.input.shiftKey && t.input.lastKeyCode != 45;
  r && ns(t, Ty(r), r.getData("text/html"), o, n) ? n.preventDefault() : nE(t, n);
};
class Cy {
  constructor(e, n, r) {
    this.slice = e, this.move = n, this.node = r;
  }
}
const rE = en ? "altKey" : "ctrlKey";
function My(t, e) {
  let n = t.someProp("dragCopies", (r) => !r(e));
  return n ?? !e[rE];
}
Lt.dragstart = (t, e) => {
  let n = e, r = t.input.mouseDown;
  if (r && r.done(), !n.dataTransfer)
    return;
  let o = t.state.selection, i = o.empty ? null : t.posAtCoords(rc(n)), s;
  if (!(i && i.pos >= o.from && i.pos <= (o instanceof se ? o.to - 1 : o.to))) {
    if (r && r.mightDrag)
      s = se.create(t.state.doc, r.mightDrag.pos);
    else if (n.target && n.target.nodeType == 1) {
      let d = t.docView.nearestDesc(n.target, !0);
      d && d.node.type.spec.draggable && d != t.docView && (s = se.create(t.state.doc, d.posBefore));
    }
  }
  let a = (s || t.state.selection).content(), { dom: l, text: c, slice: u } = tf(t, a);
  (!n.dataTransfer.files.length || !ht || Qb > 120) && n.dataTransfer.clearData(), n.dataTransfer.setData(ts ? "Text" : "text/html", l.innerHTML), n.dataTransfer.effectAllowed = "copyMove", ts || n.dataTransfer.setData("text/plain", c), t.dragging = new Cy(u, My(t, n), s);
};
Lt.dragend = (t) => {
  let e = t.dragging;
  window.setTimeout(() => {
    t.dragging == e && (t.dragging = null);
  }, 50);
};
Pt.dragover = Pt.dragenter = (t, e) => e.preventDefault();
Pt.drop = (t, e) => {
  try {
    oE(t, e, t.dragging);
  } finally {
    t.dragging = null;
  }
};
function oE(t, e, n) {
  if (!e.dataTransfer)
    return;
  let r = t.posAtCoords(rc(e));
  if (!r)
    return;
  let o = t.state.doc.resolve(r.pos), i = n && n.slice;
  i ? t.someProp("transformPasted", (h) => {
    i = h(i, t, !1);
  }) : i = gy(t, Ty(e.dataTransfer), ts ? null : e.dataTransfer.getData("text/html"), !1, o);
  let s = !!(n && My(t, e));
  if (t.someProp("handleDrop", (h) => h(t, e, i || Y.empty, s))) {
    e.preventDefault();
    return;
  }
  if (!i)
    return;
  e.preventDefault();
  let a = i ? Ob(t.state.doc, o.pos, i) : o.pos;
  a == null && (a = o.pos);
  let l = t.state.tr;
  if (s) {
    let { node: h } = n;
    h ? h.replace(l) : l.deleteSelection();
  }
  let c = l.mapping.map(a), u = i.openStart == 0 && i.openEnd == 0 && i.content.childCount == 1, d = l.doc;
  if (u ? l.replaceRangeWith(c, c, i.content.firstChild) : l.replaceRange(c, c, i), l.doc.eq(d))
    return;
  let f = l.doc.resolve(c);
  if (u && se.isSelectable(i.content.firstChild) && f.nodeAfter && f.nodeAfter.sameMarkup(i.content.firstChild))
    l.setSelection(new se(f));
  else {
    let h = l.mapping.map(a);
    l.mapping.maps[l.mapping.maps.length - 1].forEach((m, p, g, b) => h = b), l.setSelection(ef(t, f, l.doc.resolve(h)));
  }
  t.focus(), t.dispatch(l.setMeta("uiEvent", "drop"));
}
Lt.focus = (t) => {
  t.input.lastFocus = Date.now(), t.focused || (t.domObserver.stop(), t.dom.classList.add("ProseMirror-focused"), t.domObserver.start(), t.focused = !0, setTimeout(() => {
    t.docView && t.hasFocus() && !t.domObserver.currentSelection.eq(t.domSelectionRange()) && Qn(t);
  }, 20));
};
Lt.blur = (t, e) => {
  let n = e;
  t.focused && (t.domObserver.stop(), t.dom.classList.remove("ProseMirror-focused"), t.domObserver.start(), n.relatedTarget && t.dom.contains(n.relatedTarget) && t.domObserver.currentSelection.clear(), t.focused = !1);
};
Lt.beforeinput = (t, e) => {
  if (ht && Xn && e.inputType == "deleteContentBackward") {
    t.domObserver.flushSoon();
    let { domChangeCount: r } = t.input;
    setTimeout(() => {
      if (t.input.domChangeCount != r || (t.dom.blur(), t.focus(), t.someProp("handleKeyDown", (i) => i(t, Fr(8, "Backspace")))))
        return;
      let { $cursor: o } = t.state.selection;
      o && o.pos > 0 && t.dispatch(t.state.tr.delete(o.pos - 1, o.pos).scrollIntoView());
    }, 50);
  }
};
for (let t in Pt)
  Lt[t] = Pt[t];
function rs(t, e) {
  if (t == e)
    return !0;
  for (let n in t)
    if (t[n] !== e[n])
      return !1;
  for (let n in e)
    if (!(n in t))
      return !1;
  return !0;
}
class za {
  constructor(e, n) {
    this.toDOM = e, this.spec = n || jr, this.side = this.spec.side || 0;
  }
  map(e, n, r, o) {
    let { pos: i, deleted: s } = e.mapResult(n.from + o, this.side < 0 ? -1 : 1);
    return s ? null : new Ve(i - r, i - r, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof za && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && rs(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
}
class Tr {
  constructor(e, n) {
    this.attrs = e, this.spec = n || jr;
  }
  map(e, n, r, o) {
    let i = e.map(n.from + o, this.spec.inclusiveStart ? -1 : 1) - r, s = e.map(n.to + o, this.spec.inclusiveEnd ? 1 : -1) - r;
    return i >= s ? null : new Ve(i, s, this);
  }
  valid(e, n) {
    return n.from < n.to;
  }
  eq(e) {
    return this == e || e instanceof Tr && rs(this.attrs, e.attrs) && rs(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof Tr;
  }
  destroy() {
  }
}
class sf {
  constructor(e, n) {
    this.attrs = e, this.spec = n || jr;
  }
  map(e, n, r, o) {
    let i = e.mapResult(n.from + o, 1);
    if (i.deleted)
      return null;
    let s = e.mapResult(n.to + o, -1);
    return s.deleted || s.pos <= i.pos ? null : new Ve(i.pos - r, s.pos - r, this);
  }
  valid(e, n) {
    let { index: r, offset: o } = e.content.findIndex(n.from), i;
    return o == n.from && !(i = e.child(r)).isText && o + i.nodeSize == n.to;
  }
  eq(e) {
    return this == e || e instanceof sf && rs(this.attrs, e.attrs) && rs(this.spec, e.spec);
  }
  destroy() {
  }
}
class Ve {
  /**
  @internal
  */
  constructor(e, n, r) {
    this.from = e, this.to = n, this.type = r;
  }
  /**
  @internal
  */
  copy(e, n) {
    return new Ve(e, n, this.type);
  }
  /**
  @internal
  */
  eq(e, n = 0) {
    return this.type.eq(e.type) && this.from + n == e.from && this.to + n == e.to;
  }
  /**
  @internal
  */
  map(e, n, r) {
    return this.type.map(e, this, n, r);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, n, r) {
    return new Ve(e, e, new za(n, r));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, n, r, o) {
    return new Ve(e, n, new Tr(r, o));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, n, r, o) {
    return new Ve(e, n, new sf(r, o));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof Tr;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof za;
  }
}
const Lo = [], jr = {};
class Te {
  /**
  @internal
  */
  constructor(e, n) {
    this.local = e.length ? e : Lo, this.children = n.length ? n : Lo;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(e, n) {
    return n.length ? $a(n, e, 0, jr) : Tt;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, n, r) {
    let o = [];
    return this.findInner(e ?? 0, n ?? 1e9, o, 0, r), o;
  }
  findInner(e, n, r, o, i) {
    for (let s = 0; s < this.local.length; s++) {
      let a = this.local[s];
      a.from <= n && a.to >= e && (!i || i(a.spec)) && r.push(a.copy(a.from + o, a.to + o));
    }
    for (let s = 0; s < this.children.length; s += 3)
      if (this.children[s] < n && this.children[s + 1] > e) {
        let a = this.children[s] + 1;
        this.children[s + 2].findInner(e - a, n - a, r, o + a, i);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, n, r) {
    return this == Tt || e.maps.length == 0 ? this : this.mapInner(e, n, 0, 0, r || jr);
  }
  /**
  @internal
  */
  mapInner(e, n, r, o, i) {
    let s;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a].map(e, r, o);
      l && l.type.valid(n, l) ? (s || (s = [])).push(l) : i.onRemove && i.onRemove(this.local[a].spec);
    }
    return this.children.length ? iE(this.children, s || [], e, n, r, o, i) : s ? new Te(s.sort(Yr), Lo) : Tt;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(e, n) {
    return n.length ? this == Tt ? Te.create(e, n) : this.addInner(e, n, 0) : this;
  }
  addInner(e, n, r) {
    let o, i = 0;
    e.forEach((a, l) => {
      let c = l + r, u;
      if (u = _y(n, a, c)) {
        for (o || (o = this.children.slice()); i < o.length && o[i] < l; )
          i += 3;
        o[i] == l ? o[i + 2] = o[i + 2].addInner(a, u, c + 1) : o.splice(i, 0, l, l + a.nodeSize, $a(u, a, c + 1, jr)), i += 3;
      }
    });
    let s = Ay(i ? Ry(n) : n, -r);
    for (let a = 0; a < s.length; a++)
      s[a].type.valid(e, s[a]) || s.splice(a--, 1);
    return new Te(s.length ? this.local.concat(s).sort(Yr) : this.local, o || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == Tt ? this : this.removeInner(e, 0);
  }
  removeInner(e, n) {
    let r = this.children, o = this.local;
    for (let i = 0; i < r.length; i += 3) {
      let s, a = r[i] + n, l = r[i + 1] + n;
      for (let u = 0, d; u < e.length; u++)
        (d = e[u]) && d.from > a && d.to < l && (e[u] = null, (s || (s = [])).push(d));
      if (!s)
        continue;
      r == this.children && (r = this.children.slice());
      let c = r[i + 2].removeInner(s, a + 1);
      c != Tt ? r[i + 2] = c : (r.splice(i, 3), i -= 3);
    }
    if (o.length) {
      for (let i = 0, s; i < e.length; i++)
        if (s = e[i])
          for (let a = 0; a < o.length; a++)
            o[a].eq(s, n) && (o == this.local && (o = this.local.slice()), o.splice(a--, 1));
    }
    return r == this.children && o == this.local ? this : o.length || r.length ? new Te(o, r) : Tt;
  }
  forChild(e, n) {
    if (this == Tt)
      return this;
    if (n.isLeaf)
      return Te.empty;
    let r, o;
    for (let a = 0; a < this.children.length; a += 3)
      if (this.children[a] >= e) {
        this.children[a] == e && (r = this.children[a + 2]);
        break;
      }
    let i = e + 1, s = i + n.content.size;
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a];
      if (l.from < s && l.to > i && l.type instanceof Tr) {
        let c = Math.max(i, l.from) - i, u = Math.min(s, l.to) - i;
        c < u && (o || (o = [])).push(l.copy(c, u));
      }
    }
    if (o) {
      let a = new Te(o.sort(Yr), Lo);
      return r ? new gr([a, r]) : a;
    }
    return r || Tt;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof Te) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let n = 0; n < this.local.length; n++)
      if (!this.local[n].eq(e.local[n]))
        return !1;
    for (let n = 0; n < this.children.length; n += 3)
      if (this.children[n] != e.children[n] || this.children[n + 1] != e.children[n + 1] || !this.children[n + 2].eq(e.children[n + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return af(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == Tt)
      return Lo;
    if (e.inlineContent || !this.local.some(Tr.is))
      return this.local;
    let n = [];
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof Tr || n.push(this.local[r]);
    return n;
  }
  forEachSet(e) {
    e(this);
  }
}
Te.empty = new Te([], []);
Te.removeOverlap = af;
const Tt = Te.empty;
class gr {
  constructor(e) {
    this.members = e;
  }
  map(e, n) {
    const r = this.members.map((o) => o.map(e, n, jr));
    return gr.from(r);
  }
  forChild(e, n) {
    if (n.isLeaf)
      return Te.empty;
    let r = [];
    for (let o = 0; o < this.members.length; o++) {
      let i = this.members[o].forChild(e, n);
      i != Tt && (i instanceof gr ? r = r.concat(i.members) : r.push(i));
    }
    return gr.from(r);
  }
  eq(e) {
    if (!(e instanceof gr) || e.members.length != this.members.length)
      return !1;
    for (let n = 0; n < this.members.length; n++)
      if (!this.members[n].eq(e.members[n]))
        return !1;
    return !0;
  }
  locals(e) {
    let n, r = !0;
    for (let o = 0; o < this.members.length; o++) {
      let i = this.members[o].localsInner(e);
      if (i.length)
        if (!n)
          n = i;
        else {
          r && (n = n.slice(), r = !1);
          for (let s = 0; s < i.length; s++)
            n.push(i[s]);
        }
    }
    return n ? af(r ? n : n.sort(Yr)) : Lo;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return Tt;
      case 1:
        return e[0];
      default:
        return new gr(e.every((n) => n instanceof Te) ? e : e.reduce((n, r) => n.concat(r instanceof Te ? r : r.members), []));
    }
  }
  forEachSet(e) {
    for (let n = 0; n < this.members.length; n++)
      this.members[n].forEachSet(e);
  }
}
function iE(t, e, n, r, o, i, s) {
  let a = t.slice();
  for (let c = 0, u = i; c < n.maps.length; c++) {
    let d = 0;
    n.maps[c].forEach((f, h, m, p) => {
      let g = p - m - (h - f);
      for (let b = 0; b < a.length; b += 3) {
        let v = a[b + 1];
        if (v < 0 || f > v + u - d)
          continue;
        let k = a[b] + u - d;
        h >= k ? a[b + 1] = f <= k ? -2 : -1 : f >= u && g && (a[b] += g, a[b + 1] += g);
      }
      d += g;
    }), u = n.maps[c].map(u, -1);
  }
  let l = !1;
  for (let c = 0; c < a.length; c += 3)
    if (a[c + 1] < 0) {
      if (a[c + 1] == -2) {
        l = !0, a[c + 1] = -1;
        continue;
      }
      let u = n.map(t[c] + i), d = u - o;
      if (d < 0 || d >= r.content.size) {
        l = !0;
        continue;
      }
      let f = n.map(t[c + 1] + i, -1), h = f - o, { index: m, offset: p } = r.content.findIndex(d), g = r.maybeChild(m);
      if (g && p == d && p + g.nodeSize == h) {
        let b = a[c + 2].mapInner(n, g, u + 1, t[c] + i + 1, s);
        b != Tt ? (a[c] = d, a[c + 1] = h, a[c + 2] = b) : (a[c + 1] = -2, l = !0);
      } else
        l = !0;
    }
  if (l) {
    let c = sE(a, t, e, n, o, i, s), u = $a(c, r, 0, s);
    e = u.local;
    for (let d = 0; d < a.length; d += 3)
      a[d + 1] < 0 && (a.splice(d, 3), d -= 3);
    for (let d = 0, f = 0; d < u.children.length; d += 3) {
      let h = u.children[d];
      for (; f < a.length && a[f] < h; )
        f += 3;
      a.splice(f, 0, u.children[d], u.children[d + 1], u.children[d + 2]);
    }
  }
  return new Te(e.sort(Yr), a);
}
function Ay(t, e) {
  if (!e || !t.length)
    return t;
  let n = [];
  for (let r = 0; r < t.length; r++) {
    let o = t[r];
    n.push(new Ve(o.from + e, o.to + e, o.type));
  }
  return n;
}
function sE(t, e, n, r, o, i, s) {
  function a(l, c) {
    for (let u = 0; u < l.local.length; u++) {
      let d = l.local[u].map(r, o, c);
      d ? n.push(d) : s.onRemove && s.onRemove(l.local[u].spec);
    }
    for (let u = 0; u < l.children.length; u += 3)
      a(l.children[u + 2], l.children[u] + c + 1);
  }
  for (let l = 0; l < t.length; l += 3)
    t[l + 1] == -1 && a(t[l + 2], e[l] + i + 1);
  return n;
}
function _y(t, e, n) {
  if (e.isLeaf)
    return null;
  let r = n + e.nodeSize, o = null;
  for (let i = 0, s; i < t.length; i++)
    (s = t[i]) && s.from > n && s.to < r && ((o || (o = [])).push(s), t[i] = null);
  return o;
}
function Ry(t) {
  let e = [];
  for (let n = 0; n < t.length; n++)
    t[n] != null && e.push(t[n]);
  return e;
}
function $a(t, e, n, r) {
  let o = [], i = !1;
  e.forEach((a, l) => {
    let c = _y(t, a, l + n);
    if (c) {
      i = !0;
      let u = $a(c, a, n + l + 1, r);
      u != Tt && o.push(l, l + a.nodeSize, u);
    }
  });
  let s = Ay(i ? Ry(t) : t, -n).sort(Yr);
  for (let a = 0; a < s.length; a++)
    s[a].type.valid(e, s[a]) || (r.onRemove && r.onRemove(s[a].spec), s.splice(a--, 1));
  return s.length || o.length ? new Te(s, o) : Tt;
}
function Yr(t, e) {
  return t.from - e.from || t.to - e.to;
}
function af(t) {
  let e = t;
  for (let n = 0; n < e.length - 1; n++) {
    let r = e[n];
    if (r.from != r.to)
      for (let o = n + 1; o < e.length; o++) {
        let i = e[o];
        if (i.from == r.from) {
          i.to != r.to && (e == t && (e = t.slice()), e[o] = i.copy(i.from, r.to), _m(e, o + 1, i.copy(r.to, i.to)));
          continue;
        } else {
          i.from < r.to && (e == t && (e = t.slice()), e[n] = r.copy(r.from, i.from), _m(e, o, r.copy(i.from, r.to)));
          break;
        }
      }
  }
  return e;
}
function _m(t, e, n) {
  for (; e < t.length && Yr(n, t[e]) > 0; )
    e++;
  t.splice(e, 0, n);
}
function Zc(t) {
  let e = [];
  return t.someProp("decorations", (n) => {
    let r = n(t.state);
    r && r != Tt && e.push(r);
  }), t.cursorWrapper && e.push(Te.create(t.state.doc, [t.cursorWrapper.deco])), gr.from(e);
}
const aE = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, lE = $t && Er <= 11;
class cE {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(e) {
    this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
  }
}
class uE {
  constructor(e, n) {
    this.view = e, this.handleDOMChange = n, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new cE(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver((r) => {
      for (let o = 0; o < r.length; o++)
        this.queue.push(r[o]);
      $t && Er <= 11 && r.some((o) => o.type == "childList" && o.removedNodes.length || o.type == "characterData" && o.oldValue.length > o.target.nodeValue.length) ? this.flushSoon() : xt && e.composing && r.some((o) => o.type == "childList" && o.target.nodeName == "TR") ? (e.input.badSafariComposition = !0, this.flushSoon()) : this.flush();
    }), lE && (this.onCharData = (r) => {
      this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, aE)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let n = 0; n < e.length; n++)
          this.queue.push(e[n]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (xm(this.view)) {
      if (this.suppressingSelectionUpdates)
        return Qn(this.view);
      if ($t && Er <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (e.focusNode && Qr(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode)
      return !0;
    let n = /* @__PURE__ */ new Set(), r;
    for (let i = e.focusNode; i; i = Yo(i))
      n.add(i);
    for (let i = e.anchorNode; i; i = Yo(i))
      if (n.has(i)) {
        r = i;
        break;
      }
    let o = r && this.view.docView.nearestDesc(r);
    if (o && o.ignoreMutation({
      type: "selection",
      target: r.nodeType == 3 ? r.parentNode : r
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let e of this.observer.takeRecords())
        this.queue.push(e);
    return this.queue;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1)
      return;
    let n = this.pendingRecords();
    n.length && (this.queue = []);
    let r = e.domSelectionRange(), o = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && xm(e) && !this.ignoreSelectionChange(r), i = -1, s = -1, a = !1, l = [];
    if (e.editable)
      for (let u = 0; u < n.length; u++) {
        let d = this.registerMutation(n[u], l);
        d && (i = i < 0 ? d.from : Math.min(d.from, i), s = s < 0 ? d.to : Math.max(d.to, s), d.typeOver && (a = !0));
      }
    if (rn && l.length) {
      let u = l.filter((d) => d.nodeName == "BR");
      if (u.length == 2) {
        let [d, f] = u;
        d.parentNode && d.parentNode.parentNode == f.parentNode ? f.remove() : d.remove();
      } else {
        let { focusNode: d } = this.currentSelection;
        for (let f of u) {
          let h = f.parentNode;
          h && h.nodeName == "LI" && (!d || hE(e, d) != h) && f.remove();
        }
      }
    } else if ((ht || xt) && l.some((u) => u.nodeName == "BR") && (e.input.lastKeyCode == 8 || e.input.lastKeyCode == 46)) {
      for (let u of l)
        if (u.nodeName == "BR" && u.parentNode) {
          let d = u.nextSibling;
          d && d.nodeType == 1 && d.contentEditable == "false" && u.parentNode.removeChild(u);
        }
    }
    let c = null;
    i < 0 && o && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && tc(r) && (c = Qd(e)) && c.eq(pe.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, Qn(e), this.currentSelection.set(r), e.scrollToSelection()) : (i > -1 || o) && (i > -1 && (e.docView.markDirty(i, s), dE(e)), e.input.badSafariComposition && (e.input.badSafariComposition = !1, mE(e, l)), this.handleDOMChange(i, s, a, l), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || Qn(e), this.currentSelection.set(r));
  }
  registerMutation(e, n) {
    if (n.indexOf(e.target) > -1)
      return null;
    let r = this.view.docView.nearestDesc(e.target);
    if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e))
      return null;
    if (e.type == "childList") {
      for (let u = 0; u < e.addedNodes.length; u++) {
        let d = e.addedNodes[u];
        n.push(d), d.nodeType == 3 && (this.lastChangedTextNode = d);
      }
      if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target))
        return { from: r.posBefore, to: r.posAfter };
      let o = e.previousSibling, i = e.nextSibling;
      if ($t && Er <= 11 && e.addedNodes.length)
        for (let u = 0; u < e.addedNodes.length; u++) {
          let { previousSibling: d, nextSibling: f } = e.addedNodes[u];
          (!d || Array.prototype.indexOf.call(e.addedNodes, d) < 0) && (o = d), (!f || Array.prototype.indexOf.call(e.addedNodes, f) < 0) && (i = f);
        }
      let s = o && o.parentNode == e.target ? wt(o) + 1 : 0, a = r.localPosFromDOM(e.target, s, -1), l = i && i.parentNode == e.target ? wt(i) : e.target.childNodes.length, c = r.localPosFromDOM(e.target, l, 1);
      return { from: a, to: c };
    } else return e.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : (this.lastChangedTextNode = e.target, {
      from: r.posAtStart,
      to: r.posAtEnd,
      // An event was generated for a text change that didn't change
      // any text. Mark the dom change to fall back to assuming the
      // selection was typed over with an identical value if it can't
      // find another change.
      typeOver: e.target.nodeValue == e.oldValue
    });
  }
}
let Rm = /* @__PURE__ */ new WeakMap(), Om = !1;
function dE(t) {
  if (!Rm.has(t) && (Rm.set(t, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(t.dom).whiteSpace) !== -1)) {
    if (t.requiresGeckoHackNode = rn, Om)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), Om = !0;
  }
}
function Im(t, e) {
  let n = e.startContainer, r = e.startOffset, o = e.endContainer, i = e.endOffset, s = t.domAtPos(t.state.selection.anchor);
  return Qr(s.node, s.offset, o, i) && ([n, r, o, i] = [o, i, n, r]), { anchorNode: n, anchorOffset: r, focusNode: o, focusOffset: i };
}
function fE(t, e) {
  if (e.getComposedRanges) {
    let o = e.getComposedRanges(t.root)[0];
    if (o)
      return Im(t, o);
  }
  let n;
  function r(o) {
    o.preventDefault(), o.stopImmediatePropagation(), n = o.getTargetRanges()[0];
  }
  return t.dom.addEventListener("beforeinput", r, !0), document.execCommand("indent"), t.dom.removeEventListener("beforeinput", r, !0), n ? Im(t, n) : null;
}
function hE(t, e) {
  for (let n = e.parentNode; n && n != t.dom; n = n.parentNode) {
    let r = t.docView.nearestDesc(n, !0);
    if (r && r.node.isBlock)
      return n;
  }
  return null;
}
function mE(t, e) {
  var n;
  let { focusNode: r, focusOffset: o } = t.domSelectionRange();
  for (let i of e)
    if (((n = i.parentNode) === null || n === void 0 ? void 0 : n.nodeName) == "TR") {
      let s = i.nextSibling;
      for (; s && s.nodeName != "TD" && s.nodeName != "TH"; )
        s = s.nextSibling;
      if (s) {
        let a = s;
        for (; ; ) {
          let l = a.firstChild;
          if (!l || l.nodeType != 1 || l.contentEditable == "false" || /^(BR|IMG)$/.test(l.nodeName))
            break;
          a = l;
        }
        a.insertBefore(i, a.firstChild), r == i && t.domSelection().collapse(i, o);
      } else
        i.parentNode.removeChild(i);
    }
}
function pE(t, e, n) {
  let { node: r, fromOffset: o, toOffset: i, from: s, to: a } = t.docView.parseRange(e, n), l = t.domSelectionRange(), c, u = l.anchorNode;
  if (u && t.dom.contains(u.nodeType == 1 ? u : u.parentNode) && (c = [{ node: u, offset: l.anchorOffset }], tc(l) || c.push({ node: l.focusNode, offset: l.focusOffset })), ht && t.input.lastKeyCode === 8)
    for (let g = i; g > o; g--) {
      let b = r.childNodes[g - 1], v = b.pmViewDesc;
      if (b.nodeName == "BR" && !v) {
        i = g;
        break;
      }
      if (!v || v.size)
        break;
    }
  let d = t.state.doc, f = t.someProp("domParser") || Nr.fromSchema(t.state.schema), h = d.resolve(s), m = null, p = f.parse(r, {
    topNode: h.parent,
    topMatch: h.parent.contentMatchAt(h.index()),
    topOpen: !0,
    from: o,
    to: i,
    preserveWhitespace: h.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: c,
    ruleFromNode: gE,
    context: h
  });
  if (c && c[0].pos != null) {
    let g = c[0].pos, b = c[1] && c[1].pos;
    b == null && (b = g), m = { anchor: g + s, head: b + s };
  }
  return { doc: p, sel: m, from: s, to: a };
}
function gE(t) {
  let e = t.pmViewDesc;
  if (e)
    return e.parseRule();
  if (t.nodeName == "BR" && t.parentNode) {
    if (xt && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
      let n = document.createElement("div");
      return n.appendChild(document.createElement("li")), { skip: n };
    } else if (t.parentNode.lastChild == t || xt && /^(tr|table)$/i.test(t.parentNode.nodeName))
      return { ignore: !0 };
  } else if (t.nodeName == "IMG" && t.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const bE = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function yE(t, e, n, r, o) {
  let i = t.input.compositionPendingChanges || (t.composing ? t.input.compositionID : 0);
  if (t.input.compositionPendingChanges = 0, e < 0) {
    let S = t.input.lastSelectionTime > Date.now() - 50 ? t.input.lastSelectionOrigin : null, C = Qd(t, S);
    if (C && !t.state.selection.eq(C)) {
      if (ht && Xn && t.input.lastKeyCode === 13 && Date.now() - 100 < t.input.lastKeyCodeTime && t.someProp("handleKeyDown", (O) => O(t, Fr(13, "Enter"))))
        return;
      let M = t.state.tr.setSelection(C);
      S == "pointer" ? M.setMeta("pointer", !0) : S == "key" && M.scrollIntoView(), i && M.setMeta("composition", i), t.dispatch(M);
    }
    return;
  }
  let s = t.state.doc.resolve(e), a = s.sharedDepth(n);
  e = s.before(a + 1), n = t.state.doc.resolve(n).after(a + 1);
  let l = t.state.selection, c = pE(t, e, n), u = t.state.doc, d = u.slice(c.from, c.to), f, h;
  t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime ? (f = t.state.selection.to, h = "end") : (f = t.state.selection.from, h = "start"), t.input.lastKeyCode = null;
  let m = kE(d.content, c.doc.content, c.from, f, h);
  if (m && t.input.domChangeCount++, (Xo && t.input.lastIOSEnter > Date.now() - 225 || Xn) && o.some((S) => S.nodeType == 1 && !bE.test(S.nodeName)) && (!m || m.endA >= m.endB) && t.someProp("handleKeyDown", (S) => S(t, Fr(13, "Enter")))) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (!m)
    if (r && l instanceof ce && !l.empty && l.$head.sameParent(l.$anchor) && !t.composing && !(c.sel && c.sel.anchor != c.sel.head))
      m = { start: l.from, endA: l.to, endB: l.to };
    else {
      if (c.sel) {
        let S = Dm(t, t.state.doc, c.sel);
        if (S && !S.eq(t.state.selection)) {
          let C = t.state.tr.setSelection(S);
          i && C.setMeta("composition", i), t.dispatch(C);
        }
      }
      return;
    }
  t.state.selection.from < t.state.selection.to && m.start == m.endB && t.state.selection instanceof ce && (m.start > t.state.selection.from && m.start <= t.state.selection.from + 2 && t.state.selection.from >= c.from ? m.start = t.state.selection.from : m.endA < t.state.selection.to && m.endA >= t.state.selection.to - 2 && t.state.selection.to <= c.to && (m.endB += t.state.selection.to - m.endA, m.endA = t.state.selection.to)), $t && Er <= 11 && m.endB == m.start + 1 && m.endA == m.start && m.start > c.from && c.doc.textBetween(m.start - c.from - 1, m.start - c.from + 1) == "  " && (m.start--, m.endA--, m.endB--);
  let p = c.doc.resolveNoCache(m.start - c.from), g = c.doc.resolveNoCache(m.endB - c.from), b = u.resolve(m.start), v = p.sameParent(g) && p.parent.inlineContent && b.end() >= m.endA;
  if ((Xo && t.input.lastIOSEnter > Date.now() - 225 && (!v || o.some((S) => S.nodeName == "DIV" || S.nodeName == "P")) || !v && p.pos < c.doc.content.size && (!p.sameParent(g) || !p.parent.inlineContent) && p.pos < g.pos && !/\S/.test(c.doc.textBetween(p.pos, g.pos, "", ""))) && t.someProp("handleKeyDown", (S) => S(t, Fr(13, "Enter")))) {
    t.input.lastIOSEnter = 0;
    return;
  }
  if (t.state.selection.anchor > m.start && wE(u, m.start, m.endA, p, g) && t.someProp("handleKeyDown", (S) => S(t, Fr(8, "Backspace")))) {
    Xn && ht && t.domObserver.suppressSelectionUpdates();
    return;
  }
  ht && m.endB == m.start && (t.input.lastChromeDelete = Date.now()), Xn && !v && p.start() != g.start() && g.parentOffset == 0 && p.depth == g.depth && c.sel && c.sel.anchor == c.sel.head && c.sel.head == m.endA && (m.endB -= 2, g = c.doc.resolveNoCache(m.endB - c.from), setTimeout(() => {
    t.someProp("handleKeyDown", function(S) {
      return S(t, Fr(13, "Enter"));
    });
  }, 20));
  let k = m.start, x = m.endA, w = (S) => {
    let C = S || t.state.tr.replace(k, x, c.doc.slice(m.start - c.from, m.endB - c.from));
    if (c.sel) {
      let M = Dm(t, C.doc, c.sel);
      M && !(ht && t.composing && M.empty && (m.start != m.endB || t.input.lastChromeDelete < Date.now() - 100) && (M.head == k || M.head == C.mapping.map(x) - 1) || $t && M.empty && M.head == k) && C.setSelection(M);
    }
    return i && C.setMeta("composition", i), C.scrollIntoView();
  }, E;
  if (v)
    if (p.pos == g.pos) {
      $t && Er <= 11 && p.parentOffset == 0 && (t.domObserver.suppressSelectionUpdates(), setTimeout(() => Qn(t), 20));
      let S = w(t.state.tr.delete(k, x)), C = u.resolve(m.start).marksAcross(u.resolve(m.endA));
      C && S.ensureMarks(C), t.dispatch(S);
    } else if (
      // Adding or removing a mark
      m.endA == m.endB && (E = vE(p.parent.content.cut(p.parentOffset, g.parentOffset), b.parent.content.cut(b.parentOffset, m.endA - b.start())))
    ) {
      let S = w(t.state.tr);
      E.type == "add" ? S.addMark(k, x, E.mark) : S.removeMark(k, x, E.mark), t.dispatch(S);
    } else if (p.parent.child(p.index()).isText && p.index() == g.index() - (g.textOffset ? 0 : 1)) {
      let S = p.parent.textBetween(p.parentOffset, g.parentOffset), C = () => w(t.state.tr.insertText(S, k, x));
      t.someProp("handleTextInput", (M) => M(t, k, x, S, C)) || t.dispatch(C());
    } else
      t.dispatch(w());
  else
    t.dispatch(w());
}
function Dm(t, e, n) {
  return Math.max(n.anchor, n.head) > e.content.size ? null : ef(t, e.resolve(n.anchor), e.resolve(n.head));
}
function vE(t, e) {
  let n = t.firstChild.marks, r = e.firstChild.marks, o = n, i = r, s, a, l;
  for (let u = 0; u < r.length; u++)
    o = r[u].removeFromSet(o);
  for (let u = 0; u < n.length; u++)
    i = n[u].removeFromSet(i);
  if (o.length == 1 && i.length == 0)
    a = o[0], s = "add", l = (u) => u.mark(a.addToSet(u.marks));
  else if (o.length == 0 && i.length == 1)
    a = i[0], s = "remove", l = (u) => u.mark(a.removeFromSet(u.marks));
  else
    return null;
  let c = [];
  for (let u = 0; u < e.childCount; u++)
    c.push(l(e.child(u)));
  if (D.from(c).eq(t))
    return { mark: a, type: s };
}
function wE(t, e, n, r, o) {
  if (
    // The content must have shrunk
    n - e <= o.pos - r.pos || // newEnd must point directly at or after the end of the block that newStart points into
    Jc(r, !0, !1) < o.pos
  )
    return !1;
  let i = t.resolve(e);
  if (!r.parent.isTextblock) {
    let a = i.nodeAfter;
    return a != null && n == e + a.nodeSize;
  }
  if (i.parentOffset < i.parent.content.size || !i.parent.isTextblock)
    return !1;
  let s = t.resolve(Jc(i, !0, !0));
  return !s.parent.isTextblock || s.pos > n || Jc(s, !0, !1) < n ? !1 : r.parent.content.cut(r.parentOffset).eq(s.parent.content);
}
function Jc(t, e, n) {
  let r = t.depth, o = e ? t.end() : t.pos;
  for (; r > 0 && (e || t.indexAfter(r) == t.node(r).childCount); )
    r--, o++, e = !1;
  if (n) {
    let i = t.node(r).maybeChild(t.indexAfter(r));
    for (; i && !i.isLeaf; )
      i = i.firstChild, o++;
  }
  return o;
}
function kE(t, e, n, r, o) {
  let i = t.findDiffStart(e, n);
  if (i == null)
    return null;
  let { a: s, b: a } = t.findDiffEnd(e, n + t.size, n + e.size);
  if (o == "end") {
    let l = Math.max(0, i - Math.min(s, a));
    r -= s + l - i;
  }
  if (s < i && t.size < e.size) {
    let l = r <= i && r >= s ? i - r : 0;
    i -= l, i && i < e.size && Lm(e.textBetween(i - 1, i + 1)) && (i += l ? 1 : -1), a = i + (a - s), s = i;
  } else if (a < i) {
    let l = r <= i && r >= a ? i - r : 0;
    i -= l, i && i < t.size && Lm(t.textBetween(i - 1, i + 1)) && (i += l ? 1 : -1), s = i + (s - a), a = i;
  }
  return { start: i, endA: s, endB: a };
}
function Lm(t) {
  if (t.length != 2)
    return !1;
  let e = t.charCodeAt(0), n = t.charCodeAt(1);
  return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319;
}
class Oy {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(e, n) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new B1(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = n, this.state = n.state, this.directPlugins = n.plugins || [], this.directPlugins.forEach(Hm), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = zm(this), Bm(this), this.nodeViews = $m(this), this.docView = gm(this.state.doc, Pm(this), Zc(this), this.dom, this), this.domObserver = new uE(this, (r, o, i, s) => yE(this, r, o, i, s)), this.domObserver.start(), z1(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let n in e)
        this._props[n] = e[n];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && Xu(this);
    let n = this._props;
    this._props = e, e.plugins && (e.plugins.forEach(Hm), this.directPlugins = e.plugins), this.updateStateInner(e.state, n);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(e) {
    let n = {};
    for (let r in this._props)
      n[r] = this._props[r];
    n.state = this.state;
    for (let r in e)
      n[r] = e[r];
    this.update(n);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, n) {
    var r;
    let o = this.state, i = !1, s = !1;
    e.storedMarks && this.composing && (Sy(this), s = !0), this.state = e;
    let a = o.plugins != e.plugins || this._props.plugins != n.plugins;
    if (a || this._props.plugins != n.plugins || this._props.nodeViews != n.nodeViews) {
      let h = $m(this);
      NE(h, this.nodeViews) && (this.nodeViews = h, i = !0);
    }
    (a || n.handleDOMEvents != this._props.handleDOMEvents) && Xu(this), this.editable = zm(this), Bm(this);
    let l = Zc(this), c = Pm(this), u = o.plugins != e.plugins && !o.doc.eq(e.doc) ? "reset" : e.scrollToSelection > o.scrollToSelection ? "to selection" : "preserve", d = i || !this.docView.matchesNode(e.doc, c, l);
    (d || !e.selection.eq(o.selection)) && (s = !0);
    let f = u == "preserve" && s && this.dom.style.overflowAnchor == null && JN(this);
    if (s) {
      this.domObserver.stop();
      let h = d && ($t || ht) && !this.composing && !o.selection.empty && !e.selection.empty && xE(o.selection, e.selection);
      if (d) {
        let m = ht ? this.trackWrites = this.domSelectionRange().focusNode : null;
        this.composing && (this.input.compositionNode = J1(this)), (i || !this.docView.update(e.doc, c, l, this)) && (this.docView.updateOuterDeco(c), this.docView.destroy(), this.docView = gm(e.doc, c, l, this.dom, this)), m && (!this.trackWrites || !this.dom.contains(this.trackWrites)) && (h = !0);
      }
      h || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && x1(this)) ? Qn(this, h) : (hy(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(o), !((r = this.dragging) === null || r === void 0) && r.node && !o.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, o), u == "reset" ? this.dom.scrollTop = 0 : u == "to selection" ? this.scrollToSelection() : f && QN(f);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!(!e || !this.dom.contains(e.nodeType == 1 ? e : e.parentNode))) {
      if (!this.someProp("handleScrollToSelection", (n) => n(this))) if (this.state.selection instanceof se) {
        let n = this.docView.domAfterPos(this.state.selection.from);
        n.nodeType == 1 && um(this, n.getBoundingClientRect(), e);
      } else
        um(this, this.coordsAtPos(this.state.selection.head, 1), e);
    }
  }
  destroyPluginViews() {
    let e;
    for (; e = this.pluginViews.pop(); )
      e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let n = 0; n < this.directPlugins.length; n++) {
        let r = this.directPlugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
      for (let n = 0; n < this.state.plugins.length; n++) {
        let r = this.state.plugins[n];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
    } else
      for (let n = 0; n < this.pluginViews.length; n++) {
        let r = this.pluginViews[n];
        r.update && r.update(this, e);
      }
  }
  updateDraggedNode(e, n) {
    let r = e.node, o = -1;
    if (this.state.doc.nodeAt(r.from) == r.node)
      o = r.from;
    else {
      let i = r.from + (this.state.doc.content.size - n.doc.content.size);
      (i > 0 && this.state.doc.nodeAt(i)) == r.node && (o = i);
    }
    this.dragging = new Cy(e.slice, e.move, o < 0 ? void 0 : se.create(this.state.doc, o));
  }
  someProp(e, n) {
    let r = this._props && this._props[e], o;
    if (r != null && (o = n ? n(r) : r))
      return o;
    for (let s = 0; s < this.directPlugins.length; s++) {
      let a = this.directPlugins[s].props[e];
      if (a != null && (o = n ? n(a) : a))
        return o;
    }
    let i = this.state.plugins;
    if (i)
      for (let s = 0; s < i.length; s++) {
        let a = i[s].props[e];
        if (a != null && (o = n ? n(a) : a))
          return o;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if ($t) {
      let e = this.root.activeElement;
      if (e == this.dom)
        return !0;
      if (!e || !this.dom.contains(e))
        return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false")
          return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && e1(this.dom), Qn(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let e = this._root;
    if (e == null) {
      for (let n = this.dom.parentNode; n; n = n.parentNode)
        if (n.nodeType == 9 || n.nodeType == 11 && n.host)
          return n.getSelection || (Object.getPrototypeOf(n).getSelection = () => n.ownerDocument.getSelection()), this._root = n;
    }
    return e || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(e) {
    return i1(this, e);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(e, n = 1) {
    return iy(this, e, n);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(e, n = 0) {
    return this.docView.domFromPos(e, n);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(e) {
    let n = this.docView.descAt(e);
    return n ? n.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(e, n, r = -1) {
    let o = this.docView.posFromDOM(e, n, r);
    if (o == null)
      throw new RangeError("DOM position not inside the editor");
    return o;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(e, n) {
    return u1(this, n || this.state, e);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(e, n) {
    return ns(this, "", e, !1, n || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(e, n) {
    return ns(this, e, null, !0, n || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(e) {
    return tf(this, e);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && ($1(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], Zc(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, UN());
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(e) {
    return F1(this, e);
  }
  /**
  @internal
  */
  domSelectionRange() {
    let e = this.domSelection();
    return e ? xt && this.root.nodeType === 11 && GN(this.dom.ownerDocument) == this.dom && fE(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
Oy.prototype.dispatch = function(t) {
  let e = this._props.dispatchTransaction;
  e ? e.call(this, t) : this.updateState(this.state.apply(t));
};
function Pm(t) {
  let e = /* @__PURE__ */ Object.create(null);
  return e.class = "ProseMirror", e.contenteditable = String(t.editable), t.someProp("attributes", (n) => {
    if (typeof n == "function" && (n = n(t.state)), n)
      for (let r in n)
        r == "class" ? e.class += " " + n[r] : r == "style" ? e.style = (e.style ? e.style + ";" : "") + n[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(n[r]));
  }), e.translate || (e.translate = "no"), [Ve.node(0, t.state.doc.content.size, e)];
}
function Bm(t) {
  if (t.markCursor) {
    let e = document.createElement("img");
    e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), t.cursorWrapper = { dom: e, deco: Ve.widget(t.state.selection.from, e, { raw: !0, marks: t.markCursor }) };
  } else
    t.cursorWrapper = null;
}
function zm(t) {
  return !t.someProp("editable", (e) => e(t.state) === !1);
}
function xE(t, e) {
  let n = Math.min(t.$anchor.sharedDepth(t.head), e.$anchor.sharedDepth(e.head));
  return t.$anchor.start(n) != e.$anchor.start(n);
}
function $m(t) {
  let e = /* @__PURE__ */ Object.create(null);
  function n(r) {
    for (let o in r)
      Object.prototype.hasOwnProperty.call(e, o) || (e[o] = r[o]);
  }
  return t.someProp("nodeViews", n), t.someProp("markViews", n), e;
}
function NE(t, e) {
  let n = 0, r = 0;
  for (let o in t) {
    if (t[o] != e[o])
      return !0;
    n++;
  }
  for (let o in e)
    r++;
  return n != r;
}
function Hm(t) {
  if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var Cr = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Ha = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, EE = typeof navigator < "u" && /Mac/.test(navigator.platform), SE = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var kt = 0; kt < 10; kt++) Cr[48 + kt] = Cr[96 + kt] = String(kt);
for (var kt = 1; kt <= 24; kt++) Cr[kt + 111] = "F" + kt;
for (var kt = 65; kt <= 90; kt++)
  Cr[kt] = String.fromCharCode(kt + 32), Ha[kt] = String.fromCharCode(kt);
for (var Qc in Cr) Ha.hasOwnProperty(Qc) || (Ha[Qc] = Cr[Qc]);
function TE(t) {
  var e = EE && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || SE && t.shiftKey && t.key && t.key.length == 1 || t.key == "Unidentified", n = !e && t.key || (t.shiftKey ? Ha : Cr)[t.keyCode] || t.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
const CE = typeof navigator < "u" && /Mac|iP(hone|[oa]d)/.test(navigator.platform), ME = typeof navigator < "u" && /Win/.test(navigator.platform);
function AE(t) {
  let e = t.split(/-(?!$)/), n = e[e.length - 1];
  n == "Space" && (n = " ");
  let r, o, i, s;
  for (let a = 0; a < e.length - 1; a++) {
    let l = e[a];
    if (/^(cmd|meta|m)$/i.test(l))
      s = !0;
    else if (/^a(lt)?$/i.test(l))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      o = !0;
    else if (/^s(hift)?$/i.test(l))
      i = !0;
    else if (/^mod$/i.test(l))
      CE ? s = !0 : o = !0;
    else
      throw new Error("Unrecognized modifier name: " + l);
  }
  return r && (n = "Alt-" + n), o && (n = "Ctrl-" + n), s && (n = "Meta-" + n), i && (n = "Shift-" + n), n;
}
function _E(t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let n in t)
    e[AE(n)] = t[n];
  return e;
}
function eu(t, e, n = !0) {
  return e.altKey && (t = "Alt-" + t), e.ctrlKey && (t = "Ctrl-" + t), e.metaKey && (t = "Meta-" + t), n && e.shiftKey && (t = "Shift-" + t), t;
}
function Iy(t) {
  return new Ce({ props: { handleKeyDown: lf(t) } });
}
function lf(t) {
  let e = _E(t);
  return function(n, r) {
    let o = TE(r), i, s = e[eu(o, r)];
    if (s && s(n.state, n.dispatch, n))
      return !0;
    if (o.length == 1 && o != " ") {
      if (r.shiftKey) {
        let a = e[eu(o, r, !1)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
      if ((r.altKey || r.metaKey || r.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(ME && r.ctrlKey && r.altKey) && (i = Cr[r.keyCode]) && i != o) {
        let a = e[eu(i, r)];
        if (a && a(n.state, n.dispatch, n))
          return !0;
      }
    }
    return !1;
  };
}
var RE = Object.defineProperty, cf = (t, e) => {
  for (var n in e)
    RE(t, n, { get: e[n], enumerable: !0 });
};
function oc(t) {
  const { state: e, transaction: n } = t;
  let { selection: r } = n, { doc: o } = n, { storedMarks: i } = n;
  return {
    ...e,
    apply: e.apply.bind(e),
    applyTransaction: e.applyTransaction.bind(e),
    plugins: e.plugins,
    schema: e.schema,
    reconfigure: e.reconfigure.bind(e),
    toJSON: e.toJSON.bind(e),
    get storedMarks() {
      return i;
    },
    get selection() {
      return r;
    },
    get doc() {
      return o;
    },
    get tr() {
      return r = n.selection, o = n.doc, i = n.storedMarks, n;
    }
  };
}
var ic = class {
  constructor(t) {
    this.editor = t.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = t.state;
  }
  get hasCustomState() {
    return !!this.customState;
  }
  get state() {
    return this.customState || this.editor.state;
  }
  get commands() {
    const { rawCommands: t, editor: e, state: n } = this, { view: r } = e, { tr: o } = n, i = this.buildProps(o);
    return Object.fromEntries(
      Object.entries(t).map(([s, a]) => [s, (...c) => {
        const u = a(...c)(i);
        return !o.getMeta("preventDispatch") && !this.hasCustomState && r.dispatch(o), u;
      }])
    );
  }
  get chain() {
    return () => this.createChain();
  }
  get can() {
    return () => this.createCan();
  }
  createChain(t, e = !0) {
    const { rawCommands: n, editor: r, state: o } = this, { view: i } = r, s = [], a = !!t, l = t || o.tr, c = () => (!a && e && !l.getMeta("preventDispatch") && !this.hasCustomState && i.dispatch(l), s.every((d) => d === !0)), u = {
      ...Object.fromEntries(
        Object.entries(n).map(([d, f]) => [d, (...m) => {
          const p = this.buildProps(l, e), g = f(...m)(p);
          return s.push(g), u;
        }])
      ),
      run: c
    };
    return u;
  }
  createCan(t) {
    const { rawCommands: e, state: n } = this, r = !1, o = t || n.tr, i = this.buildProps(o, r);
    return {
      ...Object.fromEntries(
        Object.entries(e).map(([a, l]) => [a, (...c) => l(...c)({ ...i, dispatch: void 0 })])
      ),
      chain: () => this.createChain(o, r)
    };
  }
  buildProps(t, e = !0) {
    const { rawCommands: n, editor: r, state: o } = this, { view: i } = r, s = {
      tr: t,
      editor: r,
      view: i,
      state: oc({
        state: o,
        transaction: t
      }),
      dispatch: e ? () => {
      } : void 0,
      chain: () => this.createChain(t, e),
      can: () => this.createCan(t),
      get commands() {
        return Object.fromEntries(
          Object.entries(n).map(([a, l]) => [a, (...c) => l(...c)(s)])
        );
      }
    };
    return s;
  }
}, Dy = {};
cf(Dy, {
  blur: () => OE,
  clearContent: () => IE,
  clearNodes: () => DE,
  command: () => LE,
  createParagraphNear: () => PE,
  cut: () => BE,
  deleteCurrentNode: () => zE,
  deleteNode: () => $E,
  deleteRange: () => HE,
  deleteSelection: () => FE,
  enter: () => UE,
  exitCode: () => WE,
  extendMarkRange: () => VE,
  first: () => KE,
  focus: () => GE,
  forEach: () => jE,
  insertContent: () => YE,
  insertContentAt: () => JE,
  joinBackward: () => tS,
  joinDown: () => eS,
  joinForward: () => nS,
  joinItemBackward: () => rS,
  joinItemForward: () => oS,
  joinTextblockBackward: () => iS,
  joinTextblockForward: () => sS,
  joinUp: () => QE,
  keyboardShortcut: () => lS,
  lift: () => cS,
  liftEmptyBlock: () => uS,
  liftListItem: () => dS,
  newlineInCode: () => fS,
  resetAttributes: () => hS,
  scrollIntoView: () => mS,
  selectAll: () => pS,
  selectNodeBackward: () => gS,
  selectNodeForward: () => bS,
  selectParentNode: () => yS,
  selectTextblockEnd: () => vS,
  selectTextblockStart: () => wS,
  setContent: () => kS,
  setMark: () => $S,
  setMeta: () => HS,
  setNode: () => FS,
  setNodeSelection: () => US,
  setTextDirection: () => WS,
  setTextSelection: () => VS,
  sinkListItem: () => KS,
  splitBlock: () => qS,
  splitListItem: () => GS,
  toggleList: () => jS,
  toggleMark: () => YS,
  toggleNode: () => XS,
  toggleWrap: () => ZS,
  undoInputRule: () => JS,
  unsetAllMarks: () => QS,
  unsetMark: () => eT,
  unsetTextDirection: () => tT,
  updateAttributes: () => nT,
  wrapIn: () => rT,
  wrapInList: () => oT
});
var OE = () => ({ editor: t, view: e }) => (requestAnimationFrame(() => {
  var n;
  t.isDestroyed || (e.dom.blur(), (n = window?.getSelection()) == null || n.removeAllRanges());
}), !0), IE = (t = !0) => ({ commands: e }) => e.setContent("", { emitUpdate: t }), DE = () => ({ state: t, tr: e, dispatch: n }) => {
  const { selection: r } = e, { ranges: o } = r;
  return n && o.forEach(({ $from: i, $to: s }) => {
    t.doc.nodesBetween(i.pos, s.pos, (a, l) => {
      if (a.type.isText)
        return;
      const { doc: c, mapping: u } = e, d = c.resolve(u.map(l)), f = c.resolve(u.map(l + a.nodeSize)), h = d.blockRange(f);
      if (!h)
        return;
      const m = li(h);
      if (a.type.isTextblock) {
        const { defaultType: p } = d.parent.contentMatchAt(d.index());
        e.setNodeMarkup(h.start, p);
      }
      (m || m === 0) && e.lift(h, m);
    });
  }), !0;
}, LE = (t) => (e) => t(e), PE = () => ({ state: t, dispatch: e }) => jb(t, e), BE = (t, e) => ({ editor: n, tr: r }) => {
  const { state: o } = n, i = o.doc.slice(t.from, t.to);
  r.deleteRange(t.from, t.to);
  const s = r.mapping.map(e);
  return r.insert(s, i.content), r.setSelection(new ce(r.doc.resolve(Math.max(s - 1, 0)))), !0;
}, zE = () => ({ tr: t, dispatch: e }) => {
  const { selection: n } = t, r = n.$anchor.node();
  if (r.content.size > 0)
    return !1;
  const o = t.selection.$anchor;
  for (let i = o.depth; i > 0; i -= 1)
    if (o.node(i).type === r.type) {
      if (e) {
        const a = o.before(i), l = o.after(i);
        t.delete(a, l).scrollIntoView();
      }
      return !0;
    }
  return !1;
};
function st(t, e) {
  if (typeof t == "string") {
    if (!e.nodes[t])
      throw Error(`There is no node type named '${t}'. Maybe you forgot to add the extension?`);
    return e.nodes[t];
  }
  return t;
}
var $E = (t) => ({ tr: e, state: n, dispatch: r }) => {
  const o = st(t, n.schema), i = e.selection.$anchor;
  for (let s = i.depth; s > 0; s -= 1)
    if (i.node(s).type === o) {
      if (r) {
        const l = i.before(s), c = i.after(s);
        e.delete(l, c).scrollIntoView();
      }
      return !0;
    }
  return !1;
}, HE = (t) => ({ tr: e, dispatch: n }) => {
  const { from: r, to: o } = t;
  return n && e.delete(r, o), !0;
}, FE = () => ({ state: t, dispatch: e }) => Gd(t, e), UE = () => ({ commands: t }) => t.keyboardShortcut("Enter"), WE = () => ({ state: t, dispatch: e }) => CN(t, e);
function uf(t) {
  return Object.prototype.toString.call(t) === "[object RegExp]";
}
function Fa(t, e, n = { strict: !0 }) {
  const r = Object.keys(e);
  return r.length ? r.every((o) => n.strict ? e[o] === t[o] : uf(e[o]) ? e[o].test(t[o]) : e[o] === t[o]) : !0;
}
function Ly(t, e, n = {}) {
  return t.find((r) => r.type === e && Fa(
    // Only check equality for the attributes that are provided
    Object.fromEntries(Object.keys(n).map((o) => [o, r.attrs[o]])),
    n
  ));
}
function Fm(t, e, n = {}) {
  return !!Ly(t, e, n);
}
function df(t, e, n) {
  var r;
  if (!t || !e)
    return;
  let o = t.parent.childAfter(t.parentOffset);
  if ((!o.node || !o.node.marks.some((u) => u.type === e)) && (o = t.parent.childBefore(t.parentOffset)), !o.node || !o.node.marks.some((u) => u.type === e) || (n = n || ((r = o.node.marks[0]) == null ? void 0 : r.attrs), !Ly([...o.node.marks], e, n)))
    return;
  let s = o.index, a = t.start() + o.offset, l = s + 1, c = a + o.node.nodeSize;
  for (; s > 0 && Fm([...t.parent.child(s - 1).marks], e, n); )
    s -= 1, a -= t.parent.child(s).nodeSize;
  for (; l < t.parent.childCount && Fm([...t.parent.child(l).marks], e, n); )
    c += t.parent.child(l).nodeSize, l += 1;
  return {
    from: a,
    to: c
  };
}
function er(t, e) {
  if (typeof t == "string") {
    if (!e.marks[t])
      throw Error(`There is no mark type named '${t}'. Maybe you forgot to add the extension?`);
    return e.marks[t];
  }
  return t;
}
var VE = (t, e = {}) => ({ tr: n, state: r, dispatch: o }) => {
  const i = er(t, r.schema), { doc: s, selection: a } = n, { $from: l, from: c, to: u } = a;
  if (o) {
    const d = df(l, i, e);
    if (d && d.from <= c && d.to >= u) {
      const f = ce.create(s, d.from, d.to);
      n.setSelection(f);
    }
  }
  return !0;
}, KE = (t) => (e) => {
  const n = typeof t == "function" ? t(e) : t;
  for (let r = 0; r < n.length; r += 1)
    if (n[r](e))
      return !0;
  return !1;
};
function ff(t) {
  return t instanceof ce;
}
function Zn(t = 0, e = 0, n = 0) {
  return Math.min(Math.max(t, e), n);
}
function Py(t, e = null) {
  if (!e)
    return null;
  const n = pe.atStart(t), r = pe.atEnd(t);
  if (e === "start" || e === !0)
    return n;
  if (e === "end")
    return r;
  const o = n.from, i = r.to;
  return e === "all" ? ce.create(t, Zn(0, o, i), Zn(t.content.size, o, i)) : ce.create(t, Zn(e, o, i), Zn(e, o, i));
}
function Zu() {
  return navigator.platform === "Android" || /android/i.test(navigator.userAgent);
}
function is() {
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || // iPad on iOS 13 detection
  navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
function qE() {
  return typeof navigator < "u" ? /^((?!chrome|android).)*safari/i.test(navigator.userAgent) : !1;
}
var GE = (t = null, e = {}) => ({ editor: n, view: r, tr: o, dispatch: i }) => {
  e = {
    scrollIntoView: !0,
    ...e
  };
  const s = () => {
    (is() || Zu()) && r.dom.focus(), qE() && !is() && !Zu() && r.dom.focus({ preventScroll: !0 }), requestAnimationFrame(() => {
      n.isDestroyed || (r.focus(), e?.scrollIntoView && n.commands.scrollIntoView());
    });
  };
  try {
    if (r.hasFocus() && t === null || t === !1)
      return !0;
  } catch {
    return !1;
  }
  if (i && t === null && !ff(n.state.selection))
    return s(), !0;
  const a = Py(o.doc, t) || n.state.selection, l = n.state.selection.eq(a);
  return i && (l || o.setSelection(a), l && o.storedMarks && o.setStoredMarks(o.storedMarks), s()), !0;
}, jE = (t, e) => (n) => t.every((r, o) => e(r, { ...n, index: o })), YE = (t, e) => ({ tr: n, commands: r }) => r.insertContentAt({ from: n.selection.from, to: n.selection.to }, t, e), By = (t) => {
  const e = t.childNodes;
  for (let n = e.length - 1; n >= 0; n -= 1) {
    const r = e[n];
    r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue) ? t.removeChild(r) : r.nodeType === 1 && By(r);
  }
  return t;
};
function Hs(t) {
  if (typeof window > "u")
    throw new Error("[tiptap error]: there is no window object available, so this function cannot be used");
  const e = `<body>${t}</body>`, n = new window.DOMParser().parseFromString(e, "text/html").body;
  return By(n);
}
function ss(t, e, n) {
  if (t instanceof xr || t instanceof D)
    return t;
  n = {
    slice: !0,
    parseOptions: {},
    ...n
  };
  const r = typeof t == "object" && t !== null, o = typeof t == "string";
  if (r)
    try {
      if (Array.isArray(t) && t.length > 0)
        return D.fromArray(t.map((a) => e.nodeFromJSON(a)));
      const s = e.nodeFromJSON(t);
      return n.errorOnInvalidContent && s.check(), s;
    } catch (i) {
      if (n.errorOnInvalidContent)
        throw new Error("[tiptap error]: Invalid JSON content", { cause: i });
      return console.warn("[tiptap warn]: Invalid content.", "Passed value:", t, "Error:", i), ss("", e, n);
    }
  if (o) {
    if (n.errorOnInvalidContent) {
      let s = !1, a = "";
      const l = new kb({
        topNode: e.spec.topNode,
        marks: e.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: e.spec.nodes.append({
          __tiptap__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (c) => (s = !0, a = typeof c == "string" ? c : c.outerHTML, null)
              }
            ]
          }
        })
      });
      if (n.slice ? Nr.fromSchema(l).parseSlice(Hs(t), n.parseOptions) : Nr.fromSchema(l).parse(Hs(t), n.parseOptions), n.errorOnInvalidContent && s)
        throw new Error("[tiptap error]: Invalid HTML content", {
          cause: new Error(`Invalid element found: ${a}`)
        });
    }
    const i = Nr.fromSchema(e);
    return n.slice ? i.parseSlice(Hs(t), n.parseOptions).content : i.parse(Hs(t), n.parseOptions);
  }
  return ss("", e, n);
}
function XE(t, e, n) {
  const r = t.steps.length - 1;
  if (r < e)
    return;
  const o = t.steps[r];
  if (!(o instanceof ft || o instanceof mt))
    return;
  const i = t.mapping.maps[r];
  let s = 0;
  i.forEach((a, l, c, u) => {
    s === 0 && (s = u);
  }), t.setSelection(pe.near(t.doc.resolve(s), n));
}
var ZE = (t) => !("type" in t), JE = (t, e, n) => ({ tr: r, dispatch: o, editor: i }) => {
  var s;
  if (o) {
    n = {
      parseOptions: i.options.parseOptions,
      updateSelection: !0,
      applyInputRules: !1,
      applyPasteRules: !1,
      ...n
    };
    let a;
    const l = (g) => {
      i.emit("contentError", {
        editor: i,
        error: g,
        disableCollaboration: () => {
          "collaboration" in i.storage && typeof i.storage.collaboration == "object" && i.storage.collaboration && (i.storage.collaboration.isDisabled = !0);
        }
      });
    }, c = {
      preserveWhitespace: "full",
      ...n.parseOptions
    };
    if (!n.errorOnInvalidContent && !i.options.enableContentCheck && i.options.emitContentError)
      try {
        ss(e, i.schema, {
          parseOptions: c,
          errorOnInvalidContent: !0
        });
      } catch (g) {
        l(g);
      }
    try {
      a = ss(e, i.schema, {
        parseOptions: c,
        errorOnInvalidContent: (s = n.errorOnInvalidContent) != null ? s : i.options.enableContentCheck
      });
    } catch (g) {
      return l(g), !1;
    }
    let { from: u, to: d } = typeof t == "number" ? { from: t, to: t } : { from: t.from, to: t.to }, f = !0, h = !0;
    if ((ZE(a) ? a : [a]).forEach((g) => {
      g.check(), f = f ? g.isText && g.marks.length === 0 : !1, h = h ? g.isBlock : !1;
    }), u === d && h) {
      const { parent: g } = r.doc.resolve(u);
      g.isTextblock && !g.type.spec.code && !g.childCount && (u -= 1, d += 1);
    }
    let p;
    if (f) {
      if (Array.isArray(e))
        p = e.map((g) => g.text || "").join("");
      else if (e instanceof D) {
        let g = "";
        e.forEach((b) => {
          b.text && (g += b.text);
        }), p = g;
      } else typeof e == "object" && e && e.text ? p = e.text : p = e;
      r.insertText(p, u, d);
    } else {
      p = a;
      const g = r.doc.resolve(u), b = g.node(), v = g.parentOffset === 0, k = b.isText || b.isTextblock, x = b.content.size > 0;
      v && k && x && (u = Math.max(0, u - 1)), r.replaceWith(u, d, p);
    }
    n.updateSelection && XE(r, r.steps.length - 1, -1), n.applyInputRules && r.setMeta("applyInputRules", { from: u, text: p }), n.applyPasteRules && r.setMeta("applyPasteRules", { from: u, text: p });
  }
  return !0;
}, QE = () => ({ state: t, dispatch: e }) => EN(t, e), eS = () => ({ state: t, dispatch: e }) => SN(t, e), tS = () => ({ state: t, dispatch: e }) => Fb(t, e), nS = () => ({ state: t, dispatch: e }) => Kb(t, e), rS = () => ({ state: t, dispatch: e, tr: n }) => {
  try {
    const r = Jl(t.doc, t.selection.$from.pos, -1);
    return r == null ? !1 : (n.join(r, 2), e && e(n), !0);
  } catch {
    return !1;
  }
}, oS = () => ({ state: t, dispatch: e, tr: n }) => {
  try {
    const r = Jl(t.doc, t.selection.$from.pos, 1);
    return r == null ? !1 : (n.join(r, 2), e && e(n), !0);
  } catch {
    return !1;
  }
}, iS = () => ({ state: t, dispatch: e }) => xN(t, e), sS = () => ({ state: t, dispatch: e }) => NN(t, e);
function zy() {
  return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1;
}
function aS(t) {
  const e = t.split(/-(?!$)/);
  let n = e[e.length - 1];
  n === "Space" && (n = " ");
  let r, o, i, s;
  for (let a = 0; a < e.length - 1; a += 1) {
    const l = e[a];
    if (/^(cmd|meta|m)$/i.test(l))
      s = !0;
    else if (/^a(lt)?$/i.test(l))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(l))
      o = !0;
    else if (/^s(hift)?$/i.test(l))
      i = !0;
    else if (/^mod$/i.test(l))
      is() || zy() ? s = !0 : o = !0;
    else
      throw new Error(`Unrecognized modifier name: ${l}`);
  }
  return r && (n = `Alt-${n}`), o && (n = `Ctrl-${n}`), s && (n = `Meta-${n}`), i && (n = `Shift-${n}`), n;
}
var lS = (t) => ({ editor: e, view: n, tr: r, dispatch: o }) => {
  const i = aS(t).split(/-(?!$)/), s = i.find((c) => !["Alt", "Ctrl", "Meta", "Shift"].includes(c)), a = new KeyboardEvent("keydown", {
    key: s === "Space" ? " " : s,
    altKey: i.includes("Alt"),
    ctrlKey: i.includes("Ctrl"),
    metaKey: i.includes("Meta"),
    shiftKey: i.includes("Shift"),
    bubbles: !0,
    cancelable: !0
  }), l = e.captureTransaction(() => {
    n.someProp("handleKeyDown", (c) => c(n, a));
  });
  return l?.steps.forEach((c) => {
    const u = c.map(r.mapping);
    u && o && r.maybeStep(u);
  }), !0;
};
function Mr(t, e, n = {}) {
  const { from: r, to: o, empty: i } = t.selection, s = e ? st(e, t.schema) : null, a = [];
  t.doc.nodesBetween(r, o, (d, f) => {
    if (d.isText)
      return;
    const h = Math.max(r, f), m = Math.min(o, f + d.nodeSize);
    a.push({
      node: d,
      from: h,
      to: m
    });
  });
  const l = o - r, c = a.filter((d) => s ? s.name === d.node.type.name : !0).filter((d) => Fa(d.node.attrs, n, { strict: !1 }));
  return i ? !!c.length : c.reduce((d, f) => d + f.to - f.from, 0) >= l;
}
var cS = (t, e = {}) => ({ state: n, dispatch: r }) => {
  const o = st(t, n.schema);
  return Mr(n, o, e) ? TN(n, r) : !1;
}, uS = () => ({ state: t, dispatch: e }) => Yb(t, e), dS = (t) => ({ state: e, dispatch: n }) => {
  const r = st(t, e.schema);
  return zN(r)(e, n);
}, fS = () => ({ state: t, dispatch: e }) => Gb(t, e);
function sc(t, e) {
  return e.nodes[t] ? "node" : e.marks[t] ? "mark" : null;
}
function Um(t, e) {
  const n = typeof e == "string" ? [e] : e;
  return Object.keys(t).reduce((r, o) => (n.includes(o) || (r[o] = t[o]), r), {});
}
var hS = (t, e) => ({ tr: n, state: r, dispatch: o }) => {
  let i = null, s = null;
  const a = sc(
    typeof t == "string" ? t : t.name,
    r.schema
  );
  if (!a)
    return !1;
  a === "node" && (i = st(t, r.schema)), a === "mark" && (s = er(t, r.schema));
  let l = !1;
  return n.selection.ranges.forEach((c) => {
    r.doc.nodesBetween(c.$from.pos, c.$to.pos, (u, d) => {
      i && i === u.type && (l = !0, o && n.setNodeMarkup(d, void 0, Um(u.attrs, e))), s && u.marks.length && u.marks.forEach((f) => {
        s === f.type && (l = !0, o && n.addMark(d, d + u.nodeSize, s.create(Um(f.attrs, e))));
      });
    });
  }), l;
}, mS = () => ({ tr: t, dispatch: e }) => (e && t.scrollIntoView(), !0), pS = () => ({ tr: t, dispatch: e }) => {
  if (e) {
    const n = new Kt(t.doc);
    t.setSelection(n);
  }
  return !0;
}, gS = () => ({ state: t, dispatch: e }) => Wb(t, e), bS = () => ({ state: t, dispatch: e }) => qb(t, e), yS = () => ({ state: t, dispatch: e }) => _N(t, e), vS = () => ({ state: t, dispatch: e }) => IN(t, e), wS = () => ({ state: t, dispatch: e }) => ON(t, e);
function Ju(t, e, n = {}, r = {}) {
  return ss(t, e, {
    slice: !1,
    parseOptions: n,
    errorOnInvalidContent: r.errorOnInvalidContent
  });
}
var kS = (t, { errorOnInvalidContent: e, emitUpdate: n = !0, parseOptions: r = {} } = {}) => ({ editor: o, tr: i, dispatch: s, commands: a }) => {
  const { doc: l } = i;
  if (r.preserveWhitespace !== "full") {
    const c = Ju(t, o.schema, r, {
      errorOnInvalidContent: e ?? o.options.enableContentCheck
    });
    return s && i.replaceWith(0, l.content.size, c).setMeta("preventUpdate", !n), !0;
  }
  return s && i.setMeta("preventUpdate", !n), a.insertContentAt({ from: 0, to: l.content.size }, t, {
    parseOptions: r,
    errorOnInvalidContent: e ?? o.options.enableContentCheck
  });
};
function $y(t, e) {
  const n = er(e, t.schema), { from: r, to: o, empty: i } = t.selection, s = [];
  i ? (t.storedMarks && s.push(...t.storedMarks), s.push(...t.selection.$head.marks())) : t.doc.nodesBetween(r, o, (l) => {
    s.push(...l.marks);
  });
  const a = s.find((l) => l.type.name === n.name);
  return a ? { ...a.attrs } : {};
}
function Hy(t, e) {
  const n = new Kd(t);
  return e.forEach((r) => {
    r.steps.forEach((o) => {
      n.step(o);
    });
  }), n;
}
function xS(t) {
  for (let e = 0; e < t.edgeCount; e += 1) {
    const { type: n } = t.edge(e);
    if (n.isTextblock && !n.hasRequiredAttrs())
      return n;
  }
  return null;
}
function Qu(t, e) {
  const n = [];
  return t.descendants((r, o) => {
    e(r) && n.push({
      node: r,
      pos: o
    });
  }), n;
}
function NS(t, e, n) {
  const r = [];
  return t.nodesBetween(e.from, e.to, (o, i) => {
    n(o) && r.push({
      node: o,
      pos: i
    });
  }), r;
}
function Fy(t, e) {
  for (let n = t.depth; n > 0; n -= 1) {
    const r = t.node(n);
    if (e(r))
      return {
        pos: n > 0 ? t.before(n) : 0,
        start: t.start(n),
        depth: n,
        node: r
      };
  }
}
function ac(t) {
  return (e) => Fy(e.$from, t);
}
function le(t, e, n) {
  return t.config[e] === void 0 && t.parent ? le(t.parent, e, n) : typeof t.config[e] == "function" ? t.config[e].bind({
    ...n,
    parent: t.parent ? le(t.parent, e, n) : null
  }) : t.config[e];
}
function hf(t) {
  return t.map((e) => {
    const n = {
      name: e.name,
      options: e.options,
      storage: e.storage
    }, r = le(e, "addExtensions", n);
    return r ? [e, ...hf(r())] : e;
  }).flat(10);
}
function mf(t, e) {
  const n = so.fromSchema(e).serializeFragment(t), o = document.implementation.createHTMLDocument().createElement("div");
  return o.appendChild(n), o.innerHTML;
}
function Uy(t) {
  return typeof t == "function";
}
function ze(t, e = void 0, ...n) {
  return Uy(t) ? e ? t.bind(e)(...n) : t(...n) : t;
}
function ES(t = {}) {
  return Object.keys(t).length === 0 && t.constructor === Object;
}
function Zo(t) {
  const e = t.filter((o) => o.type === "extension"), n = t.filter((o) => o.type === "node"), r = t.filter((o) => o.type === "mark");
  return {
    baseExtensions: e,
    nodeExtensions: n,
    markExtensions: r
  };
}
function Wy(t) {
  const e = [], { nodeExtensions: n, markExtensions: r } = Zo(t), o = [...n, ...r], i = {
    default: null,
    validate: void 0,
    rendered: !0,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: !0,
    isRequired: !1
  };
  return t.forEach((s) => {
    const a = {
      name: s.name,
      options: s.options,
      storage: s.storage,
      extensions: o
    }, l = le(
      s,
      "addGlobalAttributes",
      a
    );
    if (!l)
      return;
    l().forEach((u) => {
      u.types.forEach((d) => {
        Object.entries(u.attributes).forEach(([f, h]) => {
          e.push({
            type: d,
            name: f,
            attribute: {
              ...i,
              ...h
            }
          });
        });
      });
    });
  }), o.forEach((s) => {
    const a = {
      name: s.name,
      options: s.options,
      storage: s.storage
    }, l = le(
      s,
      "addAttributes",
      a
    );
    if (!l)
      return;
    const c = l();
    Object.entries(c).forEach(([u, d]) => {
      const f = {
        ...i,
        ...d
      };
      typeof f?.default == "function" && (f.default = f.default()), f?.isRequired && f?.default === void 0 && delete f.default, e.push({
        type: s.name,
        name: u,
        attribute: f
      });
    });
  }), e;
}
function De(...t) {
  return t.filter((e) => !!e).reduce((e, n) => {
    const r = { ...e };
    return Object.entries(n).forEach(([o, i]) => {
      if (!r[o]) {
        r[o] = i;
        return;
      }
      if (o === "class") {
        const a = i ? String(i).split(" ") : [], l = r[o] ? r[o].split(" ") : [], c = a.filter((u) => !l.includes(u));
        r[o] = [...l, ...c].join(" ");
      } else if (o === "style") {
        const a = i ? i.split(";").map((u) => u.trim()).filter(Boolean) : [], l = r[o] ? r[o].split(";").map((u) => u.trim()).filter(Boolean) : [], c = /* @__PURE__ */ new Map();
        l.forEach((u) => {
          const [d, f] = u.split(":").map((h) => h.trim());
          c.set(d, f);
        }), a.forEach((u) => {
          const [d, f] = u.split(":").map((h) => h.trim());
          c.set(d, f);
        }), r[o] = Array.from(c.entries()).map(([u, d]) => `${u}: ${d}`).join("; ");
      } else
        r[o] = i;
    }), r;
  }, {});
}
function Jo(t, e) {
  return e.filter((n) => n.type === t.type.name).filter((n) => n.attribute.rendered).map((n) => n.attribute.renderHTML ? n.attribute.renderHTML(t.attrs) || {} : {
    [n.name]: t.attrs[n.name]
  }).reduce((n, r) => De(n, r), {});
}
function SS(t) {
  return typeof t != "string" ? t : t.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(t) : t === "true" ? !0 : t === "false" ? !1 : t;
}
function Wm(t, e) {
  return "style" in t ? t : {
    ...t,
    getAttrs: (n) => {
      const r = t.getAttrs ? t.getAttrs(n) : t.attrs;
      if (r === !1)
        return !1;
      const o = e.reduce((i, s) => {
        const a = s.attribute.parseHTML ? s.attribute.parseHTML(n) : SS(n.getAttribute(s.name));
        return a == null ? i : {
          ...i,
          [s.name]: a
        };
      }, {});
      return { ...r, ...o };
    }
  };
}
function Vm(t) {
  return Object.fromEntries(
    // @ts-ignore
    Object.entries(t).filter(([e, n]) => e === "attrs" && ES(n) ? !1 : n != null)
  );
}
function Km(t) {
  var e, n;
  const r = {};
  return !((e = t?.attribute) != null && e.isRequired) && "default" in (t?.attribute || {}) && (r.default = t.attribute.default), ((n = t?.attribute) == null ? void 0 : n.validate) !== void 0 && (r.validate = t.attribute.validate), [t.name, r];
}
function TS(t, e) {
  var n;
  const r = Wy(t), { nodeExtensions: o, markExtensions: i } = Zo(t), s = (n = o.find((c) => le(c, "topNode"))) == null ? void 0 : n.name, a = Object.fromEntries(
    o.map((c) => {
      const u = r.filter((b) => b.type === c.name), d = {
        name: c.name,
        options: c.options,
        storage: c.storage,
        editor: e
      }, f = t.reduce((b, v) => {
        const k = le(v, "extendNodeSchema", d);
        return {
          ...b,
          ...k ? k(c) : {}
        };
      }, {}), h = Vm({
        ...f,
        content: ze(le(c, "content", d)),
        marks: ze(le(c, "marks", d)),
        group: ze(le(c, "group", d)),
        inline: ze(le(c, "inline", d)),
        atom: ze(le(c, "atom", d)),
        selectable: ze(le(c, "selectable", d)),
        draggable: ze(le(c, "draggable", d)),
        code: ze(le(c, "code", d)),
        whitespace: ze(le(c, "whitespace", d)),
        linebreakReplacement: ze(
          le(c, "linebreakReplacement", d)
        ),
        defining: ze(le(c, "defining", d)),
        isolating: ze(le(c, "isolating", d)),
        attrs: Object.fromEntries(u.map(Km))
      }), m = ze(le(c, "parseHTML", d));
      m && (h.parseDOM = m.map(
        (b) => Wm(b, u)
      ));
      const p = le(c, "renderHTML", d);
      p && (h.toDOM = (b) => p({
        node: b,
        HTMLAttributes: Jo(b, u)
      }));
      const g = le(c, "renderText", d);
      return g && (h.toText = g), [c.name, h];
    })
  ), l = Object.fromEntries(
    i.map((c) => {
      const u = r.filter((g) => g.type === c.name), d = {
        name: c.name,
        options: c.options,
        storage: c.storage,
        editor: e
      }, f = t.reduce((g, b) => {
        const v = le(b, "extendMarkSchema", d);
        return {
          ...g,
          ...v ? v(c) : {}
        };
      }, {}), h = Vm({
        ...f,
        inclusive: ze(le(c, "inclusive", d)),
        excludes: ze(le(c, "excludes", d)),
        group: ze(le(c, "group", d)),
        spanning: ze(le(c, "spanning", d)),
        code: ze(le(c, "code", d)),
        attrs: Object.fromEntries(u.map(Km))
      }), m = ze(le(c, "parseHTML", d));
      m && (h.parseDOM = m.map(
        (g) => Wm(g, u)
      ));
      const p = le(c, "renderHTML", d);
      return p && (h.toDOM = (g) => p({
        mark: g,
        HTMLAttributes: Jo(g, u)
      })), [c.name, h];
    })
  );
  return new kb({
    topNode: s,
    nodes: a,
    marks: l
  });
}
function CS(t) {
  const e = t.filter((n, r) => t.indexOf(n) !== r);
  return Array.from(new Set(e));
}
function Ua(t) {
  return t.sort((n, r) => {
    const o = le(n, "priority") || 100, i = le(r, "priority") || 100;
    return o > i ? -1 : o < i ? 1 : 0;
  });
}
function Vy(t) {
  const e = Ua(hf(t)), n = CS(e.map((r) => r.name));
  return n.length && console.warn(
    `[tiptap warn]: Duplicate extension names found: [${n.map((r) => `'${r}'`).join(", ")}]. This can lead to issues.`
  ), e;
}
function Ky(t, e, n) {
  const { from: r, to: o } = e, { blockSeparator: i = `

`, textSerializers: s = {} } = n || {};
  let a = "";
  return t.nodesBetween(r, o, (l, c, u, d) => {
    var f;
    l.isBlock && c > r && (a += i);
    const h = s?.[l.type.name];
    if (h)
      return u && (a += h({
        node: l,
        pos: c,
        parent: u,
        index: d,
        range: e
      })), !1;
    l.isText && (a += (f = l?.text) == null ? void 0 : f.slice(Math.max(r, c) - c, o - c));
  }), a;
}
function qy(t, e) {
  const n = {
    from: 0,
    to: t.content.size
  };
  return Ky(t, n, e);
}
function pf(t) {
  return Object.fromEntries(
    Object.entries(t.nodes).filter(([, e]) => e.spec.toText).map(([e, n]) => [e, n.spec.toText])
  );
}
function MS(t, e) {
  const n = st(e, t.schema), { from: r, to: o } = t.selection, i = [];
  t.doc.nodesBetween(r, o, (a) => {
    i.push(a);
  });
  const s = i.reverse().find((a) => a.type.name === n.name);
  return s ? { ...s.attrs } : {};
}
function Gy(t, e) {
  const n = sc(
    typeof e == "string" ? e : e.name,
    t.schema
  );
  return n === "node" ? MS(t, e) : n === "mark" ? $y(t, e) : {};
}
function AS(t, e = JSON.stringify) {
  const n = {};
  return t.filter((r) => {
    const o = e(r);
    return Object.prototype.hasOwnProperty.call(n, o) ? !1 : n[o] = !0;
  });
}
function _S(t) {
  const e = AS(t);
  return e.length === 1 ? e : e.filter((n, r) => !e.filter((i, s) => s !== r).some((i) => n.oldRange.from >= i.oldRange.from && n.oldRange.to <= i.oldRange.to && n.newRange.from >= i.newRange.from && n.newRange.to <= i.newRange.to));
}
function jy(t) {
  const { mapping: e, steps: n } = t, r = [];
  return e.maps.forEach((o, i) => {
    const s = [];
    if (o.ranges.length)
      o.forEach((a, l) => {
        s.push({ from: a, to: l });
      });
    else {
      const { from: a, to: l } = n[i];
      if (a === void 0 || l === void 0)
        return;
      s.push({ from: a, to: l });
    }
    s.forEach(({ from: a, to: l }) => {
      const c = e.slice(i).map(a, -1), u = e.slice(i).map(l), d = e.invert().map(c, -1), f = e.invert().map(u);
      r.push({
        oldRange: {
          from: d,
          to: f
        },
        newRange: {
          from: c,
          to: u
        }
      });
    });
  }), _S(r);
}
function gf(t, e, n) {
  const r = [];
  return t === e ? n.resolve(t).marks().forEach((o) => {
    const i = n.resolve(t), s = df(i, o.type);
    s && r.push({
      mark: o,
      ...s
    });
  }) : n.nodesBetween(t, e, (o, i) => {
    !o || o?.nodeSize === void 0 || r.push(
      ...o.marks.map((s) => ({
        from: i,
        to: i + o.nodeSize,
        mark: s
      }))
    );
  }), r;
}
var RS = (t, e, n, r = 20) => {
  const o = t.doc.resolve(n);
  let i = r, s = null;
  for (; i > 0 && s === null; ) {
    const a = o.node(i);
    a?.type.name === e ? s = a : i -= 1;
  }
  return [s, i];
};
function Fs(t, e) {
  return e.nodes[t] || e.marks[t] || null;
}
function wa(t, e, n) {
  return Object.fromEntries(
    Object.entries(n).filter(([r]) => {
      const o = t.find((i) => i.type === e && i.name === r);
      return o ? o.attribute.keepOnSplit : !1;
    })
  );
}
var OS = (t, e = 500) => {
  let n = "";
  const r = t.parentOffset;
  return t.parent.nodesBetween(Math.max(0, r - e), r, (o, i, s, a) => {
    var l, c;
    const u = ((c = (l = o.type.spec).toText) == null ? void 0 : c.call(l, {
      node: o,
      pos: i,
      parent: s,
      index: a
    })) || o.textContent || "%leaf%";
    n += o.isAtom && !o.isText ? u : u.slice(0, Math.max(0, r - i));
  }), n;
};
function ed(t, e, n = {}) {
  const { empty: r, ranges: o } = t.selection, i = e ? er(e, t.schema) : null;
  if (r)
    return !!(t.storedMarks || t.selection.$from.marks()).filter((d) => i ? i.name === d.type.name : !0).find((d) => Fa(d.attrs, n, { strict: !1 }));
  let s = 0;
  const a = [];
  if (o.forEach(({ $from: d, $to: f }) => {
    const h = d.pos, m = f.pos;
    t.doc.nodesBetween(h, m, (p, g) => {
      if (!p.isText && !p.marks.length)
        return;
      const b = Math.max(h, g), v = Math.min(m, g + p.nodeSize), k = v - b;
      s += k, a.push(
        ...p.marks.map((x) => ({
          mark: x,
          from: b,
          to: v
        }))
      );
    });
  }), s === 0)
    return !1;
  const l = a.filter((d) => i ? i.name === d.mark.type.name : !0).filter((d) => Fa(d.mark.attrs, n, { strict: !1 })).reduce((d, f) => d + f.to - f.from, 0), c = a.filter((d) => i ? d.mark.type !== i && d.mark.type.excludes(i) : !0).reduce((d, f) => d + f.to - f.from, 0);
  return (l > 0 ? l + c : l) >= s;
}
function IS(t, e, n = {}) {
  if (!e)
    return Mr(t, null, n) || ed(t, null, n);
  const r = sc(e, t.schema);
  return r === "node" ? Mr(t, e, n) : r === "mark" ? ed(t, e, n) : !1;
}
var DS = (t, e) => {
  const { $from: n, $to: r, $anchor: o } = t.selection;
  if (e) {
    const i = ac((a) => a.type.name === e)(t.selection);
    if (!i)
      return !1;
    const s = t.doc.resolve(i.pos + 1);
    return o.pos + 1 === s.end();
  }
  return !(r.parentOffset < r.parent.nodeSize - 2 || n.pos !== r.pos);
}, LS = (t) => {
  const { $from: e, $to: n } = t.selection;
  return !(e.parentOffset > 0 || e.pos !== n.pos);
};
function qm(t, e) {
  return Array.isArray(e) ? e.some((n) => (typeof n == "string" ? n : n.name) === t.name) : e;
}
function Gm(t, e) {
  const { nodeExtensions: n } = Zo(e), r = n.find((s) => s.name === t);
  if (!r)
    return !1;
  const o = {
    name: r.name,
    options: r.options,
    storage: r.storage
  }, i = ze(le(r, "group", o));
  return typeof i != "string" ? !1 : i.split(" ").includes("list");
}
function lc(t, {
  checkChildren: e = !0,
  ignoreWhitespace: n = !1
} = {}) {
  var r;
  if (n) {
    if (t.type.name === "hardBreak")
      return !0;
    if (t.isText)
      return /^\s*$/m.test((r = t.text) != null ? r : "");
  }
  if (t.isText)
    return !t.text;
  if (t.isAtom || t.isLeaf)
    return !1;
  if (t.content.childCount === 0)
    return !0;
  if (e) {
    let o = !0;
    return t.content.forEach((i) => {
      o !== !1 && (lc(i, { ignoreWhitespace: n, checkChildren: e }) || (o = !1));
    }), o;
  }
  return !1;
}
function Yy(t) {
  return t instanceof se;
}
var Xy = class Zy {
  constructor(e) {
    this.position = e;
  }
  /**
   * Creates a MappablePosition from a JSON object.
   */
  static fromJSON(e) {
    return new Zy(e.position);
  }
  /**
   * Converts the MappablePosition to a JSON object.
   */
  toJSON() {
    return {
      position: this.position
    };
  }
};
function PS(t, e) {
  const n = e.mapping.mapResult(t.position);
  return {
    position: new Xy(n.pos),
    mapResult: n
  };
}
function BS(t) {
  return new Xy(t);
}
function Jy(t, e, n) {
  const o = t.state.doc.content.size, i = Zn(e, 0, o), s = Zn(n, 0, o), a = t.coordsAtPos(i), l = t.coordsAtPos(s, -1), c = Math.min(a.top, l.top), u = Math.max(a.bottom, l.bottom), d = Math.min(a.left, l.left), f = Math.max(a.right, l.right), h = f - d, m = u - c, b = {
    top: c,
    bottom: u,
    left: d,
    right: f,
    width: h,
    height: m,
    x: d,
    y: c
  };
  return {
    ...b,
    toJSON: () => b
  };
}
function zS(t, e, n) {
  var r;
  const { selection: o } = e;
  let i = null;
  if (ff(o) && (i = o.$cursor), i) {
    const a = (r = t.storedMarks) != null ? r : i.marks();
    return i.parent.type.allowsMarkType(n) && (!!n.isInSet(a) || !a.some((c) => c.type.excludes(n)));
  }
  const { ranges: s } = o;
  return s.some(({ $from: a, $to: l }) => {
    let c = a.depth === 0 ? t.doc.inlineContent && t.doc.type.allowsMarkType(n) : !1;
    return t.doc.nodesBetween(a.pos, l.pos, (u, d, f) => {
      if (c)
        return !1;
      if (u.isInline) {
        const h = !f || f.type.allowsMarkType(n), m = !!n.isInSet(u.marks) || !u.marks.some((p) => p.type.excludes(n));
        c = h && m;
      }
      return !c;
    }), c;
  });
}
var $S = (t, e = {}) => ({ tr: n, state: r, dispatch: o }) => {
  const { selection: i } = n, { empty: s, ranges: a } = i, l = er(t, r.schema);
  if (o)
    if (s) {
      const c = $y(r, l);
      n.addStoredMark(
        l.create({
          ...c,
          ...e
        })
      );
    } else
      a.forEach((c) => {
        const u = c.$from.pos, d = c.$to.pos;
        r.doc.nodesBetween(u, d, (f, h) => {
          const m = Math.max(h, u), p = Math.min(h + f.nodeSize, d);
          f.marks.find((b) => b.type === l) ? f.marks.forEach((b) => {
            l === b.type && n.addMark(
              m,
              p,
              l.create({
                ...b.attrs,
                ...e
              })
            );
          }) : n.addMark(m, p, l.create(e));
        });
      });
  return zS(r, n, l);
}, HS = (t, e) => ({ tr: n }) => (n.setMeta(t, e), !0), FS = (t, e = {}) => ({ state: n, dispatch: r, chain: o }) => {
  const i = st(t, n.schema);
  let s;
  return n.selection.$anchor.sameParent(n.selection.$head) && (s = n.selection.$anchor.parent.attrs), i.isTextblock ? o().command(({ commands: a }) => am(i, { ...s, ...e })(n) ? !0 : a.clearNodes()).command(({ state: a }) => am(i, { ...s, ...e })(a, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1);
}, US = (t) => ({ tr: e, dispatch: n }) => {
  if (n) {
    const { doc: r } = e, o = Zn(t, 0, r.content.size), i = se.create(r, o);
    e.setSelection(i);
  }
  return !0;
}, WS = (t, e) => ({ tr: n, state: r, dispatch: o }) => {
  const { selection: i } = r;
  let s, a;
  return typeof e == "number" ? (s = e, a = e) : e && "from" in e && "to" in e ? (s = e.from, a = e.to) : (s = i.from, a = i.to), o && n.doc.nodesBetween(s, a, (l, c) => {
    l.isText || n.setNodeMarkup(c, void 0, {
      ...l.attrs,
      dir: t
    });
  }), !0;
}, VS = (t) => ({ tr: e, dispatch: n }) => {
  if (n) {
    const { doc: r } = e, { from: o, to: i } = typeof t == "number" ? { from: t, to: t } : t, s = ce.atStart(r).from, a = ce.atEnd(r).to, l = Zn(o, s, a), c = Zn(i, s, a), u = ce.create(r, l, c);
    e.setSelection(u);
  }
  return !0;
}, KS = (t) => ({ state: e, dispatch: n }) => {
  const r = st(t, e.schema);
  return FN(r)(e, n);
};
function jm(t, e) {
  const n = t.storedMarks || t.selection.$to.parentOffset && t.selection.$from.marks();
  if (n) {
    const r = n.filter((o) => e?.includes(o.type.name));
    t.tr.ensureMarks(r);
  }
}
var qS = ({ keepMarks: t = !0 } = {}) => ({ tr: e, state: n, dispatch: r, editor: o }) => {
  const { selection: i, doc: s } = e, { $from: a, $to: l } = i, c = o.extensionManager.attributes, u = wa(c, a.node().type.name, a.node().attrs);
  if (i instanceof se && i.node.isBlock)
    return !a.parentOffset || !Jn(s, a.pos) ? !1 : (r && (t && jm(n, o.extensionManager.splittableMarks), e.split(a.pos).scrollIntoView()), !0);
  if (!a.parent.isBlock)
    return !1;
  const d = l.parentOffset === l.parent.content.size, f = a.depth === 0 ? void 0 : xS(a.node(-1).contentMatchAt(a.indexAfter(-1)));
  let h = d && f ? [
    {
      type: f,
      attrs: u
    }
  ] : void 0, m = Jn(e.doc, e.mapping.map(a.pos), 1, h);
  if (!h && !m && Jn(e.doc, e.mapping.map(a.pos), 1, f ? [{ type: f }] : void 0) && (m = !0, h = f ? [
    {
      type: f,
      attrs: u
    }
  ] : void 0), r) {
    if (m && (i instanceof ce && e.deleteSelection(), e.split(e.mapping.map(a.pos), 1, h), f && !d && !a.parentOffset && a.parent.type !== f)) {
      const p = e.mapping.map(a.before()), g = e.doc.resolve(p);
      a.node(-1).canReplaceWith(g.index(), g.index() + 1, f) && e.setNodeMarkup(e.mapping.map(a.before()), f);
    }
    t && jm(n, o.extensionManager.splittableMarks), e.scrollIntoView();
  }
  return m;
}, GS = (t, e = {}) => ({ tr: n, state: r, dispatch: o, editor: i }) => {
  var s;
  const a = st(t, r.schema), { $from: l, $to: c } = r.selection, u = r.selection.node;
  if (u && u.isBlock || l.depth < 2 || !l.sameParent(c))
    return !1;
  const d = l.node(-1);
  if (d.type !== a)
    return !1;
  const f = i.extensionManager.attributes;
  if (l.parent.content.size === 0 && l.node(-1).childCount === l.indexAfter(-1)) {
    if (l.depth === 2 || l.node(-3).type !== a || l.index(-2) !== l.node(-2).childCount - 1)
      return !1;
    if (o) {
      let b = D.empty;
      const v = l.index(-1) ? 1 : l.index(-2) ? 2 : 3;
      for (let C = l.depth - v; C >= l.depth - 3; C -= 1)
        b = D.from(l.node(C).copy(b));
      const k = (
        // eslint-disable-next-line no-nested-ternary
        l.indexAfter(-1) < l.node(-2).childCount ? 1 : l.indexAfter(-2) < l.node(-3).childCount ? 2 : 3
      ), x = {
        ...wa(f, l.node().type.name, l.node().attrs),
        ...e
      }, w = ((s = a.contentMatch.defaultType) == null ? void 0 : s.createAndFill(x)) || void 0;
      b = b.append(D.from(a.createAndFill(null, w) || void 0));
      const E = l.before(l.depth - (v - 1));
      n.replace(E, l.after(-k), new Y(b, 4 - v, 0));
      let S = -1;
      n.doc.nodesBetween(E, n.doc.content.size, (C, M) => {
        if (S > -1)
          return !1;
        C.isTextblock && C.content.size === 0 && (S = M + 1);
      }), S > -1 && n.setSelection(ce.near(n.doc.resolve(S))), n.scrollIntoView();
    }
    return !0;
  }
  const h = c.pos === l.end() ? d.contentMatchAt(0).defaultType : null, m = {
    ...wa(f, d.type.name, d.attrs),
    ...e
  }, p = {
    ...wa(f, l.node().type.name, l.node().attrs),
    ...e
  };
  n.delete(l.pos, c.pos);
  const g = h ? [
    { type: a, attrs: m },
    { type: h, attrs: p }
  ] : [{ type: a, attrs: m }];
  if (!Jn(n.doc, l.pos, 2))
    return !1;
  if (o) {
    const { selection: b, storedMarks: v } = r, { splittableMarks: k } = i.extensionManager, x = v || b.$to.parentOffset && b.$from.marks();
    if (n.split(l.pos, 2, g).scrollIntoView(), !x || !o)
      return !0;
    const w = x.filter((E) => k.includes(E.type.name));
    n.ensureMarks(w);
  }
  return !0;
}, tu = (t, e) => {
  const n = ac((s) => s.type === e)(t.selection);
  if (!n)
    return !0;
  const r = t.doc.resolve(Math.max(0, n.pos - 1)).before(n.depth);
  if (r === void 0)
    return !0;
  const o = t.doc.nodeAt(r);
  return n.node.type === o?.type && Or(t.doc, n.pos) && t.join(n.pos), !0;
}, nu = (t, e) => {
  const n = ac((s) => s.type === e)(t.selection);
  if (!n)
    return !0;
  const r = t.doc.resolve(n.start).after(n.depth);
  if (r === void 0)
    return !0;
  const o = t.doc.nodeAt(r);
  return n.node.type === o?.type && Or(t.doc, r) && t.join(r), !0;
}, jS = (t, e, n, r = {}) => ({ editor: o, tr: i, state: s, dispatch: a, chain: l, commands: c, can: u }) => {
  const { extensions: d, splittableMarks: f } = o.extensionManager, h = st(t, s.schema), m = st(e, s.schema), { selection: p, storedMarks: g } = s, { $from: b, $to: v } = p, k = b.blockRange(v), x = g || p.$to.parentOffset && p.$from.marks();
  if (!k)
    return !1;
  const w = ac((E) => Gm(E.type.name, d))(p);
  if (k.depth >= 1 && w && k.depth - w.depth <= 1) {
    if (w.node.type === h)
      return c.liftListItem(m);
    if (Gm(w.node.type.name, d) && h.validContent(w.node.content) && a)
      return l().command(() => (i.setNodeMarkup(w.pos, h), !0)).command(() => tu(i, h)).command(() => nu(i, h)).run();
  }
  return !n || !x || !a ? l().command(() => u().wrapInList(h, r) ? !0 : c.clearNodes()).wrapInList(h, r).command(() => tu(i, h)).command(() => nu(i, h)).run() : l().command(() => {
    const E = u().wrapInList(h, r), S = x.filter((C) => f.includes(C.type.name));
    return i.ensureMarks(S), E ? !0 : c.clearNodes();
  }).wrapInList(h, r).command(() => tu(i, h)).command(() => nu(i, h)).run();
}, YS = (t, e = {}, n = {}) => ({ state: r, commands: o }) => {
  const { extendEmptyMarkRange: i = !1 } = n, s = er(t, r.schema);
  return ed(r, s, e) ? o.unsetMark(s, { extendEmptyMarkRange: i }) : o.setMark(s, e);
}, XS = (t, e, n = {}) => ({ state: r, commands: o }) => {
  const i = st(t, r.schema), s = st(e, r.schema), a = Mr(r, i, n);
  let l;
  return r.selection.$anchor.sameParent(r.selection.$head) && (l = r.selection.$anchor.parent.attrs), a ? o.setNode(s, l) : o.setNode(i, { ...l, ...n });
}, ZS = (t, e = {}) => ({ state: n, commands: r }) => {
  const o = st(t, n.schema);
  return Mr(n, o, e) ? r.lift(o) : r.wrapIn(o, e);
}, JS = () => ({ state: t, dispatch: e }) => {
  const n = t.plugins;
  for (let r = 0; r < n.length; r += 1) {
    const o = n[r];
    let i;
    if (o.spec.isInputRules && (i = o.getState(t))) {
      if (e) {
        const s = t.tr, a = i.transform;
        for (let l = a.steps.length - 1; l >= 0; l -= 1)
          s.step(a.steps[l].invert(a.docs[l]));
        if (i.text) {
          const l = s.doc.resolve(i.from).marks();
          s.replaceWith(i.from, i.to, t.schema.text(i.text, l));
        } else
          s.delete(i.from, i.to);
      }
      return !0;
    }
  }
  return !1;
}, QS = () => ({ tr: t, dispatch: e }) => {
  const { selection: n } = t, { empty: r, ranges: o } = n;
  return r || e && o.forEach((i) => {
    t.removeMark(i.$from.pos, i.$to.pos);
  }), !0;
}, eT = (t, e = {}) => ({ tr: n, state: r, dispatch: o }) => {
  var i;
  const { extendEmptyMarkRange: s = !1 } = e, { selection: a } = n, l = er(t, r.schema), { $from: c, empty: u, ranges: d } = a;
  if (!o)
    return !0;
  if (u && s) {
    let { from: f, to: h } = a;
    const m = (i = c.marks().find((g) => g.type === l)) == null ? void 0 : i.attrs, p = df(c, l, m);
    p && (f = p.from, h = p.to), n.removeMark(f, h, l);
  } else
    d.forEach((f) => {
      n.removeMark(f.$from.pos, f.$to.pos, l);
    });
  return n.removeStoredMark(l), !0;
}, tT = (t) => ({ tr: e, state: n, dispatch: r }) => {
  const { selection: o } = n;
  let i, s;
  return typeof t == "number" ? (i = t, s = t) : t && "from" in t && "to" in t ? (i = t.from, s = t.to) : (i = o.from, s = o.to), r && e.doc.nodesBetween(i, s, (a, l) => {
    if (a.isText)
      return;
    const c = { ...a.attrs };
    delete c.dir, e.setNodeMarkup(l, void 0, c);
  }), !0;
}, nT = (t, e = {}) => ({ tr: n, state: r, dispatch: o }) => {
  let i = null, s = null;
  const a = sc(
    typeof t == "string" ? t : t.name,
    r.schema
  );
  if (!a)
    return !1;
  a === "node" && (i = st(t, r.schema)), a === "mark" && (s = er(t, r.schema));
  let l = !1;
  return n.selection.ranges.forEach((c) => {
    const u = c.$from.pos, d = c.$to.pos;
    let f, h, m, p;
    n.selection.empty ? r.doc.nodesBetween(u, d, (g, b) => {
      i && i === g.type && (l = !0, m = Math.max(b, u), p = Math.min(b + g.nodeSize, d), f = b, h = g);
    }) : r.doc.nodesBetween(u, d, (g, b) => {
      b < u && i && i === g.type && (l = !0, m = Math.max(b, u), p = Math.min(b + g.nodeSize, d), f = b, h = g), b >= u && b <= d && (i && i === g.type && (l = !0, o && n.setNodeMarkup(b, void 0, {
        ...g.attrs,
        ...e
      })), s && g.marks.length && g.marks.forEach((v) => {
        if (s === v.type && (l = !0, o)) {
          const k = Math.max(b, u), x = Math.min(b + g.nodeSize, d);
          n.addMark(
            k,
            x,
            s.create({
              ...v.attrs,
              ...e
            })
          );
        }
      }));
    }), h && (f !== void 0 && o && n.setNodeMarkup(f, void 0, {
      ...h.attrs,
      ...e
    }), s && h.marks.length && h.marks.forEach((g) => {
      s === g.type && o && n.addMark(
        m,
        p,
        s.create({
          ...g.attrs,
          ...e
        })
      );
    }));
  }), l;
}, rT = (t, e = {}) => ({ state: n, dispatch: r }) => {
  const o = st(t, n.schema);
  return DN(o, e)(n, r);
}, oT = (t, e = {}) => ({ state: n, dispatch: r }) => {
  const o = st(t, n.schema);
  return LN(o, e)(n, r);
}, iT = class {
  constructor() {
    this.callbacks = {};
  }
  on(t, e) {
    return this.callbacks[t] || (this.callbacks[t] = []), this.callbacks[t].push(e), this;
  }
  emit(t, ...e) {
    const n = this.callbacks[t];
    return n && n.forEach((r) => r.apply(this, e)), this;
  }
  off(t, e) {
    const n = this.callbacks[t];
    return n && (e ? this.callbacks[t] = n.filter((r) => r !== e) : delete this.callbacks[t]), this;
  }
  once(t, e) {
    const n = (...r) => {
      this.off(t, n), e.apply(this, r);
    };
    return this.on(t, n);
  }
  removeAllListeners() {
    this.callbacks = {};
  }
}, nn = class {
  constructor(t) {
    var e;
    this.find = t.find, this.handler = t.handler, this.undoable = (e = t.undoable) != null ? e : !0;
  }
}, sT = (t, e) => {
  if (uf(e))
    return e.exec(t);
  const n = e(t);
  if (!n)
    return null;
  const r = [n.text];
  return r.index = n.index, r.input = t, r.data = n.data, n.replaceWith && (n.text.includes(n.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), r.push(n.replaceWith)), r;
};
function Us(t) {
  var e;
  const { editor: n, from: r, to: o, text: i, rules: s, plugin: a } = t, { view: l } = n;
  if (l.composing)
    return !1;
  const c = l.state.doc.resolve(r);
  if (
    // check for code node
    c.parent.type.spec.code || (e = c.nodeBefore || c.nodeAfter) != null && e.marks.find((f) => f.type.spec.code)
  )
    return !1;
  let u = !1;
  const d = OS(c) + i;
  return s.forEach((f) => {
    if (u)
      return;
    const h = sT(d, f.find);
    if (!h)
      return;
    const m = l.state.tr, p = oc({
      state: l.state,
      transaction: m
    }), g = {
      from: r - (h[0].length - i.length),
      to: o
    }, { commands: b, chain: v, can: k } = new ic({
      editor: n,
      state: p
    });
    f.handler({
      state: p,
      range: g,
      match: h,
      commands: b,
      chain: v,
      can: k
    }) === null || !m.steps.length || (f.undoable && m.setMeta(a, {
      transform: m,
      from: r,
      to: o,
      text: i
    }), l.dispatch(m), u = !0);
  }), u;
}
function aT(t) {
  const { editor: e, rules: n } = t, r = new Ce({
    state: {
      init() {
        return null;
      },
      apply(o, i, s) {
        const a = o.getMeta(r);
        if (a)
          return a;
        const l = o.getMeta("applyInputRules");
        return !!l && setTimeout(() => {
          let { text: u } = l;
          typeof u == "string" ? u = u : u = mf(D.from(u), s.schema);
          const { from: d } = l, f = d + u.length;
          Us({
            editor: e,
            from: d,
            to: f,
            text: u,
            rules: n,
            plugin: r
          });
        }), o.selectionSet || o.docChanged ? null : i;
      }
    },
    props: {
      handleTextInput(o, i, s, a) {
        return Us({
          editor: e,
          from: i,
          to: s,
          text: a,
          rules: n,
          plugin: r
        });
      },
      handleDOMEvents: {
        compositionend: (o) => (setTimeout(() => {
          const { $cursor: i } = o.state.selection;
          i && Us({
            editor: e,
            from: i.pos,
            to: i.pos,
            text: "",
            rules: n,
            plugin: r
          });
        }), !1)
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(o, i) {
        if (i.key !== "Enter")
          return !1;
        const { $cursor: s } = o.state.selection;
        return s ? Us({
          editor: e,
          from: s.pos,
          to: s.pos,
          text: `
`,
          rules: n,
          plugin: r
        }) : !1;
      }
    },
    // @ts-ignore
    isInputRules: !0
  });
  return r;
}
function lT(t) {
  return Object.prototype.toString.call(t).slice(8, -1);
}
function Ws(t) {
  return lT(t) !== "Object" ? !1 : t.constructor === Object && Object.getPrototypeOf(t) === Object.prototype;
}
function Qy(t, e) {
  const n = { ...t };
  return Ws(t) && Ws(e) && Object.keys(e).forEach((r) => {
    Ws(e[r]) && Ws(t[r]) ? n[r] = Qy(t[r], e[r]) : n[r] = e[r];
  }), n;
}
var bf = class {
  constructor(t = {}) {
    this.type = "extendable", this.parent = null, this.child = null, this.name = "", this.config = {
      name: this.name
    }, this.config = {
      ...this.config,
      ...t
    }, this.name = this.config.name;
  }
  get options() {
    return {
      ...ze(
        le(this, "addOptions", {
          name: this.name
        })
      ) || {}
    };
  }
  get storage() {
    return {
      ...ze(
        le(this, "addStorage", {
          name: this.name,
          options: this.options
        })
      ) || {}
    };
  }
  configure(t = {}) {
    const e = this.extend({
      ...this.config,
      addOptions: () => Qy(this.options, t)
    });
    return e.name = this.name, e.parent = this.parent, e;
  }
  extend(t = {}) {
    const e = new this.constructor({ ...this.config, ...t });
    return e.parent = this, this.child = e, e.name = "name" in t ? t.name : e.parent.name, e;
  }
}, kn = class e0 extends bf {
  constructor() {
    super(...arguments), this.type = "mark";
  }
  /**
   * Create a new Mark instance
   * @param config - Mark configuration object or a function that returns a configuration object
   */
  static create(e = {}) {
    const n = typeof e == "function" ? e() : e;
    return new e0(n);
  }
  static handleExit({ editor: e, mark: n }) {
    const { tr: r } = e.state, o = e.state.selection.$from;
    if (o.pos === o.end()) {
      const s = o.marks();
      if (!!!s.find((c) => c?.type.name === n.name))
        return !1;
      const l = s.find((c) => c?.type.name === n.name);
      return l && r.removeStoredMark(l), r.insertText(" ", o.pos), e.view.dispatch(r), !0;
    }
    return !1;
  }
  configure(e) {
    return super.configure(e);
  }
  extend(e) {
    const n = typeof e == "function" ? e() : e;
    return super.extend(n);
  }
};
function cT(t) {
  return typeof t == "number";
}
var uT = class {
  constructor(t) {
    this.find = t.find, this.handler = t.handler;
  }
}, dT = (t, e, n) => {
  if (uf(e))
    return [...t.matchAll(e)];
  const r = e(t, n);
  return r ? r.map((o) => {
    const i = [o.text];
    return i.index = o.index, i.input = t, i.data = o.data, o.replaceWith && (o.text.includes(o.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), i.push(o.replaceWith)), i;
  }) : [];
};
function fT(t) {
  const { editor: e, state: n, from: r, to: o, rule: i, pasteEvent: s, dropEvent: a } = t, { commands: l, chain: c, can: u } = new ic({
    editor: e,
    state: n
  }), d = [];
  return n.doc.nodesBetween(r, o, (h, m) => {
    var p, g, b, v, k;
    if ((g = (p = h.type) == null ? void 0 : p.spec) != null && g.code || !(h.isText || h.isTextblock || h.isInline))
      return;
    const x = (k = (v = (b = h.content) == null ? void 0 : b.size) != null ? v : h.nodeSize) != null ? k : 0, w = Math.max(r, m), E = Math.min(o, m + x);
    if (w >= E)
      return;
    const S = h.isText ? h.text || "" : h.textBetween(w - m, E - m, void 0, "￼");
    dT(S, i.find, s).forEach((M) => {
      if (M.index === void 0)
        return;
      const O = w + M.index + 1, q = O + M[0].length, K = {
        from: n.tr.mapping.map(O),
        to: n.tr.mapping.map(q)
      }, j = i.handler({
        state: n,
        range: K,
        match: M,
        commands: l,
        chain: c,
        can: u,
        pasteEvent: s,
        dropEvent: a
      });
      d.push(j);
    });
  }), d.every((h) => h !== null);
}
var Vs = null, hT = (t) => {
  var e;
  const n = new ClipboardEvent("paste", {
    clipboardData: new DataTransfer()
  });
  return (e = n.clipboardData) == null || e.setData("text/html", t), n;
};
function mT(t) {
  const { editor: e, rules: n } = t;
  let r = null, o = !1, i = !1, s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, a;
  try {
    a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
  } catch {
    a = null;
  }
  const l = ({
    state: u,
    from: d,
    to: f,
    rule: h,
    pasteEvt: m
  }) => {
    const p = u.tr, g = oc({
      state: u,
      transaction: p
    });
    if (!(!fT({
      editor: e,
      state: g,
      from: Math.max(d - 1, 0),
      to: f.b - 1,
      rule: h,
      pasteEvent: m,
      dropEvent: a
    }) || !p.steps.length)) {
      try {
        a = typeof DragEvent < "u" ? new DragEvent("drop") : null;
      } catch {
        a = null;
      }
      return s = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, p;
    }
  };
  return n.map((u) => new Ce({
    // we register a global drag handler to track the current drag source element
    view(d) {
      const f = (m) => {
        var p;
        r = (p = d.dom.parentElement) != null && p.contains(m.target) ? d.dom.parentElement : null, r && (Vs = e);
      }, h = () => {
        Vs && (Vs = null);
      };
      return window.addEventListener("dragstart", f), window.addEventListener("dragend", h), {
        destroy() {
          window.removeEventListener("dragstart", f), window.removeEventListener("dragend", h);
        }
      };
    },
    props: {
      handleDOMEvents: {
        drop: (d, f) => {
          if (i = r === d.dom.parentElement, a = f, !i) {
            const h = Vs;
            h?.isEditable && setTimeout(() => {
              const m = h.state.selection;
              m && h.commands.deleteRange({ from: m.from, to: m.to });
            }, 10);
          }
          return !1;
        },
        paste: (d, f) => {
          var h;
          const m = (h = f.clipboardData) == null ? void 0 : h.getData("text/html");
          return s = f, o = !!m?.includes("data-pm-slice"), !1;
        }
      }
    },
    appendTransaction: (d, f, h) => {
      const m = d[0], p = m.getMeta("uiEvent") === "paste" && !o, g = m.getMeta("uiEvent") === "drop" && !i, b = m.getMeta("applyPasteRules"), v = !!b;
      if (!p && !g && !v)
        return;
      if (v) {
        let { text: w } = b;
        typeof w == "string" ? w = w : w = mf(D.from(w), h.schema);
        const { from: E } = b, S = E + w.length, C = hT(w);
        return l({
          rule: u,
          state: h,
          from: E,
          to: { b: S },
          pasteEvt: C
        });
      }
      const k = f.doc.content.findDiffStart(h.doc.content), x = f.doc.content.findDiffEnd(h.doc.content);
      if (!(!cT(k) || !x || k === x.b))
        return l({
          rule: u,
          state: h,
          from: k,
          to: x,
          pasteEvt: s
        });
    }
  }));
}
var cc = class {
  constructor(t, e) {
    this.splittableMarks = [], this.editor = e, this.baseExtensions = t, this.extensions = Vy(t), this.schema = TS(this.extensions, e), this.setupExtensions();
  }
  /**
   * Get all commands from the extensions.
   * @returns An object with all commands where the key is the command name and the value is the command function
   */
  get commands() {
    return this.extensions.reduce((t, e) => {
      const n = {
        name: e.name,
        options: e.options,
        storage: this.editor.extensionStorage[e.name],
        editor: this.editor,
        type: Fs(e.name, this.schema)
      }, r = le(e, "addCommands", n);
      return r ? {
        ...t,
        ...r()
      } : t;
    }, {});
  }
  /**
   * Get all registered Prosemirror plugins from the extensions.
   * @returns An array of Prosemirror plugins
   */
  get plugins() {
    const { editor: t } = this;
    return Ua([...this.extensions].reverse()).flatMap((r) => {
      const o = {
        name: r.name,
        options: r.options,
        storage: this.editor.extensionStorage[r.name],
        editor: t,
        type: Fs(r.name, this.schema)
      }, i = [], s = le(
        r,
        "addKeyboardShortcuts",
        o
      );
      let a = {};
      if (r.type === "mark" && le(r, "exitable", o) && (a.ArrowRight = () => kn.handleExit({ editor: t, mark: r })), s) {
        const f = Object.fromEntries(
          Object.entries(s()).map(([h, m]) => [h, () => m({ editor: t })])
        );
        a = { ...a, ...f };
      }
      const l = Iy(a);
      i.push(l);
      const c = le(r, "addInputRules", o);
      if (qm(r, t.options.enableInputRules) && c) {
        const f = c();
        if (f && f.length) {
          const h = aT({
            editor: t,
            rules: f
          }), m = Array.isArray(h) ? h : [h];
          i.push(...m);
        }
      }
      const u = le(r, "addPasteRules", o);
      if (qm(r, t.options.enablePasteRules) && u) {
        const f = u();
        if (f && f.length) {
          const h = mT({ editor: t, rules: f });
          i.push(...h);
        }
      }
      const d = le(
        r,
        "addProseMirrorPlugins",
        o
      );
      if (d) {
        const f = d();
        i.push(...f);
      }
      return i;
    });
  }
  /**
   * Get all attributes from the extensions.
   * @returns An array of attributes
   */
  get attributes() {
    return Wy(this.extensions);
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views where the key is the node name and the value is the node view function
   */
  get nodeViews() {
    const { editor: t } = this, { nodeExtensions: e } = Zo(this.extensions);
    return Object.fromEntries(
      e.filter((n) => !!le(n, "addNodeView")).map((n) => {
        const r = this.attributes.filter((l) => l.type === n.name), o = {
          name: n.name,
          options: n.options,
          storage: this.editor.extensionStorage[n.name],
          editor: t,
          type: st(n.name, this.schema)
        }, i = le(n, "addNodeView", o);
        if (!i)
          return [];
        const s = i();
        if (!s)
          return [];
        const a = (l, c, u, d, f) => {
          const h = Jo(l, r);
          return s({
            // pass-through
            node: l,
            view: c,
            getPos: u,
            decorations: d,
            innerDecorations: f,
            // tiptap-specific
            editor: t,
            extension: n,
            HTMLAttributes: h
          });
        };
        return [n.name, a];
      })
    );
  }
  /**
   * Get the composed dispatchTransaction function from all extensions.
   * @param baseDispatch The base dispatch function (e.g. from the editor or user props)
   * @returns A composed dispatch function
   */
  dispatchTransaction(t) {
    const { editor: e } = this;
    return Ua([...this.extensions].reverse()).reduceRight((r, o) => {
      const i = {
        name: o.name,
        options: o.options,
        storage: this.editor.extensionStorage[o.name],
        editor: e,
        type: Fs(o.name, this.schema)
      }, s = le(
        o,
        "dispatchTransaction",
        i
      );
      return s ? (a) => {
        s.call(i, { transaction: a, next: r });
      } : r;
    }, t);
  }
  get markViews() {
    const { editor: t } = this, { markExtensions: e } = Zo(this.extensions);
    return Object.fromEntries(
      e.filter((n) => !!le(n, "addMarkView")).map((n) => {
        const r = this.attributes.filter((a) => a.type === n.name), o = {
          name: n.name,
          options: n.options,
          storage: this.editor.extensionStorage[n.name],
          editor: t,
          type: er(n.name, this.schema)
        }, i = le(n, "addMarkView", o);
        if (!i)
          return [];
        const s = (a, l, c) => {
          const u = Jo(a, r);
          return i()({
            // pass-through
            mark: a,
            view: l,
            inline: c,
            // tiptap-specific
            editor: t,
            extension: n,
            HTMLAttributes: u,
            updateAttributes: (d) => {
              AT(a, t, d);
            }
          });
        };
        return [n.name, s];
      })
    );
  }
  /**
   * Go through all extensions, create extension storages & setup marks
   * & bind editor event listener.
   */
  setupExtensions() {
    const t = this.extensions;
    this.editor.extensionStorage = Object.fromEntries(
      t.map((e) => [e.name, e.storage])
    ), t.forEach((e) => {
      var n;
      const r = {
        name: e.name,
        options: e.options,
        storage: this.editor.extensionStorage[e.name],
        editor: this.editor,
        type: Fs(e.name, this.schema)
      };
      e.type === "mark" && ((n = ze(le(e, "keepOnSplit", r))) == null || n) && this.splittableMarks.push(e.name);
      const o = le(e, "onBeforeCreate", r), i = le(e, "onCreate", r), s = le(e, "onUpdate", r), a = le(
        e,
        "onSelectionUpdate",
        r
      ), l = le(e, "onTransaction", r), c = le(e, "onFocus", r), u = le(e, "onBlur", r), d = le(e, "onDestroy", r);
      o && this.editor.on("beforeCreate", o), i && this.editor.on("create", i), s && this.editor.on("update", s), a && this.editor.on("selectionUpdate", a), l && this.editor.on("transaction", l), c && this.editor.on("focus", c), u && this.editor.on("blur", u), d && this.editor.on("destroy", d);
    });
  }
};
cc.resolve = Vy;
cc.sort = Ua;
cc.flatten = hf;
var pT = {};
cf(pT, {
  ClipboardTextSerializer: () => n0,
  Commands: () => r0,
  Delete: () => o0,
  Drop: () => i0,
  Editable: () => s0,
  FocusEvents: () => l0,
  Keymap: () => c0,
  Paste: () => u0,
  Tabindex: () => d0,
  TextDirection: () => f0,
  focusEventsPluginKey: () => a0
});
var Re = class t0 extends bf {
  constructor() {
    super(...arguments), this.type = "extension";
  }
  /**
   * Create a new Extension instance
   * @param config - Extension configuration object or a function that returns a configuration object
   */
  static create(e = {}) {
    const n = typeof e == "function" ? e() : e;
    return new t0(n);
  }
  configure(e) {
    return super.configure(e);
  }
  extend(e) {
    const n = typeof e == "function" ? e() : e;
    return super.extend(n);
  }
}, n0 = Re.create({
  name: "clipboardTextSerializer",
  addOptions() {
    return {
      blockSeparator: void 0
    };
  },
  addProseMirrorPlugins() {
    return [
      new Ce({
        key: new Ie("clipboardTextSerializer"),
        props: {
          clipboardTextSerializer: () => {
            const { editor: t } = this, { state: e, schema: n } = t, { doc: r, selection: o } = e, { ranges: i } = o, s = Math.min(...i.map((u) => u.$from.pos)), a = Math.max(...i.map((u) => u.$to.pos)), l = pf(n);
            return Ky(r, { from: s, to: a }, {
              ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {},
              textSerializers: l
            });
          }
        }
      })
    ];
  }
}), r0 = Re.create({
  name: "commands",
  addCommands() {
    return {
      ...Dy
    };
  }
}), o0 = Re.create({
  name: "delete",
  onUpdate({ transaction: t, appendedTransactions: e }) {
    var n, r, o;
    const i = () => {
      var s, a, l, c;
      if ((c = (l = (a = (s = this.editor.options.coreExtensionOptions) == null ? void 0 : s.delete) == null ? void 0 : a.filterTransaction) == null ? void 0 : l.call(a, t)) != null ? c : t.getMeta("y-sync$"))
        return;
      const u = Hy(t.before, [t, ...e]);
      jy(u).forEach((h) => {
        u.mapping.mapResult(h.oldRange.from).deletedAfter && u.mapping.mapResult(h.oldRange.to).deletedBefore && u.before.nodesBetween(h.oldRange.from, h.oldRange.to, (m, p) => {
          const g = p + m.nodeSize - 2, b = h.oldRange.from <= p && g <= h.oldRange.to;
          this.editor.emit("delete", {
            type: "node",
            node: m,
            from: p,
            to: g,
            newFrom: u.mapping.map(p),
            newTo: u.mapping.map(g),
            deletedRange: h.oldRange,
            newRange: h.newRange,
            partial: !b,
            editor: this.editor,
            transaction: t,
            combinedTransform: u
          });
        });
      });
      const f = u.mapping;
      u.steps.forEach((h, m) => {
        var p, g;
        if (h instanceof mn) {
          const b = f.slice(m).map(h.from, -1), v = f.slice(m).map(h.to), k = f.invert().map(b, -1), x = f.invert().map(v), w = (p = u.doc.nodeAt(b - 1)) == null ? void 0 : p.marks.some((S) => S.eq(h.mark)), E = (g = u.doc.nodeAt(v)) == null ? void 0 : g.marks.some((S) => S.eq(h.mark));
          this.editor.emit("delete", {
            type: "mark",
            mark: h.mark,
            from: h.from,
            to: h.to,
            deletedRange: {
              from: k,
              to: x
            },
            newRange: {
              from: b,
              to: v
            },
            partial: !!(E || w),
            editor: this.editor,
            transaction: t,
            combinedTransform: u
          });
        }
      });
    };
    (o = (r = (n = this.editor.options.coreExtensionOptions) == null ? void 0 : n.delete) == null ? void 0 : r.async) == null || o ? setTimeout(i, 0) : i();
  }
}), i0 = Re.create({
  name: "drop",
  addProseMirrorPlugins() {
    return [
      new Ce({
        key: new Ie("tiptapDrop"),
        props: {
          handleDrop: (t, e, n, r) => {
            this.editor.emit("drop", {
              editor: this.editor,
              event: e,
              slice: n,
              moved: r
            });
          }
        }
      })
    ];
  }
}), s0 = Re.create({
  name: "editable",
  addProseMirrorPlugins() {
    return [
      new Ce({
        key: new Ie("editable"),
        props: {
          editable: () => this.editor.options.editable
        }
      })
    ];
  }
}), a0 = new Ie("focusEvents"), l0 = Re.create({
  name: "focusEvents",
  addProseMirrorPlugins() {
    const { editor: t } = this;
    return [
      new Ce({
        key: a0,
        props: {
          handleDOMEvents: {
            focus: (e, n) => {
              t.isFocused = !0;
              const r = t.state.tr.setMeta("focus", { event: n }).setMeta("addToHistory", !1);
              return e.dispatch(r), !1;
            },
            blur: (e, n) => {
              t.isFocused = !1;
              const r = t.state.tr.setMeta("blur", { event: n }).setMeta("addToHistory", !1);
              return e.dispatch(r), !1;
            }
          }
        }
      })
    ];
  }
}), c0 = Re.create({
  name: "keymap",
  addKeyboardShortcuts() {
    const t = () => this.editor.commands.first(({ commands: s }) => [
      () => s.undoInputRule(),
      // maybe convert first text block node to default node
      () => s.command(({ tr: a }) => {
        const { selection: l, doc: c } = a, { empty: u, $anchor: d } = l, { pos: f, parent: h } = d, m = d.parent.isTextblock && f > 0 ? a.doc.resolve(f - 1) : d, p = m.parent.type.spec.isolating, g = d.pos - d.parentOffset, b = p && m.parent.childCount === 1 ? g === d.pos : pe.atStart(c).from === f;
        return !u || !h.type.isTextblock || h.textContent.length || !b || b && d.parent.type.name === "paragraph" ? !1 : s.clearNodes();
      }),
      () => s.deleteSelection(),
      () => s.joinBackward(),
      () => s.selectNodeBackward()
    ]), e = () => this.editor.commands.first(({ commands: s }) => [
      () => s.deleteSelection(),
      () => s.deleteCurrentNode(),
      () => s.joinForward(),
      () => s.selectNodeForward()
    ]), r = {
      Enter: () => this.editor.commands.first(({ commands: s }) => [
        () => s.newlineInCode(),
        () => s.createParagraphNear(),
        () => s.liftEmptyBlock(),
        () => s.splitBlock()
      ]),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: t,
      "Mod-Backspace": t,
      "Shift-Backspace": t,
      Delete: e,
      "Mod-Delete": e,
      "Mod-a": () => this.editor.commands.selectAll()
    }, o = {
      ...r
    }, i = {
      ...r,
      "Ctrl-h": t,
      "Alt-Backspace": t,
      "Ctrl-d": e,
      "Ctrl-Alt-Backspace": e,
      "Alt-Delete": e,
      "Alt-d": e,
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd()
    };
    return is() || zy() ? i : o;
  },
  addProseMirrorPlugins() {
    return [
      // With this plugin we check if the whole document was selected and deleted.
      // In this case we will additionally call `clearNodes()` to convert e.g. a heading
      // to a paragraph if necessary.
      // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well
      // with many other commands.
      new Ce({
        key: new Ie("clearDocument"),
        appendTransaction: (t, e, n) => {
          if (t.some((p) => p.getMeta("composition")))
            return;
          const r = t.some((p) => p.docChanged) && !e.doc.eq(n.doc), o = t.some((p) => p.getMeta("preventClearDocument"));
          if (!r || o)
            return;
          const { empty: i, from: s, to: a } = e.selection, l = pe.atStart(e.doc).from, c = pe.atEnd(e.doc).to;
          if (i || !(s === l && a === c) || !lc(n.doc))
            return;
          const f = n.tr, h = oc({
            state: n,
            transaction: f
          }), { commands: m } = new ic({
            editor: this.editor,
            state: h
          });
          if (m.clearNodes(), !!f.steps.length)
            return f;
        }
      })
    ];
  }
}), u0 = Re.create({
  name: "paste",
  addProseMirrorPlugins() {
    return [
      new Ce({
        key: new Ie("tiptapPaste"),
        props: {
          handlePaste: (t, e, n) => {
            this.editor.emit("paste", {
              editor: this.editor,
              event: e,
              slice: n
            });
          }
        }
      })
    ];
  }
}), d0 = Re.create({
  name: "tabindex",
  addProseMirrorPlugins() {
    return [
      new Ce({
        key: new Ie("tabindex"),
        props: {
          attributes: () => this.editor.isEditable ? { tabindex: "0" } : {}
        }
      })
    ];
  }
}), f0 = Re.create({
  name: "textDirection",
  addOptions() {
    return {
      direction: void 0
    };
  },
  addGlobalAttributes() {
    if (!this.options.direction)
      return [];
    const { nodeExtensions: t } = Zo(this.extensions);
    return [
      {
        types: t.filter((e) => e.name !== "text").map((e) => e.name),
        attributes: {
          dir: {
            default: this.options.direction,
            parseHTML: (e) => {
              const n = e.getAttribute("dir");
              return n && (n === "ltr" || n === "rtl" || n === "auto") ? n : this.options.direction;
            },
            renderHTML: (e) => e.dir ? {
              dir: e.dir
            } : {}
          }
        }
      }
    ];
  },
  addProseMirrorPlugins() {
    return [
      new Ce({
        key: new Ie("textDirection"),
        props: {
          attributes: () => {
            const t = this.options.direction;
            return t ? {
              dir: t
            } : {};
          }
        }
      })
    ];
  }
}), gT = class Ai {
  constructor(e, n, r = !1, o = null) {
    this.currentNode = null, this.actualDepth = null, this.isBlock = r, this.resolvedPos = e, this.editor = n, this.currentNode = o;
  }
  get name() {
    return this.node.type.name;
  }
  get node() {
    return this.currentNode || this.resolvedPos.node();
  }
  get element() {
    return this.editor.view.domAtPos(this.pos).node;
  }
  get depth() {
    var e;
    return (e = this.actualDepth) != null ? e : this.resolvedPos.depth;
  }
  get pos() {
    return this.resolvedPos.pos;
  }
  get content() {
    return this.node.content;
  }
  set content(e) {
    let n = this.from, r = this.to;
    if (this.isBlock) {
      if (this.content.size === 0) {
        console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);
        return;
      }
      n = this.from + 1, r = this.to - 1;
    }
    this.editor.commands.insertContentAt({ from: n, to: r }, e);
  }
  get attributes() {
    return this.node.attrs;
  }
  get textContent() {
    return this.node.textContent;
  }
  get size() {
    return this.node.nodeSize;
  }
  get from() {
    return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth);
  }
  get range() {
    return {
      from: this.from,
      to: this.to
    };
  }
  get to() {
    return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);
  }
  get parent() {
    if (this.depth === 0)
      return null;
    const e = this.resolvedPos.start(this.resolvedPos.depth - 1), n = this.resolvedPos.doc.resolve(e);
    return new Ai(n, this.editor);
  }
  get before() {
    let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)), new Ai(e, this.editor);
  }
  get after() {
    let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));
    return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)), new Ai(e, this.editor);
  }
  get children() {
    const e = [];
    return this.node.content.forEach((n, r) => {
      const o = n.isBlock && !n.isTextblock, i = n.isAtom && !n.isText, s = n.isInline, a = this.pos + r + (i ? 0 : 1);
      if (a < 0 || a > this.resolvedPos.doc.nodeSize - 2)
        return;
      const l = this.resolvedPos.doc.resolve(a);
      if (!o && !s && l.depth <= this.depth)
        return;
      const c = new Ai(l, this.editor, o, o || s ? n : null);
      o && (c.actualDepth = this.depth + 1), e.push(c);
    }), e;
  }
  get firstChild() {
    return this.children[0] || null;
  }
  get lastChild() {
    const e = this.children;
    return e[e.length - 1] || null;
  }
  closest(e, n = {}) {
    let r = null, o = this.parent;
    for (; o && !r; ) {
      if (o.node.type.name === e)
        if (Object.keys(n).length > 0) {
          const i = o.node.attrs, s = Object.keys(n);
          for (let a = 0; a < s.length; a += 1) {
            const l = s[a];
            if (i[l] !== n[l])
              break;
          }
        } else
          r = o;
      o = o.parent;
    }
    return r;
  }
  querySelector(e, n = {}) {
    return this.querySelectorAll(e, n, !0)[0] || null;
  }
  querySelectorAll(e, n = {}, r = !1) {
    let o = [];
    if (!this.children || this.children.length === 0)
      return o;
    const i = Object.keys(n);
    return this.children.forEach((s) => {
      r && o.length > 0 || (s.node.type.name === e && i.every((l) => n[l] === s.node.attrs[l]) && o.push(s), !(r && o.length > 0) && (o = o.concat(s.querySelectorAll(e, n, r))));
    }), o;
  }
  setAttribute(e) {
    const { tr: n } = this.editor.state;
    n.setNodeMarkup(this.from, void 0, {
      ...this.node.attrs,
      ...e
    }), this.editor.view.dispatch(n);
  }
}, bT = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}`;
function yT(t, e, n) {
  const r = document.querySelector("style[data-tiptap-style]");
  if (r !== null)
    return r;
  const o = document.createElement("style");
  return e && o.setAttribute("nonce", e), o.setAttribute("data-tiptap-style", ""), o.innerHTML = t, document.getElementsByTagName("head")[0].appendChild(o), o;
}
var vT = class extends iT {
  constructor(t = {}) {
    super(), this.css = null, this.className = "tiptap", this.editorView = null, this.isFocused = !1, this.isInitialized = !1, this.extensionStorage = {}, this.instanceId = Math.random().toString(36).slice(2, 9), this.options = {
      element: typeof document < "u" ? document.createElement("div") : null,
      content: "",
      injectCSS: !0,
      injectNonce: void 0,
      extensions: [],
      autofocus: !1,
      editable: !0,
      textDirection: void 0,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: !0,
      enablePasteRules: !0,
      enableCoreExtensions: !0,
      enableContentCheck: !1,
      emitContentError: !1,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onMount: () => null,
      onUnmount: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error: r }) => {
        throw r;
      },
      onPaste: () => null,
      onDrop: () => null,
      onDelete: () => null,
      enableExtensionDispatchTransaction: !0
    }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.utils = {
      getUpdatedPosition: PS,
      createMappablePosition: BS
    }, this.setOptions(t), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("mount", this.options.onMount), this.on("unmount", this.options.onUnmount), this.on("contentError", this.options.onContentError), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("drop", ({ event: r, slice: o, moved: i }) => this.options.onDrop(r, o, i)), this.on("paste", ({ event: r, slice: o }) => this.options.onPaste(r, o)), this.on("delete", this.options.onDelete);
    const e = this.createDoc(), n = Py(e, this.options.autofocus);
    this.editorState = $o.create({
      doc: e,
      schema: this.schema,
      selection: n || void 0
    }), this.options.element && this.mount(this.options.element);
  }
  /**
   * Attach the editor to the DOM, creating a new editor view.
   */
  mount(t) {
    if (typeof document > "u")
      throw new Error(
        "[tiptap error]: The editor cannot be mounted because there is no 'document' defined in this environment."
      );
    this.createView(t), this.emit("mount", { editor: this }), this.css && !document.head.contains(this.css) && document.head.appendChild(this.css), window.setTimeout(() => {
      this.isDestroyed || (this.options.autofocus !== !1 && this.options.autofocus !== null && this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }), this.isInitialized = !0);
    }, 0);
  }
  /**
   * Remove the editor from the DOM, but still allow remounting at a different point in time
   */
  unmount() {
    if (this.editorView) {
      const t = this.editorView.dom;
      t?.editor && delete t.editor, this.editorView.destroy();
    }
    if (this.editorView = null, this.isInitialized = !1, this.css && !document.querySelectorAll(`.${this.className}`).length)
      try {
        typeof this.css.remove == "function" ? this.css.remove() : this.css.parentNode && this.css.parentNode.removeChild(this.css);
      } catch (t) {
        console.warn("Failed to remove CSS element:", t);
      }
    this.css = null, this.emit("unmount", { editor: this });
  }
  /**
   * Returns the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * An object of all registered commands.
   */
  get commands() {
    return this.commandManager.commands;
  }
  /**
   * Create a command chain to call multiple commands at once.
   */
  chain() {
    return this.commandManager.chain();
  }
  /**
   * Check if a command or a command chain can be executed. Without executing it.
   */
  can() {
    return this.commandManager.can();
  }
  /**
   * Inject CSS styles.
   */
  injectCSS() {
    this.options.injectCSS && typeof document < "u" && (this.css = yT(bT, this.options.injectNonce));
  }
  /**
   * Update editor options.
   *
   * @param options A list of options
   */
  setOptions(t = {}) {
    this.options = {
      ...this.options,
      ...t
    }, !(!this.editorView || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state));
  }
  /**
   * Update editable state of the editor.
   */
  setEditable(t, e = !0) {
    this.setOptions({ editable: t }), e && this.emit("update", { editor: this, transaction: this.state.tr, appendedTransactions: [] });
  }
  /**
   * Returns whether the editor is editable.
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Returns the editor state.
   */
  get view() {
    return this.editorView ? this.editorView : new Proxy(
      {
        state: this.editorState,
        updateState: (t) => {
          this.editorState = t;
        },
        dispatch: (t) => {
          this.dispatchTransaction(t);
        },
        // Stub some commonly accessed properties to prevent errors
        composing: !1,
        dragging: null,
        editable: !0,
        isDestroyed: !1
      },
      {
        get: (t, e) => {
          if (this.editorView)
            return this.editorView[e];
          if (e === "state")
            return this.editorState;
          if (e in t)
            return Reflect.get(t, e);
          throw new Error(
            `[tiptap error]: The editor view is not available. Cannot access view['${e}']. The editor may not be mounted yet.`
          );
        }
      }
    );
  }
  /**
   * Returns the editor state.
   */
  get state() {
    return this.editorView && (this.editorState = this.view.state), this.editorState;
  }
  /**
   * Register a ProseMirror plugin.
   *
   * @param plugin A ProseMirror plugin
   * @param handlePlugins Control how to merge the plugin into the existing plugins.
   * @returns The new editor state
   */
  registerPlugin(t, e) {
    const n = Uy(e) ? e(t, [...this.state.plugins]) : [...this.state.plugins, t], r = this.state.reconfigure({ plugins: n });
    return this.view.updateState(r), r;
  }
  /**
   * Unregister a ProseMirror plugin.
   *
   * @param nameOrPluginKeyToRemove The plugins name
   * @returns The new editor state or undefined if the editor is destroyed
   */
  unregisterPlugin(t) {
    if (this.isDestroyed)
      return;
    const e = this.state.plugins;
    let n = e;
    if ([].concat(t).forEach((o) => {
      const i = typeof o == "string" ? `${o}$` : o.key;
      n = n.filter((s) => !s.key.startsWith(i));
    }), e.length === n.length)
      return;
    const r = this.state.reconfigure({
      plugins: n
    });
    return this.view.updateState(r), r;
  }
  /**
   * Creates an extension manager.
   */
  createExtensionManager() {
    var t, e;
    const r = [...this.options.enableCoreExtensions ? [
      s0,
      n0.configure({
        blockSeparator: (e = (t = this.options.coreExtensionOptions) == null ? void 0 : t.clipboardTextSerializer) == null ? void 0 : e.blockSeparator
      }),
      r0,
      l0,
      c0,
      d0,
      i0,
      u0,
      o0,
      f0.configure({
        direction: this.options.textDirection
      })
    ].filter((o) => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[o.name] !== !1 : !0) : [], ...this.options.extensions].filter((o) => ["extension", "node", "mark"].includes(o?.type));
    this.extensionManager = new cc(r, this);
  }
  /**
   * Creates an command manager.
   */
  createCommandManager() {
    this.commandManager = new ic({
      editor: this
    });
  }
  /**
   * Creates a ProseMirror schema.
   */
  createSchema() {
    this.schema = this.extensionManager.schema;
  }
  /**
   * Creates the initial document.
   */
  createDoc() {
    let t;
    try {
      t = Ju(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: this.options.enableContentCheck
      });
    } catch (e) {
      if (!(e instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(e.message))
        throw e;
      this.emit("contentError", {
        editor: this,
        error: e,
        disableCollaboration: () => {
          "collaboration" in this.storage && typeof this.storage.collaboration == "object" && this.storage.collaboration && (this.storage.collaboration.isDisabled = !0), this.options.extensions = this.options.extensions.filter((n) => n.name !== "collaboration"), this.createExtensionManager();
        }
      }), t = Ju(this.options.content, this.schema, this.options.parseOptions, {
        errorOnInvalidContent: !1
      });
    }
    return t;
  }
  /**
   * Creates a ProseMirror view.
   */
  createView(t) {
    const { editorProps: e, enableExtensionDispatchTransaction: n } = this.options, r = e.dispatchTransaction || this.dispatchTransaction.bind(this), o = n ? this.extensionManager.dispatchTransaction(r) : r;
    this.editorView = new Oy(t, {
      ...e,
      attributes: {
        // add `role="textbox"` to the editor element
        role: "textbox",
        ...e?.attributes
      },
      dispatchTransaction: o,
      state: this.editorState,
      markViews: this.extensionManager.markViews,
      nodeViews: this.extensionManager.nodeViews
    });
    const i = this.state.reconfigure({
      plugins: this.extensionManager.plugins
    });
    this.view.updateState(i), this.prependClass(), this.injectCSS();
    const s = this.view.dom;
    s.editor = this;
  }
  /**
   * Creates all node and mark views.
   */
  createNodeViews() {
    this.view.isDestroyed || this.view.setProps({
      markViews: this.extensionManager.markViews,
      nodeViews: this.extensionManager.nodeViews
    });
  }
  /**
   * Prepend class name to element.
   */
  prependClass() {
    this.view.dom.className = `${this.className} ${this.view.dom.className}`;
  }
  captureTransaction(t) {
    this.isCapturingTransaction = !0, t(), this.isCapturingTransaction = !1;
    const e = this.capturedTransaction;
    return this.capturedTransaction = null, e;
  }
  /**
   * The callback over which to send transactions (state updates) produced by the view.
   *
   * @param transaction An editor state transaction
   */
  dispatchTransaction(t) {
    if (this.view.isDestroyed)
      return;
    if (this.isCapturingTransaction) {
      if (!this.capturedTransaction) {
        this.capturedTransaction = t;
        return;
      }
      t.steps.forEach((c) => {
        var u;
        return (u = this.capturedTransaction) == null ? void 0 : u.step(c);
      });
      return;
    }
    const { state: e, transactions: n } = this.state.applyTransaction(t), r = !this.state.selection.eq(e.selection), o = n.includes(t), i = this.state;
    if (this.emit("beforeTransaction", {
      editor: this,
      transaction: t,
      nextState: e
    }), !o)
      return;
    this.view.updateState(e), this.emit("transaction", {
      editor: this,
      transaction: t,
      appendedTransactions: n.slice(1)
    }), r && this.emit("selectionUpdate", {
      editor: this,
      transaction: t
    });
    const s = n.findLast((c) => c.getMeta("focus") || c.getMeta("blur")), a = s?.getMeta("focus"), l = s?.getMeta("blur");
    a && this.emit("focus", {
      editor: this,
      event: a.event,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      transaction: s
    }), l && this.emit("blur", {
      editor: this,
      event: l.event,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      transaction: s
    }), !(t.getMeta("preventUpdate") || !n.some((c) => c.docChanged) || i.doc.eq(e.doc)) && this.emit("update", {
      editor: this,
      transaction: t,
      appendedTransactions: n.slice(1)
    });
  }
  /**
   * Get attributes of the currently selected node or mark.
   */
  getAttributes(t) {
    return Gy(this.state, t);
  }
  isActive(t, e) {
    const n = typeof t == "string" ? t : null, r = typeof t == "string" ? e : t;
    return IS(this.state, n, r);
  }
  /**
   * Get the document as JSON.
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the document as HTML.
   */
  getHTML() {
    return mf(this.state.doc.content, this.schema);
  }
  /**
   * Get the document as text.
   */
  getText(t) {
    const { blockSeparator: e = `

`, textSerializers: n = {} } = t || {};
    return qy(this.state.doc, {
      blockSeparator: e,
      textSerializers: {
        ...pf(this.schema),
        ...n
      }
    });
  }
  /**
   * Check if there is no content.
   */
  get isEmpty() {
    return lc(this.state.doc);
  }
  /**
   * Destroy the editor.
   */
  destroy() {
    this.emit("destroy"), this.unmount(), this.removeAllListeners();
  }
  /**
   * Check if the editor is already destroyed.
   */
  get isDestroyed() {
    var t, e;
    return (e = (t = this.editorView) == null ? void 0 : t.isDestroyed) != null ? e : !0;
  }
  $node(t, e) {
    var n;
    return ((n = this.$doc) == null ? void 0 : n.querySelector(t, e)) || null;
  }
  $nodes(t, e) {
    var n;
    return ((n = this.$doc) == null ? void 0 : n.querySelectorAll(t, e)) || null;
  }
  $pos(t) {
    const e = this.state.doc.resolve(t);
    return new gT(e, this);
  }
  get $doc() {
    return this.$pos(0);
  }
};
function to(t) {
  return new nn({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const o = ze(t.getAttributes, void 0, r);
      if (o === !1 || o === null)
        return null;
      const { tr: i } = e, s = r[r.length - 1], a = r[0];
      if (s) {
        const l = a.search(/\S/), c = n.from + a.indexOf(s), u = c + s.length;
        if (gf(n.from, n.to, e.doc).filter((h) => h.mark.type.excluded.find((p) => p === t.type && p !== h.mark.type)).filter((h) => h.to > c).length)
          return null;
        u < n.to && i.delete(u, n.to), c > n.from && i.delete(n.from + l, c);
        const f = n.from + l + s.length;
        i.addMark(n.from + l, f, t.type.create(o || {})), i.removeStoredMark(t.type);
      }
    },
    undoable: t.undoable
  });
}
function h0(t) {
  return new nn({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const o = ze(t.getAttributes, void 0, r) || {}, { tr: i } = e, s = n.from;
      let a = n.to;
      const l = t.type.create(o);
      if (r[1]) {
        const c = r[0].lastIndexOf(r[1]);
        let u = s + c;
        u > a ? u = a : a = u + r[1].length;
        const d = r[0][r[0].length - 1];
        i.insertText(d, s + r[0].length - 1), i.replaceWith(u, a, l);
      } else if (r[0]) {
        const c = t.type.isInline ? s : s - 1;
        i.insert(c, t.type.create(o)).delete(i.mapping.map(s), i.mapping.map(a));
      }
      i.scrollIntoView();
    },
    undoable: t.undoable
  });
}
function td(t) {
  return new nn({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      const o = e.doc.resolve(n.from), i = ze(t.getAttributes, void 0, r) || {};
      if (!o.node(-1).canReplaceWith(o.index(-1), o.indexAfter(-1), t.type))
        return null;
      e.tr.delete(n.from, n.to).setBlockType(n.from, n.from, t.type, i);
    },
    undoable: t.undoable
  });
}
function nt(t) {
  return new nn({
    find: t.find,
    handler: ({ state: e, range: n, match: r }) => {
      let o = t.replace, i = n.from;
      const s = n.to;
      if (r[1]) {
        const a = r[0].lastIndexOf(r[1]);
        o += r[0].slice(a + r[1].length), i += a;
        const l = i - s;
        l > 0 && (o = r[0].slice(a - l, a) + o, i = s);
      }
      e.tr.insertText(o, i, s);
    },
    undoable: t.undoable
  });
}
function Qo(t) {
  return new nn({
    find: t.find,
    handler: ({ state: e, range: n, match: r, chain: o }) => {
      const i = ze(t.getAttributes, void 0, r) || {}, s = e.tr.delete(n.from, n.to), l = s.doc.resolve(n.from).blockRange(), c = l && Vd(l, t.type, i);
      if (!c)
        return null;
      if (s.wrap(l, c), t.keepMarks && t.editor) {
        const { selection: d, storedMarks: f } = e, { splittableMarks: h } = t.editor.extensionManager, m = f || d.$to.parentOffset && d.$from.marks();
        if (m) {
          const p = m.filter((g) => h.includes(g.type.name));
          s.ensureMarks(p);
        }
      }
      if (t.keepAttributes) {
        const d = t.type.name === "bulletList" || t.type.name === "orderedList" ? "listItem" : "taskList";
        o().updateAttributes(d, i).run();
      }
      const u = s.doc.resolve(n.from - 1).nodeBefore;
      u && u.type === t.type && Or(s.doc, n.from - 1) && (!t.joinPredicate || t.joinPredicate(r, u)) && s.join(n.from - 1);
    },
    undoable: t.undoable
  });
}
var wT = (t) => "touches" in t, kT = class {
  /**
   * Creates a new ResizableNodeView instance.
   *
   * The constructor sets up the resize handles, applies initial sizing from
   * node attributes, and configures all resize behavior options.
   *
   * @param options - Configuration options for the resizable node view
   */
  constructor(t) {
    this.directions = ["bottom-left", "bottom-right", "top-left", "top-right"], this.minSize = {
      height: 8,
      width: 8
    }, this.preserveAspectRatio = !1, this.classNames = {
      container: "",
      wrapper: "",
      handle: "",
      resizing: ""
    }, this.initialWidth = 0, this.initialHeight = 0, this.aspectRatio = 1, this.isResizing = !1, this.activeHandle = null, this.startX = 0, this.startY = 0, this.startWidth = 0, this.startHeight = 0, this.isShiftKeyPressed = !1, this.lastEditableState = void 0, this.handleMap = /* @__PURE__ */ new Map(), this.handleMouseMove = (a) => {
      if (!this.isResizing || !this.activeHandle)
        return;
      const l = a.clientX - this.startX, c = a.clientY - this.startY;
      this.handleResize(l, c);
    }, this.handleTouchMove = (a) => {
      if (!this.isResizing || !this.activeHandle)
        return;
      const l = a.touches[0];
      if (!l)
        return;
      const c = l.clientX - this.startX, u = l.clientY - this.startY;
      this.handleResize(c, u);
    }, this.handleMouseUp = () => {
      if (!this.isResizing)
        return;
      const a = this.element.offsetWidth, l = this.element.offsetHeight;
      this.onCommit(a, l), this.isResizing = !1, this.activeHandle = null, this.container.dataset.resizeState = "false", this.classNames.resizing && this.container.classList.remove(this.classNames.resizing), document.removeEventListener("mousemove", this.handleMouseMove), document.removeEventListener("mouseup", this.handleMouseUp), document.removeEventListener("keydown", this.handleKeyDown), document.removeEventListener("keyup", this.handleKeyUp);
    }, this.handleKeyDown = (a) => {
      a.key === "Shift" && (this.isShiftKeyPressed = !0);
    }, this.handleKeyUp = (a) => {
      a.key === "Shift" && (this.isShiftKeyPressed = !1);
    };
    var e, n, r, o, i, s;
    this.node = t.node, this.editor = t.editor, this.element = t.element, this.contentElement = t.contentElement, this.getPos = t.getPos, this.onResize = t.onResize, this.onCommit = t.onCommit, this.onUpdate = t.onUpdate, (e = t.options) != null && e.min && (this.minSize = {
      ...this.minSize,
      ...t.options.min
    }), (n = t.options) != null && n.max && (this.maxSize = t.options.max), (r = t?.options) != null && r.directions && (this.directions = t.options.directions), (o = t.options) != null && o.preserveAspectRatio && (this.preserveAspectRatio = t.options.preserveAspectRatio), (i = t.options) != null && i.className && (this.classNames = {
      container: t.options.className.container || "",
      wrapper: t.options.className.wrapper || "",
      handle: t.options.className.handle || "",
      resizing: t.options.className.resizing || ""
    }), (s = t.options) != null && s.createCustomHandle && (this.createCustomHandle = t.options.createCustomHandle), this.wrapper = this.createWrapper(), this.container = this.createContainer(), this.applyInitialSize(), this.attachHandles(), this.editor.on("update", this.handleEditorUpdate.bind(this));
  }
  /**
   * Returns the top-level DOM node that should be placed in the editor.
   *
   * This is required by the ProseMirror NodeView interface. The container
   * includes the wrapper, handles, and the actual content element.
   *
   * @returns The container element to be inserted into the editor
   */
  get dom() {
    return this.container;
  }
  get contentDOM() {
    var t;
    return (t = this.contentElement) != null ? t : null;
  }
  handleEditorUpdate() {
    const t = this.editor.isEditable;
    t !== this.lastEditableState && (this.lastEditableState = t, t ? t && this.handleMap.size === 0 && this.attachHandles() : this.removeHandles());
  }
  /**
   * Called when the node's content or attributes change.
   *
   * Updates the internal node reference. If a custom `onUpdate` callback
   * was provided, it will be called to handle additional update logic.
   *
   * @param node - The new/updated node
   * @param decorations - Node decorations
   * @param innerDecorations - Inner decorations
   * @returns `false` if the node type has changed (requires full rebuild), otherwise the result of `onUpdate` or `true`
   */
  update(t, e, n) {
    return t.type !== this.node.type ? !1 : (this.node = t, this.onUpdate ? this.onUpdate(t, e, n) : !0);
  }
  /**
   * Cleanup method called when the node view is being removed.
   *
   * Removes all event listeners to prevent memory leaks. This is required
   * by the ProseMirror NodeView interface. If a resize is active when
   * destroy is called, it will be properly cancelled.
   */
  destroy() {
    this.isResizing && (this.container.dataset.resizeState = "false", this.classNames.resizing && this.container.classList.remove(this.classNames.resizing), document.removeEventListener("mousemove", this.handleMouseMove), document.removeEventListener("mouseup", this.handleMouseUp), document.removeEventListener("keydown", this.handleKeyDown), document.removeEventListener("keyup", this.handleKeyUp), this.isResizing = !1, this.activeHandle = null), this.editor.off("update", this.handleEditorUpdate.bind(this)), this.container.remove();
  }
  /**
   * Creates the outer container element.
   *
   * The container is the top-level element returned by the NodeView and
   * wraps the entire resizable node. It's set up with flexbox to handle
   * alignment and includes data attributes for styling and identification.
   *
   * @returns The container element
   */
  createContainer() {
    const t = document.createElement("div");
    return t.dataset.resizeContainer = "", t.dataset.node = this.node.type.name, t.style.display = "flex", this.classNames.container && (t.className = this.classNames.container), t.appendChild(this.wrapper), t;
  }
  /**
   * Creates the wrapper element that contains the content and handles.
   *
   * The wrapper uses relative positioning so that resize handles can be
   * positioned absolutely within it. This is the direct parent of the
   * content element being made resizable.
   *
   * @returns The wrapper element
   */
  createWrapper() {
    const t = document.createElement("div");
    return t.style.position = "relative", t.style.display = "block", t.dataset.resizeWrapper = "", this.classNames.wrapper && (t.className = this.classNames.wrapper), t.appendChild(this.element), t;
  }
  /**
   * Creates a resize handle element for a specific direction.
   *
   * Each handle is absolutely positioned and includes a data attribute
   * identifying its direction for styling purposes.
   *
   * @param direction - The resize direction for this handle
   * @returns The handle element
   */
  createHandle(t) {
    const e = document.createElement("div");
    return e.dataset.resizeHandle = t, e.style.position = "absolute", this.classNames.handle && (e.className = this.classNames.handle), e;
  }
  /**
   * Positions a handle element according to its direction.
   *
   * Corner handles (e.g., 'top-left') are positioned at the intersection
   * of two edges. Edge handles (e.g., 'top') span the full width or height.
   *
   * @param handle - The handle element to position
   * @param direction - The direction determining the position
   */
  positionHandle(t, e) {
    const n = e.includes("top"), r = e.includes("bottom"), o = e.includes("left"), i = e.includes("right");
    n && (t.style.top = "0"), r && (t.style.bottom = "0"), o && (t.style.left = "0"), i && (t.style.right = "0"), (e === "top" || e === "bottom") && (t.style.left = "0", t.style.right = "0"), (e === "left" || e === "right") && (t.style.top = "0", t.style.bottom = "0");
  }
  /**
   * Creates and attaches all resize handles to the wrapper.
   *
   * Iterates through the configured directions, creates a handle for each,
   * positions it, attaches the mousedown listener, and appends it to the DOM.
   */
  attachHandles() {
    this.directions.forEach((t) => {
      let e;
      this.createCustomHandle ? e = this.createCustomHandle(t) : e = this.createHandle(t), e instanceof HTMLElement || (console.warn(
        `[ResizableNodeView] createCustomHandle("${t}") did not return an HTMLElement. Falling back to default handle.`
      ), e = this.createHandle(t)), this.createCustomHandle || this.positionHandle(e, t), e.addEventListener("mousedown", (n) => this.handleResizeStart(n, t)), e.addEventListener("touchstart", (n) => this.handleResizeStart(n, t)), this.handleMap.set(t, e), this.wrapper.appendChild(e);
    });
  }
  /**
   * Removes all resize handles from the wrapper.
   *
   * Cleans up the handle map and removes each handle element from the DOM.
   */
  removeHandles() {
    this.handleMap.forEach((t) => t.remove()), this.handleMap.clear();
  }
  /**
   * Applies initial sizing from node attributes to the element.
   *
   * If width/height attributes exist on the node, they're applied to the element.
   * Otherwise, the element's natural/current dimensions are measured. The aspect
   * ratio is calculated for later use in aspect-ratio-preserving resizes.
   */
  applyInitialSize() {
    const t = this.node.attrs.width, e = this.node.attrs.height;
    t ? (this.element.style.width = `${t}px`, this.initialWidth = t) : this.initialWidth = this.element.offsetWidth, e ? (this.element.style.height = `${e}px`, this.initialHeight = e) : this.initialHeight = this.element.offsetHeight, this.initialWidth > 0 && this.initialHeight > 0 && (this.aspectRatio = this.initialWidth / this.initialHeight);
  }
  /**
   * Initiates a resize operation when a handle is clicked.
   *
   * Captures the starting mouse position and element dimensions, sets up
   * the resize state, adds the resizing class and state attribute, and
   * attaches document-level listeners for mouse movement and keyboard input.
   *
   * @param event - The mouse down event
   * @param direction - The direction of the handle being dragged
   */
  handleResizeStart(t, e) {
    t.preventDefault(), t.stopPropagation(), this.isResizing = !0, this.activeHandle = e, wT(t) ? (this.startX = t.touches[0].clientX, this.startY = t.touches[0].clientY) : (this.startX = t.clientX, this.startY = t.clientY), this.startWidth = this.element.offsetWidth, this.startHeight = this.element.offsetHeight, this.startWidth > 0 && this.startHeight > 0 && (this.aspectRatio = this.startWidth / this.startHeight), this.getPos(), this.container.dataset.resizeState = "true", this.classNames.resizing && this.container.classList.add(this.classNames.resizing), document.addEventListener("mousemove", this.handleMouseMove), document.addEventListener("touchmove", this.handleTouchMove), document.addEventListener("mouseup", this.handleMouseUp), document.addEventListener("keydown", this.handleKeyDown), document.addEventListener("keyup", this.handleKeyUp);
  }
  handleResize(t, e) {
    if (!this.activeHandle)
      return;
    const n = this.preserveAspectRatio || this.isShiftKeyPressed, { width: r, height: o } = this.calculateNewDimensions(this.activeHandle, t, e), i = this.applyConstraints(r, o, n);
    this.element.style.width = `${i.width}px`, this.element.style.height = `${i.height}px`, this.onResize && this.onResize(i.width, i.height);
  }
  /**
   * Calculates new dimensions based on mouse delta and resize direction.
   *
   * Takes the starting dimensions and applies the mouse movement delta
   * according to the handle direction. For corner handles, both dimensions
   * are affected. For edge handles, only one dimension changes. If aspect
   * ratio should be preserved, delegates to applyAspectRatio.
   *
   * @param direction - The active resize handle direction
   * @param deltaX - Horizontal mouse movement since resize start
   * @param deltaY - Vertical mouse movement since resize start
   * @returns The calculated width and height
   */
  calculateNewDimensions(t, e, n) {
    let r = this.startWidth, o = this.startHeight;
    const i = t.includes("right"), s = t.includes("left"), a = t.includes("bottom"), l = t.includes("top");
    return i ? r = this.startWidth + e : s && (r = this.startWidth - e), a ? o = this.startHeight + n : l && (o = this.startHeight - n), (t === "right" || t === "left") && (r = this.startWidth + (i ? e : -e)), (t === "top" || t === "bottom") && (o = this.startHeight + (a ? n : -n)), this.preserveAspectRatio || this.isShiftKeyPressed ? this.applyAspectRatio(r, o, t) : { width: r, height: o };
  }
  /**
   * Applies min/max constraints to dimensions.
   *
   * When aspect ratio is NOT preserved, constraints are applied independently
   * to width and height. When aspect ratio IS preserved, constraints are
   * applied while maintaining the aspect ratio—if one dimension hits a limit,
   * the other is recalculated proportionally.
   *
   * This ensures that aspect ratio is never broken when constrained.
   *
   * @param width - The unconstrained width
   * @param height - The unconstrained height
   * @param preserveAspectRatio - Whether to maintain aspect ratio while constraining
   * @returns The constrained dimensions
   */
  applyConstraints(t, e, n) {
    var r, o, i, s;
    if (!n) {
      let c = Math.max(this.minSize.width, t), u = Math.max(this.minSize.height, e);
      return (r = this.maxSize) != null && r.width && (c = Math.min(this.maxSize.width, c)), (o = this.maxSize) != null && o.height && (u = Math.min(this.maxSize.height, u)), { width: c, height: u };
    }
    let a = t, l = e;
    return a < this.minSize.width && (a = this.minSize.width, l = a / this.aspectRatio), l < this.minSize.height && (l = this.minSize.height, a = l * this.aspectRatio), (i = this.maxSize) != null && i.width && a > this.maxSize.width && (a = this.maxSize.width, l = a / this.aspectRatio), (s = this.maxSize) != null && s.height && l > this.maxSize.height && (l = this.maxSize.height, a = l * this.aspectRatio), { width: a, height: l };
  }
  /**
   * Adjusts dimensions to maintain the original aspect ratio.
   *
   * For horizontal handles (left/right), uses width as the primary dimension
   * and calculates height from it. For vertical handles (top/bottom), uses
   * height as primary and calculates width. For corner handles, uses width
   * as the primary dimension.
   *
   * @param width - The new width
   * @param height - The new height
   * @param direction - The active resize direction
   * @returns Dimensions adjusted to preserve aspect ratio
   */
  applyAspectRatio(t, e, n) {
    const r = n === "left" || n === "right", o = n === "top" || n === "bottom";
    return r ? {
      width: t,
      height: t / this.aspectRatio
    } : o ? {
      width: e * this.aspectRatio,
      height: e
    } : {
      width: t,
      height: t / this.aspectRatio
    };
  }
};
function xT(t, e) {
  const { selection: n } = t, { $from: r } = n;
  if (n instanceof se) {
    const i = r.index();
    return r.parent.canReplaceWith(i, i + 1, e);
  }
  let o = r.depth;
  for (; o >= 0; ) {
    const i = r.index(o);
    if (r.node(o).contentMatchAt(i).matchType(e))
      return !0;
    o -= 1;
  }
  return !1;
}
var NT = {};
cf(NT, {
  createAtomBlockMarkdownSpec: () => ET,
  createBlockMarkdownSpec: () => ST,
  createInlineMarkdownSpec: () => MT,
  parseAttributes: () => yf,
  parseIndentedBlocks: () => nd,
  renderNestedMarkdownContent: () => wf,
  serializeAttributes: () => vf
});
function yf(t) {
  if (!t?.trim())
    return {};
  const e = {}, n = [], r = t.replace(/["']([^"']*)["']/g, (c) => (n.push(c), `__QUOTED_${n.length - 1}__`)), o = r.match(/(?:^|\s)\.([a-zA-Z][\w-]*)/g);
  if (o) {
    const c = o.map((u) => u.trim().slice(1));
    e.class = c.join(" ");
  }
  const i = r.match(/(?:^|\s)#([a-zA-Z][\w-]*)/);
  i && (e.id = i[1]);
  const s = /([a-zA-Z][\w-]*)\s*=\s*(__QUOTED_\d+__)/g;
  Array.from(r.matchAll(s)).forEach(([, c, u]) => {
    var d;
    const f = parseInt(((d = u.match(/__QUOTED_(\d+)__/)) == null ? void 0 : d[1]) || "0", 10), h = n[f];
    h && (e[c] = h.slice(1, -1));
  });
  const l = r.replace(/(?:^|\s)\.([a-zA-Z][\w-]*)/g, "").replace(/(?:^|\s)#([a-zA-Z][\w-]*)/g, "").replace(/([a-zA-Z][\w-]*)\s*=\s*__QUOTED_\d+__/g, "").trim();
  return l && l.split(/\s+/).filter(Boolean).forEach((u) => {
    u.match(/^[a-zA-Z][\w-]*$/) && (e[u] = !0);
  }), e;
}
function vf(t) {
  if (!t || Object.keys(t).length === 0)
    return "";
  const e = [];
  return t.class && String(t.class).split(/\s+/).filter(Boolean).forEach((r) => e.push(`.${r}`)), t.id && e.push(`#${t.id}`), Object.entries(t).forEach(([n, r]) => {
    n === "class" || n === "id" || (r === !0 ? e.push(n) : r !== !1 && r != null && e.push(`${n}="${String(r)}"`));
  }), e.join(" ");
}
function ET(t) {
  const {
    nodeName: e,
    name: n,
    parseAttributes: r = yf,
    serializeAttributes: o = vf,
    defaultAttributes: i = {},
    requiredAttributes: s = [],
    allowedAttributes: a
  } = t, l = n || e, c = (u) => {
    if (!a)
      return u;
    const d = {};
    return a.forEach((f) => {
      f in u && (d[f] = u[f]);
    }), d;
  };
  return {
    parseMarkdown: (u, d) => {
      const f = { ...i, ...u.attributes };
      return d.createNode(e, f, []);
    },
    markdownTokenizer: {
      name: e,
      level: "block",
      start(u) {
        var d;
        const f = new RegExp(`^:::${l}(?:\\s|$)`, "m"), h = (d = u.match(f)) == null ? void 0 : d.index;
        return h !== void 0 ? h : -1;
      },
      tokenize(u, d, f) {
        const h = new RegExp(`^:::${l}(?:\\s+\\{([^}]*)\\})?\\s*:::(?:\\n|$)`), m = u.match(h);
        if (!m)
          return;
        const p = m[1] || "", g = r(p);
        if (!s.find((v) => !(v in g)))
          return {
            type: e,
            raw: m[0],
            attributes: g
          };
      }
    },
    renderMarkdown: (u) => {
      const d = c(u.attrs || {}), f = o(d), h = f ? ` {${f}}` : "";
      return `:::${l}${h} :::`;
    }
  };
}
function ST(t) {
  const {
    nodeName: e,
    name: n,
    getContent: r,
    parseAttributes: o = yf,
    serializeAttributes: i = vf,
    defaultAttributes: s = {},
    content: a = "block",
    allowedAttributes: l
  } = t, c = n || e, u = (d) => {
    if (!l)
      return d;
    const f = {};
    return l.forEach((h) => {
      h in d && (f[h] = d[h]);
    }), f;
  };
  return {
    parseMarkdown: (d, f) => {
      let h;
      if (r) {
        const p = r(d);
        h = typeof p == "string" ? [{ type: "text", text: p }] : p;
      } else a === "block" ? h = f.parseChildren(d.tokens || []) : h = f.parseInline(d.tokens || []);
      const m = { ...s, ...d.attributes };
      return f.createNode(e, m, h);
    },
    markdownTokenizer: {
      name: e,
      level: "block",
      start(d) {
        var f;
        const h = new RegExp(`^:::${c}`, "m"), m = (f = d.match(h)) == null ? void 0 : f.index;
        return m !== void 0 ? m : -1;
      },
      tokenize(d, f, h) {
        var m;
        const p = new RegExp(`^:::${c}(?:\\s+\\{([^}]*)\\})?\\s*\\n`), g = d.match(p);
        if (!g)
          return;
        const [b, v = ""] = g, k = o(v);
        let x = 1;
        const w = b.length;
        let E = "";
        const S = /^:::([\w-]*)(\s.*)?/gm, C = d.slice(w);
        for (S.lastIndex = 0; ; ) {
          const M = S.exec(C);
          if (M === null)
            break;
          const O = M.index, q = M[1];
          if (!((m = M[2]) != null && m.endsWith(":::"))) {
            if (q)
              x += 1;
            else if (x -= 1, x === 0) {
              const K = C.slice(0, O);
              E = K.trim();
              const j = d.slice(0, w + O + M[0].length);
              let H = [];
              if (E)
                if (a === "block")
                  for (H = h.blockTokens(K), H.forEach((G) => {
                    G.text && (!G.tokens || G.tokens.length === 0) && (G.tokens = h.inlineTokens(G.text));
                  }); H.length > 0; ) {
                    const G = H[H.length - 1];
                    if (G.type === "paragraph" && (!G.text || G.text.trim() === ""))
                      H.pop();
                    else
                      break;
                  }
                else
                  H = h.inlineTokens(E);
              return {
                type: e,
                raw: j,
                attributes: k,
                content: E,
                tokens: H
              };
            }
          }
        }
      }
    },
    renderMarkdown: (d, f) => {
      const h = u(d.attrs || {}), m = i(h), p = m ? ` {${m}}` : "", g = f.renderChildren(d.content || [], `

`);
      return `:::${c}${p}

${g}

:::`;
    }
  };
}
function TT(t) {
  if (!t.trim())
    return {};
  const e = {}, n = /(\w+)=(?:"([^"]*)"|'([^']*)')/g;
  let r = n.exec(t);
  for (; r !== null; ) {
    const [, o, i, s] = r;
    e[o] = i || s, r = n.exec(t);
  }
  return e;
}
function CT(t) {
  return Object.entries(t).filter(([, e]) => e != null).map(([e, n]) => `${e}="${n}"`).join(" ");
}
function MT(t) {
  const {
    nodeName: e,
    name: n,
    getContent: r,
    parseAttributes: o = TT,
    serializeAttributes: i = CT,
    defaultAttributes: s = {},
    selfClosing: a = !1,
    allowedAttributes: l
  } = t, c = n || e, u = (f) => {
    if (!l)
      return f;
    const h = {};
    return l.forEach((m) => {
      const p = typeof m == "string" ? m : m.name, g = typeof m == "string" ? void 0 : m.skipIfDefault;
      if (p in f) {
        const b = f[p];
        if (g !== void 0 && b === g)
          return;
        h[p] = b;
      }
    }), h;
  }, d = c.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  return {
    parseMarkdown: (f, h) => {
      const m = { ...s, ...f.attributes };
      if (a)
        return h.createNode(e, m);
      const p = r ? r(f) : f.content || "";
      return p ? h.createNode(e, m, [h.createTextNode(p)]) : h.createNode(e, m, []);
    },
    markdownTokenizer: {
      name: e,
      level: "inline",
      start(f) {
        const h = a ? new RegExp(`\\[${d}\\s*[^\\]]*\\]`) : new RegExp(`\\[${d}\\s*[^\\]]*\\][\\s\\S]*?\\[\\/${d}\\]`), m = f.match(h), p = m?.index;
        return p !== void 0 ? p : -1;
      },
      tokenize(f, h, m) {
        const p = a ? new RegExp(`^\\[${d}\\s*([^\\]]*)\\]`) : new RegExp(`^\\[${d}\\s*([^\\]]*)\\]([\\s\\S]*?)\\[\\/${d}\\]`), g = f.match(p);
        if (!g)
          return;
        let b = "", v = "";
        if (a) {
          const [, x] = g;
          v = x;
        } else {
          const [, x, w] = g;
          v = x, b = w || "";
        }
        const k = o(v.trim());
        return {
          type: e,
          raw: g[0],
          content: b.trim(),
          attributes: k
        };
      }
    },
    renderMarkdown: (f) => {
      let h = "";
      r ? h = r(f) : f.content && f.content.length > 0 && (h = f.content.filter((b) => b.type === "text").map((b) => b.text).join(""));
      const m = u(f.attrs || {}), p = i(m), g = p ? ` ${p}` : "";
      return a ? `[${c}${g}]` : `[${c}${g}]${h}[/${c}]`;
    }
  };
}
function nd(t, e, n) {
  var r, o, i, s;
  const a = t.split(`
`), l = [];
  let c = "", u = 0;
  const d = e.baseIndentSize || 2;
  for (; u < a.length; ) {
    const f = a[u], h = f.match(e.itemPattern);
    if (!h) {
      if (l.length > 0)
        break;
      if (f.trim() === "") {
        u += 1, c = `${c}${f}
`;
        continue;
      } else
        return;
    }
    const m = e.extractItemData(h), { indentLevel: p, mainContent: g } = m;
    c = `${c}${f}
`;
    const b = [g];
    for (u += 1; u < a.length; ) {
      const w = a[u];
      if (w.trim() === "") {
        const S = a.slice(u + 1).findIndex((O) => O.trim() !== "");
        if (S === -1)
          break;
        if ((((o = (r = a[u + 1 + S].match(/^(\s*)/)) == null ? void 0 : r[1]) == null ? void 0 : o.length) || 0) > p) {
          b.push(w), c = `${c}${w}
`, u += 1;
          continue;
        } else
          break;
      }
      if ((((s = (i = w.match(/^(\s*)/)) == null ? void 0 : i[1]) == null ? void 0 : s.length) || 0) > p)
        b.push(w), c = `${c}${w}
`, u += 1;
      else
        break;
    }
    let v;
    const k = b.slice(1);
    if (k.length > 0) {
      const w = k.map((E) => E.slice(p + d)).join(`
`);
      w.trim() && (e.customNestedParser ? v = e.customNestedParser(w) : v = n.blockTokens(w));
    }
    const x = e.createToken(m, v);
    l.push(x);
  }
  if (l.length !== 0)
    return {
      items: l,
      raw: c
    };
}
function wf(t, e, n, r) {
  if (!t || !Array.isArray(t.content))
    return "";
  const o = typeof n == "function" ? n(r) : n, [i, ...s] = t.content, a = e.renderChildren([i]), l = [`${o}${a}`];
  return s && s.length > 0 && s.forEach((c) => {
    const u = e.renderChildren([c]);
    if (u) {
      const d = u.split(`
`).map((f) => f ? e.indent(f) : "").join(`
`);
      l.push(d);
    }
  }), l.join(`
`);
}
function AT(t, e, n = {}) {
  const { state: r } = e, { doc: o, tr: i } = r, s = t;
  o.descendants((a, l) => {
    const c = i.mapping.map(l), u = i.mapping.map(l) + a.nodeSize;
    let d = null;
    if (a.marks.forEach((h) => {
      if (h !== s)
        return !1;
      d = h;
    }), !d)
      return;
    let f = !1;
    if (Object.keys(n).forEach((h) => {
      n[h] !== d.attrs[h] && (f = !0);
    }), f) {
      const h = t.type.create({
        ...t.attrs,
        ...n
      });
      i.removeMark(c, u, t.type), i.addMark(c, u, h);
    }
  }), i.docChanged && e.view.dispatch(i);
}
var rt = class m0 extends bf {
  constructor() {
    super(...arguments), this.type = "node";
  }
  /**
   * Create a new Node instance
   * @param config - Node configuration object or a function that returns a configuration object
   */
  static create(e = {}) {
    const n = typeof e == "function" ? e() : e;
    return new m0(n);
  }
  configure(e) {
    return super.configure(e);
  }
  extend(e) {
    const n = typeof e == "function" ? e() : e;
    return super.extend(n);
  }
}, _T = class {
  constructor(t, e, n) {
    this.isDragging = !1, this.component = t, this.editor = e.editor, this.options = {
      stopEvent: null,
      ignoreMutation: null,
      ...n
    }, this.extension = e.extension, this.node = e.node, this.decorations = e.decorations, this.innerDecorations = e.innerDecorations, this.view = e.view, this.HTMLAttributes = e.HTMLAttributes, this.getPos = e.getPos, this.mount();
  }
  mount() {
  }
  get dom() {
    return this.editor.view.dom;
  }
  get contentDOM() {
    return null;
  }
  onDragStart(t) {
    var e, n, r, o, i, s, a;
    const { view: l } = this.editor, c = t.target, u = c.nodeType === 3 ? (e = c.parentElement) == null ? void 0 : e.closest("[data-drag-handle]") : c.closest("[data-drag-handle]");
    if (!this.dom || (n = this.contentDOM) != null && n.contains(c) || !u)
      return;
    let d = 0, f = 0;
    if (this.dom !== u) {
      const v = this.dom.getBoundingClientRect(), k = u.getBoundingClientRect(), x = (o = t.offsetX) != null ? o : (r = t.nativeEvent) == null ? void 0 : r.offsetX, w = (s = t.offsetY) != null ? s : (i = t.nativeEvent) == null ? void 0 : i.offsetY;
      d = k.x - v.x + x, f = k.y - v.y + w;
    }
    const h = this.dom.cloneNode(!0);
    try {
      const v = this.dom.getBoundingClientRect();
      h.style.width = `${Math.round(v.width)}px`, h.style.height = `${Math.round(v.height)}px`, h.style.boxSizing = "border-box", h.style.pointerEvents = "none";
    } catch {
    }
    let m = null;
    try {
      m = document.createElement("div"), m.style.position = "absolute", m.style.top = "-9999px", m.style.left = "-9999px", m.style.pointerEvents = "none", m.appendChild(h), document.body.appendChild(m), (a = t.dataTransfer) == null || a.setDragImage(h, d, f);
    } finally {
      m && setTimeout(() => {
        try {
          m?.remove();
        } catch {
        }
      }, 0);
    }
    const p = this.getPos();
    if (typeof p != "number")
      return;
    const g = se.create(l.state.doc, p), b = l.state.tr.setSelection(g);
    l.dispatch(b);
  }
  stopEvent(t) {
    var e;
    if (!this.dom)
      return !1;
    if (typeof this.options.stopEvent == "function")
      return this.options.stopEvent({ event: t });
    const n = t.target;
    if (!(this.dom.contains(n) && !((e = this.contentDOM) != null && e.contains(n))))
      return !1;
    const o = t.type.startsWith("drag"), i = t.type === "drop";
    if ((["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(n.tagName) || n.isContentEditable) && !i && !o)
      return !0;
    const { isEditable: a } = this.editor, { isDragging: l } = this, c = !!this.node.type.spec.draggable, u = se.isSelectable(this.node), d = t.type === "copy", f = t.type === "paste", h = t.type === "cut", m = t.type === "mousedown";
    if (!c && u && o && t.target === this.dom && t.preventDefault(), c && o && !l && t.target === this.dom)
      return t.preventDefault(), !1;
    if (c && a && !l && m) {
      const p = n.closest("[data-drag-handle]");
      p && (this.dom === p || this.dom.contains(p)) && (this.isDragging = !0, document.addEventListener(
        "dragend",
        () => {
          this.isDragging = !1;
        },
        { once: !0 }
      ), document.addEventListener(
        "drop",
        () => {
          this.isDragging = !1;
        },
        { once: !0 }
      ), document.addEventListener(
        "mouseup",
        () => {
          this.isDragging = !1;
        },
        { once: !0 }
      ));
    }
    return !(l || i || d || f || h || m && u);
  }
  /**
   * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.
   * @return `false` if the editor should re-read the selection or re-parse the range around the mutation
   * @return `true` if it can safely be ignored.
   */
  ignoreMutation(t) {
    return !this.dom || !this.contentDOM ? !0 : typeof this.options.ignoreMutation == "function" ? this.options.ignoreMutation({ mutation: t }) : this.node.isLeaf || this.node.isAtom ? !0 : t.type === "selection" || this.dom.contains(t.target) && t.type === "childList" && (is() || Zu()) && this.editor.isFocused && [...Array.from(t.addedNodes), ...Array.from(t.removedNodes)].every((n) => n.isContentEditable) ? !1 : this.contentDOM === t.target && t.type === "attributes" ? !0 : !this.contentDOM.contains(t.target);
  }
  /**
   * Update the attributes of the prosemirror node.
   */
  updateAttributes(t) {
    this.editor.commands.command(({ tr: e }) => {
      const n = this.getPos();
      return typeof n != "number" ? !1 : (e.setNodeMarkup(n, void 0, {
        ...this.node.attrs,
        ...t
      }), !0);
    });
  }
  /**
   * Delete the node.
   */
  deleteNode() {
    const t = this.getPos();
    if (typeof t != "number")
      return;
    const e = t + this.node.nodeSize;
    this.editor.commands.deleteRange({ from: t, to: e });
  }
};
function Ar(t) {
  return new uT({
    find: t.find,
    handler: ({ state: e, range: n, match: r, pasteEvent: o }) => {
      const i = ze(t.getAttributes, void 0, r, o);
      if (i === !1 || i === null)
        return null;
      const { tr: s } = e, a = r[r.length - 1], l = r[0];
      let c = n.to;
      if (a) {
        const u = l.search(/\S/), d = n.from + l.indexOf(a), f = d + a.length;
        if (gf(n.from, n.to, e.doc).filter((m) => m.mark.type.excluded.find((g) => g === t.type && g !== m.mark.type)).filter((m) => m.to > d).length)
          return null;
        f < n.to && s.delete(f, n.to), d > n.from && s.delete(n.from + u, d), c = n.from + u + a.length, s.addMark(n.from + u, c, t.type.create(i || {})), s.removeStoredMark(t.type);
      }
    }
  });
}
const { getOwnPropertyNames: RT, getOwnPropertySymbols: OT } = Object, { hasOwnProperty: IT } = Object.prototype;
function ru(t, e) {
  return function(r, o, i) {
    return t(r, o, i) && e(r, o, i);
  };
}
function Ks(t) {
  return function(n, r, o) {
    if (!n || !r || typeof n != "object" || typeof r != "object")
      return t(n, r, o);
    const { cache: i } = o, s = i.get(n), a = i.get(r);
    if (s && a)
      return s === r && a === n;
    i.set(n, r), i.set(r, n);
    const l = t(n, r, o);
    return i.delete(n), i.delete(r), l;
  };
}
function DT(t) {
  return t?.[Symbol.toStringTag];
}
function Ym(t) {
  return RT(t).concat(OT(t));
}
const LT = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  Object.hasOwn || ((t, e) => IT.call(t, e))
);
function ao(t, e) {
  return t === e || !t && !e && t !== t && e !== e;
}
const PT = "__v", BT = "__o", zT = "_owner", { getOwnPropertyDescriptor: Xm, keys: Zm } = Object;
function $T(t, e) {
  return t.byteLength === e.byteLength && Wa(new Uint8Array(t), new Uint8Array(e));
}
function HT(t, e, n) {
  let r = t.length;
  if (e.length !== r)
    return !1;
  for (; r-- > 0; )
    if (!n.equals(t[r], e[r], r, r, t, e, n))
      return !1;
  return !0;
}
function FT(t, e) {
  return t.byteLength === e.byteLength && Wa(new Uint8Array(t.buffer, t.byteOffset, t.byteLength), new Uint8Array(e.buffer, e.byteOffset, e.byteLength));
}
function UT(t, e) {
  return ao(t.getTime(), e.getTime());
}
function WT(t, e) {
  return t.name === e.name && t.message === e.message && t.cause === e.cause && t.stack === e.stack;
}
function VT(t, e) {
  return t === e;
}
function Jm(t, e, n) {
  const r = t.size;
  if (r !== e.size)
    return !1;
  if (!r)
    return !0;
  const o = new Array(r), i = t.entries();
  let s, a, l = 0;
  for (; (s = i.next()) && !s.done; ) {
    const c = e.entries();
    let u = !1, d = 0;
    for (; (a = c.next()) && !a.done; ) {
      if (o[d]) {
        d++;
        continue;
      }
      const f = s.value, h = a.value;
      if (n.equals(f[0], h[0], l, d, t, e, n) && n.equals(f[1], h[1], f[0], h[0], t, e, n)) {
        u = o[d] = !0;
        break;
      }
      d++;
    }
    if (!u)
      return !1;
    l++;
  }
  return !0;
}
const KT = ao;
function qT(t, e, n) {
  const r = Zm(t);
  let o = r.length;
  if (Zm(e).length !== o)
    return !1;
  for (; o-- > 0; )
    if (!p0(t, e, n, r[o]))
      return !1;
  return !0;
}
function yi(t, e, n) {
  const r = Ym(t);
  let o = r.length;
  if (Ym(e).length !== o)
    return !1;
  let i, s, a;
  for (; o-- > 0; )
    if (i = r[o], !p0(t, e, n, i) || (s = Xm(t, i), a = Xm(e, i), (s || a) && (!s || !a || s.configurable !== a.configurable || s.enumerable !== a.enumerable || s.writable !== a.writable)))
      return !1;
  return !0;
}
function GT(t, e) {
  return ao(t.valueOf(), e.valueOf());
}
function jT(t, e) {
  return t.source === e.source && t.flags === e.flags;
}
function Qm(t, e, n) {
  const r = t.size;
  if (r !== e.size)
    return !1;
  if (!r)
    return !0;
  const o = new Array(r), i = t.values();
  let s, a;
  for (; (s = i.next()) && !s.done; ) {
    const l = e.values();
    let c = !1, u = 0;
    for (; (a = l.next()) && !a.done; ) {
      if (!o[u] && n.equals(s.value, a.value, s.value, a.value, t, e, n)) {
        c = o[u] = !0;
        break;
      }
      u++;
    }
    if (!c)
      return !1;
  }
  return !0;
}
function Wa(t, e) {
  let n = t.byteLength;
  if (e.byteLength !== n || t.byteOffset !== e.byteOffset)
    return !1;
  for (; n-- > 0; )
    if (t[n] !== e[n])
      return !1;
  return !0;
}
function YT(t, e) {
  return t.hostname === e.hostname && t.pathname === e.pathname && t.protocol === e.protocol && t.port === e.port && t.hash === e.hash && t.username === e.username && t.password === e.password;
}
function p0(t, e, n, r) {
  return (r === zT || r === BT || r === PT) && (t.$$typeof || e.$$typeof) ? !0 : LT(e, r) && n.equals(t[r], e[r], r, r, t, e, n);
}
const XT = "[object ArrayBuffer]", ZT = "[object Arguments]", JT = "[object Boolean]", QT = "[object DataView]", eC = "[object Date]", tC = "[object Error]", nC = "[object Map]", rC = "[object Number]", oC = "[object Object]", iC = "[object RegExp]", sC = "[object Set]", aC = "[object String]", lC = {
  "[object Int8Array]": !0,
  "[object Uint8Array]": !0,
  "[object Uint8ClampedArray]": !0,
  "[object Int16Array]": !0,
  "[object Uint16Array]": !0,
  "[object Int32Array]": !0,
  "[object Uint32Array]": !0,
  "[object Float16Array]": !0,
  "[object Float32Array]": !0,
  "[object Float64Array]": !0,
  "[object BigInt64Array]": !0,
  "[object BigUint64Array]": !0
}, cC = "[object URL]", uC = Object.prototype.toString;
function dC({ areArrayBuffersEqual: t, areArraysEqual: e, areDataViewsEqual: n, areDatesEqual: r, areErrorsEqual: o, areFunctionsEqual: i, areMapsEqual: s, areNumbersEqual: a, areObjectsEqual: l, arePrimitiveWrappersEqual: c, areRegExpsEqual: u, areSetsEqual: d, areTypedArraysEqual: f, areUrlsEqual: h, unknownTagComparators: m }) {
  return function(g, b, v) {
    if (g === b)
      return !0;
    if (g == null || b == null)
      return !1;
    const k = typeof g;
    if (k !== typeof b)
      return !1;
    if (k !== "object")
      return k === "number" ? a(g, b, v) : k === "function" ? i(g, b, v) : !1;
    const x = g.constructor;
    if (x !== b.constructor)
      return !1;
    if (x === Object)
      return l(g, b, v);
    if (Array.isArray(g))
      return e(g, b, v);
    if (x === Date)
      return r(g, b, v);
    if (x === RegExp)
      return u(g, b, v);
    if (x === Map)
      return s(g, b, v);
    if (x === Set)
      return d(g, b, v);
    const w = uC.call(g);
    if (w === eC)
      return r(g, b, v);
    if (w === iC)
      return u(g, b, v);
    if (w === nC)
      return s(g, b, v);
    if (w === sC)
      return d(g, b, v);
    if (w === oC)
      return typeof g.then != "function" && typeof b.then != "function" && l(g, b, v);
    if (w === cC)
      return h(g, b, v);
    if (w === tC)
      return o(g, b, v);
    if (w === ZT)
      return l(g, b, v);
    if (lC[w])
      return f(g, b, v);
    if (w === XT)
      return t(g, b, v);
    if (w === QT)
      return n(g, b, v);
    if (w === JT || w === rC || w === aC)
      return c(g, b, v);
    if (m) {
      let E = m[w];
      if (!E) {
        const S = DT(g);
        S && (E = m[S]);
      }
      if (E)
        return E(g, b, v);
    }
    return !1;
  };
}
function fC({ circular: t, createCustomConfig: e, strict: n }) {
  let r = {
    areArrayBuffersEqual: $T,
    areArraysEqual: n ? yi : HT,
    areDataViewsEqual: FT,
    areDatesEqual: UT,
    areErrorsEqual: WT,
    areFunctionsEqual: VT,
    areMapsEqual: n ? ru(Jm, yi) : Jm,
    areNumbersEqual: KT,
    areObjectsEqual: n ? yi : qT,
    arePrimitiveWrappersEqual: GT,
    areRegExpsEqual: jT,
    areSetsEqual: n ? ru(Qm, yi) : Qm,
    areTypedArraysEqual: n ? ru(Wa, yi) : Wa,
    areUrlsEqual: YT,
    unknownTagComparators: void 0
  };
  if (e && (r = Object.assign({}, r, e(r))), t) {
    const o = Ks(r.areArraysEqual), i = Ks(r.areMapsEqual), s = Ks(r.areObjectsEqual), a = Ks(r.areSetsEqual);
    r = Object.assign({}, r, {
      areArraysEqual: o,
      areMapsEqual: i,
      areObjectsEqual: s,
      areSetsEqual: a
    });
  }
  return r;
}
function hC(t) {
  return function(e, n, r, o, i, s, a) {
    return t(e, n, a);
  };
}
function mC({ circular: t, comparator: e, createState: n, equals: r, strict: o }) {
  if (n)
    return function(a, l) {
      const { cache: c = t ? /* @__PURE__ */ new WeakMap() : void 0, meta: u } = n();
      return e(a, l, {
        cache: c,
        equals: r,
        meta: u,
        strict: o
      });
    };
  if (t)
    return function(a, l) {
      return e(a, l, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals: r,
        meta: void 0,
        strict: o
      });
    };
  const i = {
    cache: void 0,
    equals: r,
    meta: void 0,
    strict: o
  };
  return function(a, l) {
    return e(a, l, i);
  };
}
const pC = Dr();
Dr({ strict: !0 });
Dr({ circular: !0 });
Dr({
  circular: !0,
  strict: !0
});
Dr({
  createInternalComparator: () => ao
});
Dr({
  strict: !0,
  createInternalComparator: () => ao
});
Dr({
  circular: !0,
  createInternalComparator: () => ao
});
Dr({
  circular: !0,
  createInternalComparator: () => ao,
  strict: !0
});
function Dr(t = {}) {
  const { circular: e = !1, createInternalComparator: n, createState: r, strict: o = !1 } = t, i = fC(t), s = dC(i), a = n ? n(s) : hC(s);
  return mC({ circular: e, comparator: s, createState: r, equals: a, strict: o });
}
var qs = { exports: {} }, ou = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ep;
function gC() {
  if (ep) return ou;
  ep = 1;
  var t = ot, e = Fd();
  function n(c, u) {
    return c === u && (c !== 0 || 1 / c === 1 / u) || c !== c && u !== u;
  }
  var r = typeof Object.is == "function" ? Object.is : n, o = e.useSyncExternalStore, i = t.useRef, s = t.useEffect, a = t.useMemo, l = t.useDebugValue;
  return ou.useSyncExternalStoreWithSelector = function(c, u, d, f, h) {
    var m = i(null);
    if (m.current === null) {
      var p = { hasValue: !1, value: null };
      m.current = p;
    } else p = m.current;
    m = a(
      function() {
        function b(E) {
          if (!v) {
            if (v = !0, k = E, E = f(E), h !== void 0 && p.hasValue) {
              var S = p.value;
              if (h(S, E))
                return x = S;
            }
            return x = E;
          }
          if (S = x, r(k, E)) return S;
          var C = f(E);
          return h !== void 0 && h(S, C) ? (k = E, S) : (k = E, x = C);
        }
        var v = !1, k, x, w = d === void 0 ? null : d;
        return [
          function() {
            return b(u());
          },
          w === null ? void 0 : function() {
            return b(w());
          }
        ];
      },
      [u, d, f, h]
    );
    var g = o(c, m[0], m[1]);
    return s(
      function() {
        p.hasValue = !0, p.value = g;
      },
      [g]
    ), l(g), g;
  }, ou;
}
var iu = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tp;
function bC() {
  return tp || (tp = 1, process.env.NODE_ENV !== "production" && (function() {
    function t(c, u) {
      return c === u && (c !== 0 || 1 / c === 1 / u) || c !== c && u !== u;
    }
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var e = ot, n = Fd(), r = typeof Object.is == "function" ? Object.is : t, o = n.useSyncExternalStore, i = e.useRef, s = e.useEffect, a = e.useMemo, l = e.useDebugValue;
    iu.useSyncExternalStoreWithSelector = function(c, u, d, f, h) {
      var m = i(null);
      if (m.current === null) {
        var p = { hasValue: !1, value: null };
        m.current = p;
      } else p = m.current;
      m = a(
        function() {
          function b(E) {
            if (!v) {
              if (v = !0, k = E, E = f(E), h !== void 0 && p.hasValue) {
                var S = p.value;
                if (h(S, E))
                  return x = S;
              }
              return x = E;
            }
            if (S = x, r(k, E))
              return S;
            var C = f(E);
            return h !== void 0 && h(S, C) ? (k = E, S) : (k = E, x = C);
          }
          var v = !1, k, x, w = d === void 0 ? null : d;
          return [
            function() {
              return b(u());
            },
            w === null ? void 0 : function() {
              return b(w());
            }
          ];
        },
        [u, d, f, h]
      );
      var g = o(c, m[0], m[1]);
      return s(
        function() {
          p.hasValue = !0, p.value = g;
        },
        [g]
      ), l(g), g;
    }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })()), iu;
}
var np;
function yC() {
  return np || (np = 1, process.env.NODE_ENV === "production" ? qs.exports = gC() : qs.exports = bC()), qs.exports;
}
var vC = yC();
const g0 = ["top", "right", "bottom", "left"], rp = ["start", "end"], op = /* @__PURE__ */ g0.reduce((t, e) => t.concat(e, e + "-" + rp[0], e + "-" + rp[1]), []), bn = Math.min, Ct = Math.max, Va = Math.round, Gs = Math.floor, On = (t) => ({
  x: t,
  y: t
}), wC = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, kC = {
  start: "end",
  end: "start"
};
function rd(t, e, n) {
  return Ct(t, bn(e, n));
}
function yn(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Gt(t) {
  return t.split("-")[0];
}
function gn(t) {
  return t.split("-")[1];
}
function kf(t) {
  return t === "x" ? "y" : "x";
}
function xf(t) {
  return t === "y" ? "height" : "width";
}
const xC = /* @__PURE__ */ new Set(["top", "bottom"]);
function pn(t) {
  return xC.has(Gt(t)) ? "y" : "x";
}
function Nf(t) {
  return kf(pn(t));
}
function b0(t, e, n) {
  n === void 0 && (n = !1);
  const r = gn(t), o = Nf(t), i = xf(o);
  let s = o === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return e.reference[i] > e.floating[i] && (s = qa(s)), [s, qa(s)];
}
function NC(t) {
  const e = qa(t);
  return [Ka(t), e, Ka(e)];
}
function Ka(t) {
  return t.replace(/start|end/g, (e) => kC[e]);
}
const ip = ["left", "right"], sp = ["right", "left"], EC = ["top", "bottom"], SC = ["bottom", "top"];
function TC(t, e, n) {
  switch (t) {
    case "top":
    case "bottom":
      return n ? e ? sp : ip : e ? ip : sp;
    case "left":
    case "right":
      return e ? EC : SC;
    default:
      return [];
  }
}
function CC(t, e, n, r) {
  const o = gn(t);
  let i = TC(Gt(t), n === "start", r);
  return o && (i = i.map((s) => s + "-" + o), e && (i = i.concat(i.map(Ka)))), i;
}
function qa(t) {
  return t.replace(/left|right|bottom|top/g, (e) => wC[e]);
}
function MC(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function Ef(t) {
  return typeof t != "number" ? MC(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function ei(t) {
  const {
    x: e,
    y: n,
    width: r,
    height: o
  } = t;
  return {
    width: r,
    height: o,
    top: n,
    left: e,
    right: e + r,
    bottom: n + o,
    x: e,
    y: n
  };
}
function ap(t, e, n) {
  let {
    reference: r,
    floating: o
  } = t;
  const i = pn(e), s = Nf(e), a = xf(s), l = Gt(e), c = i === "y", u = r.x + r.width / 2 - o.width / 2, d = r.y + r.height / 2 - o.height / 2, f = r[a] / 2 - o[a] / 2;
  let h;
  switch (l) {
    case "top":
      h = {
        x: u,
        y: r.y - o.height
      };
      break;
    case "bottom":
      h = {
        x: u,
        y: r.y + r.height
      };
      break;
    case "right":
      h = {
        x: r.x + r.width,
        y: d
      };
      break;
    case "left":
      h = {
        x: r.x - o.width,
        y: d
      };
      break;
    default:
      h = {
        x: r.x,
        y: r.y
      };
  }
  switch (gn(e)) {
    case "start":
      h[s] -= f * (n && c ? -1 : 1);
      break;
    case "end":
      h[s] += f * (n && c ? -1 : 1);
      break;
  }
  return h;
}
const AC = async (t, e, n) => {
  const {
    placement: r = "bottom",
    strategy: o = "absolute",
    middleware: i = [],
    platform: s
  } = n, a = i.filter(Boolean), l = await (s.isRTL == null ? void 0 : s.isRTL(e));
  let c = await s.getElementRects({
    reference: t,
    floating: e,
    strategy: o
  }), {
    x: u,
    y: d
  } = ap(c, r, l), f = r, h = {}, m = 0;
  for (let p = 0; p < a.length; p++) {
    const {
      name: g,
      fn: b
    } = a[p], {
      x: v,
      y: k,
      data: x,
      reset: w
    } = await b({
      x: u,
      y: d,
      initialPlacement: r,
      placement: f,
      strategy: o,
      middlewareData: h,
      rects: c,
      platform: s,
      elements: {
        reference: t,
        floating: e
      }
    });
    u = v ?? u, d = k ?? d, h = {
      ...h,
      [g]: {
        ...h[g],
        ...x
      }
    }, w && m <= 50 && (m++, typeof w == "object" && (w.placement && (f = w.placement), w.rects && (c = w.rects === !0 ? await s.getElementRects({
      reference: t,
      floating: e,
      strategy: o
    }) : w.rects), {
      x: u,
      y: d
    } = ap(c, f, l)), p = -1);
  }
  return {
    x: u,
    y: d,
    placement: f,
    strategy: o,
    middlewareData: h
  };
};
async function ti(t, e) {
  var n;
  e === void 0 && (e = {});
  const {
    x: r,
    y: o,
    platform: i,
    rects: s,
    elements: a,
    strategy: l
  } = t, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: d = "floating",
    altBoundary: f = !1,
    padding: h = 0
  } = yn(e, t), m = Ef(h), g = a[f ? d === "floating" ? "reference" : "floating" : d], b = ei(await i.getClippingRect({
    element: (n = await (i.isElement == null ? void 0 : i.isElement(g))) == null || n ? g : g.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(a.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: l
  })), v = d === "floating" ? {
    x: r,
    y: o,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, k = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(a.floating)), x = await (i.isElement == null ? void 0 : i.isElement(k)) ? await (i.getScale == null ? void 0 : i.getScale(k)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, w = ei(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: a,
    rect: v,
    offsetParent: k,
    strategy: l
  }) : v);
  return {
    top: (b.top - w.top + m.top) / x.y,
    bottom: (w.bottom - b.bottom + m.bottom) / x.y,
    left: (b.left - w.left + m.left) / x.x,
    right: (w.right - b.right + m.right) / x.x
  };
}
const _C = (t) => ({
  name: "arrow",
  options: t,
  async fn(e) {
    const {
      x: n,
      y: r,
      placement: o,
      rects: i,
      platform: s,
      elements: a,
      middlewareData: l
    } = e, {
      element: c,
      padding: u = 0
    } = yn(t, e) || {};
    if (c == null)
      return {};
    const d = Ef(u), f = {
      x: n,
      y: r
    }, h = Nf(o), m = xf(h), p = await s.getDimensions(c), g = h === "y", b = g ? "top" : "left", v = g ? "bottom" : "right", k = g ? "clientHeight" : "clientWidth", x = i.reference[m] + i.reference[h] - f[h] - i.floating[m], w = f[h] - i.reference[h], E = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(c));
    let S = E ? E[k] : 0;
    (!S || !await (s.isElement == null ? void 0 : s.isElement(E))) && (S = a.floating[k] || i.floating[m]);
    const C = x / 2 - w / 2, M = S / 2 - p[m] / 2 - 1, O = bn(d[b], M), q = bn(d[v], M), K = O, j = S - p[m] - q, H = S / 2 - p[m] / 2 + C, G = rd(K, H, j), V = !l.arrow && gn(o) != null && H !== G && i.reference[m] / 2 - (H < K ? O : q) - p[m] / 2 < 0, re = V ? H < K ? H - K : H - j : 0;
    return {
      [h]: f[h] + re,
      data: {
        [h]: G,
        centerOffset: H - G - re,
        ...V && {
          alignmentOffset: re
        }
      },
      reset: V
    };
  }
});
function RC(t, e, n) {
  return (t ? [...n.filter((o) => gn(o) === t), ...n.filter((o) => gn(o) !== t)] : n.filter((o) => Gt(o) === o)).filter((o) => t ? gn(o) === t || (e ? Ka(o) !== o : !1) : !0);
}
const OC = function(t) {
  return t === void 0 && (t = {}), {
    name: "autoPlacement",
    options: t,
    async fn(e) {
      var n, r, o;
      const {
        rects: i,
        middlewareData: s,
        placement: a,
        platform: l,
        elements: c
      } = e, {
        crossAxis: u = !1,
        alignment: d,
        allowedPlacements: f = op,
        autoAlignment: h = !0,
        ...m
      } = yn(t, e), p = d !== void 0 || f === op ? RC(d || null, h, f) : f, g = await ti(e, m), b = ((n = s.autoPlacement) == null ? void 0 : n.index) || 0, v = p[b];
      if (v == null)
        return {};
      const k = b0(v, i, await (l.isRTL == null ? void 0 : l.isRTL(c.floating)));
      if (a !== v)
        return {
          reset: {
            placement: p[0]
          }
        };
      const x = [g[Gt(v)], g[k[0]], g[k[1]]], w = [...((r = s.autoPlacement) == null ? void 0 : r.overflows) || [], {
        placement: v,
        overflows: x
      }], E = p[b + 1];
      if (E)
        return {
          data: {
            index: b + 1,
            overflows: w
          },
          reset: {
            placement: E
          }
        };
      const S = w.map((O) => {
        const q = gn(O.placement);
        return [O.placement, q && u ? (
          // Check along the mainAxis and main crossAxis side.
          O.overflows.slice(0, 2).reduce((K, j) => K + j, 0)
        ) : (
          // Check only the mainAxis.
          O.overflows[0]
        ), O.overflows];
      }).sort((O, q) => O[1] - q[1]), M = ((o = S.filter((O) => O[2].slice(
        0,
        // Aligned placements should not check their opposite crossAxis
        // side.
        gn(O[0]) ? 2 : 3
      ).every((q) => q <= 0))[0]) == null ? void 0 : o[0]) || S[0][0];
      return M !== a ? {
        data: {
          index: b + 1,
          overflows: w
        },
        reset: {
          placement: M
        }
      } : {};
    }
  };
}, IC = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(e) {
      var n, r;
      const {
        placement: o,
        middlewareData: i,
        rects: s,
        initialPlacement: a,
        platform: l,
        elements: c
      } = e, {
        mainAxis: u = !0,
        crossAxis: d = !0,
        fallbackPlacements: f,
        fallbackStrategy: h = "bestFit",
        fallbackAxisSideDirection: m = "none",
        flipAlignment: p = !0,
        ...g
      } = yn(t, e);
      if ((n = i.arrow) != null && n.alignmentOffset)
        return {};
      const b = Gt(o), v = pn(a), k = Gt(a) === a, x = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), w = f || (k || !p ? [qa(a)] : NC(a)), E = m !== "none";
      !f && E && w.push(...CC(a, p, m, x));
      const S = [a, ...w], C = await ti(e, g), M = [];
      let O = ((r = i.flip) == null ? void 0 : r.overflows) || [];
      if (u && M.push(C[b]), d) {
        const H = b0(o, s, x);
        M.push(C[H[0]], C[H[1]]);
      }
      if (O = [...O, {
        placement: o,
        overflows: M
      }], !M.every((H) => H <= 0)) {
        var q, K;
        const H = (((q = i.flip) == null ? void 0 : q.index) || 0) + 1, G = S[H];
        if (G && (!(d === "alignment" ? v !== pn(G) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        O.every((A) => pn(A.placement) === v ? A.overflows[0] > 0 : !0)))
          return {
            data: {
              index: H,
              overflows: O
            },
            reset: {
              placement: G
            }
          };
        let V = (K = O.filter((re) => re.overflows[0] <= 0).sort((re, A) => re.overflows[1] - A.overflows[1])[0]) == null ? void 0 : K.placement;
        if (!V)
          switch (h) {
            case "bestFit": {
              var j;
              const re = (j = O.filter((A) => {
                if (E) {
                  const $ = pn(A.placement);
                  return $ === v || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  $ === "y";
                }
                return !0;
              }).map((A) => [A.placement, A.overflows.filter(($) => $ > 0).reduce(($, _) => $ + _, 0)]).sort((A, $) => A[1] - $[1])[0]) == null ? void 0 : j[0];
              re && (V = re);
              break;
            }
            case "initialPlacement":
              V = a;
              break;
          }
        if (o !== V)
          return {
            reset: {
              placement: V
            }
          };
      }
      return {};
    }
  };
};
function lp(t, e) {
  return {
    top: t.top - e.height,
    right: t.right - e.width,
    bottom: t.bottom - e.height,
    left: t.left - e.width
  };
}
function cp(t) {
  return g0.some((e) => t[e] >= 0);
}
const DC = function(t) {
  return t === void 0 && (t = {}), {
    name: "hide",
    options: t,
    async fn(e) {
      const {
        rects: n
      } = e, {
        strategy: r = "referenceHidden",
        ...o
      } = yn(t, e);
      switch (r) {
        case "referenceHidden": {
          const i = await ti(e, {
            ...o,
            elementContext: "reference"
          }), s = lp(i, n.reference);
          return {
            data: {
              referenceHiddenOffsets: s,
              referenceHidden: cp(s)
            }
          };
        }
        case "escaped": {
          const i = await ti(e, {
            ...o,
            altBoundary: !0
          }), s = lp(i, n.floating);
          return {
            data: {
              escapedOffsets: s,
              escaped: cp(s)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
function y0(t) {
  const e = bn(...t.map((i) => i.left)), n = bn(...t.map((i) => i.top)), r = Ct(...t.map((i) => i.right)), o = Ct(...t.map((i) => i.bottom));
  return {
    x: e,
    y: n,
    width: r - e,
    height: o - n
  };
}
function LC(t) {
  const e = t.slice().sort((o, i) => o.y - i.y), n = [];
  let r = null;
  for (let o = 0; o < e.length; o++) {
    const i = e[o];
    !r || i.y - r.y > r.height / 2 ? n.push([i]) : n[n.length - 1].push(i), r = i;
  }
  return n.map((o) => ei(y0(o)));
}
const PC = function(t) {
  return t === void 0 && (t = {}), {
    name: "inline",
    options: t,
    async fn(e) {
      const {
        placement: n,
        elements: r,
        rects: o,
        platform: i,
        strategy: s
      } = e, {
        padding: a = 2,
        x: l,
        y: c
      } = yn(t, e), u = Array.from(await (i.getClientRects == null ? void 0 : i.getClientRects(r.reference)) || []), d = LC(u), f = ei(y0(u)), h = Ef(a);
      function m() {
        if (d.length === 2 && d[0].left > d[1].right && l != null && c != null)
          return d.find((g) => l > g.left - h.left && l < g.right + h.right && c > g.top - h.top && c < g.bottom + h.bottom) || f;
        if (d.length >= 2) {
          if (pn(n) === "y") {
            const O = d[0], q = d[d.length - 1], K = Gt(n) === "top", j = O.top, H = q.bottom, G = K ? O.left : q.left, V = K ? O.right : q.right, re = V - G, A = H - j;
            return {
              top: j,
              bottom: H,
              left: G,
              right: V,
              width: re,
              height: A,
              x: G,
              y: j
            };
          }
          const g = Gt(n) === "left", b = Ct(...d.map((O) => O.right)), v = bn(...d.map((O) => O.left)), k = d.filter((O) => g ? O.left === v : O.right === b), x = k[0].top, w = k[k.length - 1].bottom, E = v, S = b, C = S - E, M = w - x;
          return {
            top: x,
            bottom: w,
            left: E,
            right: S,
            width: C,
            height: M,
            x: E,
            y: x
          };
        }
        return f;
      }
      const p = await i.getElementRects({
        reference: {
          getBoundingClientRect: m
        },
        floating: r.floating,
        strategy: s
      });
      return o.reference.x !== p.reference.x || o.reference.y !== p.reference.y || o.reference.width !== p.reference.width || o.reference.height !== p.reference.height ? {
        reset: {
          rects: p
        }
      } : {};
    }
  };
}, v0 = /* @__PURE__ */ new Set(["left", "top"]);
async function BC(t, e) {
  const {
    placement: n,
    platform: r,
    elements: o
  } = t, i = await (r.isRTL == null ? void 0 : r.isRTL(o.floating)), s = Gt(n), a = gn(n), l = pn(n) === "y", c = v0.has(s) ? -1 : 1, u = i && l ? -1 : 1, d = yn(e, t);
  let {
    mainAxis: f,
    crossAxis: h,
    alignmentAxis: m
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: d.mainAxis || 0,
    crossAxis: d.crossAxis || 0,
    alignmentAxis: d.alignmentAxis
  };
  return a && typeof m == "number" && (h = a === "end" ? m * -1 : m), l ? {
    x: h * u,
    y: f * c
  } : {
    x: f * c,
    y: h * u
  };
}
const zC = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(e) {
      var n, r;
      const {
        x: o,
        y: i,
        placement: s,
        middlewareData: a
      } = e, l = await BC(e, t);
      return s === ((n = a.offset) == null ? void 0 : n.placement) && (r = a.arrow) != null && r.alignmentOffset ? {} : {
        x: o + l.x,
        y: i + l.y,
        data: {
          ...l,
          placement: s
        }
      };
    }
  };
}, $C = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(e) {
      const {
        x: n,
        y: r,
        placement: o
      } = e, {
        mainAxis: i = !0,
        crossAxis: s = !1,
        limiter: a = {
          fn: (g) => {
            let {
              x: b,
              y: v
            } = g;
            return {
              x: b,
              y: v
            };
          }
        },
        ...l
      } = yn(t, e), c = {
        x: n,
        y: r
      }, u = await ti(e, l), d = pn(Gt(o)), f = kf(d);
      let h = c[f], m = c[d];
      if (i) {
        const g = f === "y" ? "top" : "left", b = f === "y" ? "bottom" : "right", v = h + u[g], k = h - u[b];
        h = rd(v, h, k);
      }
      if (s) {
        const g = d === "y" ? "top" : "left", b = d === "y" ? "bottom" : "right", v = m + u[g], k = m - u[b];
        m = rd(v, m, k);
      }
      const p = a.fn({
        ...e,
        [f]: h,
        [d]: m
      });
      return {
        ...p,
        data: {
          x: p.x - n,
          y: p.y - r,
          enabled: {
            [f]: i,
            [d]: s
          }
        }
      };
    }
  };
}, HC = function(t) {
  return t === void 0 && (t = {}), {
    options: t,
    fn(e) {
      const {
        x: n,
        y: r,
        placement: o,
        rects: i,
        middlewareData: s
      } = e, {
        offset: a = 0,
        mainAxis: l = !0,
        crossAxis: c = !0
      } = yn(t, e), u = {
        x: n,
        y: r
      }, d = pn(o), f = kf(d);
      let h = u[f], m = u[d];
      const p = yn(a, e), g = typeof p == "number" ? {
        mainAxis: p,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...p
      };
      if (l) {
        const k = f === "y" ? "height" : "width", x = i.reference[f] - i.floating[k] + g.mainAxis, w = i.reference[f] + i.reference[k] - g.mainAxis;
        h < x ? h = x : h > w && (h = w);
      }
      if (c) {
        var b, v;
        const k = f === "y" ? "width" : "height", x = v0.has(Gt(o)), w = i.reference[d] - i.floating[k] + (x && ((b = s.offset) == null ? void 0 : b[d]) || 0) + (x ? 0 : g.crossAxis), E = i.reference[d] + i.reference[k] + (x ? 0 : ((v = s.offset) == null ? void 0 : v[d]) || 0) - (x ? g.crossAxis : 0);
        m < w ? m = w : m > E && (m = E);
      }
      return {
        [f]: h,
        [d]: m
      };
    }
  };
}, FC = function(t) {
  return t === void 0 && (t = {}), {
    name: "size",
    options: t,
    async fn(e) {
      var n, r;
      const {
        placement: o,
        rects: i,
        platform: s,
        elements: a
      } = e, {
        apply: l = () => {
        },
        ...c
      } = yn(t, e), u = await ti(e, c), d = Gt(o), f = gn(o), h = pn(o) === "y", {
        width: m,
        height: p
      } = i.floating;
      let g, b;
      d === "top" || d === "bottom" ? (g = d, b = f === (await (s.isRTL == null ? void 0 : s.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (b = d, g = f === "end" ? "top" : "bottom");
      const v = p - u.top - u.bottom, k = m - u.left - u.right, x = bn(p - u[g], v), w = bn(m - u[b], k), E = !e.middlewareData.shift;
      let S = x, C = w;
      if ((n = e.middlewareData.shift) != null && n.enabled.x && (C = k), (r = e.middlewareData.shift) != null && r.enabled.y && (S = v), E && !f) {
        const O = Ct(u.left, 0), q = Ct(u.right, 0), K = Ct(u.top, 0), j = Ct(u.bottom, 0);
        h ? C = m - 2 * (O !== 0 || q !== 0 ? O + q : Ct(u.left, u.right)) : S = p - 2 * (K !== 0 || j !== 0 ? K + j : Ct(u.top, u.bottom));
      }
      await l({
        ...e,
        availableWidth: C,
        availableHeight: S
      });
      const M = await s.getDimensions(a.floating);
      return m !== M.width || p !== M.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function uc() {
  return typeof window < "u";
}
function ci(t) {
  return w0(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function qt(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function Bn(t) {
  var e;
  return (e = (w0(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;
}
function w0(t) {
  return uc() ? t instanceof Node || t instanceof qt(t).Node : !1;
}
function vn(t) {
  return uc() ? t instanceof Element || t instanceof qt(t).Element : !1;
}
function Ln(t) {
  return uc() ? t instanceof HTMLElement || t instanceof qt(t).HTMLElement : !1;
}
function up(t) {
  return !uc() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof qt(t).ShadowRoot;
}
const UC = /* @__PURE__ */ new Set(["inline", "contents"]);
function ys(t) {
  const {
    overflow: e,
    overflowX: n,
    overflowY: r,
    display: o
  } = wn(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && !UC.has(o);
}
const WC = /* @__PURE__ */ new Set(["table", "td", "th"]);
function VC(t) {
  return WC.has(ci(t));
}
const KC = [":popover-open", ":modal"];
function dc(t) {
  return KC.some((e) => {
    try {
      return t.matches(e);
    } catch {
      return !1;
    }
  });
}
const qC = ["transform", "translate", "scale", "rotate", "perspective"], GC = ["transform", "translate", "scale", "rotate", "perspective", "filter"], jC = ["paint", "layout", "strict", "content"];
function Sf(t) {
  const e = Tf(), n = vn(t) ? wn(t) : t;
  return qC.some((r) => n[r] ? n[r] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !e && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !e && (n.filter ? n.filter !== "none" : !1) || GC.some((r) => (n.willChange || "").includes(r)) || jC.some((r) => (n.contain || "").includes(r));
}
function YC(t) {
  let e = _r(t);
  for (; Ln(e) && !ni(e); ) {
    if (Sf(e))
      return e;
    if (dc(e))
      return null;
    e = _r(e);
  }
  return null;
}
function Tf() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const XC = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function ni(t) {
  return XC.has(ci(t));
}
function wn(t) {
  return qt(t).getComputedStyle(t);
}
function fc(t) {
  return vn(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.scrollX,
    scrollTop: t.scrollY
  };
}
function _r(t) {
  if (ci(t) === "html")
    return t;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t.assignedSlot || // DOM Element detected.
    t.parentNode || // ShadowRoot detected.
    up(t) && t.host || // Fallback.
    Bn(t)
  );
  return up(e) ? e.host : e;
}
function k0(t) {
  const e = _r(t);
  return ni(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : Ln(e) && ys(e) ? e : k0(e);
}
function as(t, e, n) {
  var r;
  e === void 0 && (e = []), n === void 0 && (n = !0);
  const o = k0(t), i = o === ((r = t.ownerDocument) == null ? void 0 : r.body), s = qt(o);
  if (i) {
    const a = od(s);
    return e.concat(s, s.visualViewport || [], ys(o) ? o : [], a && n ? as(a) : []);
  }
  return e.concat(o, as(o, [], n));
}
function od(t) {
  return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null;
}
function x0(t) {
  const e = wn(t);
  let n = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0;
  const o = Ln(t), i = o ? t.offsetWidth : n, s = o ? t.offsetHeight : r, a = Va(n) !== i || Va(r) !== s;
  return a && (n = i, r = s), {
    width: n,
    height: r,
    $: a
  };
}
function Cf(t) {
  return vn(t) ? t : t.contextElement;
}
function Wo(t) {
  const e = Cf(t);
  if (!Ln(e))
    return On(1);
  const n = e.getBoundingClientRect(), {
    width: r,
    height: o,
    $: i
  } = x0(e);
  let s = (i ? Va(n.width) : n.width) / r, a = (i ? Va(n.height) : n.height) / o;
  return (!s || !Number.isFinite(s)) && (s = 1), (!a || !Number.isFinite(a)) && (a = 1), {
    x: s,
    y: a
  };
}
const ZC = /* @__PURE__ */ On(0);
function N0(t) {
  const e = qt(t);
  return !Tf() || !e.visualViewport ? ZC : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function JC(t, e, n) {
  return e === void 0 && (e = !1), !n || e && n !== qt(t) ? !1 : e;
}
function no(t, e, n, r) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  const o = t.getBoundingClientRect(), i = Cf(t);
  let s = On(1);
  e && (r ? vn(r) && (s = Wo(r)) : s = Wo(t));
  const a = JC(i, n, r) ? N0(i) : On(0);
  let l = (o.left + a.x) / s.x, c = (o.top + a.y) / s.y, u = o.width / s.x, d = o.height / s.y;
  if (i) {
    const f = qt(i), h = r && vn(r) ? qt(r) : r;
    let m = f, p = od(m);
    for (; p && r && h !== m; ) {
      const g = Wo(p), b = p.getBoundingClientRect(), v = wn(p), k = b.left + (p.clientLeft + parseFloat(v.paddingLeft)) * g.x, x = b.top + (p.clientTop + parseFloat(v.paddingTop)) * g.y;
      l *= g.x, c *= g.y, u *= g.x, d *= g.y, l += k, c += x, m = qt(p), p = od(m);
    }
  }
  return ei({
    width: u,
    height: d,
    x: l,
    y: c
  });
}
function hc(t, e) {
  const n = fc(t).scrollLeft;
  return e ? e.left + n : no(Bn(t)).left + n;
}
function E0(t, e) {
  const n = t.getBoundingClientRect(), r = n.left + e.scrollLeft - hc(t, n), o = n.top + e.scrollTop;
  return {
    x: r,
    y: o
  };
}
function QC(t) {
  let {
    elements: e,
    rect: n,
    offsetParent: r,
    strategy: o
  } = t;
  const i = o === "fixed", s = Bn(r), a = e ? dc(e.floating) : !1;
  if (r === s || a && i)
    return n;
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  }, c = On(1);
  const u = On(0), d = Ln(r);
  if ((d || !d && !i) && ((ci(r) !== "body" || ys(s)) && (l = fc(r)), Ln(r))) {
    const h = no(r);
    c = Wo(r), u.x = h.x + r.clientLeft, u.y = h.y + r.clientTop;
  }
  const f = s && !d && !i ? E0(s, l) : On(0);
  return {
    width: n.width * c.x,
    height: n.height * c.y,
    x: n.x * c.x - l.scrollLeft * c.x + u.x + f.x,
    y: n.y * c.y - l.scrollTop * c.y + u.y + f.y
  };
}
function eM(t) {
  return Array.from(t.getClientRects());
}
function tM(t) {
  const e = Bn(t), n = fc(t), r = t.ownerDocument.body, o = Ct(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth), i = Ct(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
  let s = -n.scrollLeft + hc(t);
  const a = -n.scrollTop;
  return wn(r).direction === "rtl" && (s += Ct(e.clientWidth, r.clientWidth) - o), {
    width: o,
    height: i,
    x: s,
    y: a
  };
}
const dp = 25;
function nM(t, e) {
  const n = qt(t), r = Bn(t), o = n.visualViewport;
  let i = r.clientWidth, s = r.clientHeight, a = 0, l = 0;
  if (o) {
    i = o.width, s = o.height;
    const u = Tf();
    (!u || u && e === "fixed") && (a = o.offsetLeft, l = o.offsetTop);
  }
  const c = hc(r);
  if (c <= 0) {
    const u = r.ownerDocument, d = u.body, f = getComputedStyle(d), h = u.compatMode === "CSS1Compat" && parseFloat(f.marginLeft) + parseFloat(f.marginRight) || 0, m = Math.abs(r.clientWidth - d.clientWidth - h);
    m <= dp && (i -= m);
  } else c <= dp && (i += c);
  return {
    width: i,
    height: s,
    x: a,
    y: l
  };
}
const rM = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function oM(t, e) {
  const n = no(t, !0, e === "fixed"), r = n.top + t.clientTop, o = n.left + t.clientLeft, i = Ln(t) ? Wo(t) : On(1), s = t.clientWidth * i.x, a = t.clientHeight * i.y, l = o * i.x, c = r * i.y;
  return {
    width: s,
    height: a,
    x: l,
    y: c
  };
}
function fp(t, e, n) {
  let r;
  if (e === "viewport")
    r = nM(t, n);
  else if (e === "document")
    r = tM(Bn(t));
  else if (vn(e))
    r = oM(e, n);
  else {
    const o = N0(t);
    r = {
      x: e.x - o.x,
      y: e.y - o.y,
      width: e.width,
      height: e.height
    };
  }
  return ei(r);
}
function S0(t, e) {
  const n = _r(t);
  return n === e || !vn(n) || ni(n) ? !1 : wn(n).position === "fixed" || S0(n, e);
}
function iM(t, e) {
  const n = e.get(t);
  if (n)
    return n;
  let r = as(t, [], !1).filter((a) => vn(a) && ci(a) !== "body"), o = null;
  const i = wn(t).position === "fixed";
  let s = i ? _r(t) : t;
  for (; vn(s) && !ni(s); ) {
    const a = wn(s), l = Sf(s);
    !l && a.position === "fixed" && (o = null), (i ? !l && !o : !l && a.position === "static" && !!o && rM.has(o.position) || ys(s) && !l && S0(t, s)) ? r = r.filter((u) => u !== s) : o = a, s = _r(s);
  }
  return e.set(t, r), r;
}
function sM(t) {
  let {
    element: e,
    boundary: n,
    rootBoundary: r,
    strategy: o
  } = t;
  const s = [...n === "clippingAncestors" ? dc(e) ? [] : iM(e, this._c) : [].concat(n), r], a = s[0], l = s.reduce((c, u) => {
    const d = fp(e, u, o);
    return c.top = Ct(d.top, c.top), c.right = bn(d.right, c.right), c.bottom = bn(d.bottom, c.bottom), c.left = Ct(d.left, c.left), c;
  }, fp(e, a, o));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function aM(t) {
  const {
    width: e,
    height: n
  } = x0(t);
  return {
    width: e,
    height: n
  };
}
function lM(t, e, n) {
  const r = Ln(e), o = Bn(e), i = n === "fixed", s = no(t, !0, i, e);
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = On(0);
  function c() {
    l.x = hc(o);
  }
  if (r || !r && !i)
    if ((ci(e) !== "body" || ys(o)) && (a = fc(e)), r) {
      const h = no(e, !0, i, e);
      l.x = h.x + e.clientLeft, l.y = h.y + e.clientTop;
    } else o && c();
  i && !r && o && c();
  const u = o && !r && !i ? E0(o, a) : On(0), d = s.left + a.scrollLeft - l.x - u.x, f = s.top + a.scrollTop - l.y - u.y;
  return {
    x: d,
    y: f,
    width: s.width,
    height: s.height
  };
}
function su(t) {
  return wn(t).position === "static";
}
function hp(t, e) {
  if (!Ln(t) || wn(t).position === "fixed")
    return null;
  if (e)
    return e(t);
  let n = t.offsetParent;
  return Bn(t) === n && (n = n.ownerDocument.body), n;
}
function T0(t, e) {
  const n = qt(t);
  if (dc(t))
    return n;
  if (!Ln(t)) {
    let o = _r(t);
    for (; o && !ni(o); ) {
      if (vn(o) && !su(o))
        return o;
      o = _r(o);
    }
    return n;
  }
  let r = hp(t, e);
  for (; r && VC(r) && su(r); )
    r = hp(r, e);
  return r && ni(r) && su(r) && !Sf(r) ? n : r || YC(t) || n;
}
const cM = async function(t) {
  const e = this.getOffsetParent || T0, n = this.getDimensions, r = await n(t.floating);
  return {
    reference: lM(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function uM(t) {
  return wn(t).direction === "rtl";
}
const dM = {
  convertOffsetParentRelativeRectToViewportRelativeRect: QC,
  getDocumentElement: Bn,
  getClippingRect: sM,
  getOffsetParent: T0,
  getElementRects: cM,
  getClientRects: eM,
  getDimensions: aM,
  getScale: Wo,
  isElement: vn,
  isRTL: uM
};
function C0(t, e) {
  return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height;
}
function fM(t, e) {
  let n = null, r;
  const o = Bn(t);
  function i() {
    var a;
    clearTimeout(r), (a = n) == null || a.disconnect(), n = null;
  }
  function s(a, l) {
    a === void 0 && (a = !1), l === void 0 && (l = 1), i();
    const c = t.getBoundingClientRect(), {
      left: u,
      top: d,
      width: f,
      height: h
    } = c;
    if (a || e(), !f || !h)
      return;
    const m = Gs(d), p = Gs(o.clientWidth - (u + f)), g = Gs(o.clientHeight - (d + h)), b = Gs(u), k = {
      rootMargin: -m + "px " + -p + "px " + -g + "px " + -b + "px",
      threshold: Ct(0, bn(1, l)) || 1
    };
    let x = !0;
    function w(E) {
      const S = E[0].intersectionRatio;
      if (S !== l) {
        if (!x)
          return s();
        S ? s(!1, S) : r = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      S === 1 && !C0(c, t.getBoundingClientRect()) && s(), x = !1;
    }
    try {
      n = new IntersectionObserver(w, {
        ...k,
        // Handle <iframe>s
        root: o.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(w, k);
    }
    n.observe(t);
  }
  return s(!0), i;
}
function hM(t, e, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: o = !0,
    ancestorResize: i = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: a = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = r, c = Cf(t), u = o || i ? [...c ? as(c) : [], ...as(e)] : [];
  u.forEach((b) => {
    o && b.addEventListener("scroll", n, {
      passive: !0
    }), i && b.addEventListener("resize", n);
  });
  const d = c && a ? fM(c, n) : null;
  let f = -1, h = null;
  s && (h = new ResizeObserver((b) => {
    let [v] = b;
    v && v.target === c && h && (h.unobserve(e), cancelAnimationFrame(f), f = requestAnimationFrame(() => {
      var k;
      (k = h) == null || k.observe(e);
    })), n();
  }), c && !l && h.observe(c), h.observe(e));
  let m, p = l ? no(t) : null;
  l && g();
  function g() {
    const b = no(t);
    p && !C0(p, b) && n(), p = b, m = requestAnimationFrame(g);
  }
  return n(), () => {
    var b;
    u.forEach((v) => {
      o && v.removeEventListener("scroll", n), i && v.removeEventListener("resize", n);
    }), d?.(), (b = h) == null || b.disconnect(), h = null, l && cancelAnimationFrame(m);
  };
}
const Mf = zC, M0 = OC, Af = $C, _f = IC, Rf = FC, Of = DC, Ga = _C, A0 = PC, mM = HC, If = (t, e, n) => {
  const r = /* @__PURE__ */ new Map(), o = {
    platform: dM,
    ...n
  }, i = {
    ...o.platform,
    _c: r
  };
  return AC(t, e, {
    ...o,
    platform: i
  });
};
let id, sd;
if (typeof WeakMap < "u") {
  let t = /* @__PURE__ */ new WeakMap();
  id = (e) => t.get(e), sd = (e, n) => (t.set(e, n), n);
} else {
  const t = [];
  let n = 0;
  id = (r) => {
    for (let o = 0; o < t.length; o += 2) if (t[o] == r) return t[o + 1];
  }, sd = (r, o) => (n == 10 && (n = 0), t[n++] = r, t[n++] = o);
}
var tt = class {
  constructor(t, e, n, r) {
    this.width = t, this.height = e, this.map = n, this.problems = r;
  }
  findCell(t) {
    for (let e = 0; e < this.map.length; e++) {
      const n = this.map[e];
      if (n != t) continue;
      const r = e % this.width, o = e / this.width | 0;
      let i = r + 1, s = o + 1;
      for (let a = 1; i < this.width && this.map[e + a] == n; a++) i++;
      for (let a = 1; s < this.height && this.map[e + this.width * a] == n; a++) s++;
      return {
        left: r,
        top: o,
        right: i,
        bottom: s
      };
    }
    throw new RangeError(`No cell with offset ${t} found`);
  }
  colCount(t) {
    for (let e = 0; e < this.map.length; e++) if (this.map[e] == t) return e % this.width;
    throw new RangeError(`No cell with offset ${t} found`);
  }
  nextCell(t, e, n) {
    const { left: r, right: o, top: i, bottom: s } = this.findCell(t);
    return e == "horiz" ? (n < 0 ? r == 0 : o == this.width) ? null : this.map[i * this.width + (n < 0 ? r - 1 : o)] : (n < 0 ? i == 0 : s == this.height) ? null : this.map[r + this.width * (n < 0 ? i - 1 : s)];
  }
  rectBetween(t, e) {
    const { left: n, right: r, top: o, bottom: i } = this.findCell(t), { left: s, right: a, top: l, bottom: c } = this.findCell(e);
    return {
      left: Math.min(n, s),
      top: Math.min(o, l),
      right: Math.max(r, a),
      bottom: Math.max(i, c)
    };
  }
  cellsInRect(t) {
    const e = [], n = {};
    for (let r = t.top; r < t.bottom; r++) for (let o = t.left; o < t.right; o++) {
      const i = r * this.width + o, s = this.map[i];
      n[s] || (n[s] = !0, !(o == t.left && o && this.map[i - 1] == s || r == t.top && r && this.map[i - this.width] == s) && e.push(s));
    }
    return e;
  }
  positionAt(t, e, n) {
    for (let r = 0, o = 0; ; r++) {
      const i = o + n.child(r).nodeSize;
      if (r == t) {
        let s = e + t * this.width;
        const a = (t + 1) * this.width;
        for (; s < a && this.map[s] < o; ) s++;
        return s == a ? i - 1 : this.map[s];
      }
      o = i;
    }
  }
  static get(t) {
    return id(t) || sd(t, pM(t));
  }
};
function pM(t) {
  if (t.type.spec.tableRole != "table") throw new RangeError("Not a table node: " + t.type.name);
  const e = gM(t), n = t.childCount, r = [];
  let o = 0, i = null;
  const s = [];
  for (let c = 0, u = e * n; c < u; c++) r[c] = 0;
  for (let c = 0, u = 0; c < n; c++) {
    const d = t.child(c);
    u++;
    for (let m = 0; ; m++) {
      for (; o < r.length && r[o] != 0; ) o++;
      if (m == d.childCount) break;
      const p = d.child(m), { colspan: g, rowspan: b, colwidth: v } = p.attrs;
      for (let k = 0; k < b; k++) {
        if (k + c >= n) {
          (i || (i = [])).push({
            type: "overlong_rowspan",
            pos: u,
            n: b - k
          });
          break;
        }
        const x = o + k * e;
        for (let w = 0; w < g; w++) {
          r[x + w] == 0 ? r[x + w] = u : (i || (i = [])).push({
            type: "collision",
            row: c,
            pos: u,
            n: g - w
          });
          const E = v && v[w];
          if (E) {
            const S = (x + w) % e * 2, C = s[S];
            C == null || C != E && s[S + 1] == 1 ? (s[S] = E, s[S + 1] = 1) : C == E && s[S + 1]++;
          }
        }
      }
      o += g, u += p.nodeSize;
    }
    const f = (c + 1) * e;
    let h = 0;
    for (; o < f; ) r[o++] == 0 && h++;
    h && (i || (i = [])).push({
      type: "missing",
      row: c,
      n: h
    }), u++;
  }
  (e === 0 || n === 0) && (i || (i = [])).push({ type: "zero_sized" });
  const a = new tt(e, n, r, i);
  let l = !1;
  for (let c = 0; !l && c < s.length; c += 2) s[c] != null && s[c + 1] < n && (l = !0);
  return l && bM(a, s, t), a;
}
function gM(t) {
  let e = -1, n = !1;
  for (let r = 0; r < t.childCount; r++) {
    const o = t.child(r);
    let i = 0;
    if (n) for (let s = 0; s < r; s++) {
      const a = t.child(s);
      for (let l = 0; l < a.childCount; l++) {
        const c = a.child(l);
        s + c.attrs.rowspan > r && (i += c.attrs.colspan);
      }
    }
    for (let s = 0; s < o.childCount; s++) {
      const a = o.child(s);
      i += a.attrs.colspan, a.attrs.rowspan > 1 && (n = !0);
    }
    e == -1 ? e = i : e != i && (e = Math.max(e, i));
  }
  return e;
}
function bM(t, e, n) {
  t.problems || (t.problems = []);
  const r = {};
  for (let o = 0; o < t.map.length; o++) {
    const i = t.map[o];
    if (r[i]) continue;
    r[i] = !0;
    const s = n.nodeAt(i);
    if (!s) throw new RangeError(`No cell with offset ${i} found`);
    let a = null;
    const l = s.attrs;
    for (let c = 0; c < l.colspan; c++) {
      const u = e[(o + c) % t.width * 2];
      u != null && (!l.colwidth || l.colwidth[c] != u) && ((a || (a = yM(l)))[c] = u);
    }
    a && t.problems.unshift({
      type: "colwidth mismatch",
      pos: i,
      colwidth: a
    });
  }
}
function yM(t) {
  if (t.colwidth) return t.colwidth.slice();
  const e = [];
  for (let n = 0; n < t.colspan; n++) e.push(0);
  return e;
}
function Mt(t) {
  let e = t.cached.tableNodeTypes;
  if (!e) {
    e = t.cached.tableNodeTypes = {};
    for (const n in t.nodes) {
      const r = t.nodes[n], o = r.spec.tableRole;
      o && (e[o] = r);
    }
  }
  return e;
}
const br = new Ie("selectingCells");
function ro(t) {
  for (let e = t.depth - 1; e > 0; e--) if (t.node(e).type.spec.tableRole == "row") return t.node(0).resolve(t.before(e + 1));
  return null;
}
function vM(t) {
  for (let e = t.depth; e > 0; e--) {
    const n = t.node(e).type.spec.tableRole;
    if (n === "cell" || n === "header_cell") return t.node(e);
  }
  return null;
}
function xn(t) {
  const e = t.selection.$head;
  for (let n = e.depth; n > 0; n--) if (e.node(n).type.spec.tableRole == "row") return !0;
  return !1;
}
function mc(t) {
  const e = t.selection;
  if ("$anchorCell" in e && e.$anchorCell) return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell;
  if ("node" in e && e.node && e.node.type.spec.tableRole == "cell") return e.$anchor;
  const n = ro(e.$head) || wM(e.$head);
  if (n) return n;
  throw new RangeError(`No cell found around position ${e.head}`);
}
function wM(t) {
  for (let e = t.nodeAfter, n = t.pos; e; e = e.firstChild, n++) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell") return t.doc.resolve(n);
  }
  for (let e = t.nodeBefore, n = t.pos; e; e = e.lastChild, n--) {
    const r = e.type.spec.tableRole;
    if (r == "cell" || r == "header_cell") return t.doc.resolve(n - e.nodeSize);
  }
}
function ad(t) {
  return t.parent.type.spec.tableRole == "row" && !!t.nodeAfter;
}
function kM(t) {
  return t.node(0).resolve(t.pos + t.nodeAfter.nodeSize);
}
function Df(t, e) {
  return t.depth == e.depth && t.pos >= e.start(-1) && t.pos <= e.end(-1);
}
function _0(t, e, n) {
  const r = t.node(-1), o = tt.get(r), i = t.start(-1), s = o.nextCell(t.pos - i, e, n);
  return s == null ? null : t.node(0).resolve(i + s);
}
function oo(t, e, n = 1) {
  const r = {
    ...t,
    colspan: t.colspan - n
  };
  return r.colwidth && (r.colwidth = r.colwidth.slice(), r.colwidth.splice(e, n), r.colwidth.some((o) => o > 0) || (r.colwidth = null)), r;
}
function R0(t, e, n = 1) {
  const r = {
    ...t,
    colspan: t.colspan + n
  };
  if (r.colwidth) {
    r.colwidth = r.colwidth.slice();
    for (let o = 0; o < n; o++) r.colwidth.splice(e, 0, 0);
  }
  return r;
}
function xM(t, e, n) {
  const r = Mt(e.type.schema).header_cell;
  for (let o = 0; o < t.height; o++) if (e.nodeAt(t.map[n + o * t.width]).type != r) return !1;
  return !0;
}
var Ke = class qn extends pe {
  constructor(e, n = e) {
    const r = e.node(-1), o = tt.get(r), i = e.start(-1), s = o.rectBetween(e.pos - i, n.pos - i), a = e.node(0), l = o.cellsInRect(s).filter((u) => u != n.pos - i);
    l.unshift(n.pos - i);
    const c = l.map((u) => {
      const d = r.nodeAt(u);
      if (!d) throw new RangeError(`No cell with offset ${u} found`);
      const f = i + u + 1;
      return new Bb(a.resolve(f), a.resolve(f + d.content.size));
    });
    super(c[0].$from, c[0].$to, c), this.$anchorCell = e, this.$headCell = n;
  }
  map(e, n) {
    const r = e.resolve(n.map(this.$anchorCell.pos)), o = e.resolve(n.map(this.$headCell.pos));
    if (ad(r) && ad(o) && Df(r, o)) {
      const i = this.$anchorCell.node(-1) != r.node(-1);
      return i && this.isRowSelection() ? qn.rowSelection(r, o) : i && this.isColSelection() ? qn.colSelection(r, o) : new qn(r, o);
    }
    return ce.between(r, o);
  }
  content() {
    const e = this.$anchorCell.node(-1), n = tt.get(e), r = this.$anchorCell.start(-1), o = n.rectBetween(this.$anchorCell.pos - r, this.$headCell.pos - r), i = {}, s = [];
    for (let l = o.top; l < o.bottom; l++) {
      const c = [];
      for (let u = l * n.width + o.left, d = o.left; d < o.right; d++, u++) {
        const f = n.map[u];
        if (i[f]) continue;
        i[f] = !0;
        const h = n.findCell(f);
        let m = e.nodeAt(f);
        if (!m) throw new RangeError(`No cell with offset ${f} found`);
        const p = o.left - h.left, g = h.right - o.right;
        if (p > 0 || g > 0) {
          let b = m.attrs;
          if (p > 0 && (b = oo(b, 0, p)), g > 0 && (b = oo(b, b.colspan - g, g)), h.left < o.left) {
            if (m = m.type.createAndFill(b), !m) throw new RangeError(`Could not create cell with attrs ${JSON.stringify(b)}`);
          } else m = m.type.create(b, m.content);
        }
        if (h.top < o.top || h.bottom > o.bottom) {
          const b = {
            ...m.attrs,
            rowspan: Math.min(h.bottom, o.bottom) - Math.max(h.top, o.top)
          };
          h.top < o.top ? m = m.type.createAndFill(b) : m = m.type.create(b, m.content);
        }
        c.push(m);
      }
      s.push(e.child(l).copy(D.from(c)));
    }
    const a = this.isColSelection() && this.isRowSelection() ? e : s;
    return new Y(D.from(a), 1, 1);
  }
  replace(e, n = Y.empty) {
    const r = e.steps.length, o = this.ranges;
    for (let s = 0; s < o.length; s++) {
      const { $from: a, $to: l } = o[s], c = e.mapping.slice(r);
      e.replace(c.map(a.pos), c.map(l.pos), s ? Y.empty : n);
    }
    const i = pe.findFrom(e.doc.resolve(e.mapping.slice(r).map(this.to)), -1);
    i && e.setSelection(i);
  }
  replaceWith(e, n) {
    this.replace(e, new Y(D.from(n), 0, 0));
  }
  forEachCell(e) {
    const n = this.$anchorCell.node(-1), r = tt.get(n), o = this.$anchorCell.start(-1), i = r.cellsInRect(r.rectBetween(this.$anchorCell.pos - o, this.$headCell.pos - o));
    for (let s = 0; s < i.length; s++) e(n.nodeAt(i[s]), o + i[s]);
  }
  isColSelection() {
    const e = this.$anchorCell.index(-1), n = this.$headCell.index(-1);
    if (Math.min(e, n) > 0) return !1;
    const r = e + this.$anchorCell.nodeAfter.attrs.rowspan, o = n + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(r, o) == this.$headCell.node(-1).childCount;
  }
  static colSelection(e, n = e) {
    const r = e.node(-1), o = tt.get(r), i = e.start(-1), s = o.findCell(e.pos - i), a = o.findCell(n.pos - i), l = e.node(0);
    return s.top <= a.top ? (s.top > 0 && (e = l.resolve(i + o.map[s.left])), a.bottom < o.height && (n = l.resolve(i + o.map[o.width * (o.height - 1) + a.right - 1]))) : (a.top > 0 && (n = l.resolve(i + o.map[a.left])), s.bottom < o.height && (e = l.resolve(i + o.map[o.width * (o.height - 1) + s.right - 1]))), new qn(e, n);
  }
  isRowSelection() {
    const e = this.$anchorCell.node(-1), n = tt.get(e), r = this.$anchorCell.start(-1), o = n.colCount(this.$anchorCell.pos - r), i = n.colCount(this.$headCell.pos - r);
    if (Math.min(o, i) > 0) return !1;
    const s = o + this.$anchorCell.nodeAfter.attrs.colspan, a = i + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(s, a) == n.width;
  }
  eq(e) {
    return e instanceof qn && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos;
  }
  static rowSelection(e, n = e) {
    const r = e.node(-1), o = tt.get(r), i = e.start(-1), s = o.findCell(e.pos - i), a = o.findCell(n.pos - i), l = e.node(0);
    return s.left <= a.left ? (s.left > 0 && (e = l.resolve(i + o.map[s.top * o.width])), a.right < o.width && (n = l.resolve(i + o.map[o.width * (a.top + 1) - 1]))) : (a.left > 0 && (n = l.resolve(i + o.map[a.top * o.width])), s.right < o.width && (e = l.resolve(i + o.map[o.width * (s.top + 1) - 1]))), new qn(e, n);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(e, n) {
    return new qn(e.resolve(n.anchor), e.resolve(n.head));
  }
  static create(e, n, r = n) {
    return new qn(e.resolve(n), e.resolve(r));
  }
  getBookmark() {
    return new NM(this.$anchorCell.pos, this.$headCell.pos);
  }
};
Ke.prototype.visible = !1;
pe.jsonID("cell", Ke);
var NM = class O0 {
  constructor(e, n) {
    this.anchor = e, this.head = n;
  }
  map(e) {
    return new O0(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    const n = e.resolve(this.anchor), r = e.resolve(this.head);
    return n.parent.type.spec.tableRole == "row" && r.parent.type.spec.tableRole == "row" && n.index() < n.parent.childCount && r.index() < r.parent.childCount && Df(n, r) ? new Ke(n, r) : pe.near(r, 1);
  }
};
function EM(t) {
  if (!(t.selection instanceof Ke)) return null;
  const e = [];
  return t.selection.forEachCell((n, r) => {
    e.push(Ve.node(r, r + n.nodeSize, { class: "selectedCell" }));
  }), Te.create(t.doc, e);
}
function SM({ $from: t, $to: e }) {
  if (t.pos == e.pos || t.pos < e.pos - 6) return !1;
  let n = t.pos, r = e.pos, o = t.depth;
  for (; o >= 0 && !(t.after(o + 1) < t.end(o)); o--, n++) ;
  for (let i = e.depth; i >= 0 && !(e.before(i + 1) > e.start(i)); i--, r--) ;
  return n == r && /row|table/.test(t.node(o).type.spec.tableRole);
}
function TM({ $from: t, $to: e }) {
  let n, r;
  for (let o = t.depth; o > 0; o--) {
    const i = t.node(o);
    if (i.type.spec.tableRole === "cell" || i.type.spec.tableRole === "header_cell") {
      n = i;
      break;
    }
  }
  for (let o = e.depth; o > 0; o--) {
    const i = e.node(o);
    if (i.type.spec.tableRole === "cell" || i.type.spec.tableRole === "header_cell") {
      r = i;
      break;
    }
  }
  return n !== r && e.parentOffset === 0;
}
function CM(t, e, n) {
  const r = (e || t).selection, o = (e || t).doc;
  let i, s;
  if (r instanceof se && (s = r.node.type.spec.tableRole)) {
    if (s == "cell" || s == "header_cell") i = Ke.create(o, r.from);
    else if (s == "row") {
      const a = o.resolve(r.from + 1);
      i = Ke.rowSelection(a, a);
    } else if (!n) {
      const a = tt.get(r.node), l = r.from + 1, c = l + a.map[a.width * a.height - 1];
      i = Ke.create(o, l + 1, c);
    }
  } else r instanceof ce && SM(r) ? i = ce.create(o, r.from) : r instanceof ce && TM(r) && (i = ce.create(o, r.$from.start(), r.$from.end()));
  return i && (e || (e = t.tr)).setSelection(i), e;
}
const MM = new Ie("fix-tables");
function I0(t, e, n, r) {
  const o = t.childCount, i = e.childCount;
  e: for (let s = 0, a = 0; s < i; s++) {
    const l = e.child(s);
    for (let c = a, u = Math.min(o, s + 3); c < u; c++) if (t.child(c) == l) {
      a = c + 1, n += l.nodeSize;
      continue e;
    }
    r(l, n), a < o && t.child(a).sameMarkup(l) ? I0(t.child(a), l, n + 1, r) : l.nodesBetween(0, l.content.size, r, n + 1), n += l.nodeSize;
  }
}
function D0(t, e) {
  let n;
  const r = (o, i) => {
    o.type.spec.tableRole == "table" && (n = AM(t, o, i, n));
  };
  return e ? e.doc != t.doc && I0(e.doc, t.doc, 0, r) : t.doc.descendants(r), n;
}
function AM(t, e, n, r) {
  const o = tt.get(e);
  if (!o.problems) return r;
  r || (r = t.tr);
  const i = [];
  for (let l = 0; l < o.height; l++) i.push(0);
  for (let l = 0; l < o.problems.length; l++) {
    const c = o.problems[l];
    if (c.type == "collision") {
      const u = e.nodeAt(c.pos);
      if (!u) continue;
      const d = u.attrs;
      for (let f = 0; f < d.rowspan; f++) i[c.row + f] += c.n;
      r.setNodeMarkup(r.mapping.map(n + 1 + c.pos), null, oo(d, d.colspan - c.n, c.n));
    } else if (c.type == "missing") i[c.row] += c.n;
    else if (c.type == "overlong_rowspan") {
      const u = e.nodeAt(c.pos);
      if (!u) continue;
      r.setNodeMarkup(r.mapping.map(n + 1 + c.pos), null, {
        ...u.attrs,
        rowspan: u.attrs.rowspan - c.n
      });
    } else if (c.type == "colwidth mismatch") {
      const u = e.nodeAt(c.pos);
      if (!u) continue;
      r.setNodeMarkup(r.mapping.map(n + 1 + c.pos), null, {
        ...u.attrs,
        colwidth: c.colwidth
      });
    } else if (c.type == "zero_sized") {
      const u = r.mapping.map(n);
      r.delete(u, u + e.nodeSize);
    }
  }
  let s, a;
  for (let l = 0; l < i.length; l++) i[l] && (s == null && (s = l), a = l);
  for (let l = 0, c = n + 1; l < o.height; l++) {
    const u = e.child(l), d = c + u.nodeSize, f = i[l];
    if (f > 0) {
      let h = "cell";
      u.firstChild && (h = u.firstChild.type.spec.tableRole);
      const m = [];
      for (let g = 0; g < f; g++) {
        const b = Mt(t.schema)[h].createAndFill();
        b && m.push(b);
      }
      const p = (l == 0 || s == l - 1) && a == l ? c + 1 : d - 1;
      r.insert(r.mapping.map(p), m);
    }
    c = d;
  }
  return r.setMeta(MM, { fixTables: !0 });
}
function zn(t) {
  const e = t.selection, n = mc(t), r = n.node(-1), o = n.start(-1), i = tt.get(r);
  return {
    ...e instanceof Ke ? i.rectBetween(e.$anchorCell.pos - o, e.$headCell.pos - o) : i.findCell(n.pos - o),
    tableStart: o,
    map: i,
    table: r
  };
}
function L0(t, { map: e, tableStart: n, table: r }, o) {
  let i = o > 0 ? -1 : 0;
  xM(e, r, o + i) && (i = o == 0 || o == e.width ? null : 0);
  for (let s = 0; s < e.height; s++) {
    const a = s * e.width + o;
    if (o > 0 && o < e.width && e.map[a - 1] == e.map[a]) {
      const l = e.map[a], c = r.nodeAt(l);
      t.setNodeMarkup(t.mapping.map(n + l), null, R0(c.attrs, o - e.colCount(l))), s += c.attrs.rowspan - 1;
    } else {
      const l = i == null ? Mt(r.type.schema).cell : r.nodeAt(e.map[a + i]).type, c = e.positionAt(s, o, r);
      t.insert(t.mapping.map(n + c), l.createAndFill());
    }
  }
  return t;
}
function _M(t, e) {
  if (!xn(t)) return !1;
  if (e) {
    const n = zn(t);
    e(L0(t.tr, n, n.left));
  }
  return !0;
}
function RM(t, e) {
  if (!xn(t)) return !1;
  if (e) {
    const n = zn(t);
    e(L0(t.tr, n, n.right));
  }
  return !0;
}
function OM(t, { map: e, table: n, tableStart: r }, o) {
  const i = t.mapping.maps.length;
  for (let s = 0; s < e.height; ) {
    const a = s * e.width + o, l = e.map[a], c = n.nodeAt(l), u = c.attrs;
    if (o > 0 && e.map[a - 1] == l || o < e.width - 1 && e.map[a + 1] == l) t.setNodeMarkup(t.mapping.slice(i).map(r + l), null, oo(u, o - e.colCount(l)));
    else {
      const d = t.mapping.slice(i).map(r + l);
      t.delete(d, d + c.nodeSize);
    }
    s += u.rowspan;
  }
}
function IM(t, e) {
  if (!xn(t)) return !1;
  if (e) {
    const n = zn(t), r = t.tr;
    if (n.left == 0 && n.right == n.map.width) return !1;
    for (let o = n.right - 1; OM(r, n, o), o != n.left; o--) {
      const i = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
      if (!i) throw new RangeError("No table found");
      n.table = i, n.map = tt.get(i);
    }
    e(r);
  }
  return !0;
}
function DM(t, e, n) {
  var r;
  const o = Mt(e.type.schema).header_cell;
  for (let i = 0; i < t.width; i++) if (((r = e.nodeAt(t.map[i + n * t.width])) === null || r === void 0 ? void 0 : r.type) != o) return !1;
  return !0;
}
function P0(t, { map: e, tableStart: n, table: r }, o) {
  let i = n;
  for (let c = 0; c < o; c++) i += r.child(c).nodeSize;
  const s = [];
  let a = o > 0 ? -1 : 0;
  DM(e, r, o + a) && (a = o == 0 || o == e.height ? null : 0);
  for (let c = 0, u = e.width * o; c < e.width; c++, u++) if (o > 0 && o < e.height && e.map[u] == e.map[u - e.width]) {
    const d = e.map[u], f = r.nodeAt(d).attrs;
    t.setNodeMarkup(n + d, null, {
      ...f,
      rowspan: f.rowspan + 1
    }), c += f.colspan - 1;
  } else {
    var l;
    const d = a == null ? Mt(r.type.schema).cell : (l = r.nodeAt(e.map[u + a * e.width])) === null || l === void 0 ? void 0 : l.type, f = d?.createAndFill();
    f && s.push(f);
  }
  return t.insert(i, Mt(r.type.schema).row.create(null, s)), t;
}
function LM(t, e) {
  if (!xn(t)) return !1;
  if (e) {
    const n = zn(t);
    e(P0(t.tr, n, n.top));
  }
  return !0;
}
function PM(t, e) {
  if (!xn(t)) return !1;
  if (e) {
    const n = zn(t);
    e(P0(t.tr, n, n.bottom));
  }
  return !0;
}
function BM(t, { map: e, table: n, tableStart: r }, o) {
  let i = 0;
  for (let c = 0; c < o; c++) i += n.child(c).nodeSize;
  const s = i + n.child(o).nodeSize, a = t.mapping.maps.length;
  t.delete(i + r, s + r);
  const l = /* @__PURE__ */ new Set();
  for (let c = 0, u = o * e.width; c < e.width; c++, u++) {
    const d = e.map[u];
    if (!l.has(d)) {
      if (l.add(d), o > 0 && d == e.map[u - e.width]) {
        const f = n.nodeAt(d).attrs;
        t.setNodeMarkup(t.mapping.slice(a).map(d + r), null, {
          ...f,
          rowspan: f.rowspan - 1
        }), c += f.colspan - 1;
      } else if (o < e.height && d == e.map[u + e.width]) {
        const f = n.nodeAt(d), h = f.attrs, m = f.type.create({
          ...h,
          rowspan: f.attrs.rowspan - 1
        }, f.content), p = e.positionAt(o + 1, c, n);
        t.insert(t.mapping.slice(a).map(r + p), m), c += h.colspan - 1;
      }
    }
  }
}
function zM(t, e) {
  if (!xn(t)) return !1;
  if (e) {
    const n = zn(t), r = t.tr;
    if (n.top == 0 && n.bottom == n.map.height) return !1;
    for (let o = n.bottom - 1; BM(r, n, o), o != n.top; o--) {
      const i = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
      if (!i) throw new RangeError("No table found");
      n.table = i, n.map = tt.get(n.table);
    }
    e(r);
  }
  return !0;
}
function mp(t) {
  const e = t.content;
  return e.childCount == 1 && e.child(0).isTextblock && e.child(0).childCount == 0;
}
function $M({ width: t, height: e, map: n }, r) {
  let o = r.top * t + r.left, i = o, s = (r.bottom - 1) * t + r.left, a = o + (r.right - r.left - 1);
  for (let l = r.top; l < r.bottom; l++) {
    if (r.left > 0 && n[i] == n[i - 1] || r.right < t && n[a] == n[a + 1]) return !0;
    i += t, a += t;
  }
  for (let l = r.left; l < r.right; l++) {
    if (r.top > 0 && n[o] == n[o - t] || r.bottom < e && n[s] == n[s + t]) return !0;
    o++, s++;
  }
  return !1;
}
function pp(t, e) {
  const n = t.selection;
  if (!(n instanceof Ke) || n.$anchorCell.pos == n.$headCell.pos) return !1;
  const r = zn(t), { map: o } = r;
  if ($M(o, r)) return !1;
  if (e) {
    const i = t.tr, s = {};
    let a = D.empty, l, c;
    for (let u = r.top; u < r.bottom; u++) for (let d = r.left; d < r.right; d++) {
      const f = o.map[u * o.width + d], h = r.table.nodeAt(f);
      if (!(s[f] || !h))
        if (s[f] = !0, l == null)
          l = f, c = h;
        else {
          mp(h) || (a = a.append(h.content));
          const m = i.mapping.map(f + r.tableStart);
          i.delete(m, m + h.nodeSize);
        }
    }
    if (l == null || c == null) return !0;
    if (i.setNodeMarkup(l + r.tableStart, null, {
      ...R0(c.attrs, c.attrs.colspan, r.right - r.left - c.attrs.colspan),
      rowspan: r.bottom - r.top
    }), a.size > 0) {
      const u = l + 1 + c.content.size, d = mp(c) ? l + 1 : u;
      i.replaceWith(d + r.tableStart, u + r.tableStart, a);
    }
    i.setSelection(new Ke(i.doc.resolve(l + r.tableStart))), e(i);
  }
  return !0;
}
function gp(t, e) {
  const n = Mt(t.schema);
  return HM(({ node: r }) => n[r.type.spec.tableRole])(t, e);
}
function HM(t) {
  return (e, n) => {
    const r = e.selection;
    let o, i;
    if (r instanceof Ke) {
      if (r.$anchorCell.pos != r.$headCell.pos) return !1;
      o = r.$anchorCell.nodeAfter, i = r.$anchorCell.pos;
    } else {
      var s;
      if (o = vM(r.$from), !o) return !1;
      i = (s = ro(r.$from)) === null || s === void 0 ? void 0 : s.pos;
    }
    if (o == null || i == null || o.attrs.colspan == 1 && o.attrs.rowspan == 1) return !1;
    if (n) {
      let a = o.attrs;
      const l = [], c = a.colwidth;
      a.rowspan > 1 && (a = {
        ...a,
        rowspan: 1
      }), a.colspan > 1 && (a = {
        ...a,
        colspan: 1
      });
      const u = zn(e), d = e.tr;
      for (let h = 0; h < u.right - u.left; h++) l.push(c ? {
        ...a,
        colwidth: c && c[h] ? [c[h]] : null
      } : a);
      let f;
      for (let h = u.top; h < u.bottom; h++) {
        let m = u.map.positionAt(h, u.left, u.table);
        h == u.top && (m += o.nodeSize);
        for (let p = u.left, g = 0; p < u.right; p++, g++)
          p == u.left && h == u.top || d.insert(f = d.mapping.map(m + u.tableStart, 1), t({
            node: o,
            row: h,
            col: p
          }).createAndFill(l[g]));
      }
      d.setNodeMarkup(i, t({
        node: o,
        row: u.top,
        col: u.left
      }), l[0]), r instanceof Ke && d.setSelection(new Ke(d.doc.resolve(r.$anchorCell.pos), f ? d.doc.resolve(f) : void 0)), n(d);
    }
    return !0;
  };
}
function FM(t, e) {
  return function(n, r) {
    if (!xn(n)) return !1;
    const o = mc(n);
    if (o.nodeAfter.attrs[t] === e) return !1;
    if (r) {
      const i = n.tr;
      n.selection instanceof Ke ? n.selection.forEachCell((s, a) => {
        s.attrs[t] !== e && i.setNodeMarkup(a, null, {
          ...s.attrs,
          [t]: e
        });
      }) : i.setNodeMarkup(o.pos, null, {
        ...o.nodeAfter.attrs,
        [t]: e
      }), r(i);
    }
    return !0;
  };
}
function UM(t) {
  return function(e, n) {
    if (!xn(e)) return !1;
    if (n) {
      const r = Mt(e.schema), o = zn(e), i = e.tr, s = o.map.cellsInRect(t == "column" ? {
        left: o.left,
        top: 0,
        right: o.right,
        bottom: o.map.height
      } : t == "row" ? {
        left: 0,
        top: o.top,
        right: o.map.width,
        bottom: o.bottom
      } : o), a = s.map((l) => o.table.nodeAt(l));
      for (let l = 0; l < s.length; l++) a[l].type == r.header_cell && i.setNodeMarkup(o.tableStart + s[l], r.cell, a[l].attrs);
      if (i.steps.length === 0) for (let l = 0; l < s.length; l++) i.setNodeMarkup(o.tableStart + s[l], r.header_cell, a[l].attrs);
      n(i);
    }
    return !0;
  };
}
function bp(t, e, n) {
  const r = e.map.cellsInRect({
    left: 0,
    top: 0,
    right: t == "row" ? e.map.width : 1,
    bottom: t == "column" ? e.map.height : 1
  });
  for (let o = 0; o < r.length; o++) {
    const i = e.table.nodeAt(r[o]);
    if (i && i.type !== n.header_cell) return !1;
  }
  return !0;
}
function ls(t, e) {
  return e = e || { useDeprecatedLogic: !1 }, e.useDeprecatedLogic ? UM(t) : function(n, r) {
    if (!xn(n)) return !1;
    if (r) {
      const o = Mt(n.schema), i = zn(n), s = n.tr, a = bp("row", i, o), l = bp("column", i, o), c = (t === "column" ? a : t === "row" && l) ? 1 : 0, u = t == "column" ? {
        left: 0,
        top: c,
        right: 1,
        bottom: i.map.height
      } : t == "row" ? {
        left: c,
        top: 0,
        right: i.map.width,
        bottom: 1
      } : i, d = t == "column" ? l ? o.cell : o.header_cell : t == "row" ? a ? o.cell : o.header_cell : o.cell;
      i.map.cellsInRect(u).forEach((f) => {
        const h = f + i.tableStart, m = s.doc.nodeAt(h);
        m && s.setNodeMarkup(h, d, m.attrs);
      }), r(s);
    }
    return !0;
  };
}
ls("row", { useDeprecatedLogic: !0 });
ls("column", { useDeprecatedLogic: !0 });
const WM = ls("cell", { useDeprecatedLogic: !0 });
function VM(t, e) {
  if (e < 0) {
    const n = t.nodeBefore;
    if (n) return t.pos - n.nodeSize;
    for (let r = t.index(-1) - 1, o = t.before(); r >= 0; r--) {
      const i = t.node(-1).child(r), s = i.lastChild;
      if (s) return o - 1 - s.nodeSize;
      o -= i.nodeSize;
    }
  } else {
    if (t.index() < t.parent.childCount - 1) return t.pos + t.nodeAfter.nodeSize;
    const n = t.node(-1);
    for (let r = t.indexAfter(-1), o = t.after(); r < n.childCount; r++) {
      const i = n.child(r);
      if (i.childCount) return o + 1;
      o += i.nodeSize;
    }
  }
  return null;
}
function yp(t) {
  return function(e, n) {
    if (!xn(e)) return !1;
    const r = VM(mc(e), t);
    if (r == null) return !1;
    if (n) {
      const o = e.doc.resolve(r);
      n(e.tr.setSelection(ce.between(o, kM(o))).scrollIntoView());
    }
    return !0;
  };
}
function KM(t, e) {
  const n = t.selection.$anchor;
  for (let r = n.depth; r > 0; r--) if (n.node(r).type.spec.tableRole == "table")
    return e && e(t.tr.delete(n.before(r), n.after(r)).scrollIntoView()), !0;
  return !1;
}
function js(t, e) {
  const n = t.selection;
  if (!(n instanceof Ke)) return !1;
  if (e) {
    const r = t.tr, o = Mt(t.schema).cell.createAndFill().content;
    n.forEachCell((i, s) => {
      i.content.eq(o) || r.replace(r.mapping.map(s + 1), r.mapping.map(s + i.nodeSize - 1), new Y(o, 0, 0));
    }), r.docChanged && e(r);
  }
  return !0;
}
function qM(t) {
  if (t.size === 0) return null;
  let { content: e, openStart: n, openEnd: r } = t;
  for (; e.childCount == 1 && (n > 0 && r > 0 || e.child(0).type.spec.tableRole == "table"); )
    n--, r--, e = e.child(0).content;
  const o = e.child(0), i = o.type.spec.tableRole, s = o.type.schema, a = [];
  if (i == "row") for (let l = 0; l < e.childCount; l++) {
    let c = e.child(l).content;
    const u = l ? 0 : Math.max(0, n - 1), d = l < e.childCount - 1 ? 0 : Math.max(0, r - 1);
    (u || d) && (c = ld(Mt(s).row, new Y(c, u, d)).content), a.push(c);
  }
  else if (i == "cell" || i == "header_cell") a.push(n || r ? ld(Mt(s).row, new Y(e, n, r)).content : e);
  else return null;
  return GM(s, a);
}
function GM(t, e) {
  const n = [];
  for (let o = 0; o < e.length; o++) {
    const i = e[o];
    for (let s = i.childCount - 1; s >= 0; s--) {
      const { rowspan: a, colspan: l } = i.child(s).attrs;
      for (let c = o; c < o + a; c++) n[c] = (n[c] || 0) + l;
    }
  }
  let r = 0;
  for (let o = 0; o < n.length; o++) r = Math.max(r, n[o]);
  for (let o = 0; o < n.length; o++)
    if (o >= e.length && e.push(D.empty), n[o] < r) {
      const i = Mt(t).cell.createAndFill(), s = [];
      for (let a = n[o]; a < r; a++) s.push(i);
      e[o] = e[o].append(D.from(s));
    }
  return {
    height: e.length,
    width: r,
    rows: e
  };
}
function ld(t, e) {
  const n = t.createAndFill();
  return new Kd(n).replace(0, n.content.size, e).doc;
}
function jM({ width: t, height: e, rows: n }, r, o) {
  if (t != r) {
    const i = [], s = [];
    for (let a = 0; a < n.length; a++) {
      const l = n[a], c = [];
      for (let u = i[a] || 0, d = 0; u < r; d++) {
        let f = l.child(d % l.childCount);
        u + f.attrs.colspan > r && (f = f.type.createChecked(oo(f.attrs, f.attrs.colspan, u + f.attrs.colspan - r), f.content)), c.push(f), u += f.attrs.colspan;
        for (let h = 1; h < f.attrs.rowspan; h++) i[a + h] = (i[a + h] || 0) + f.attrs.colspan;
      }
      s.push(D.from(c));
    }
    n = s, t = r;
  }
  if (e != o) {
    const i = [];
    for (let s = 0, a = 0; s < o; s++, a++) {
      const l = [], c = n[a % e];
      for (let u = 0; u < c.childCount; u++) {
        let d = c.child(u);
        s + d.attrs.rowspan > o && (d = d.type.create({
          ...d.attrs,
          rowspan: Math.max(1, o - d.attrs.rowspan)
        }, d.content)), l.push(d);
      }
      i.push(D.from(l));
    }
    n = i, e = o;
  }
  return {
    width: t,
    height: e,
    rows: n
  };
}
function YM(t, e, n, r, o, i, s) {
  const a = t.doc.type.schema, l = Mt(a);
  let c, u;
  if (o > e.width) for (let d = 0, f = 0; d < e.height; d++) {
    const h = n.child(d);
    f += h.nodeSize;
    const m = [];
    let p;
    h.lastChild == null || h.lastChild.type == l.cell ? p = c || (c = l.cell.createAndFill()) : p = u || (u = l.header_cell.createAndFill());
    for (let g = e.width; g < o; g++) m.push(p);
    t.insert(t.mapping.slice(s).map(f - 1 + r), m);
  }
  if (i > e.height) {
    const d = [];
    for (let m = 0, p = (e.height - 1) * e.width; m < Math.max(e.width, o); m++) {
      const g = m >= e.width ? !1 : n.nodeAt(e.map[p + m]).type == l.header_cell;
      d.push(g ? u || (u = l.header_cell.createAndFill()) : c || (c = l.cell.createAndFill()));
    }
    const f = l.row.create(null, D.from(d)), h = [];
    for (let m = e.height; m < i; m++) h.push(f);
    t.insert(t.mapping.slice(s).map(r + n.nodeSize - 2), h);
  }
  return !!(c || u);
}
function vp(t, e, n, r, o, i, s, a) {
  if (s == 0 || s == e.height) return !1;
  let l = !1;
  for (let c = o; c < i; c++) {
    const u = s * e.width + c, d = e.map[u];
    if (e.map[u - e.width] == d) {
      l = !0;
      const f = n.nodeAt(d), { top: h, left: m } = e.findCell(d);
      t.setNodeMarkup(t.mapping.slice(a).map(d + r), null, {
        ...f.attrs,
        rowspan: s - h
      }), t.insert(t.mapping.slice(a).map(e.positionAt(s, m, n)), f.type.createAndFill({
        ...f.attrs,
        rowspan: h + f.attrs.rowspan - s
      })), c += f.attrs.colspan - 1;
    }
  }
  return l;
}
function wp(t, e, n, r, o, i, s, a) {
  if (s == 0 || s == e.width) return !1;
  let l = !1;
  for (let c = o; c < i; c++) {
    const u = c * e.width + s, d = e.map[u];
    if (e.map[u - 1] == d) {
      l = !0;
      const f = n.nodeAt(d), h = e.colCount(d), m = t.mapping.slice(a).map(d + r);
      t.setNodeMarkup(m, null, oo(f.attrs, s - h, f.attrs.colspan - (s - h))), t.insert(m + f.nodeSize, f.type.createAndFill(oo(f.attrs, 0, s - h))), c += f.attrs.rowspan - 1;
    }
  }
  return l;
}
function kp(t, e, n, r, o) {
  let i = n ? t.doc.nodeAt(n - 1) : t.doc;
  if (!i) throw new Error("No table found");
  let s = tt.get(i);
  const { top: a, left: l } = r, c = l + o.width, u = a + o.height, d = t.tr;
  let f = 0;
  function h() {
    if (i = n ? d.doc.nodeAt(n - 1) : d.doc, !i) throw new Error("No table found");
    s = tt.get(i), f = d.mapping.maps.length;
  }
  YM(d, s, i, n, c, u, f) && h(), vp(d, s, i, n, l, c, a, f) && h(), vp(d, s, i, n, l, c, u, f) && h(), wp(d, s, i, n, a, u, l, f) && h(), wp(d, s, i, n, a, u, c, f) && h();
  for (let m = a; m < u; m++) {
    const p = s.positionAt(m, l, i), g = s.positionAt(m, c, i);
    d.replace(d.mapping.slice(f).map(p + n), d.mapping.slice(f).map(g + n), new Y(o.rows[m - a], 0, 0));
  }
  h(), d.setSelection(new Ke(d.doc.resolve(n + s.positionAt(a, l, i)), d.doc.resolve(n + s.positionAt(u - 1, c - 1, i)))), e(d);
}
const XM = lf({
  ArrowLeft: Ys("horiz", -1),
  ArrowRight: Ys("horiz", 1),
  ArrowUp: Ys("vert", -1),
  ArrowDown: Ys("vert", 1),
  "Shift-ArrowLeft": Xs("horiz", -1),
  "Shift-ArrowRight": Xs("horiz", 1),
  "Shift-ArrowUp": Xs("vert", -1),
  "Shift-ArrowDown": Xs("vert", 1),
  Backspace: js,
  "Mod-Backspace": js,
  Delete: js,
  "Mod-Delete": js
});
function ka(t, e, n) {
  return n.eq(t.selection) ? !1 : (e && e(t.tr.setSelection(n).scrollIntoView()), !0);
}
function Ys(t, e) {
  return (n, r, o) => {
    if (!o) return !1;
    const i = n.selection;
    if (i instanceof Ke) return ka(n, r, pe.near(i.$headCell, e));
    if (t != "horiz" && !i.empty) return !1;
    const s = B0(o, t, e);
    if (s == null) return !1;
    if (t == "horiz") return ka(n, r, pe.near(n.doc.resolve(i.head + e), e));
    {
      const a = n.doc.resolve(s), l = _0(a, t, e);
      let c;
      return l ? c = pe.near(l, 1) : e < 0 ? c = pe.near(n.doc.resolve(a.before(-1)), -1) : c = pe.near(n.doc.resolve(a.after(-1)), 1), ka(n, r, c);
    }
  };
}
function Xs(t, e) {
  return (n, r, o) => {
    if (!o) return !1;
    const i = n.selection;
    let s;
    if (i instanceof Ke) s = i;
    else {
      const l = B0(o, t, e);
      if (l == null) return !1;
      s = new Ke(n.doc.resolve(l));
    }
    const a = _0(s.$headCell, t, e);
    return a ? ka(n, r, new Ke(s.$anchorCell, a)) : !1;
  };
}
function ZM(t, e) {
  const n = t.state.doc, r = ro(n.resolve(e));
  return r ? (t.dispatch(t.state.tr.setSelection(new Ke(r))), !0) : !1;
}
function JM(t, e, n) {
  if (!xn(t.state)) return !1;
  let r = qM(n);
  const o = t.state.selection;
  if (o instanceof Ke) {
    r || (r = {
      width: 1,
      height: 1,
      rows: [D.from(ld(Mt(t.state.schema).cell, n))]
    });
    const i = o.$anchorCell.node(-1), s = o.$anchorCell.start(-1), a = tt.get(i).rectBetween(o.$anchorCell.pos - s, o.$headCell.pos - s);
    return r = jM(r, a.right - a.left, a.bottom - a.top), kp(t.state, t.dispatch, s, a, r), !0;
  } else if (r) {
    const i = mc(t.state), s = i.start(-1);
    return kp(t.state, t.dispatch, s, tt.get(i.node(-1)).findCell(i.pos - s), r), !0;
  } else return !1;
}
function QM(t, e) {
  var n;
  if (e.button != 0 || e.ctrlKey || e.metaKey) return;
  const r = xp(t, e.target);
  let o;
  if (e.shiftKey && t.state.selection instanceof Ke)
    i(t.state.selection.$anchorCell, e), e.preventDefault();
  else if (e.shiftKey && r && (o = ro(t.state.selection.$anchor)) != null && ((n = au(t, e)) === null || n === void 0 ? void 0 : n.pos) != o.pos)
    i(o, e), e.preventDefault();
  else if (!r) return;
  function i(l, c) {
    let u = au(t, c);
    const d = br.getState(t.state) == null;
    if (!u || !Df(l, u)) if (d) u = l;
    else return;
    const f = new Ke(l, u);
    if (d || !t.state.selection.eq(f)) {
      const h = t.state.tr.setSelection(f);
      d && h.setMeta(br, l.pos), t.dispatch(h);
    }
  }
  function s() {
    t.root.removeEventListener("mouseup", s), t.root.removeEventListener("dragstart", s), t.root.removeEventListener("mousemove", a), br.getState(t.state) != null && t.dispatch(t.state.tr.setMeta(br, -1));
  }
  function a(l) {
    const c = l, u = br.getState(t.state);
    let d;
    if (u != null) d = t.state.doc.resolve(u);
    else if (xp(t, c.target) != r && (d = au(t, e), !d))
      return s();
    d && i(d, c);
  }
  t.root.addEventListener("mouseup", s), t.root.addEventListener("dragstart", s), t.root.addEventListener("mousemove", a);
}
function B0(t, e, n) {
  if (!(t.state.selection instanceof ce)) return null;
  const { $head: r } = t.state.selection;
  for (let o = r.depth - 1; o >= 0; o--) {
    const i = r.node(o);
    if ((n < 0 ? r.index(o) : r.indexAfter(o)) != (n < 0 ? 0 : i.childCount)) return null;
    if (i.type.spec.tableRole == "cell" || i.type.spec.tableRole == "header_cell") {
      const s = r.before(o), a = e == "vert" ? n > 0 ? "down" : "up" : n > 0 ? "right" : "left";
      return t.endOfTextblock(a) ? s : null;
    }
  }
  return null;
}
function xp(t, e) {
  for (; e && e != t.dom; e = e.parentNode) if (e.nodeName == "TD" || e.nodeName == "TH") return e;
  return null;
}
function au(t, e) {
  const n = t.posAtCoords({
    left: e.clientX,
    top: e.clientY
  });
  if (!n) return null;
  let { inside: r, pos: o } = n;
  return r >= 0 && ro(t.state.doc.resolve(r)) || ro(t.state.doc.resolve(o));
}
var eA = class {
  constructor(e, n) {
    this.node = e, this.defaultCellMinWidth = n, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.table.style.setProperty("--default-cell-min-width", `${n}px`), this.colgroup = this.table.appendChild(document.createElement("colgroup")), cd(e, this.colgroup, this.table, n), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(e) {
    return e.type != this.node.type ? !1 : (this.node = e, cd(e, this.colgroup, this.table, this.defaultCellMinWidth), !0);
  }
  ignoreMutation(e) {
    return e.type == "attributes" && (e.target == this.table || this.colgroup.contains(e.target));
  }
};
function cd(t, e, n, r, o, i) {
  let s = 0, a = !0, l = e.firstChild;
  const c = t.firstChild;
  if (c) {
    for (let d = 0, f = 0; d < c.childCount; d++) {
      const { colspan: h, colwidth: m } = c.child(d).attrs;
      for (let p = 0; p < h; p++, f++) {
        const g = o == f ? i : m && m[p], b = g ? g + "px" : "";
        if (s += g || r, g || (a = !1), l)
          l.style.width != b && (l.style.width = b), l = l.nextSibling;
        else {
          const v = document.createElement("col");
          v.style.width = b, e.appendChild(v);
        }
      }
    }
    for (; l; ) {
      var u;
      const d = l.nextSibling;
      (u = l.parentNode) === null || u === void 0 || u.removeChild(l), l = d;
    }
    a ? (n.style.width = s + "px", n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = s + "px");
  }
}
const Vt = new Ie("tableColumnResizing");
function tA({ handleWidth: t = 5, cellMinWidth: e = 25, defaultCellMinWidth: n = 100, View: r = eA, lastColumnResizable: o = !0 } = {}) {
  const i = new Ce({
    key: Vt,
    state: {
      init(s, a) {
        var l;
        const c = (l = i.spec) === null || l === void 0 || (l = l.props) === null || l === void 0 ? void 0 : l.nodeViews, u = Mt(a.schema).table.name;
        return r && c && (c[u] = (d, f) => new r(d, n, f)), new nA(-1, !1);
      },
      apply(s, a) {
        return a.apply(s);
      }
    },
    props: {
      attributes: (s) => {
        const a = Vt.getState(s);
        return a && a.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (s, a) => {
          rA(s, a, t, o);
        },
        mouseleave: (s) => {
          oA(s);
        },
        mousedown: (s, a) => {
          iA(s, a, e, n);
        }
      },
      decorations: (s) => {
        const a = Vt.getState(s);
        if (a && a.activeHandle > -1) return uA(s, a.activeHandle);
      },
      nodeViews: {}
    }
  });
  return i;
}
var nA = class xa {
  constructor(e, n) {
    this.activeHandle = e, this.dragging = n;
  }
  apply(e) {
    const n = this, r = e.getMeta(Vt);
    if (r && r.setHandle != null) return new xa(r.setHandle, !1);
    if (r && r.setDragging !== void 0) return new xa(n.activeHandle, r.setDragging);
    if (n.activeHandle > -1 && e.docChanged) {
      let o = e.mapping.map(n.activeHandle, -1);
      return ad(e.doc.resolve(o)) || (o = -1), new xa(o, n.dragging);
    }
    return n;
  }
};
function rA(t, e, n, r) {
  if (!t.editable) return;
  const o = Vt.getState(t.state);
  if (o && !o.dragging) {
    const i = aA(e.target);
    let s = -1;
    if (i) {
      const { left: a, right: l } = i.getBoundingClientRect();
      e.clientX - a <= n ? s = Np(t, e, "left", n) : l - e.clientX <= n && (s = Np(t, e, "right", n));
    }
    if (s != o.activeHandle) {
      if (!r && s !== -1) {
        const a = t.state.doc.resolve(s), l = a.node(-1), c = tt.get(l), u = a.start(-1);
        if (c.colCount(a.pos - u) + a.nodeAfter.attrs.colspan - 1 == c.width - 1) return;
      }
      z0(t, s);
    }
  }
}
function oA(t) {
  if (!t.editable) return;
  const e = Vt.getState(t.state);
  e && e.activeHandle > -1 && !e.dragging && z0(t, -1);
}
function iA(t, e, n, r) {
  var o;
  if (!t.editable) return !1;
  const i = (o = t.dom.ownerDocument.defaultView) !== null && o !== void 0 ? o : window, s = Vt.getState(t.state);
  if (!s || s.activeHandle == -1 || s.dragging) return !1;
  const a = t.state.doc.nodeAt(s.activeHandle), l = sA(t, s.activeHandle, a.attrs);
  t.dispatch(t.state.tr.setMeta(Vt, { setDragging: {
    startX: e.clientX,
    startWidth: l
  } }));
  function c(d) {
    i.removeEventListener("mouseup", c), i.removeEventListener("mousemove", u);
    const f = Vt.getState(t.state);
    f?.dragging && (lA(t, f.activeHandle, Ep(f.dragging, d, n)), t.dispatch(t.state.tr.setMeta(Vt, { setDragging: null })));
  }
  function u(d) {
    if (!d.which) return c(d);
    const f = Vt.getState(t.state);
    if (f && f.dragging) {
      const h = Ep(f.dragging, d, n);
      Sp(t, f.activeHandle, h, r);
    }
  }
  return Sp(t, s.activeHandle, l, r), i.addEventListener("mouseup", c), i.addEventListener("mousemove", u), e.preventDefault(), !0;
}
function sA(t, e, { colspan: n, colwidth: r }) {
  const o = r && r[r.length - 1];
  if (o) return o;
  const i = t.domAtPos(e);
  let s = i.node.childNodes[i.offset].offsetWidth, a = n;
  if (r)
    for (let l = 0; l < n; l++) r[l] && (s -= r[l], a--);
  return s / a;
}
function aA(t) {
  for (; t && t.nodeName != "TD" && t.nodeName != "TH"; ) t = t.classList && t.classList.contains("ProseMirror") ? null : t.parentNode;
  return t;
}
function Np(t, e, n, r) {
  const o = n == "right" ? -r : r, i = t.posAtCoords({
    left: e.clientX + o,
    top: e.clientY
  });
  if (!i) return -1;
  const { pos: s } = i, a = ro(t.state.doc.resolve(s));
  if (!a) return -1;
  if (n == "right") return a.pos;
  const l = tt.get(a.node(-1)), c = a.start(-1), u = l.map.indexOf(a.pos - c);
  return u % l.width == 0 ? -1 : c + l.map[u - 1];
}
function Ep(t, e, n) {
  const r = e.clientX - t.startX;
  return Math.max(n, t.startWidth + r);
}
function z0(t, e) {
  t.dispatch(t.state.tr.setMeta(Vt, { setHandle: e }));
}
function lA(t, e, n) {
  const r = t.state.doc.resolve(e), o = r.node(-1), i = tt.get(o), s = r.start(-1), a = i.colCount(r.pos - s) + r.nodeAfter.attrs.colspan - 1, l = t.state.tr;
  for (let c = 0; c < i.height; c++) {
    const u = c * i.width + a;
    if (c && i.map[u] == i.map[u - i.width]) continue;
    const d = i.map[u], f = o.nodeAt(d).attrs, h = f.colspan == 1 ? 0 : a - i.colCount(d);
    if (f.colwidth && f.colwidth[h] == n) continue;
    const m = f.colwidth ? f.colwidth.slice() : cA(f.colspan);
    m[h] = n, l.setNodeMarkup(s + d, null, {
      ...f,
      colwidth: m
    });
  }
  l.docChanged && t.dispatch(l);
}
function Sp(t, e, n, r) {
  const o = t.state.doc.resolve(e), i = o.node(-1), s = o.start(-1), a = tt.get(i).colCount(o.pos - s) + o.nodeAfter.attrs.colspan - 1;
  let l = t.domAtPos(o.start(-1)).node;
  for (; l && l.nodeName != "TABLE"; ) l = l.parentNode;
  l && cd(i, l.firstChild, l, r, a, n);
}
function cA(t) {
  return Array(t).fill(0);
}
function uA(t, e) {
  const n = [], r = t.doc.resolve(e), o = r.node(-1);
  if (!o) return Te.empty;
  const i = tt.get(o), s = r.start(-1), a = i.colCount(r.pos - s) + r.nodeAfter.attrs.colspan - 1;
  for (let c = 0; c < i.height; c++) {
    const u = a + c * i.width;
    if ((a == i.width - 1 || i.map[u] != i.map[u + 1]) && (c == 0 || i.map[u] != i.map[u - i.width])) {
      var l;
      const d = i.map[u], f = s + d + o.nodeAt(d).nodeSize - 1, h = document.createElement("div");
      h.className = "column-resize-handle", !((l = Vt.getState(t)) === null || l === void 0) && l.dragging && n.push(Ve.node(s + d, s + d + o.nodeAt(d).nodeSize, { class: "column-resize-dragging" })), n.push(Ve.widget(f, h));
    }
  }
  return Te.create(t.doc, n);
}
function dA({ allowTableNodeSelection: t = !1 } = {}) {
  return new Ce({
    key: br,
    state: {
      init() {
        return null;
      },
      apply(e, n) {
        const r = e.getMeta(br);
        if (r != null) return r == -1 ? null : r;
        if (n == null || !e.docChanged) return n;
        const { deleted: o, pos: i } = e.mapping.mapResult(n);
        return o ? null : i;
      }
    },
    props: {
      decorations: EM,
      handleDOMEvents: { mousedown: QM },
      createSelectionBetween(e) {
        return br.getState(e.state) != null ? e.state.selection : null;
      },
      handleTripleClick: ZM,
      handleKeyDown: XM,
      handlePaste: JM
    },
    appendTransaction(e, n, r) {
      return CM(r, D0(r, n), t);
    }
  });
}
function fA(t, e) {
  const n = Math.min(t.top, e.top), r = Math.max(t.bottom, e.bottom), o = Math.min(t.left, e.left), s = Math.max(t.right, e.right) - o, a = r - n, l = o, c = n;
  return new DOMRect(l, c, s, a);
}
var hA = class {
  constructor({
    editor: t,
    element: e,
    view: n,
    updateDelay: r = 250,
    resizeDelay: o = 60,
    shouldShow: i,
    appendTo: s,
    getReferencedVirtualElement: a,
    options: l
  }) {
    this.preventHide = !1, this.isVisible = !1, this.scrollTarget = window, this.floatingUIOptions = {
      strategy: "absolute",
      placement: "top",
      offset: 8,
      flip: {},
      shift: {},
      arrow: !1,
      size: !1,
      autoPlacement: !1,
      hide: !1,
      inline: !1,
      onShow: void 0,
      onHide: void 0,
      onUpdate: void 0,
      onDestroy: void 0
    }, this.shouldShow = ({ view: u, state: d, from: f, to: h }) => {
      const { doc: m, selection: p } = d, { empty: g } = p, b = !m.textBetween(f, h).length && ff(d.selection), v = this.element.contains(document.activeElement);
      return !(!(u.hasFocus() || v) || g || b || !this.editor.isEditable);
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.dragstartHandler = () => {
      this.hide();
    }, this.resizeHandler = () => {
      this.resizeDebounceTimer && clearTimeout(this.resizeDebounceTimer), this.resizeDebounceTimer = window.setTimeout(() => {
        this.updatePosition();
      }, this.resizeDelay);
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: u }) => {
      var d;
      if (this.editor.isDestroyed) {
        this.destroy();
        return;
      }
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      u?.relatedTarget && ((d = this.element.parentNode) != null && d.contains(u.relatedTarget)) || u?.relatedTarget !== this.editor.view.dom && this.hide();
    }, this.handleDebouncedUpdate = (u, d) => {
      const f = !d?.selection.eq(u.state.selection), h = !d?.doc.eq(u.state.doc);
      !f && !h || (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer), this.updateDebounceTimer = window.setTimeout(() => {
        this.updateHandler(u, f, h, d);
      }, this.updateDelay));
    }, this.updateHandler = (u, d, f, h) => {
      const { composing: m } = u;
      if (m || !d && !f)
        return;
      if (!this.getShouldShow(h)) {
        this.hide();
        return;
      }
      this.updatePosition(), this.show();
    }, this.transactionHandler = ({ transaction: u }) => {
      const d = u.getMeta("bubbleMenu");
      d === "updatePosition" ? this.updatePosition() : d && typeof d == "object" && d.type === "updateOptions" && this.updateOptions(d.options);
    };
    var c;
    this.editor = t, this.element = e, this.view = n, this.updateDelay = r, this.resizeDelay = o, this.appendTo = s, this.scrollTarget = (c = l?.scrollTarget) != null ? c : window, this.getReferencedVirtualElement = a, this.floatingUIOptions = {
      ...this.floatingUIOptions,
      ...l
    }, this.element.tabIndex = 0, i && (this.shouldShow = i), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.addEventListener("dragstart", this.dragstartHandler), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.editor.on("transaction", this.transactionHandler), window.addEventListener("resize", this.resizeHandler), this.scrollTarget.addEventListener("scroll", this.resizeHandler), this.update(n, n.state), this.getShouldShow() && (this.show(), this.updatePosition());
  }
  get middlewares() {
    const t = [];
    return this.floatingUIOptions.flip && t.push(_f(typeof this.floatingUIOptions.flip != "boolean" ? this.floatingUIOptions.flip : void 0)), this.floatingUIOptions.shift && t.push(
      Af(typeof this.floatingUIOptions.shift != "boolean" ? this.floatingUIOptions.shift : void 0)
    ), this.floatingUIOptions.offset && t.push(
      Mf(typeof this.floatingUIOptions.offset != "boolean" ? this.floatingUIOptions.offset : void 0)
    ), this.floatingUIOptions.arrow && t.push(Ga(this.floatingUIOptions.arrow)), this.floatingUIOptions.size && t.push(Rf(typeof this.floatingUIOptions.size != "boolean" ? this.floatingUIOptions.size : void 0)), this.floatingUIOptions.autoPlacement && t.push(
      M0(
        typeof this.floatingUIOptions.autoPlacement != "boolean" ? this.floatingUIOptions.autoPlacement : void 0
      )
    ), this.floatingUIOptions.hide && t.push(Of(typeof this.floatingUIOptions.hide != "boolean" ? this.floatingUIOptions.hide : void 0)), this.floatingUIOptions.inline && t.push(
      A0(typeof this.floatingUIOptions.inline != "boolean" ? this.floatingUIOptions.inline : void 0)
    ), t;
  }
  get virtualElement() {
    var t, e, n;
    const { selection: r } = this.editor.state, o = (t = this.getReferencedVirtualElement) == null ? void 0 : t.call(this);
    if (o)
      return o;
    if (!((n = (e = this.view) == null ? void 0 : e.dom) != null && n.parentNode))
      return;
    const i = Jy(this.view, r.from, r.to);
    let s = {
      getBoundingClientRect: () => i,
      getClientRects: () => [i]
    };
    if (r instanceof se) {
      let a = this.view.nodeDOM(r.from);
      const l = a.dataset.nodeViewWrapper ? a : a.querySelector("[data-node-view-wrapper]");
      l && (a = l), a && (s = {
        getBoundingClientRect: () => a.getBoundingClientRect(),
        getClientRects: () => [a.getBoundingClientRect()]
      });
    }
    if (r instanceof Ke) {
      const { $anchorCell: a, $headCell: l } = r, c = a ? a.pos : l.pos, u = l ? l.pos : a.pos, d = this.view.nodeDOM(c), f = this.view.nodeDOM(u);
      if (!d || !f)
        return;
      const h = d === f ? d.getBoundingClientRect() : fA(
        d.getBoundingClientRect(),
        f.getBoundingClientRect()
      );
      s = {
        getBoundingClientRect: () => h,
        getClientRects: () => [h]
      };
    }
    return s;
  }
  updatePosition() {
    const t = this.virtualElement;
    t && If(t, this.element, {
      placement: this.floatingUIOptions.placement,
      strategy: this.floatingUIOptions.strategy,
      middleware: this.middlewares
    }).then(({ x: e, y: n, strategy: r, middlewareData: o }) => {
      var i, s;
      if ((i = o.hide) != null && i.referenceHidden || (s = o.hide) != null && s.escaped) {
        this.element.style.visibility = "hidden";
        return;
      }
      this.element.style.visibility = "visible", this.element.style.width = "max-content", this.element.style.position = r, this.element.style.left = `${e}px`, this.element.style.top = `${n}px`, this.isVisible && this.floatingUIOptions.onUpdate && this.floatingUIOptions.onUpdate();
    });
  }
  update(t, e) {
    const { state: n } = t, r = n.selection.from !== n.selection.to;
    if (this.updateDelay > 0 && r) {
      this.handleDebouncedUpdate(t, e);
      return;
    }
    const o = !e?.selection.eq(t.state.selection), i = !e?.doc.eq(t.state.doc);
    this.updateHandler(t, o, i, e);
  }
  getShouldShow(t) {
    var e;
    const { state: n } = this.view, { selection: r } = n, { ranges: o } = r, i = Math.min(...o.map((l) => l.$from.pos)), s = Math.max(...o.map((l) => l.$to.pos));
    return ((e = this.shouldShow) == null ? void 0 : e.call(this, {
      editor: this.editor,
      element: this.element,
      view: this.view,
      state: n,
      oldState: t,
      from: i,
      to: s
    })) || !1;
  }
  show() {
    var t;
    if (this.isVisible)
      return;
    this.element.style.visibility = "visible", this.element.style.opacity = "1";
    const e = typeof this.appendTo == "function" ? this.appendTo() : this.appendTo;
    (t = e ?? this.view.dom.parentElement) == null || t.appendChild(this.element), this.floatingUIOptions.onShow && this.floatingUIOptions.onShow(), this.isVisible = !0;
  }
  hide() {
    this.isVisible && (this.element.style.visibility = "hidden", this.element.style.opacity = "0", this.element.remove(), this.floatingUIOptions.onHide && this.floatingUIOptions.onHide(), this.isVisible = !1);
  }
  updateOptions(t) {
    var e;
    if (t.updateDelay !== void 0 && (this.updateDelay = t.updateDelay), t.resizeDelay !== void 0 && (this.resizeDelay = t.resizeDelay), t.appendTo !== void 0 && (this.appendTo = t.appendTo), t.getReferencedVirtualElement !== void 0 && (this.getReferencedVirtualElement = t.getReferencedVirtualElement), t.shouldShow !== void 0 && t.shouldShow && (this.shouldShow = t.shouldShow), t.options !== void 0) {
      const n = (e = t.options.scrollTarget) != null ? e : window;
      n !== this.scrollTarget && (this.scrollTarget.removeEventListener("scroll", this.resizeHandler), this.scrollTarget = n, this.scrollTarget.addEventListener("scroll", this.resizeHandler)), this.floatingUIOptions = {
        ...this.floatingUIOptions,
        ...t.options
      };
    }
  }
  destroy() {
    this.hide(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.removeEventListener("dragstart", this.dragstartHandler), window.removeEventListener("resize", this.resizeHandler), this.scrollTarget.removeEventListener("scroll", this.resizeHandler), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler), this.editor.off("transaction", this.transactionHandler), this.floatingUIOptions.onDestroy && this.floatingUIOptions.onDestroy();
  }
}, $0 = (t) => new Ce({
  key: typeof t.pluginKey == "string" ? new Ie(t.pluginKey) : t.pluginKey,
  view: (e) => new hA({ view: e, ...t })
});
Re.create({
  name: "bubbleMenu",
  addOptions() {
    return {
      element: null,
      pluginKey: "bubbleMenu",
      updateDelay: void 0,
      appendTo: void 0,
      shouldShow: null
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      $0({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        updateDelay: this.options.updateDelay,
        options: this.options.options,
        appendTo: this.options.appendTo,
        getReferencedVirtualElement: this.options.getReferencedVirtualElement,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
var mA = class {
  constructor({
    editor: t,
    element: e,
    view: n,
    updateDelay: r = 250,
    resizeDelay: o = 60,
    options: i,
    appendTo: s,
    shouldShow: a
  }) {
    this.preventHide = !1, this.isVisible = !1, this.scrollTarget = window, this.shouldShow = ({ view: c, state: u }) => {
      const { selection: d } = u, { $anchor: f, empty: h } = d, m = f.depth === 1, p = f.parent.isTextblock && !f.parent.type.spec.code && !f.parent.textContent && f.parent.childCount === 0 && !this.getTextContent(f.parent);
      return !(!c.hasFocus() || !h || !m || !p || !this.editor.isEditable);
    }, this.floatingUIOptions = {
      strategy: "absolute",
      placement: "right",
      offset: 8,
      flip: {},
      shift: {},
      arrow: !1,
      size: !1,
      autoPlacement: !1,
      hide: !1,
      inline: !1
    }, this.updateHandler = (c, u, d, f) => {
      const { composing: h } = c;
      if (h || !u && !d)
        return;
      if (!this.getShouldShow(f)) {
        this.hide();
        return;
      }
      this.updatePosition(), this.show();
    }, this.mousedownHandler = () => {
      this.preventHide = !0;
    }, this.focusHandler = () => {
      setTimeout(() => this.update(this.editor.view));
    }, this.blurHandler = ({ event: c }) => {
      var u;
      if (this.preventHide) {
        this.preventHide = !1;
        return;
      }
      c?.relatedTarget && ((u = this.element.parentNode) != null && u.contains(c.relatedTarget)) || c?.relatedTarget !== this.editor.view.dom && this.hide();
    }, this.transactionHandler = ({ transaction: c }) => {
      const u = c.getMeta("floatingMenu");
      u === "updatePosition" ? this.updatePosition() : u && typeof u == "object" && u.type === "updateOptions" && this.updateOptions(u.options);
    }, this.resizeHandler = () => {
      this.resizeDebounceTimer && clearTimeout(this.resizeDebounceTimer), this.resizeDebounceTimer = window.setTimeout(() => {
        this.updatePosition();
      }, this.resizeDelay);
    };
    var l;
    this.editor = t, this.element = e, this.view = n, this.updateDelay = r, this.resizeDelay = o, this.appendTo = s, this.scrollTarget = (l = i?.scrollTarget) != null ? l : window, this.floatingUIOptions = {
      ...this.floatingUIOptions,
      ...i
    }, this.element.tabIndex = 0, a && (this.shouldShow = a), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.editor.on("transaction", this.transactionHandler), window.addEventListener("resize", this.resizeHandler), this.scrollTarget.addEventListener("scroll", this.resizeHandler), this.update(n, n.state), this.getShouldShow() && (this.show(), this.updatePosition());
  }
  getTextContent(t) {
    return qy(t, { textSerializers: pf(this.editor.schema) });
  }
  get middlewares() {
    const t = [];
    return this.floatingUIOptions.flip && t.push(_f(typeof this.floatingUIOptions.flip != "boolean" ? this.floatingUIOptions.flip : void 0)), this.floatingUIOptions.shift && t.push(
      Af(typeof this.floatingUIOptions.shift != "boolean" ? this.floatingUIOptions.shift : void 0)
    ), this.floatingUIOptions.offset && t.push(
      Mf(typeof this.floatingUIOptions.offset != "boolean" ? this.floatingUIOptions.offset : void 0)
    ), this.floatingUIOptions.arrow && t.push(Ga(this.floatingUIOptions.arrow)), this.floatingUIOptions.size && t.push(Rf(typeof this.floatingUIOptions.size != "boolean" ? this.floatingUIOptions.size : void 0)), this.floatingUIOptions.autoPlacement && t.push(
      M0(
        typeof this.floatingUIOptions.autoPlacement != "boolean" ? this.floatingUIOptions.autoPlacement : void 0
      )
    ), this.floatingUIOptions.hide && t.push(Of(typeof this.floatingUIOptions.hide != "boolean" ? this.floatingUIOptions.hide : void 0)), this.floatingUIOptions.inline && t.push(
      A0(typeof this.floatingUIOptions.inline != "boolean" ? this.floatingUIOptions.inline : void 0)
    ), t;
  }
  getShouldShow(t) {
    var e;
    const { state: n } = this.view, { selection: r } = n, { ranges: o } = r, i = Math.min(...o.map((l) => l.$from.pos)), s = Math.max(...o.map((l) => l.$to.pos));
    return (e = this.shouldShow) == null ? void 0 : e.call(this, {
      editor: this.editor,
      view: this.view,
      state: n,
      oldState: t,
      from: i,
      to: s
    });
  }
  updateOptions(t) {
    var e;
    if (t.updateDelay !== void 0 && (this.updateDelay = t.updateDelay), t.resizeDelay !== void 0 && (this.resizeDelay = t.resizeDelay), t.appendTo !== void 0 && (this.appendTo = t.appendTo), t.shouldShow !== void 0 && t.shouldShow && (this.shouldShow = t.shouldShow), t.options !== void 0) {
      const n = (e = t.options.scrollTarget) != null ? e : window;
      n !== this.scrollTarget && (this.scrollTarget.removeEventListener("scroll", this.resizeHandler), this.scrollTarget = n, this.scrollTarget.addEventListener("scroll", this.resizeHandler)), this.floatingUIOptions = {
        ...this.floatingUIOptions,
        ...t.options
      };
    }
  }
  updatePosition() {
    const { selection: t } = this.editor.state, e = Jy(this.view, t.from, t.to);
    If({
      getBoundingClientRect: () => e,
      getClientRects: () => [e]
    }, this.element, {
      placement: this.floatingUIOptions.placement,
      strategy: this.floatingUIOptions.strategy,
      middleware: this.middlewares
    }).then(({ x: r, y: o, strategy: i, middlewareData: s }) => {
      var a, l;
      if ((a = s.hide) != null && a.referenceHidden || (l = s.hide) != null && l.escaped) {
        this.element.style.visibility = "hidden";
        return;
      }
      this.element.style.visibility = "visible", this.element.style.width = "max-content", this.element.style.position = i, this.element.style.left = `${r}px`, this.element.style.top = `${o}px`, this.isVisible && this.floatingUIOptions.onUpdate && this.floatingUIOptions.onUpdate();
    });
  }
  update(t, e) {
    const n = !e?.selection.eq(t.state.selection), r = !e?.doc.eq(t.state.doc);
    this.updateHandler(t, n, r, e);
  }
  show() {
    var t;
    if (this.isVisible)
      return;
    this.element.style.visibility = "visible", this.element.style.opacity = "1";
    const e = typeof this.appendTo == "function" ? this.appendTo() : this.appendTo;
    (t = e ?? this.view.dom.parentElement) == null || t.appendChild(this.element), this.floatingUIOptions.onShow && this.floatingUIOptions.onShow(), this.isVisible = !0;
  }
  hide() {
    this.isVisible && (this.element.style.visibility = "hidden", this.element.style.opacity = "0", this.element.remove(), this.floatingUIOptions.onHide && this.floatingUIOptions.onHide(), this.isVisible = !1);
  }
  destroy() {
    this.hide(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), window.removeEventListener("resize", this.resizeHandler), this.scrollTarget.removeEventListener("scroll", this.resizeHandler), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler), this.editor.off("transaction", this.transactionHandler), this.floatingUIOptions.onDestroy && this.floatingUIOptions.onDestroy();
  }
}, H0 = (t) => new Ce({
  key: typeof t.pluginKey == "string" ? new Ie(t.pluginKey) : t.pluginKey,
  view: (e) => new mA({ view: e, ...t })
});
Re.create({
  name: "floatingMenu",
  addOptions() {
    return {
      element: null,
      options: {},
      pluginKey: "floatingMenu",
      updateDelay: void 0,
      resizeDelay: void 0,
      appendTo: void 0,
      shouldShow: null
    };
  },
  addCommands() {
    return {
      updateFloatingMenuPosition: () => ({ tr: t, dispatch: e }) => (e && t.setMeta("floatingMenu", "updatePosition"), !0)
    };
  },
  addProseMirrorPlugins() {
    return this.options.element ? [
      H0({
        pluginKey: this.options.pluginKey,
        editor: this.editor,
        element: this.options.element,
        updateDelay: this.options.updateDelay,
        resizeDelay: this.options.resizeDelay,
        options: this.options.options,
        appendTo: this.options.appendTo,
        shouldShow: this.options.shouldShow
      })
    ] : [];
  }
});
var pA = (...t) => (e) => {
  t.forEach((n) => {
    typeof n == "function" ? n(e) : n && (n.current = e);
  });
}, gA = ({ contentComponent: t }) => {
  const e = ib.useSyncExternalStore(
    t.subscribe,
    t.getSnapshot,
    t.getServerSnapshot
  );
  return /* @__PURE__ */ R(Hd, { children: Object.values(e) });
};
function bA() {
  const t = /* @__PURE__ */ new Set();
  let e = {};
  return {
    /**
     * Subscribe to the editor instance's changes.
     */
    subscribe(n) {
      return t.add(n), () => {
        t.delete(n);
      };
    },
    getSnapshot() {
      return e;
    },
    getServerSnapshot() {
      return e;
    },
    /**
     * Adds a new NodeView Renderer to the editor.
     */
    setRenderer(n, r) {
      e = {
        ...e,
        [n]: rb.createPortal(r.reactElement, r.element, n)
      }, t.forEach((o) => o());
    },
    /**
     * Removes a NodeView Renderer from the editor.
     */
    removeRenderer(n) {
      const r = { ...e };
      delete r[n], e = r, t.forEach((o) => o());
    }
  };
}
var yA = class extends ot.Component {
  constructor(t) {
    var e;
    super(t), this.editorContentRef = ot.createRef(), this.initialized = !1, this.state = {
      hasContentComponentInitialized: !!((e = t.editor) != null && e.contentComponent)
    };
  }
  componentDidMount() {
    this.init();
  }
  componentDidUpdate() {
    this.init();
  }
  init() {
    var t;
    const e = this.props.editor;
    if (e && !e.isDestroyed && ((t = e.view.dom) != null && t.parentNode)) {
      if (e.contentComponent)
        return;
      const n = this.editorContentRef.current;
      n.append(...e.view.dom.parentNode.childNodes), e.setOptions({
        element: n
      }), e.contentComponent = bA(), this.state.hasContentComponentInitialized || (this.unsubscribeToContentComponent = e.contentComponent.subscribe(() => {
        this.setState((r) => r.hasContentComponentInitialized ? r : {
          hasContentComponentInitialized: !0
        }), this.unsubscribeToContentComponent && this.unsubscribeToContentComponent();
      })), e.createNodeViews(), this.initialized = !0;
    }
  }
  componentWillUnmount() {
    var t;
    const e = this.props.editor;
    if (e) {
      this.initialized = !1, e.isDestroyed || e.view.setProps({
        nodeViews: {}
      }), this.unsubscribeToContentComponent && this.unsubscribeToContentComponent(), e.contentComponent = null;
      try {
        if (!((t = e.view.dom) != null && t.parentNode))
          return;
        const n = document.createElement("div");
        n.append(...e.view.dom.parentNode.childNodes), e.setOptions({
          element: n
        });
      } catch {
      }
    }
  }
  render() {
    const { editor: t, innerRef: e, ...n } = this.props;
    return /* @__PURE__ */ ob(Hd, { children: [
      /* @__PURE__ */ R("div", { ref: pA(e, this.editorContentRef), ...n }),
      t?.contentComponent && /* @__PURE__ */ R(gA, { contentComponent: t.contentComponent })
    ] });
  }
}, vA = Xl(
  (t, e) => {
    const n = ot.useMemo(() => Math.floor(Math.random() * 4294967295).toString(), [t.editor]);
    return ot.createElement(yA, {
      key: n,
      innerRef: e,
      ...t
    });
  }
), F0 = ot.memo(vA), wA = typeof window < "u" ? eb : ge, kA = class {
  constructor(t) {
    this.transactionNumber = 0, this.lastTransactionNumber = 0, this.subscribers = /* @__PURE__ */ new Set(), this.editor = t, this.lastSnapshot = { editor: t, transactionNumber: 0 }, this.getSnapshot = this.getSnapshot.bind(this), this.getServerSnapshot = this.getServerSnapshot.bind(this), this.watch = this.watch.bind(this), this.subscribe = this.subscribe.bind(this);
  }
  /**
   * Get the current editor instance.
   */
  getSnapshot() {
    return this.transactionNumber === this.lastTransactionNumber ? this.lastSnapshot : (this.lastTransactionNumber = this.transactionNumber, this.lastSnapshot = { editor: this.editor, transactionNumber: this.transactionNumber }, this.lastSnapshot);
  }
  /**
   * Always disable the editor on the server-side.
   */
  getServerSnapshot() {
    return { editor: null, transactionNumber: 0 };
  }
  /**
   * Subscribe to the editor instance's changes.
   */
  subscribe(t) {
    return this.subscribers.add(t), () => {
      this.subscribers.delete(t);
    };
  }
  /**
   * Watch the editor instance for changes.
   */
  watch(t) {
    if (this.editor = t, this.editor) {
      const e = () => {
        this.transactionNumber += 1, this.subscribers.forEach((r) => r());
      }, n = this.editor;
      return n.on("transaction", e), () => {
        n.off("transaction", e);
      };
    }
  }
};
function Lf(t) {
  var e;
  const [n] = J(() => new kA(t.editor)), r = vC.useSyncExternalStoreWithSelector(
    n.subscribe,
    n.getSnapshot,
    n.getServerSnapshot,
    t.selector,
    (e = t.equalityFn) != null ? e : pC
  );
  return wA(() => n.watch(t.editor), [t.editor, n]), tb(r), r;
}
var Tp = process.env.NODE_ENV !== "production", ud = typeof window > "u", xA = ud || !!(typeof window < "u" && window.next), NA = class U0 {
  constructor(e) {
    this.editor = null, this.subscriptions = /* @__PURE__ */ new Set(), this.isComponentMounted = !1, this.previousDeps = null, this.instanceId = "", this.options = e, this.subscriptions = /* @__PURE__ */ new Set(), this.setEditor(this.getInitialEditor()), this.scheduleDestroy(), this.getEditor = this.getEditor.bind(this), this.getServerSnapshot = this.getServerSnapshot.bind(this), this.subscribe = this.subscribe.bind(this), this.refreshEditorInstance = this.refreshEditorInstance.bind(this), this.scheduleDestroy = this.scheduleDestroy.bind(this), this.onRender = this.onRender.bind(this), this.createEditor = this.createEditor.bind(this);
  }
  setEditor(e) {
    this.editor = e, this.instanceId = Math.random().toString(36).slice(2, 9), this.subscriptions.forEach((n) => n());
  }
  getInitialEditor() {
    if (this.options.current.immediatelyRender === void 0) {
      if (ud || xA) {
        if (Tp)
          throw new Error(
            "Tiptap Error: SSR has been detected, please set `immediatelyRender` explicitly to `false` to avoid hydration mismatches."
          );
        return null;
      }
      return this.createEditor();
    }
    if (this.options.current.immediatelyRender && ud && Tp)
      throw new Error(
        "Tiptap Error: SSR has been detected, and `immediatelyRender` has been set to `true` this is an unsupported configuration that may result in errors, explicitly set `immediatelyRender` to `false` to avoid hydration mismatches."
      );
    return this.options.current.immediatelyRender ? this.createEditor() : null;
  }
  /**
   * Create a new editor instance. And attach event listeners.
   */
  createEditor() {
    const e = {
      ...this.options.current,
      // Always call the most recent version of the callback function by default
      onBeforeCreate: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onBeforeCreate) == null ? void 0 : i.call(o, ...r);
      },
      onBlur: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onBlur) == null ? void 0 : i.call(o, ...r);
      },
      onCreate: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onCreate) == null ? void 0 : i.call(o, ...r);
      },
      onDestroy: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onDestroy) == null ? void 0 : i.call(o, ...r);
      },
      onFocus: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onFocus) == null ? void 0 : i.call(o, ...r);
      },
      onSelectionUpdate: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onSelectionUpdate) == null ? void 0 : i.call(o, ...r);
      },
      onTransaction: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onTransaction) == null ? void 0 : i.call(o, ...r);
      },
      onUpdate: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onUpdate) == null ? void 0 : i.call(o, ...r);
      },
      onContentError: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onContentError) == null ? void 0 : i.call(o, ...r);
      },
      onDrop: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onDrop) == null ? void 0 : i.call(o, ...r);
      },
      onPaste: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onPaste) == null ? void 0 : i.call(o, ...r);
      },
      onDelete: (...r) => {
        var o, i;
        return (i = (o = this.options.current).onDelete) == null ? void 0 : i.call(o, ...r);
      }
    };
    return new vT(e);
  }
  /**
   * Get the current editor instance.
   */
  getEditor() {
    return this.editor;
  }
  /**
   * Always disable the editor on the server-side.
   */
  getServerSnapshot() {
    return null;
  }
  /**
   * Subscribe to the editor instance's changes.
   */
  subscribe(e) {
    return this.subscriptions.add(e), () => {
      this.subscriptions.delete(e);
    };
  }
  static compareOptions(e, n) {
    return Object.keys(e).every((r) => [
      "onCreate",
      "onBeforeCreate",
      "onDestroy",
      "onUpdate",
      "onTransaction",
      "onFocus",
      "onBlur",
      "onSelectionUpdate",
      "onContentError",
      "onDrop",
      "onPaste"
    ].includes(r) ? !0 : r === "extensions" && e.extensions && n.extensions ? e.extensions.length !== n.extensions.length ? !1 : e.extensions.every((o, i) => {
      var s;
      return o === ((s = n.extensions) == null ? void 0 : s[i]);
    }) : e[r] === n[r]);
  }
  /**
   * On each render, we will create, update, or destroy the editor instance.
   * @param deps The dependencies to watch for changes
   * @returns A cleanup function
   */
  onRender(e) {
    return () => (this.isComponentMounted = !0, clearTimeout(this.scheduledDestructionTimeout), this.editor && !this.editor.isDestroyed && e.length === 0 ? U0.compareOptions(this.options.current, this.editor.options) || this.editor.setOptions({
      ...this.options.current,
      editable: this.editor.isEditable
    }) : this.refreshEditorInstance(e), () => {
      this.isComponentMounted = !1, this.scheduleDestroy();
    });
  }
  /**
   * Recreate the editor instance if the dependencies have changed.
   */
  refreshEditorInstance(e) {
    if (this.editor && !this.editor.isDestroyed) {
      if (this.previousDeps === null) {
        this.previousDeps = e;
        return;
      }
      if (this.previousDeps.length === e.length && this.previousDeps.every((r, o) => r === e[o]))
        return;
    }
    this.editor && !this.editor.isDestroyed && this.editor.destroy(), this.setEditor(this.createEditor()), this.previousDeps = e;
  }
  /**
   * Schedule the destruction of the editor instance.
   * This will only destroy the editor if it was not mounted on the next tick.
   * This is to avoid destroying the editor instance when it's actually still mounted.
   */
  scheduleDestroy() {
    const e = this.instanceId, n = this.editor;
    this.scheduledDestructionTimeout = setTimeout(() => {
      if (this.isComponentMounted && this.instanceId === e) {
        n && n.setOptions(this.options.current);
        return;
      }
      n && !n.isDestroyed && (n.destroy(), this.instanceId === e && this.setEditor(null));
    }, 1);
  }
};
function EA(t = {}, e = []) {
  const n = fe(t);
  n.current = t;
  const [r] = J(() => new NA(n)), o = ib.useSyncExternalStore(
    r.subscribe,
    r.getEditor,
    r.getServerSnapshot
  );
  return tb(o), ge(r.onRender(e)), Lf({
    editor: o,
    selector: ({ transactionNumber: i }) => t.shouldRerenderOnTransaction === !1 || t.shouldRerenderOnTransaction === void 0 ? null : t.immediatelyRender && i === 0 ? 0 : i + 1
  }), o;
}
var Pf = jl({
  editor: null
});
Pf.Consumer;
var W0 = () => Yl(Pf), V0 = jl({
  onDragStart: () => {
  },
  nodeViewContentChildren: void 0,
  nodeViewContentRef: () => {
  }
}), K0 = () => Yl(V0);
function Bf({
  as: t = "div",
  ...e
}) {
  const { nodeViewContentRef: n, nodeViewContentChildren: r } = K0();
  return (
    // @ts-ignore
    /* @__PURE__ */ R(
      t,
      {
        ...e,
        ref: n,
        "data-node-view-content": "",
        style: {
          whiteSpace: "pre-wrap",
          ...e.style
        },
        children: r
      }
    )
  );
}
var pc = ot.forwardRef((t, e) => {
  const { onDragStart: n } = K0(), r = t.as || "div";
  return (
    // @ts-ignore
    /* @__PURE__ */ R(
      r,
      {
        ...t,
        ref: e,
        "data-node-view-wrapper": "",
        onDragStart: n,
        style: {
          whiteSpace: "normal",
          ...t.style
        }
      }
    )
  );
});
function Cp(t) {
  return !!(typeof t == "function" && t.prototype && t.prototype.isReactComponent);
}
function Mp(t) {
  return !!(typeof t == "object" && t.$$typeof && (t.$$typeof.toString() === "Symbol(react.forward_ref)" || t.$$typeof.description === "react.forward_ref"));
}
function SA(t) {
  return !!(typeof t == "object" && t.$$typeof && (t.$$typeof.toString() === "Symbol(react.memo)" || t.$$typeof.description === "react.memo"));
}
function TA(t) {
  if (Cp(t) || Mp(t))
    return !0;
  if (SA(t)) {
    const e = t.type;
    if (e)
      return Cp(e) || Mp(e);
  }
  return !1;
}
function CA() {
  try {
    if (zh)
      return parseInt(zh.split(".")[0], 10) >= 19;
  } catch {
  }
  return !1;
}
var MA = class {
  /**
   * Immediately creates element and renders the provided React component.
   */
  constructor(t, { editor: e, props: n = {}, as: r = "div", className: o = "" }) {
    this.ref = null, this.destroyed = !1, this.id = Math.floor(Math.random() * 4294967295).toString(), this.component = t, this.editor = e, this.props = n, this.element = document.createElement(r), this.element.classList.add("react-renderer"), o && this.element.classList.add(...o.split(" ")), this.editor.isInitialized ? Ex(() => {
      this.render();
    }) : queueMicrotask(() => {
      this.destroyed || this.render();
    });
  }
  /**
   * Render the React component.
   */
  render() {
    var t;
    if (this.destroyed)
      return;
    const e = this.component, n = this.props, r = this.editor, o = CA(), i = TA(e), s = { ...n };
    s.ref && !(o || i) && delete s.ref, !s.ref && (o || i) && (s.ref = (a) => {
      this.ref = a;
    }), this.reactElement = /* @__PURE__ */ R(e, { ...s }), (t = r?.contentComponent) == null || t.setRenderer(this.id, this);
  }
  /**
   * Re-renders the React component with new props.
   */
  updateProps(t = {}) {
    this.destroyed || (this.props = {
      ...this.props,
      ...t
    }, this.render());
  }
  /**
   * Destroy the React component.
   */
  destroy() {
    var t;
    this.destroyed = !0;
    const e = this.editor;
    (t = e?.contentComponent) == null || t.removeRenderer(this.id);
    try {
      this.element && this.element.parentNode && this.element.parentNode.removeChild(this.element);
    } catch {
    }
  }
  /**
   * Update the attributes of the element that holds the React component.
   */
  updateAttributes(t) {
    Object.keys(t).forEach((e) => {
      this.element.setAttribute(e, t[e]);
    });
  }
};
ot.createContext({
  markViewContentRef: () => {
  }
});
var AA = class extends _T {
  constructor(t, e, n) {
    if (super(t, e, n), this.selectionRafId = null, this.cachedExtensionWithSyncedStorage = null, !this.node.isLeaf) {
      this.options.contentDOMElementTag ? this.contentDOMElement = document.createElement(this.options.contentDOMElementTag) : this.contentDOMElement = document.createElement(this.node.isInline ? "span" : "div"), this.contentDOMElement.dataset.nodeViewContentReact = "", this.contentDOMElement.dataset.nodeViewWrapper = "", this.contentDOMElement.style.whiteSpace = "inherit";
      const r = this.dom.querySelector("[data-node-view-content]");
      if (!r)
        return;
      r.appendChild(this.contentDOMElement);
    }
  }
  /**
   * Returns a proxy of the extension that redirects storage access to the editor's mutable storage.
   * This preserves the original prototype chain (instanceof checks, methods like configure/extend work).
   * Cached to avoid proxy creation on every update.
   */
  get extensionWithSyncedStorage() {
    if (!this.cachedExtensionWithSyncedStorage) {
      const t = this.editor, e = this.extension;
      this.cachedExtensionWithSyncedStorage = new Proxy(e, {
        get(n, r, o) {
          var i;
          return r === "storage" ? (i = t.storage[e.name]) != null ? i : {} : Reflect.get(n, r, o);
        }
      });
    }
    return this.cachedExtensionWithSyncedStorage;
  }
  /**
   * Setup the React component.
   * Called on initialization.
   */
  mount() {
    const t = {
      editor: this.editor,
      node: this.node,
      decorations: this.decorations,
      innerDecorations: this.innerDecorations,
      view: this.view,
      selected: !1,
      extension: this.extensionWithSyncedStorage,
      HTMLAttributes: this.HTMLAttributes,
      getPos: () => this.getPos(),
      updateAttributes: (l = {}) => this.updateAttributes(l),
      deleteNode: () => this.deleteNode(),
      ref: xx()
    };
    if (!this.component.displayName) {
      const l = (c) => c.charAt(0).toUpperCase() + c.substring(1);
      this.component.displayName = l(this.extension.name);
    }
    const r = { onDragStart: this.onDragStart.bind(this), nodeViewContentRef: (l) => {
      l && this.contentDOMElement && l.firstChild !== this.contentDOMElement && (l.hasAttribute("data-node-view-wrapper") && l.removeAttribute("data-node-view-wrapper"), l.appendChild(this.contentDOMElement));
    } }, o = this.component, i = si((l) => /* @__PURE__ */ R(V0.Provider, { value: r, children: Aa(o, l) }));
    i.displayName = "ReactNodeView";
    let s = this.node.isInline ? "span" : "div";
    this.options.as && (s = this.options.as);
    const { className: a = "" } = this.options;
    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this), this.renderer = new MA(i, {
      editor: this.editor,
      props: t,
      as: s,
      className: `node-${this.node.type.name} ${a}`.trim()
    }), this.editor.on("selectionUpdate", this.handleSelectionUpdate), this.updateElementAttributes();
  }
  /**
   * Return the DOM element.
   * This is the element that will be used to display the node view.
   */
  get dom() {
    var t;
    if (this.renderer.element.firstElementChild && !((t = this.renderer.element.firstElementChild) != null && t.hasAttribute("data-node-view-wrapper")))
      throw Error("Please use the NodeViewWrapper component for your node view.");
    return this.renderer.element;
  }
  /**
   * Return the content DOM element.
   * This is the element that will be used to display the rich-text content of the node.
   */
  get contentDOM() {
    return this.node.isLeaf ? null : this.contentDOMElement;
  }
  /**
   * On editor selection update, check if the node is selected.
   * If it is, call `selectNode`, otherwise call `deselectNode`.
   */
  handleSelectionUpdate() {
    this.selectionRafId && (cancelAnimationFrame(this.selectionRafId), this.selectionRafId = null), this.selectionRafId = requestAnimationFrame(() => {
      this.selectionRafId = null;
      const { from: t, to: e } = this.editor.state.selection, n = this.getPos();
      if (typeof n == "number")
        if (t <= n && e >= n + this.node.nodeSize) {
          if (this.renderer.props.selected)
            return;
          this.selectNode();
        } else {
          if (!this.renderer.props.selected)
            return;
          this.deselectNode();
        }
    });
  }
  /**
   * On update, update the React component.
   * To prevent unnecessary updates, the `update` option can be used.
   */
  update(t, e, n) {
    const r = (o) => {
      this.renderer.updateProps(o), typeof this.options.attrs == "function" && this.updateElementAttributes();
    };
    if (t.type !== this.node.type)
      return !1;
    if (typeof this.options.update == "function") {
      const o = this.node, i = this.decorations, s = this.innerDecorations;
      return this.node = t, this.decorations = e, this.innerDecorations = n, this.options.update({
        oldNode: o,
        oldDecorations: i,
        newNode: t,
        newDecorations: e,
        oldInnerDecorations: s,
        innerDecorations: n,
        updateProps: () => r({ node: t, decorations: e, innerDecorations: n, extension: this.extensionWithSyncedStorage })
      });
    }
    return t === this.node && this.decorations === e && this.innerDecorations === n || (this.node = t, this.decorations = e, this.innerDecorations = n, r({ node: t, decorations: e, innerDecorations: n, extension: this.extensionWithSyncedStorage })), !0;
  }
  /**
   * Select the node.
   * Add the `selected` prop and the `ProseMirror-selectednode` class.
   */
  selectNode() {
    this.renderer.updateProps({
      selected: !0
    }), this.renderer.element.classList.add("ProseMirror-selectednode");
  }
  /**
   * Deselect the node.
   * Remove the `selected` prop and the `ProseMirror-selectednode` class.
   */
  deselectNode() {
    this.renderer.updateProps({
      selected: !1
    }), this.renderer.element.classList.remove("ProseMirror-selectednode");
  }
  /**
   * Destroy the React component instance.
   */
  destroy() {
    this.renderer.destroy(), this.editor.off("selectionUpdate", this.handleSelectionUpdate), this.contentDOMElement = null, this.selectionRafId && (cancelAnimationFrame(this.selectionRafId), this.selectionRafId = null);
  }
  /**
   * Update the attributes of the top-level element that holds the React component.
   * Applying the attributes defined in the `attrs` option.
   */
  updateElementAttributes() {
    if (this.options.attrs) {
      let t = {};
      if (typeof this.options.attrs == "function") {
        const e = this.editor.extensionManager.attributes, n = Jo(this.node, e);
        t = this.options.attrs({ node: this.node, HTMLAttributes: n });
      } else
        t = this.options.attrs;
      this.renderer.updateAttributes(t);
    }
  }
};
function zf(t, e) {
  return (n) => n.editor.contentComponent ? new AA(t, n, e) : {};
}
var _A = ot.forwardRef(
  ({
    pluginKey: t = "bubbleMenu",
    editor: e,
    updateDelay: n,
    resizeDelay: r,
    appendTo: o,
    shouldShow: i = null,
    getReferencedVirtualElement: s,
    options: a,
    children: l,
    ...c
  }, u) => {
    const d = fe(document.createElement("div"));
    typeof u == "function" ? u(d.current) : u && (u.current = d.current);
    const { editor: f } = W0(), h = e || f, m = {
      updateDelay: n,
      resizeDelay: r,
      appendTo: o,
      pluginKey: t,
      shouldShow: i,
      getReferencedVirtualElement: s,
      options: a
    }, p = fe(m);
    p.current = m;
    const [g, b] = J(!1), v = fe(!0);
    return ge(() => {
      if (h?.isDestroyed)
        return;
      if (!h) {
        console.warn("BubbleMenu component is not rendered inside of an editor component or does not have editor prop.");
        return;
      }
      const k = d.current;
      k.style.visibility = "hidden", k.style.position = "absolute";
      const x = $0({
        ...p.current,
        editor: h,
        element: k
      });
      h.registerPlugin(x);
      const w = p.current.pluginKey;
      return v.current = !0, b(!0), () => {
        b(!1), h.unregisterPlugin(w), window.requestAnimationFrame(() => {
          k.parentNode && k.parentNode.removeChild(k);
        });
      };
    }, [h]), ge(() => {
      if (!(!g || !h || h.isDestroyed)) {
        if (v.current) {
          v.current = !1;
          return;
        }
        h.view.dispatch(
          h.state.tr.setMeta("bubbleMenu", {
            type: "updateOptions",
            options: p.current
          })
        );
      }
    }, [
      g,
      h,
      n,
      r,
      i,
      a,
      o,
      s
    ]), ai(/* @__PURE__ */ R("div", { ...c, children: l }), d.current);
  }
), RA = ot.forwardRef(
  ({
    pluginKey: t = "floatingMenu",
    editor: e,
    updateDelay: n,
    resizeDelay: r,
    appendTo: o,
    shouldShow: i = null,
    options: s,
    children: a,
    ...l
  }, c) => {
    const u = fe(document.createElement("div"));
    typeof c == "function" ? c(u.current) : c && (c.current = u.current);
    const { editor: d } = W0(), f = e || d, h = {
      updateDelay: n,
      resizeDelay: r,
      appendTo: o,
      pluginKey: t,
      shouldShow: i,
      options: s
    }, m = fe(h);
    m.current = h;
    const [p, g] = J(!1), b = fe(!0);
    return ge(() => {
      if (f?.isDestroyed)
        return;
      if (!f) {
        console.warn(
          "FloatingMenu component is not rendered inside of an editor component or does not have editor prop."
        );
        return;
      }
      const v = u.current;
      v.style.visibility = "hidden", v.style.position = "absolute";
      const k = H0({
        ...m.current,
        editor: f,
        element: v
      });
      f.registerPlugin(k);
      const x = m.current.pluginKey;
      return b.current = !0, g(!0), () => {
        g(!1), f.unregisterPlugin(x), window.requestAnimationFrame(() => {
          v.parentNode && v.parentNode.removeChild(v);
        });
      };
    }, [f]), ge(() => {
      if (!(!p || !f || f.isDestroyed)) {
        if (b.current) {
          b.current = !1;
          return;
        }
        f.view.dispatch(
          f.state.tr.setMeta("floatingMenu", {
            type: "updateOptions",
            options: m.current
          })
        );
      }
    }, [p, f, n, r, i, s, o]), ai(/* @__PURE__ */ R("div", { ...l, children: a }), u.current);
  }
), $f = jl({
  editor: null,
  isReady: !1
});
$f.displayName = "TiptapContext";
var gc = () => Yl($f);
function q0({ instance: t, children: e }) {
  var n;
  const [r, o] = J((n = t?.isInitialized) != null ? n : !1);
  ge(() => {
    if (!t) {
      o(!1);
      return;
    }
    if (t.isInitialized) {
      o(!0);
      return;
    }
    const a = () => {
      o(!0);
    };
    return t.on("create", a), () => {
      t.off("create", a);
    };
  }, [t]);
  const i = Xi(() => ({ editor: t, isReady: r }), [t, r]), s = Xi(() => ({ editor: t }), [t]);
  return /* @__PURE__ */ R(Pf.Provider, { value: s, children: /* @__PURE__ */ R($f.Provider, { value: i, children: e }) });
}
q0.displayName = "Tiptap";
function G0({ ...t }) {
  const { editor: e } = gc();
  return /* @__PURE__ */ R(F0, { editor: e, ...t });
}
G0.displayName = "Tiptap.Content";
function j0({ children: t }) {
  const { isReady: e } = gc();
  return e ? null : t;
}
j0.displayName = "Tiptap.Loading";
function Y0({ children: t, ...e }) {
  const { editor: n } = gc();
  return n ? /* @__PURE__ */ R(_A, { editor: n, ...e, children: t }) : null;
}
Y0.displayName = "Tiptap.BubbleMenu";
function X0({ children: t, ...e }) {
  const { editor: n } = gc();
  return n ? /* @__PURE__ */ R(RA, { ...e, editor: n, children: t }) : null;
}
X0.displayName = "Tiptap.FloatingMenu";
Object.assign(q0, {
  /**
   * The Tiptap Content component that renders the EditorContent with the editor instance from the context.
   * @see TiptapContent
   */
  Content: G0,
  /**
   * The Tiptap Loading component that renders its children only when the editor is not ready.
   * @see TiptapLoading
   */
  Loading: j0,
  /**
   * The Tiptap BubbleMenu component that wraps the BubbleMenu from Tiptap and provides the editor instance from the context.
   * @see TiptapBubbleMenu
   */
  BubbleMenu: Y0,
  /**
   * The Tiptap FloatingMenu component that wraps the FloatingMenu from Tiptap and provides the editor instance from the context.
   * @see TiptapFloatingMenu
   */
  FloatingMenu: X0
});
var ja = (t, e) => {
  if (t === "slot")
    return 0;
  if (t instanceof Function)
    return t(e);
  const { children: n, ...r } = e ?? {};
  if (t === "svg")
    throw new Error("SVG elements are not supported in the JSX syntax, use the array syntax instead");
  return [t, r, n];
}, OA = /^\s*>\s$/, IA = rt.create({
  name: "blockquote",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  group: "block",
  defining: !0,
  parseHTML() {
    return [{ tag: "blockquote" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return /* @__PURE__ */ ja("blockquote", { ...De(this.options.HTMLAttributes, t), children: /* @__PURE__ */ ja("slot", {}) });
  },
  parseMarkdown: (t, e) => e.createNode("blockquote", void 0, e.parseChildren(t.tokens || [])),
  renderMarkdown: (t, e) => {
    if (!t.content)
      return "";
    const n = ">", r = [];
    return t.content.forEach((o) => {
      const a = e.renderChildren([o]).split(`
`).map((l) => l.trim() === "" ? n : `${n} ${l}`);
      r.push(a.join(`
`));
    }), r.join(`
${n}
`);
  },
  addCommands() {
    return {
      setBlockquote: () => ({ commands: t }) => t.wrapIn(this.name),
      toggleBlockquote: () => ({ commands: t }) => t.toggleWrap(this.name),
      unsetBlockquote: () => ({ commands: t }) => t.lift(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-b": () => this.editor.commands.toggleBlockquote()
    };
  },
  addInputRules() {
    return [
      Qo({
        find: OA,
        type: this.type
      })
    ];
  }
}), DA = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, LA = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, PA = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, BA = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, zA = kn.create({
  name: "bold",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "strong"
      },
      {
        tag: "b",
        getAttrs: (t) => t.style.fontWeight !== "normal" && null
      },
      {
        style: "font-weight=400",
        clearMark: (t) => t.type.name === this.name
      },
      {
        style: "font-weight",
        getAttrs: (t) => /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return /* @__PURE__ */ ja("strong", { ...De(this.options.HTMLAttributes, t), children: /* @__PURE__ */ ja("slot", {}) });
  },
  markdownTokenName: "strong",
  parseMarkdown: (t, e) => e.applyMark("bold", e.parseInline(t.tokens || [])),
  renderMarkdown: (t, e) => `**${e.renderChildren(t)}**`,
  addCommands() {
    return {
      setBold: () => ({ commands: t }) => t.setMark(this.name),
      toggleBold: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetBold: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  },
  addInputRules() {
    return [
      to({
        find: DA,
        type: this.type
      }),
      to({
        find: PA,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Ar({
        find: LA,
        type: this.type
      }),
      Ar({
        find: BA,
        type: this.type
      })
    ];
  }
}), $A = /(^|[^`])`([^`]+)`(?!`)$/, HA = /(^|[^`])`([^`]+)`(?!`)/g, FA = kn.create({
  name: "code",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: "_",
  code: !0,
  exitable: !0,
  parseHTML() {
    return [{ tag: "code" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["code", De(this.options.HTMLAttributes, t), 0];
  },
  markdownTokenName: "codespan",
  parseMarkdown: (t, e) => e.applyMark("code", [{ type: "text", text: t.text || "" }]),
  renderMarkdown: (t, e) => t.content ? `\`${e.renderChildren(t.content)}\`` : "",
  addCommands() {
    return {
      setCode: () => ({ commands: t }) => t.setMark(this.name),
      toggleCode: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetCode: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-e": () => this.editor.commands.toggleCode()
    };
  },
  addInputRules() {
    return [
      to({
        find: $A,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Ar({
        find: HA,
        type: this.type
      })
    ];
  }
}), lu = 4, UA = /^```([a-z]+)?[\s\n]$/, WA = /^~~~([a-z]+)?[\s\n]$/, Z0 = rt.create({
  name: "codeBlock",
  addOptions() {
    return {
      languageClassPrefix: "language-",
      exitOnTripleEnter: !0,
      exitOnArrowDown: !0,
      defaultLanguage: null,
      enableTabIndentation: !1,
      tabSize: lu,
      HTMLAttributes: {}
    };
  },
  content: "text*",
  marks: "",
  group: "block",
  code: !0,
  defining: !0,
  addAttributes() {
    return {
      language: {
        default: this.options.defaultLanguage,
        parseHTML: (t) => {
          var e;
          const { languageClassPrefix: n } = this.options;
          if (!n)
            return null;
          const i = [...((e = t.firstElementChild) == null ? void 0 : e.classList) || []].filter((s) => s.startsWith(n)).map((s) => s.replace(n, ""))[0];
          return i || null;
        },
        rendered: !1
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "pre",
        preserveWhitespace: "full"
      }
    ];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [
      "pre",
      De(this.options.HTMLAttributes, e),
      [
        "code",
        {
          class: t.attrs.language ? this.options.languageClassPrefix + t.attrs.language : null
        },
        0
      ]
    ];
  },
  markdownTokenName: "code",
  parseMarkdown: (t, e) => {
    var n;
    return ((n = t.raw) == null ? void 0 : n.startsWith("```")) === !1 && t.codeBlockStyle !== "indented" ? [] : e.createNode(
      "codeBlock",
      { language: t.lang || null },
      t.text ? [e.createTextNode(t.text)] : []
    );
  },
  renderMarkdown: (t, e) => {
    var n;
    let r = "";
    const o = ((n = t.attrs) == null ? void 0 : n.language) || "";
    return t.content ? r = [`\`\`\`${o}`, e.renderChildren(t.content), "```"].join(`
`) : r = `\`\`\`${o}

\`\`\``, r;
  },
  addCommands() {
    return {
      setCodeBlock: (t) => ({ commands: e }) => e.setNode(this.name, t),
      toggleCodeBlock: (t) => ({ commands: e }) => e.toggleNode(this.name, "paragraph", t)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
      // remove code block when at start of document or code block is empty
      Backspace: () => {
        const { empty: t, $anchor: e } = this.editor.state.selection, n = e.pos === 1;
        return !t || e.parent.type.name !== this.name ? !1 : n || !e.parent.textContent.length ? this.editor.commands.clearNodes() : !1;
      },
      // handle tab indentation
      Tab: ({ editor: t }) => {
        var e;
        if (!this.options.enableTabIndentation)
          return !1;
        const n = (e = this.options.tabSize) != null ? e : lu, { state: r } = t, { selection: o } = r, { $from: i, empty: s } = o;
        if (i.parent.type !== this.type)
          return !1;
        const a = " ".repeat(n);
        return s ? t.commands.insertContent(a) : t.commands.command(({ tr: l }) => {
          const { from: c, to: u } = o, h = r.doc.textBetween(c, u, `
`, `
`).split(`
`).map((m) => a + m).join(`
`);
          return l.replaceWith(c, u, r.schema.text(h)), !0;
        });
      },
      // handle shift+tab reverse indentation
      "Shift-Tab": ({ editor: t }) => {
        var e;
        if (!this.options.enableTabIndentation)
          return !1;
        const n = (e = this.options.tabSize) != null ? e : lu, { state: r } = t, { selection: o } = r, { $from: i, empty: s } = o;
        return i.parent.type !== this.type ? !1 : s ? t.commands.command(({ tr: a }) => {
          var l;
          const { pos: c } = i, u = i.start(), d = i.end(), h = r.doc.textBetween(u, d, `
`, `
`).split(`
`);
          let m = 0, p = 0;
          const g = c - u;
          for (let E = 0; E < h.length; E += 1) {
            if (p + h[E].length >= g) {
              m = E;
              break;
            }
            p += h[E].length + 1;
          }
          const v = ((l = h[m].match(/^ */)) == null ? void 0 : l[0]) || "", k = Math.min(v.length, n);
          if (k === 0)
            return !0;
          let x = u;
          for (let E = 0; E < m; E += 1)
            x += h[E].length + 1;
          return a.delete(x, x + k), c - x <= k && a.setSelection(ce.create(a.doc, x)), !0;
        }) : t.commands.command(({ tr: a }) => {
          const { from: l, to: c } = o, f = r.doc.textBetween(l, c, `
`, `
`).split(`
`).map((h) => {
            var m;
            const p = ((m = h.match(/^ */)) == null ? void 0 : m[0]) || "", g = Math.min(p.length, n);
            return h.slice(g);
          }).join(`
`);
          return a.replaceWith(l, c, r.schema.text(f)), !0;
        });
      },
      // exit node on triple enter
      Enter: ({ editor: t }) => {
        if (!this.options.exitOnTripleEnter)
          return !1;
        const { state: e } = t, { selection: n } = e, { $from: r, empty: o } = n;
        if (!o || r.parent.type !== this.type)
          return !1;
        const i = r.parentOffset === r.parent.nodeSize - 2, s = r.parent.textContent.endsWith(`

`);
        return !i || !s ? !1 : t.chain().command(({ tr: a }) => (a.delete(r.pos - 2, r.pos), !0)).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: ({ editor: t }) => {
        if (!this.options.exitOnArrowDown)
          return !1;
        const { state: e } = t, { selection: n, doc: r } = e, { $from: o, empty: i } = n;
        if (!i || o.parent.type !== this.type || !(o.parentOffset === o.parent.nodeSize - 2))
          return !1;
        const a = o.after();
        return a === void 0 ? !1 : r.nodeAt(a) ? t.commands.command(({ tr: c }) => (c.setSelection(pe.near(r.resolve(a))), !0)) : t.commands.exitCode();
      }
    };
  },
  addInputRules() {
    return [
      td({
        find: UA,
        type: this.type,
        getAttributes: (t) => ({
          language: t[1]
        })
      }),
      td({
        find: WA,
        type: this.type,
        getAttributes: (t) => ({
          language: t[1]
        })
      })
    ];
  },
  addProseMirrorPlugins() {
    return [
      // this plugin creates a code block for pasted content from VS Code
      // we can also detect the copied code language
      new Ce({
        key: new Ie("codeBlockVSCodeHandler"),
        props: {
          handlePaste: (t, e) => {
            if (!e.clipboardData || this.editor.isActive(this.type.name))
              return !1;
            const n = e.clipboardData.getData("text/plain"), r = e.clipboardData.getData("vscode-editor-data"), o = r ? JSON.parse(r) : void 0, i = o?.mode;
            if (!n || !i)
              return !1;
            const { tr: s, schema: a } = t.state, l = a.text(n.replace(/\r\n?/g, `
`));
            return s.replaceSelectionWith(this.type.create({ language: i }, l)), s.selection.$from.parent.type !== this.type && s.setSelection(ce.near(s.doc.resolve(Math.max(0, s.selection.from - 2)))), s.setMeta("paste", !0), t.dispatch(s), !0;
          }
        }
      })
    ];
  }
}), VA = Z0, KA = rt.create({
  name: "doc",
  topNode: !0,
  content: "block+",
  renderMarkdown: (t, e) => t.content ? e.renderChildren(t.content, `

`) : ""
}), qA = rt.create({
  name: "hardBreak",
  markdownTokenName: "br",
  addOptions() {
    return {
      keepMarks: !0,
      HTMLAttributes: {}
    };
  },
  inline: !0,
  group: "inline",
  selectable: !1,
  linebreakReplacement: !0,
  parseHTML() {
    return [{ tag: "br" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["br", De(this.options.HTMLAttributes, t)];
  },
  renderText() {
    return `
`;
  },
  renderMarkdown: () => `  
`,
  parseMarkdown: () => ({
    type: "hardBreak"
  }),
  addCommands() {
    return {
      setHardBreak: () => ({ commands: t, chain: e, state: n, editor: r }) => t.first([
        () => t.exitCode(),
        () => t.command(() => {
          const { selection: o, storedMarks: i } = n;
          if (o.$from.parent.type.spec.isolating)
            return !1;
          const { keepMarks: s } = this.options, { splittableMarks: a } = r.extensionManager, l = i || o.$to.parentOffset && o.$from.marks();
          return e().insertContent({ type: this.name }).command(({ tr: c, dispatch: u }) => {
            if (u && l && s) {
              const d = l.filter((f) => a.includes(f.type.name));
              c.ensureMarks(d);
            }
            return !0;
          }).run();
        })
      ])
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.setHardBreak(),
      "Shift-Enter": () => this.editor.commands.setHardBreak()
    };
  }
}), GA = rt.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: "inline*",
  group: "block",
  defining: !0,
  addAttributes() {
    return {
      level: {
        default: 1,
        rendered: !1
      }
    };
  },
  parseHTML() {
    return this.options.levels.map((t) => ({
      tag: `h${t}`,
      attrs: { level: t }
    }));
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [`h${this.options.levels.includes(t.attrs.level) ? t.attrs.level : this.options.levels[0]}`, De(this.options.HTMLAttributes, e), 0];
  },
  parseMarkdown: (t, e) => e.createNode("heading", { level: t.depth || 1 }, e.parseInline(t.tokens || [])),
  renderMarkdown: (t, e) => {
    var n;
    const r = (n = t.attrs) != null && n.level ? parseInt(t.attrs.level, 10) : 1, o = "#".repeat(r);
    return t.content ? `${o} ${e.renderChildren(t.content)}` : "";
  },
  addCommands() {
    return {
      setHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.setNode(this.name, t) : !1,
      toggleHeading: (t) => ({ commands: e }) => this.options.levels.includes(t.level) ? e.toggleNode(this.name, "paragraph", t) : !1
    };
  },
  addKeyboardShortcuts() {
    return this.options.levels.reduce(
      (t, e) => ({
        ...t,
        [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e })
      }),
      {}
    );
  },
  addInputRules() {
    return this.options.levels.map((t) => td({
      find: new RegExp(`^(#{${Math.min(...this.options.levels)},${t}})\\s$`),
      type: this.type,
      getAttributes: {
        level: t
      }
    }));
  }
}), jA = rt.create({
  name: "horizontalRule",
  addOptions() {
    return {
      HTMLAttributes: {},
      nextNodeType: "paragraph"
    };
  },
  group: "block",
  parseHTML() {
    return [{ tag: "hr" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["hr", De(this.options.HTMLAttributes, t)];
  },
  markdownTokenName: "hr",
  parseMarkdown: (t, e) => e.createNode("horizontalRule"),
  renderMarkdown: () => "---",
  addCommands() {
    return {
      setHorizontalRule: () => ({ chain: t, state: e }) => {
        if (!xT(e, e.schema.nodes[this.name]))
          return !1;
        const { selection: n } = e, { $to: r } = n, o = t();
        return Yy(n) ? o.insertContentAt(r.pos, {
          type: this.name
        }) : o.insertContent({ type: this.name }), o.command(({ state: i, tr: s, dispatch: a }) => {
          if (a) {
            const { $to: l } = s.selection, c = l.end();
            if (l.nodeAfter)
              l.nodeAfter.isTextblock ? s.setSelection(ce.create(s.doc, l.pos + 1)) : l.nodeAfter.isBlock ? s.setSelection(se.create(s.doc, l.pos)) : s.setSelection(ce.create(s.doc, l.pos));
            else {
              const u = i.schema.nodes[this.options.nextNodeType] || l.parent.type.contentMatch.defaultType, d = u?.create();
              d && (s.insert(c, d), s.setSelection(ce.create(s.doc, c + 1)));
            }
            s.scrollIntoView();
          }
          return !0;
        }).run();
      }
    };
  },
  addInputRules() {
    return [
      h0({
        find: /^(?:---|—-|___\s|\*\*\*\s)$/,
        type: this.type
      })
    ];
  }
}), YA = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, XA = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, ZA = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, JA = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, QA = kn.create({
  name: "italic",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "em"
      },
      {
        tag: "i",
        getAttrs: (t) => t.style.fontStyle !== "normal" && null
      },
      {
        style: "font-style=normal",
        clearMark: (t) => t.type.name === this.name
      },
      {
        style: "font-style=italic"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["em", De(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setItalic: () => ({ commands: t }) => t.setMark(this.name),
      toggleItalic: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetItalic: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  markdownTokenName: "em",
  parseMarkdown: (t, e) => e.applyMark("italic", e.parseInline(t.tokens || [])),
  renderMarkdown: (t, e) => `*${e.renderChildren(t)}*`,
  addKeyboardShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  },
  addInputRules() {
    return [
      to({
        find: YA,
        type: this.type
      }),
      to({
        find: ZA,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Ar({
        find: XA,
        type: this.type
      }),
      Ar({
        find: JA,
        type: this.type
      })
    ];
  }
});
const e_ = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0axi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", t_ = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2", dd = "numeric", fd = "ascii", hd = "alpha", Hi = "asciinumeric", _i = "alphanumeric", md = "domain", J0 = "emoji", n_ = "scheme", r_ = "slashscheme", cu = "whitespace";
function o_(t, e) {
  return t in e || (e[t] = []), e[t];
}
function Vr(t, e, n) {
  e[dd] && (e[Hi] = !0, e[_i] = !0), e[fd] && (e[Hi] = !0, e[hd] = !0), e[Hi] && (e[_i] = !0), e[hd] && (e[_i] = !0), e[_i] && (e[md] = !0), e[J0] && (e[md] = !0);
  for (const r in e) {
    const o = o_(r, n);
    o.indexOf(t) < 0 && o.push(t);
  }
}
function i_(t, e) {
  const n = {};
  for (const r in e)
    e[r].indexOf(t) >= 0 && (n[r] = !0);
  return n;
}
function zt(t = null) {
  this.j = {}, this.jr = [], this.jd = null, this.t = t;
}
zt.groups = {};
zt.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(t) {
    const e = this, n = e.j[t];
    if (n)
      return n;
    for (let r = 0; r < e.jr.length; r++) {
      const o = e.jr[r][0], i = e.jr[r][1];
      if (i && o.test(t))
        return i;
    }
    return e.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(t, e = !1) {
    return e ? t in this.j : !!this.go(t);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(t, e, n, r) {
    for (let o = 0; o < t.length; o++)
      this.tt(t[o], e, n, r);
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(t, e, n, r) {
    r = r || zt.groups;
    let o;
    return e && e.j ? o = e : (o = new zt(e), n && r && Vr(e, n, r)), this.jr.push([t, o]), o;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(t, e, n, r) {
    let o = this;
    const i = t.length;
    if (!i)
      return o;
    for (let s = 0; s < i - 1; s++)
      o = o.tt(t[s]);
    return o.tt(t[i - 1], e, n, r);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(t, e, n, r) {
    r = r || zt.groups;
    const o = this;
    if (e && e.j)
      return o.j[t] = e, e;
    const i = e;
    let s, a = o.go(t);
    if (a ? (s = new zt(), Object.assign(s.j, a.j), s.jr.push.apply(s.jr, a.jr), s.jd = a.jd, s.t = a.t) : s = new zt(), i) {
      if (r)
        if (s.t && typeof s.t == "string") {
          const l = Object.assign(i_(s.t, r), n);
          Vr(i, l, r);
        } else n && Vr(i, n, r);
      s.t = i;
    }
    return o.j[t] = s, s;
  }
};
const xe = (t, e, n, r, o) => t.ta(e, n, r, o), Qe = (t, e, n, r, o) => t.tr(e, n, r, o), Ap = (t, e, n, r, o) => t.ts(e, n, r, o), B = (t, e, n, r, o) => t.tt(e, n, r, o), Gn = "WORD", pd = "UWORD", Q0 = "ASCIINUMERICAL", ev = "ALPHANUMERICAL", cs = "LOCALHOST", gd = "TLD", bd = "UTLD", Na = "SCHEME", Po = "SLASH_SCHEME", Hf = "NUM", yd = "WS", Ff = "NL", Fi = "OPENBRACE", Ui = "CLOSEBRACE", Ya = "OPENBRACKET", Xa = "CLOSEBRACKET", Za = "OPENPAREN", Ja = "CLOSEPAREN", Qa = "OPENANGLEBRACKET", el = "CLOSEANGLEBRACKET", tl = "FULLWIDTHLEFTPAREN", nl = "FULLWIDTHRIGHTPAREN", rl = "LEFTCORNERBRACKET", ol = "RIGHTCORNERBRACKET", il = "LEFTWHITECORNERBRACKET", sl = "RIGHTWHITECORNERBRACKET", al = "FULLWIDTHLESSTHAN", ll = "FULLWIDTHGREATERTHAN", cl = "AMPERSAND", ul = "APOSTROPHE", dl = "ASTERISK", mr = "AT", fl = "BACKSLASH", hl = "BACKTICK", ml = "CARET", yr = "COLON", Uf = "COMMA", pl = "DOLLAR", An = "DOT", gl = "EQUALS", Wf = "EXCLAMATION", Qt = "HYPHEN", Wi = "PERCENT", bl = "PIPE", yl = "PLUS", vl = "POUND", Vi = "QUERY", Vf = "QUOTE", tv = "FULLWIDTHMIDDLEDOT", Kf = "SEMI", _n = "SLASH", Ki = "TILDE", wl = "UNDERSCORE", nv = "EMOJI", kl = "SYM";
var rv = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ALPHANUMERICAL: ev,
  AMPERSAND: cl,
  APOSTROPHE: ul,
  ASCIINUMERICAL: Q0,
  ASTERISK: dl,
  AT: mr,
  BACKSLASH: fl,
  BACKTICK: hl,
  CARET: ml,
  CLOSEANGLEBRACKET: el,
  CLOSEBRACE: Ui,
  CLOSEBRACKET: Xa,
  CLOSEPAREN: Ja,
  COLON: yr,
  COMMA: Uf,
  DOLLAR: pl,
  DOT: An,
  EMOJI: nv,
  EQUALS: gl,
  EXCLAMATION: Wf,
  FULLWIDTHGREATERTHAN: ll,
  FULLWIDTHLEFTPAREN: tl,
  FULLWIDTHLESSTHAN: al,
  FULLWIDTHMIDDLEDOT: tv,
  FULLWIDTHRIGHTPAREN: nl,
  HYPHEN: Qt,
  LEFTCORNERBRACKET: rl,
  LEFTWHITECORNERBRACKET: il,
  LOCALHOST: cs,
  NL: Ff,
  NUM: Hf,
  OPENANGLEBRACKET: Qa,
  OPENBRACE: Fi,
  OPENBRACKET: Ya,
  OPENPAREN: Za,
  PERCENT: Wi,
  PIPE: bl,
  PLUS: yl,
  POUND: vl,
  QUERY: Vi,
  QUOTE: Vf,
  RIGHTCORNERBRACKET: ol,
  RIGHTWHITECORNERBRACKET: sl,
  SCHEME: Na,
  SEMI: Kf,
  SLASH: _n,
  SLASH_SCHEME: Po,
  SYM: kl,
  TILDE: Ki,
  TLD: gd,
  UNDERSCORE: wl,
  UTLD: bd,
  UWORD: pd,
  WORD: Gn,
  WS: yd
});
const Un = /[a-z]/, vi = new RegExp("\\p{L}", "u"), uu = new RegExp("\\p{Emoji}", "u"), Wn = /\d/, du = /\s/, _p = "\r", fu = `
`, s_ = "️", a_ = "‍", hu = "￼";
let Zs = null, Js = null;
function l_(t = []) {
  const e = {};
  zt.groups = e;
  const n = new zt();
  Zs == null && (Zs = Rp(e_)), Js == null && (Js = Rp(t_)), B(n, "'", ul), B(n, "{", Fi), B(n, "}", Ui), B(n, "[", Ya), B(n, "]", Xa), B(n, "(", Za), B(n, ")", Ja), B(n, "<", Qa), B(n, ">", el), B(n, "（", tl), B(n, "）", nl), B(n, "「", rl), B(n, "」", ol), B(n, "『", il), B(n, "』", sl), B(n, "＜", al), B(n, "＞", ll), B(n, "&", cl), B(n, "*", dl), B(n, "@", mr), B(n, "`", hl), B(n, "^", ml), B(n, ":", yr), B(n, ",", Uf), B(n, "$", pl), B(n, ".", An), B(n, "=", gl), B(n, "!", Wf), B(n, "-", Qt), B(n, "%", Wi), B(n, "|", bl), B(n, "+", yl), B(n, "#", vl), B(n, "?", Vi), B(n, '"', Vf), B(n, "/", _n), B(n, ";", Kf), B(n, "~", Ki), B(n, "_", wl), B(n, "\\", fl), B(n, "・", tv);
  const r = Qe(n, Wn, Hf, {
    [dd]: !0
  });
  Qe(r, Wn, r);
  const o = Qe(r, Un, Q0, {
    [Hi]: !0
  }), i = Qe(r, vi, ev, {
    [_i]: !0
  }), s = Qe(n, Un, Gn, {
    [fd]: !0
  });
  Qe(s, Wn, o), Qe(s, Un, s), Qe(o, Wn, o), Qe(o, Un, o);
  const a = Qe(n, vi, pd, {
    [hd]: !0
  });
  Qe(a, Un), Qe(a, Wn, i), Qe(a, vi, a), Qe(i, Wn, i), Qe(i, Un), Qe(i, vi, i);
  const l = B(n, fu, Ff, {
    [cu]: !0
  }), c = B(n, _p, yd, {
    [cu]: !0
  }), u = Qe(n, du, yd, {
    [cu]: !0
  });
  B(n, hu, u), B(c, fu, l), B(c, hu, u), Qe(c, du, u), B(u, _p), B(u, fu), Qe(u, du, u), B(u, hu, u);
  const d = Qe(n, uu, nv, {
    [J0]: !0
  });
  B(d, "#"), Qe(d, uu, d), B(d, s_, d);
  const f = B(d, a_);
  B(f, "#"), Qe(f, uu, d);
  const h = [[Un, s], [Wn, o]], m = [[Un, null], [vi, a], [Wn, i]];
  for (let p = 0; p < Zs.length; p++)
    ir(n, Zs[p], gd, Gn, h);
  for (let p = 0; p < Js.length; p++)
    ir(n, Js[p], bd, pd, m);
  Vr(gd, {
    tld: !0,
    ascii: !0
  }, e), Vr(bd, {
    utld: !0,
    alpha: !0
  }, e), ir(n, "file", Na, Gn, h), ir(n, "mailto", Na, Gn, h), ir(n, "http", Po, Gn, h), ir(n, "https", Po, Gn, h), ir(n, "ftp", Po, Gn, h), ir(n, "ftps", Po, Gn, h), Vr(Na, {
    scheme: !0,
    ascii: !0
  }, e), Vr(Po, {
    slashscheme: !0,
    ascii: !0
  }, e), t = t.sort((p, g) => p[0] > g[0] ? 1 : -1);
  for (let p = 0; p < t.length; p++) {
    const g = t[p][0], v = t[p][1] ? {
      [n_]: !0
    } : {
      [r_]: !0
    };
    g.indexOf("-") >= 0 ? v[md] = !0 : Un.test(g) ? Wn.test(g) ? v[Hi] = !0 : v[fd] = !0 : v[dd] = !0, Ap(n, g, g, v);
  }
  return Ap(n, "localhost", cs, {
    ascii: !0
  }), n.jd = new zt(kl), {
    start: n,
    tokens: Object.assign({
      groups: e
    }, rv)
  };
}
function ov(t, e) {
  const n = c_(e.replace(/[A-Z]/g, (a) => a.toLowerCase())), r = n.length, o = [];
  let i = 0, s = 0;
  for (; s < r; ) {
    let a = t, l = null, c = 0, u = null, d = -1, f = -1;
    for (; s < r && (l = a.go(n[s])); )
      a = l, a.accepts() ? (d = 0, f = 0, u = a) : d >= 0 && (d += n[s].length, f++), c += n[s].length, i += n[s].length, s++;
    i -= d, s -= f, c -= d, o.push({
      t: u.t,
      // token type/name
      v: e.slice(i - c, i),
      // string value
      s: i - c,
      // start index
      e: i
      // end index (excluding)
    });
  }
  return o;
}
function c_(t) {
  const e = [], n = t.length;
  let r = 0;
  for (; r < n; ) {
    let o = t.charCodeAt(r), i, s = o < 55296 || o > 56319 || r + 1 === n || (i = t.charCodeAt(r + 1)) < 56320 || i > 57343 ? t[r] : t.slice(r, r + 2);
    e.push(s), r += s.length;
  }
  return e;
}
function ir(t, e, n, r, o) {
  let i;
  const s = e.length;
  for (let a = 0; a < s - 1; a++) {
    const l = e[a];
    t.j[l] ? i = t.j[l] : (i = new zt(r), i.jr = o.slice(), t.j[l] = i), t = i;
  }
  return i = new zt(n), i.jr = o.slice(), t.j[e[s - 1]] = i, i;
}
function Rp(t) {
  const e = [], n = [];
  let r = 0, o = "0123456789";
  for (; r < t.length; ) {
    let i = 0;
    for (; o.indexOf(t[r + i]) >= 0; )
      i++;
    if (i > 0) {
      e.push(n.join(""));
      for (let s = parseInt(t.substring(r, r + i), 10); s > 0; s--)
        n.pop();
      r += i;
    } else
      n.push(t[r]), r++;
  }
  return e;
}
const us = {
  defaultProtocol: "http",
  events: null,
  format: Op,
  formatHref: Op,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function qf(t, e = null) {
  let n = Object.assign({}, us);
  t && (n = Object.assign(n, t instanceof qf ? t.o : t));
  const r = n.ignoreTags, o = [];
  for (let i = 0; i < r.length; i++)
    o.push(r[i].toUpperCase());
  this.o = n, e && (this.defaultRender = e), this.ignoreTags = o;
}
qf.prototype = {
  o: us,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(t) {
    return t;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(t) {
    return this.get("validate", t.toString(), t);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(t, e, n) {
    const r = e != null;
    let o = this.o[t];
    return o && (typeof o == "object" ? (o = n.t in o ? o[n.t] : us[t], typeof o == "function" && r && (o = o(e, n))) : typeof o == "function" && r && (o = o(e, n.t, n)), o);
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(t, e, n) {
    let r = this.o[t];
    return typeof r == "function" && e != null && (r = r(e, n.t, n)), r;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(t) {
    const e = t.render(this);
    return (this.get("render", null, t) || this.defaultRender)(e, t.t, t);
  }
};
function Op(t) {
  return t;
}
function iv(t, e) {
  this.t = "token", this.v = t, this.tk = e;
}
iv.prototype = {
  isLink: !1,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(t) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(t) {
    const e = this.toString(), n = t.get("truncate", e, this), r = t.get("format", e, this);
    return n && r.length > n ? r.substring(0, n) + "…" : r;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(t) {
    return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(t = us.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(t) {
    return {
      type: this.t,
      value: this.toFormattedString(t),
      isLink: this.isLink,
      href: this.toFormattedHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(t) {
    return t.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(t) {
    const e = this, n = this.toHref(t.get("defaultProtocol")), r = t.get("formatHref", n, this), o = t.get("tagName", n, e), i = this.toFormattedString(t), s = {}, a = t.get("className", n, e), l = t.get("target", n, e), c = t.get("rel", n, e), u = t.getObj("attributes", n, e), d = t.getObj("events", n, e);
    return s.href = r, a && (s.class = a), l && (s.target = l), c && (s.rel = c), u && Object.assign(s, u), {
      tagName: o,
      attributes: s,
      content: i,
      eventListeners: d
    };
  }
};
function bc(t, e) {
  class n extends iv {
    constructor(o, i) {
      super(o, i), this.t = t;
    }
  }
  for (const r in e)
    n.prototype[r] = e[r];
  return n.t = t, n;
}
const Ip = bc("email", {
  isLink: !0,
  toHref() {
    return "mailto:" + this.toString();
  }
}), Dp = bc("text"), u_ = bc("nl"), Qs = bc("url", {
  isLink: !0,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(t = us.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${t}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const t = this.tk;
    return t.length >= 2 && t[0].t !== cs && t[1].t === yr;
  }
}), Jt = (t) => new zt(t);
function d_({
  groups: t
}) {
  const e = t.domain.concat([cl, dl, mr, fl, hl, ml, pl, gl, Qt, Hf, Wi, bl, yl, vl, _n, kl, Ki, wl]), n = [ul, yr, Uf, An, Wf, Wi, Vi, Vf, Kf, Qa, el, Fi, Ui, Xa, Ya, Za, Ja, tl, nl, rl, ol, il, sl, al, ll], r = [cl, ul, dl, fl, hl, ml, pl, gl, Qt, Fi, Ui, Wi, bl, yl, vl, Vi, _n, kl, Ki, wl], o = Jt(), i = B(o, Ki);
  xe(i, r, i), xe(i, t.domain, i);
  const s = Jt(), a = Jt(), l = Jt();
  xe(o, t.domain, s), xe(o, t.scheme, a), xe(o, t.slashscheme, l), xe(s, r, i), xe(s, t.domain, s);
  const c = B(s, mr);
  B(i, mr, c), B(a, mr, c), B(l, mr, c);
  const u = B(i, An);
  xe(u, r, i), xe(u, t.domain, i);
  const d = Jt();
  xe(c, t.domain, d), xe(d, t.domain, d);
  const f = B(d, An);
  xe(f, t.domain, d);
  const h = Jt(Ip);
  xe(f, t.tld, h), xe(f, t.utld, h), B(c, cs, h);
  const m = B(d, Qt);
  B(m, Qt, m), xe(m, t.domain, d), xe(h, t.domain, d), B(h, An, f), B(h, Qt, m);
  const p = B(h, yr);
  xe(p, t.numeric, Ip);
  const g = B(s, Qt), b = B(s, An);
  B(g, Qt, g), xe(g, t.domain, s), xe(b, r, i), xe(b, t.domain, s);
  const v = Jt(Qs);
  xe(b, t.tld, v), xe(b, t.utld, v), xe(v, t.domain, s), xe(v, r, i), B(v, An, b), B(v, Qt, g), B(v, mr, c);
  const k = B(v, yr), x = Jt(Qs);
  xe(k, t.numeric, x);
  const w = Jt(Qs), E = Jt();
  xe(w, e, w), xe(w, n, E), xe(E, e, w), xe(E, n, E), B(v, _n, w), B(x, _n, w);
  const S = B(a, yr), C = B(l, yr), M = B(C, _n), O = B(M, _n);
  xe(a, t.domain, s), B(a, An, b), B(a, Qt, g), xe(l, t.domain, s), B(l, An, b), B(l, Qt, g), xe(S, t.domain, w), B(S, _n, w), B(S, Vi, w), xe(O, t.domain, w), xe(O, e, w), B(O, _n, w);
  const q = [
    [Fi, Ui],
    // {}
    [Ya, Xa],
    // []
    [Za, Ja],
    // ()
    [Qa, el],
    // <>
    [tl, nl],
    // （）
    [rl, ol],
    // 「」
    [il, sl],
    // 『』
    [al, ll]
    // ＜＞
  ];
  for (let K = 0; K < q.length; K++) {
    const [j, H] = q[K], G = B(w, j);
    B(E, j, G), B(G, H, w);
    const V = Jt(Qs);
    xe(G, e, V);
    const re = Jt();
    xe(G, n), xe(V, e, V), xe(V, n, re), xe(re, e, V), xe(re, n, re), B(V, H, w), B(re, H, w);
  }
  return B(o, cs, v), B(o, Ff, u_), {
    start: o,
    tokens: rv
  };
}
function f_(t, e, n) {
  let r = n.length, o = 0, i = [], s = [];
  for (; o < r; ) {
    let a = t, l = null, c = null, u = 0, d = null, f = -1;
    for (; o < r && !(l = a.go(n[o].t)); )
      s.push(n[o++]);
    for (; o < r && (c = l || a.go(n[o].t)); )
      l = null, a = c, a.accepts() ? (f = 0, d = a) : f >= 0 && f++, o++, u++;
    if (f < 0)
      o -= u, o < r && (s.push(n[o]), o++);
    else {
      s.length > 0 && (i.push(mu(Dp, e, s)), s = []), o -= f, u -= f;
      const h = d.t, m = n.slice(o - u, o);
      i.push(mu(h, e, m));
    }
  }
  return s.length > 0 && i.push(mu(Dp, e, s)), i;
}
function mu(t, e, n) {
  const r = n[0].s, o = n[n.length - 1].e, i = e.slice(r, o);
  return new t(i, n);
}
const h_ = typeof console < "u" && console && console.warn || (() => {
}), m_ = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", Xe = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: !1
};
function p_() {
  return zt.groups = {}, Xe.scanner = null, Xe.parser = null, Xe.tokenQueue = [], Xe.pluginQueue = [], Xe.customSchemes = [], Xe.initialized = !1, Xe;
}
function Lp(t, e = !1) {
  if (Xe.initialized && h_(`linkifyjs: already initialized - will not register custom scheme "${t}" ${m_}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  Xe.customSchemes.push([t, e]);
}
function g_() {
  Xe.scanner = l_(Xe.customSchemes);
  for (let t = 0; t < Xe.tokenQueue.length; t++)
    Xe.tokenQueue[t][1]({
      scanner: Xe.scanner
    });
  Xe.parser = d_(Xe.scanner.tokens);
  for (let t = 0; t < Xe.pluginQueue.length; t++)
    Xe.pluginQueue[t][1]({
      scanner: Xe.scanner,
      parser: Xe.parser
    });
  return Xe.initialized = !0, Xe;
}
function Gf(t) {
  return Xe.initialized || g_(), f_(Xe.parser.start, t, ov(Xe.scanner.start, t));
}
Gf.scan = ov;
function sv(t, e = null, n = null) {
  if (e && typeof e == "object") {
    if (n)
      throw Error(`linkifyjs: Invalid link type ${e}; must be a string`);
    n = e, e = null;
  }
  const r = new qf(n), o = Gf(t), i = [];
  for (let s = 0; s < o.length; s++) {
    const a = o[s];
    a.isLink && (!e || a.t === e) && r.check(a) && i.push(a.toFormattedObject(r));
  }
  return i;
}
var jf = "[\0-   ᠎ -\u2029 　]", b_ = new RegExp(jf), y_ = new RegExp(`${jf}$`), v_ = new RegExp(jf, "g");
function w_(t) {
  return t.length === 1 ? t[0].isLink : t.length === 3 && t[1].isLink ? ["()", "[]"].includes(t[0].value + t[2].value) : !1;
}
function k_(t) {
  return new Ce({
    key: new Ie("autolink"),
    appendTransaction: (e, n, r) => {
      const o = e.some((c) => c.docChanged) && !n.doc.eq(r.doc), i = e.some((c) => c.getMeta("preventAutolink"));
      if (!o || i)
        return;
      const { tr: s } = r, a = Hy(n.doc, [...e]);
      if (jy(a).forEach(({ newRange: c }) => {
        const u = NS(r.doc, c, (h) => h.isTextblock);
        let d, f;
        if (u.length > 1)
          d = u[0], f = r.doc.textBetween(
            d.pos,
            d.pos + d.node.nodeSize,
            void 0,
            " "
          );
        else if (u.length) {
          const h = r.doc.textBetween(c.from, c.to, " ", " ");
          if (!y_.test(h))
            return;
          d = u[0], f = r.doc.textBetween(d.pos, c.to, void 0, " ");
        }
        if (d && f) {
          const h = f.split(b_).filter(Boolean);
          if (h.length <= 0)
            return !1;
          const m = h[h.length - 1], p = d.pos + f.lastIndexOf(m);
          if (!m)
            return !1;
          const g = Gf(m).map((b) => b.toObject(t.defaultProtocol));
          if (!w_(g))
            return !1;
          g.filter((b) => b.isLink).map((b) => ({
            ...b,
            from: p + b.start + 1,
            to: p + b.end + 1
          })).filter((b) => r.schema.marks.code ? !r.doc.rangeHasMark(b.from, b.to, r.schema.marks.code) : !0).filter((b) => t.validate(b.value)).filter((b) => t.shouldAutoLink(b.value)).forEach((b) => {
            gf(b.from, b.to, r.doc).some((v) => v.mark.type === t.type) || s.addMark(
              b.from,
              b.to,
              t.type.create({
                href: b.href
              })
            );
          });
        }
      }), !!s.steps.length)
        return s;
    }
  });
}
function x_(t) {
  return new Ce({
    key: new Ie("handleClickLink"),
    props: {
      handleClick: (e, n, r) => {
        var o, i;
        if (r.button !== 0 || !e.editable)
          return !1;
        let s = null;
        if (r.target instanceof HTMLAnchorElement)
          s = r.target;
        else {
          const l = r.target;
          if (!l)
            return !1;
          const c = t.editor.view.dom;
          s = l.closest("a"), s && !c.contains(s) && (s = null);
        }
        if (!s)
          return !1;
        let a = !1;
        if (t.enableClickSelection && (a = t.editor.commands.extendMarkRange(t.type.name)), t.openOnClick) {
          const l = Gy(e.state, t.type.name), c = (o = s.href) != null ? o : l.href, u = (i = s.target) != null ? i : l.target;
          c && (window.open(c, u), a = !0);
        }
        return a;
      }
    }
  });
}
function N_(t) {
  return new Ce({
    key: new Ie("handlePasteLink"),
    props: {
      handlePaste: (e, n, r) => {
        const { shouldAutoLink: o } = t, { state: i } = e, { selection: s } = i, { empty: a } = s;
        if (a)
          return !1;
        let l = "";
        r.content.forEach((u) => {
          l += u.textContent;
        });
        const c = sv(l, { defaultProtocol: t.defaultProtocol }).find(
          (u) => u.isLink && u.value === l
        );
        return !l || !c || o !== void 0 && !o(c.value) ? !1 : t.editor.commands.setMark(t.type, {
          href: c.href
        });
      }
    }
  });
}
function $r(t, e) {
  const n = ["http", "https", "ftp", "ftps", "mailto", "tel", "callto", "sms", "cid", "xmpp"];
  return e && e.forEach((r) => {
    const o = typeof r == "string" ? r : r.scheme;
    o && n.push(o);
  }), !t || t.replace(v_, "").match(
    new RegExp(
      // eslint-disable-next-line no-useless-escape
      `^(?:(?:${n.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
      "i"
    )
  );
}
var av = kn.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: !1,
  exitable: !0,
  onCreate() {
    this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach((t) => {
      if (typeof t == "string") {
        Lp(t);
        return;
      }
      Lp(t.scheme, t.optionalSlashes);
    });
  },
  onDestroy() {
    p_();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: !0,
      enableClickSelection: !1,
      linkOnPaste: !0,
      autolink: !0,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (t, e) => !!$r(t, e.protocols),
      validate: (t) => !!t,
      shouldAutoLink: (t) => {
        const e = /^[a-z][a-z0-9+.-]*:\/\//i.test(t), n = /^[a-z][a-z0-9+.-]*:/i.test(t);
        if (e || n && !t.includes("@"))
          return !0;
        const o = (t.includes("@") ? t.split("@").pop() : t).split(/[/?#:]/)[0];
        return !(/^\d{1,3}(\.\d{1,3}){3}$/.test(o) || !/\./.test(o));
      }
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(t) {
          return t.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (t) => {
          const e = t.getAttribute("href");
          return !e || !this.options.isAllowedUri(e, {
            defaultValidate: (n) => !!$r(n, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          }) ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return this.options.isAllowedUri(t.href, {
      defaultValidate: (e) => !!$r(e, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    }) ? ["a", De(this.options.HTMLAttributes, t), 0] : ["a", De(this.options.HTMLAttributes, { ...t, href: "" }), 0];
  },
  markdownTokenName: "link",
  parseMarkdown: (t, e) => e.applyMark("link", e.parseInline(t.tokens || []), {
    href: t.href,
    title: t.title || null
  }),
  renderMarkdown: (t, e) => {
    var n;
    const r = ((n = t.attrs) == null ? void 0 : n.href) || "";
    return `[${e.renderChildren(t)}](${r})`;
  },
  addCommands() {
    return {
      setLink: (t) => ({ chain: e }) => {
        const { href: n } = t;
        return this.options.isAllowedUri(n, {
          defaultValidate: (r) => !!$r(r, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? e().setMark(this.name, t).setMeta("preventAutolink", !0).run() : !1;
      },
      toggleLink: (t) => ({ chain: e }) => {
        const { href: n } = t || {};
        return n && !this.options.isAllowedUri(n, {
          defaultValidate: (r) => !!$r(r, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? !1 : e().toggleMark(this.name, t, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run();
      },
      unsetLink: () => ({ chain: t }) => t().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run()
    };
  },
  addPasteRules() {
    return [
      Ar({
        find: (t) => {
          const e = [];
          if (t) {
            const { protocols: n, defaultProtocol: r } = this.options, o = sv(t).filter(
              (i) => i.isLink && this.options.isAllowedUri(i.value, {
                defaultValidate: (s) => !!$r(s, n),
                protocols: n,
                defaultProtocol: r
              })
            );
            o.length && o.forEach((i) => {
              this.options.shouldAutoLink(i.value) && e.push({
                text: i.value,
                data: {
                  href: i.href
                },
                index: i.start
              });
            });
          }
          return e;
        },
        type: this.type,
        getAttributes: (t) => {
          var e;
          return {
            href: (e = t.data) == null ? void 0 : e.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const t = [], { protocols: e, defaultProtocol: n } = this.options;
    return this.options.autolink && t.push(
      k_({
        type: this.type,
        defaultProtocol: this.options.defaultProtocol,
        validate: (r) => this.options.isAllowedUri(r, {
          defaultValidate: (o) => !!$r(o, e),
          protocols: e,
          defaultProtocol: n
        }),
        shouldAutoLink: this.options.shouldAutoLink
      })
    ), t.push(
      x_({
        type: this.type,
        editor: this.editor,
        openOnClick: this.options.openOnClick === "whenNotEditable" ? !0 : this.options.openOnClick,
        enableClickSelection: this.options.enableClickSelection
      })
    ), this.options.linkOnPaste && t.push(
      N_({
        editor: this.editor,
        defaultProtocol: this.options.defaultProtocol,
        type: this.type,
        shouldAutoLink: this.options.shouldAutoLink
      })
    ), t;
  }
}), E_ = av, S_ = Object.defineProperty, T_ = (t, e) => {
  for (var n in e)
    S_(t, n, { get: e[n], enumerable: !0 });
}, C_ = "listItem", Pp = "textStyle", Bp = /^\s*([-+*])\s$/, lv = rt.create({
  name: "bulletList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [{ tag: "ul" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["ul", De(this.options.HTMLAttributes, t), 0];
  },
  markdownTokenName: "list",
  parseMarkdown: (t, e) => t.type !== "list" || t.ordered ? [] : {
    type: "bulletList",
    content: t.items ? e.parseChildren(t.items) : []
  },
  renderMarkdown: (t, e) => t.content ? e.renderChildren(t.content, `
`) : "",
  markdownOptions: {
    indentsContent: !0
  },
  addCommands() {
    return {
      toggleBulletList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(C_, this.editor.getAttributes(Pp)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-8": () => this.editor.commands.toggleBulletList()
    };
  },
  addInputRules() {
    let t = Qo({
      find: Bp,
      type: this.type
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t = Qo({
      find: Bp,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: () => this.editor.getAttributes(Pp),
      editor: this.editor
    })), [t];
  }
}), cv = rt.create({
  name: "listItem",
  addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  content: "paragraph block*",
  defining: !0,
  parseHTML() {
    return [
      {
        tag: "li"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["li", De(this.options.HTMLAttributes, t), 0];
  },
  markdownTokenName: "list_item",
  parseMarkdown: (t, e) => {
    if (t.type !== "list_item")
      return [];
    let n = [];
    if (t.tokens && t.tokens.length > 0)
      if (t.tokens.some((o) => o.type === "paragraph"))
        n = e.parseChildren(t.tokens);
      else {
        const o = t.tokens[0];
        if (o && o.type === "text" && o.tokens && o.tokens.length > 0) {
          if (n = [
            {
              type: "paragraph",
              content: e.parseInline(o.tokens)
            }
          ], t.tokens.length > 1) {
            const s = t.tokens.slice(1), a = e.parseChildren(s);
            n.push(...a);
          }
        } else
          n = e.parseChildren(t.tokens);
      }
    return n.length === 0 && (n = [
      {
        type: "paragraph",
        content: []
      }
    ]), {
      type: "listItem",
      content: n
    };
  },
  renderMarkdown: (t, e, n) => wf(
    t,
    e,
    (r) => {
      var o, i;
      return r.parentType === "bulletList" ? "- " : r.parentType === "orderedList" ? `${(((i = (o = r.meta) == null ? void 0 : o.parentAttrs) == null ? void 0 : i.start) || 1) + r.index}. ` : "- ";
    },
    n
  ),
  addKeyboardShortcuts() {
    return {
      Enter: () => this.editor.commands.splitListItem(this.name),
      Tab: () => this.editor.commands.sinkListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
  }
}), M_ = {};
T_(M_, {
  findListItemPos: () => vs,
  getNextListDepth: () => Yf,
  handleBackspace: () => vd,
  handleDelete: () => wd,
  hasListBefore: () => uv,
  hasListItemAfter: () => A_,
  hasListItemBefore: () => dv,
  listItemHasSubList: () => fv,
  nextListIsDeeper: () => hv,
  nextListIsHigher: () => mv
});
var vs = (t, e) => {
  const { $from: n } = e.selection, r = st(t, e.schema);
  let o = null, i = n.depth, s = n.pos, a = null;
  for (; i > 0 && a === null; )
    o = n.node(i), o.type === r ? a = i : (i -= 1, s -= 1);
  return a === null ? null : { $pos: e.doc.resolve(s), depth: a };
}, Yf = (t, e) => {
  const n = vs(t, e);
  if (!n)
    return !1;
  const [, r] = RS(e, t, n.$pos.pos + 4);
  return r;
}, uv = (t, e, n) => {
  const { $anchor: r } = t.selection, o = Math.max(0, r.pos - 2), i = t.doc.resolve(o).node();
  return !(!i || !n.includes(i.type.name));
}, dv = (t, e) => {
  var n;
  const { $anchor: r } = e.selection, o = e.doc.resolve(r.pos - 2);
  return !(o.index() === 0 || ((n = o.nodeBefore) == null ? void 0 : n.type.name) !== t);
}, fv = (t, e, n) => {
  if (!n)
    return !1;
  const r = st(t, e.schema);
  let o = !1;
  return n.descendants((i) => {
    i.type === r && (o = !0);
  }), o;
}, vd = (t, e, n) => {
  if (t.commands.undoInputRule())
    return !0;
  if (t.state.selection.from !== t.state.selection.to)
    return !1;
  if (!Mr(t.state, e) && uv(t.state, e, n)) {
    const { $anchor: a } = t.state.selection, l = t.state.doc.resolve(a.before() - 1), c = [];
    l.node().descendants((f, h) => {
      f.type.name === e && c.push({ node: f, pos: h });
    });
    const u = c.at(-1);
    if (!u)
      return !1;
    const d = t.state.doc.resolve(l.start() + u.pos + 1);
    return t.chain().cut({ from: a.start() - 1, to: a.end() + 1 }, d.end()).joinForward().run();
  }
  if (!Mr(t.state, e) || !LS(t.state))
    return !1;
  const r = vs(e, t.state);
  if (!r)
    return !1;
  const i = t.state.doc.resolve(r.$pos.pos - 2).node(r.depth), s = fv(e, t.state, i);
  return dv(e, t.state) && !s ? t.commands.joinItemBackward() : t.chain().liftListItem(e).run();
}, hv = (t, e) => {
  const n = Yf(t, e), r = vs(t, e);
  return !r || !n ? !1 : n > r.depth;
}, mv = (t, e) => {
  const n = Yf(t, e), r = vs(t, e);
  return !r || !n ? !1 : n < r.depth;
}, wd = (t, e) => {
  if (!Mr(t.state, e) || !DS(t.state, e))
    return !1;
  const { selection: n } = t.state, { $from: r, $to: o } = n;
  return !n.empty && r.sameParent(o) ? !1 : hv(e, t.state) ? t.chain().focus(t.state.selection.from + 4).lift(e).joinBackward().run() : mv(e, t.state) ? t.chain().joinForward().joinBackward().run() : t.commands.joinItemForward();
}, A_ = (t, e) => {
  var n;
  const { $anchor: r } = e.selection, o = e.doc.resolve(r.pos - r.parentOffset - 2);
  return !(o.index() === o.parent.childCount - 1 || ((n = o.nodeAfter) == null ? void 0 : n.type.name) !== t);
}, pv = Re.create({
  name: "listKeymap",
  addOptions() {
    return {
      listTypes: [
        {
          itemName: "listItem",
          wrapperNames: ["bulletList", "orderedList"]
        },
        {
          itemName: "taskItem",
          wrapperNames: ["taskList"]
        }
      ]
    };
  },
  addKeyboardShortcuts() {
    return {
      Delete: ({ editor: t }) => {
        let e = !1;
        return this.options.listTypes.forEach(({ itemName: n }) => {
          t.state.schema.nodes[n] !== void 0 && wd(t, n) && (e = !0);
        }), e;
      },
      "Mod-Delete": ({ editor: t }) => {
        let e = !1;
        return this.options.listTypes.forEach(({ itemName: n }) => {
          t.state.schema.nodes[n] !== void 0 && wd(t, n) && (e = !0);
        }), e;
      },
      Backspace: ({ editor: t }) => {
        let e = !1;
        return this.options.listTypes.forEach(({ itemName: n, wrapperNames: r }) => {
          t.state.schema.nodes[n] !== void 0 && vd(t, n, r) && (e = !0);
        }), e;
      },
      "Mod-Backspace": ({ editor: t }) => {
        let e = !1;
        return this.options.listTypes.forEach(({ itemName: n, wrapperNames: r }) => {
          t.state.schema.nodes[n] !== void 0 && vd(t, n, r) && (e = !0);
        }), e;
      }
    };
  }
}), zp = /^(\s*)(\d+)\.\s+(.*)$/, __ = /^\s/;
function R_(t) {
  const e = [];
  let n = 0, r = 0;
  for (; n < t.length; ) {
    const o = t[n], i = o.match(zp);
    if (!i)
      break;
    const [, s, a, l] = i, c = s.length;
    let u = l, d = n + 1;
    const f = [o];
    for (; d < t.length; ) {
      const h = t[d];
      if (h.match(zp))
        break;
      if (h.trim() === "")
        f.push(h), u += `
`, d += 1;
      else if (h.match(__))
        f.push(h), u += `
${h.slice(c + 2)}`, d += 1;
      else
        break;
    }
    e.push({
      indent: c,
      number: parseInt(a, 10),
      content: u.trim(),
      raw: f.join(`
`)
    }), r = d, n = d;
  }
  return [e, r];
}
function gv(t, e, n) {
  var r;
  const o = [];
  let i = 0;
  for (; i < t.length; ) {
    const s = t[i];
    if (s.indent === e) {
      const a = s.content.split(`
`), l = ((r = a[0]) == null ? void 0 : r.trim()) || "", c = [];
      l && c.push({
        type: "paragraph",
        raw: l,
        tokens: n.inlineTokens(l)
      });
      const u = a.slice(1).join(`
`).trim();
      if (u) {
        const h = n.blockTokens(u);
        c.push(...h);
      }
      let d = i + 1;
      const f = [];
      for (; d < t.length && t[d].indent > e; )
        f.push(t[d]), d += 1;
      if (f.length > 0) {
        const h = Math.min(...f.map((p) => p.indent)), m = gv(f, h, n);
        c.push({
          type: "list",
          ordered: !0,
          start: f[0].number,
          items: m,
          raw: f.map((p) => p.raw).join(`
`)
        });
      }
      o.push({
        type: "list_item",
        raw: s.raw,
        tokens: c
      }), i = d;
    } else
      i += 1;
  }
  return o;
}
function O_(t, e) {
  return t.map((n) => {
    if (n.type !== "list_item")
      return e.parseChildren([n])[0];
    const r = [];
    return n.tokens && n.tokens.length > 0 && n.tokens.forEach((o) => {
      if (o.type === "paragraph" || o.type === "list" || o.type === "blockquote" || o.type === "code")
        r.push(...e.parseChildren([o]));
      else if (o.type === "text" && o.tokens) {
        const i = e.parseChildren([o]);
        r.push({
          type: "paragraph",
          content: i
        });
      } else {
        const i = e.parseChildren([o]);
        i.length > 0 && r.push(...i);
      }
    }), {
      type: "listItem",
      content: r
    };
  });
}
var I_ = "listItem", $p = "textStyle", Hp = /^(\d+)\.\s$/, bv = rt.create({
  name: "orderedList",
  addOptions() {
    return {
      itemTypeName: "listItem",
      HTMLAttributes: {},
      keepMarks: !1,
      keepAttributes: !1
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addAttributes() {
    return {
      start: {
        default: 1,
        parseHTML: (t) => t.hasAttribute("start") ? parseInt(t.getAttribute("start") || "", 10) : 1
      },
      type: {
        default: null,
        parseHTML: (t) => t.getAttribute("type")
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "ol"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    const { start: e, ...n } = t;
    return e === 1 ? ["ol", De(this.options.HTMLAttributes, n), 0] : ["ol", De(this.options.HTMLAttributes, t), 0];
  },
  markdownTokenName: "list",
  parseMarkdown: (t, e) => {
    if (t.type !== "list" || !t.ordered)
      return [];
    const n = t.start || 1, r = t.items ? O_(t.items, e) : [];
    return n !== 1 ? {
      type: "orderedList",
      attrs: { start: n },
      content: r
    } : {
      type: "orderedList",
      content: r
    };
  },
  renderMarkdown: (t, e) => t.content ? e.renderChildren(t.content, `
`) : "",
  markdownTokenizer: {
    name: "orderedList",
    level: "block",
    start: (t) => {
      const e = t.match(/^(\s*)(\d+)\.\s+/), n = e?.index;
      return n !== void 0 ? n : -1;
    },
    tokenize: (t, e, n) => {
      var r;
      const o = t.split(`
`), [i, s] = R_(o);
      if (i.length === 0)
        return;
      const a = gv(i, 0, n);
      return a.length === 0 ? void 0 : {
        type: "list",
        ordered: !0,
        start: ((r = i[0]) == null ? void 0 : r.number) || 1,
        items: a,
        raw: o.slice(0, s).join(`
`)
      };
    }
  },
  markdownOptions: {
    indentsContent: !0
  },
  addCommands() {
    return {
      toggleOrderedList: () => ({ commands: t, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(I_, this.editor.getAttributes($p)).run() : t.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-7": () => this.editor.commands.toggleOrderedList()
    };
  },
  addInputRules() {
    let t = Qo({
      find: Hp,
      type: this.type,
      getAttributes: (e) => ({ start: +e[1] }),
      joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1]
    });
    return (this.options.keepMarks || this.options.keepAttributes) && (t = Qo({
      find: Hp,
      type: this.type,
      keepMarks: this.options.keepMarks,
      keepAttributes: this.options.keepAttributes,
      getAttributes: (e) => ({ start: +e[1], ...this.editor.getAttributes($p) }),
      joinPredicate: (e, n) => n.childCount + n.attrs.start === +e[1],
      editor: this.editor
    })), [t];
  }
}), D_ = /^\s*(\[([( |x])?\])\s$/, yv = rt.create({
  name: "taskItem",
  addOptions() {
    return {
      nested: !1,
      HTMLAttributes: {},
      taskListTypeName: "taskList",
      a11y: void 0
    };
  },
  content() {
    return this.options.nested ? "paragraph block*" : "paragraph+";
  },
  defining: !0,
  addAttributes() {
    return {
      checked: {
        default: !1,
        keepOnSplit: !1,
        parseHTML: (t) => {
          const e = t.getAttribute("data-checked");
          return e === "" || e === "true";
        },
        renderHTML: (t) => ({
          "data-checked": t.checked
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: `li[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    return [
      "li",
      De(this.options.HTMLAttributes, e, {
        "data-type": this.name
      }),
      [
        "label",
        [
          "input",
          {
            type: "checkbox",
            checked: t.attrs.checked ? "checked" : null
          }
        ],
        ["span"]
      ],
      ["div", 0]
    ];
  },
  parseMarkdown: (t, e) => {
    const n = [];
    if (t.tokens && t.tokens.length > 0 ? n.push(e.createNode("paragraph", {}, e.parseInline(t.tokens))) : t.text ? n.push(e.createNode("paragraph", {}, [e.createNode("text", { text: t.text })])) : n.push(e.createNode("paragraph", {}, [])), t.nestedTokens && t.nestedTokens.length > 0) {
      const r = e.parseChildren(t.nestedTokens);
      n.push(...r);
    }
    return e.createNode("taskItem", { checked: t.checked || !1 }, n);
  },
  renderMarkdown: (t, e) => {
    var n;
    const o = `- [${(n = t.attrs) != null && n.checked ? "x" : " "}] `;
    return wf(t, e, o);
  },
  addKeyboardShortcuts() {
    const t = {
      Enter: () => this.editor.commands.splitListItem(this.name),
      "Shift-Tab": () => this.editor.commands.liftListItem(this.name)
    };
    return this.options.nested ? {
      ...t,
      Tab: () => this.editor.commands.sinkListItem(this.name)
    } : t;
  },
  addNodeView() {
    return ({ node: t, HTMLAttributes: e, getPos: n, editor: r }) => {
      const o = document.createElement("li"), i = document.createElement("label"), s = document.createElement("span"), a = document.createElement("input"), l = document.createElement("div"), c = (d) => {
        var f, h;
        a.ariaLabel = ((h = (f = this.options.a11y) == null ? void 0 : f.checkboxLabel) == null ? void 0 : h.call(f, d, a.checked)) || `Task item checkbox for ${d.textContent || "empty task item"}`;
      };
      c(t), i.contentEditable = "false", a.type = "checkbox", a.addEventListener("mousedown", (d) => d.preventDefault()), a.addEventListener("change", (d) => {
        if (!r.isEditable && !this.options.onReadOnlyChecked) {
          a.checked = !a.checked;
          return;
        }
        const { checked: f } = d.target;
        r.isEditable && typeof n == "function" && r.chain().focus(void 0, { scrollIntoView: !1 }).command(({ tr: h }) => {
          const m = n();
          if (typeof m != "number")
            return !1;
          const p = h.doc.nodeAt(m);
          return h.setNodeMarkup(m, void 0, {
            ...p?.attrs,
            checked: f
          }), !0;
        }).run(), !r.isEditable && this.options.onReadOnlyChecked && (this.options.onReadOnlyChecked(t, f) || (a.checked = !a.checked));
      }), Object.entries(this.options.HTMLAttributes).forEach(([d, f]) => {
        o.setAttribute(d, f);
      }), o.dataset.checked = t.attrs.checked, a.checked = t.attrs.checked, i.append(a, s), o.append(i, l), Object.entries(e).forEach(([d, f]) => {
        o.setAttribute(d, f);
      });
      let u = new Set(Object.keys(e));
      return {
        dom: o,
        contentDOM: l,
        update: (d) => {
          if (d.type !== this.type)
            return !1;
          o.dataset.checked = d.attrs.checked, a.checked = d.attrs.checked, c(d);
          const f = r.extensionManager.attributes, h = Jo(d, f), m = new Set(Object.keys(h)), p = this.options.HTMLAttributes;
          return u.forEach((g) => {
            m.has(g) || (g in p ? o.setAttribute(g, p[g]) : o.removeAttribute(g));
          }), Object.entries(h).forEach(([g, b]) => {
            b == null ? g in p ? o.setAttribute(g, p[g]) : o.removeAttribute(g) : o.setAttribute(g, b);
          }), u = m, !0;
        }
      };
    };
  },
  addInputRules() {
    return [
      Qo({
        find: D_,
        type: this.type,
        getAttributes: (t) => ({
          checked: t[t.length - 1] === "x"
        })
      })
    ];
  }
}), vv = rt.create({
  name: "taskList",
  addOptions() {
    return {
      itemTypeName: "taskItem",
      HTMLAttributes: {}
    };
  },
  group: "block list",
  content() {
    return `${this.options.itemTypeName}+`;
  },
  parseHTML() {
    return [
      {
        tag: `ul[data-type="${this.name}"]`,
        priority: 51
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["ul", De(this.options.HTMLAttributes, t, { "data-type": this.name }), 0];
  },
  parseMarkdown: (t, e) => e.createNode("taskList", {}, e.parseChildren(t.items || [])),
  renderMarkdown: (t, e) => t.content ? e.renderChildren(t.content, `
`) : "",
  markdownTokenizer: {
    name: "taskList",
    level: "block",
    start(t) {
      var e;
      const n = (e = t.match(/^\s*[-+*]\s+\[([ xX])\]\s+/)) == null ? void 0 : e.index;
      return n !== void 0 ? n : -1;
    },
    tokenize(t, e, n) {
      const r = (i) => {
        const s = nd(
          i,
          {
            itemPattern: /^(\s*)([-+*])\s+\[([ xX])\]\s+(.*)$/,
            extractItemData: (a) => ({
              indentLevel: a[1].length,
              mainContent: a[4],
              checked: a[3].toLowerCase() === "x"
            }),
            createToken: (a, l) => ({
              type: "taskItem",
              raw: "",
              mainContent: a.mainContent,
              indentLevel: a.indentLevel,
              checked: a.checked,
              text: a.mainContent,
              tokens: n.inlineTokens(a.mainContent),
              nestedTokens: l
            }),
            // Allow recursive nesting
            customNestedParser: r
          },
          n
        );
        return s ? [
          {
            type: "taskList",
            raw: s.raw,
            items: s.items
          }
        ] : n.blockTokens(i);
      }, o = nd(
        t,
        {
          itemPattern: /^(\s*)([-+*])\s+\[([ xX])\]\s+(.*)$/,
          extractItemData: (i) => ({
            indentLevel: i[1].length,
            mainContent: i[4],
            checked: i[3].toLowerCase() === "x"
          }),
          createToken: (i, s) => ({
            type: "taskItem",
            raw: "",
            mainContent: i.mainContent,
            indentLevel: i.indentLevel,
            checked: i.checked,
            text: i.mainContent,
            tokens: n.inlineTokens(i.mainContent),
            nestedTokens: s
          }),
          // Use the recursive parser for nested content
          customNestedParser: r
        },
        n
      );
      if (o)
        return {
          type: "taskList",
          raw: o.raw,
          items: o.items
        };
    }
  },
  markdownOptions: {
    indentsContent: !0
  },
  addCommands() {
    return {
      toggleTaskList: () => ({ commands: t }) => t.toggleList(this.name, this.options.itemTypeName)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-9": () => this.editor.commands.toggleTaskList()
    };
  }
});
Re.create({
  name: "listKit",
  addExtensions() {
    const t = [];
    return this.options.bulletList !== !1 && t.push(lv.configure(this.options.bulletList)), this.options.listItem !== !1 && t.push(cv.configure(this.options.listItem)), this.options.listKeymap !== !1 && t.push(pv.configure(this.options.listKeymap)), this.options.orderedList !== !1 && t.push(bv.configure(this.options.orderedList)), this.options.taskItem !== !1 && t.push(yv.configure(this.options.taskItem)), this.options.taskList !== !1 && t.push(vv.configure(this.options.taskList)), t;
  }
});
var Fp = "&nbsp;", L_ = " ", P_ = rt.create({
  name: "paragraph",
  priority: 1e3,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: "block",
  content: "inline*",
  parseHTML() {
    return [{ tag: "p" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["p", De(this.options.HTMLAttributes, t), 0];
  },
  parseMarkdown: (t, e) => {
    const n = t.tokens || [];
    if (n.length === 1 && n[0].type === "image")
      return e.parseChildren([n[0]]);
    const r = e.parseInline(n);
    return r.length === 1 && r[0].type === "text" && (r[0].text === Fp || r[0].text === L_) ? e.createNode("paragraph", void 0, []) : e.createNode("paragraph", void 0, r);
  },
  renderMarkdown: (t, e) => {
    if (!t)
      return "";
    const n = Array.isArray(t.content) ? t.content : [];
    return n.length === 0 ? Fp : e.renderChildren(n);
  },
  addCommands() {
    return {
      setParagraph: () => ({ commands: t }) => t.setNode(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Alt-0": () => this.editor.commands.setParagraph()
    };
  }
}), B_ = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, z_ = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, $_ = kn.create({
  name: "strike",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "s"
      },
      {
        tag: "del"
      },
      {
        tag: "strike"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (t) => t.includes("line-through") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["s", De(this.options.HTMLAttributes, t), 0];
  },
  markdownTokenName: "del",
  parseMarkdown: (t, e) => e.applyMark("strike", e.parseInline(t.tokens || [])),
  renderMarkdown: (t, e) => `~~${e.renderChildren(t)}~~`,
  addCommands() {
    return {
      setStrike: () => ({ commands: t }) => t.setMark(this.name),
      toggleStrike: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetStrike: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  },
  addInputRules() {
    return [
      to({
        find: B_,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Ar({
        find: z_,
        type: this.type
      })
    ];
  }
}), H_ = rt.create({
  name: "text",
  group: "inline",
  parseMarkdown: (t) => ({
    type: "text",
    text: t.text || ""
  }),
  renderMarkdown: (t) => t.text || ""
}), wv = kn.create({
  name: "underline",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "u"
      },
      {
        style: "text-decoration",
        consuming: !1,
        getAttrs: (t) => t.includes("underline") ? {} : !1
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["u", De(this.options.HTMLAttributes, t), 0];
  },
  parseMarkdown(t, e) {
    return e.applyMark(this.name || "underline", e.parseInline(t.tokens || []));
  },
  renderMarkdown(t, e) {
    return `++${e.renderChildren(t)}++`;
  },
  markdownTokenizer: {
    name: "underline",
    level: "inline",
    start(t) {
      return t.indexOf("++");
    },
    tokenize(t, e, n) {
      const o = /^(\+\+)([\s\S]+?)(\+\+)/.exec(t);
      if (!o)
        return;
      const i = o[2].trim();
      return {
        type: "underline",
        raw: o[0],
        text: i,
        tokens: n.inlineTokens(i)
      };
    }
  },
  addCommands() {
    return {
      setUnderline: () => ({ commands: t }) => t.setMark(this.name),
      toggleUnderline: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetUnderline: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
}), F_ = wv;
function U_(t = {}) {
  return new Ce({
    view(e) {
      return new W_(e, t);
    }
  });
}
class W_ {
  constructor(e, n) {
    var r;
    this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (r = n.width) !== null && r !== void 0 ? r : 1, this.color = n.color === !1 ? void 0 : n.color || "black", this.class = n.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((o) => {
      let i = (s) => {
        this[o](s);
      };
      return e.dom.addEventListener(o, i), { name: o, handler: i };
    });
  }
  destroy() {
    this.handlers.forEach(({ name: e, handler: n }) => this.editorView.dom.removeEventListener(e, n));
  }
  update(e, n) {
    this.cursorPos != null && n.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay());
  }
  setCursor(e) {
    e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay());
  }
  updateOverlay() {
    let e = this.editorView.state.doc.resolve(this.cursorPos), n = !e.parent.inlineContent, r, o = this.editorView.dom, i = o.getBoundingClientRect(), s = i.width / o.offsetWidth, a = i.height / o.offsetHeight;
    if (n) {
      let d = e.nodeBefore, f = e.nodeAfter;
      if (d || f) {
        let h = this.editorView.nodeDOM(this.cursorPos - (d ? d.nodeSize : 0));
        if (h) {
          let m = h.getBoundingClientRect(), p = d ? m.bottom : m.top;
          d && f && (p = (p + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2);
          let g = this.width / 2 * a;
          r = { left: m.left, right: m.right, top: p - g, bottom: p + g };
        }
      }
    }
    if (!r) {
      let d = this.editorView.coordsAtPos(this.cursorPos), f = this.width / 2 * s;
      r = { left: d.left - f, right: d.left + f, top: d.top, bottom: d.bottom };
    }
    let l = this.editorView.dom.offsetParent;
    this.element || (this.element = l.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", n), this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
    let c, u;
    if (!l || l == document.body && getComputedStyle(l).position == "static")
      c = -pageXOffset, u = -pageYOffset;
    else {
      let d = l.getBoundingClientRect(), f = d.width / l.offsetWidth, h = d.height / l.offsetHeight;
      c = d.left - l.scrollLeft * f, u = d.top - l.scrollTop * h;
    }
    this.element.style.left = (r.left - c) / s + "px", this.element.style.top = (r.top - u) / a + "px", this.element.style.width = (r.right - r.left) / s + "px", this.element.style.height = (r.bottom - r.top) / a + "px";
  }
  scheduleRemoval(e) {
    clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e);
  }
  dragover(e) {
    if (!this.editorView.editable)
      return;
    let n = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), r = n && n.inside >= 0 && this.editorView.state.doc.nodeAt(n.inside), o = r && r.type.spec.disableDropCursor, i = typeof o == "function" ? o(this.editorView, n, e) : o;
    if (n && !i) {
      let s = n.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let a = Ob(this.editorView.state.doc, s, this.editorView.dragging.slice);
        a != null && (s = a);
      }
      this.setCursor(s), this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(e) {
    this.editorView.dom.contains(e.relatedTarget) || this.setCursor(null);
  }
}
class et extends pe {
  /**
  Create a gap cursor.
  */
  constructor(e) {
    super(e, e);
  }
  map(e, n) {
    let r = e.resolve(n.map(this.head));
    return et.valid(r) ? new et(r) : pe.near(r);
  }
  content() {
    return Y.empty;
  }
  eq(e) {
    return e instanceof et && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, n) {
    if (typeof n.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new et(e.resolve(n.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new Xf(this.anchor);
  }
  /**
  @internal
  */
  static valid(e) {
    let n = e.parent;
    if (n.isTextblock || !V_(e) || !K_(e))
      return !1;
    let r = n.type.spec.allowGapCursor;
    if (r != null)
      return r;
    let o = n.contentMatchAt(e.index()).defaultType;
    return o && o.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(e, n, r = !1) {
    e: for (; ; ) {
      if (!r && et.valid(e))
        return e;
      let o = e.pos, i = null;
      for (let s = e.depth; ; s--) {
        let a = e.node(s);
        if (n > 0 ? e.indexAfter(s) < a.childCount : e.index(s) > 0) {
          i = a.child(n > 0 ? e.indexAfter(s) : e.index(s) - 1);
          break;
        } else if (s == 0)
          return null;
        o += n;
        let l = e.doc.resolve(o);
        if (et.valid(l))
          return l;
      }
      for (; ; ) {
        let s = n > 0 ? i.firstChild : i.lastChild;
        if (!s) {
          if (i.isAtom && !i.isText && !se.isSelectable(i)) {
            e = e.doc.resolve(o + i.nodeSize * n), r = !1;
            continue e;
          }
          break;
        }
        i = s, o += n;
        let a = e.doc.resolve(o);
        if (et.valid(a))
          return a;
      }
      return null;
    }
  }
}
et.prototype.visible = !1;
et.findFrom = et.findGapCursorFrom;
pe.jsonID("gapcursor", et);
class Xf {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new Xf(e.map(this.pos));
  }
  resolve(e) {
    let n = e.resolve(this.pos);
    return et.valid(n) ? new et(n) : pe.near(n);
  }
}
function kv(t) {
  return t.isAtom || t.spec.isolating || t.spec.createGapCursor;
}
function V_(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.index(e), r = t.node(e);
    if (n == 0) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let o = r.child(n - 1); ; o = o.lastChild) {
      if (o.childCount == 0 && !o.inlineContent || kv(o.type))
        return !0;
      if (o.inlineContent)
        return !1;
    }
  }
  return !0;
}
function K_(t) {
  for (let e = t.depth; e >= 0; e--) {
    let n = t.indexAfter(e), r = t.node(e);
    if (n == r.childCount) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let o = r.child(n); ; o = o.firstChild) {
      if (o.childCount == 0 && !o.inlineContent || kv(o.type))
        return !0;
      if (o.inlineContent)
        return !1;
    }
  }
  return !0;
}
function q_() {
  return new Ce({
    props: {
      decorations: X_,
      createSelectionBetween(t, e, n) {
        return e.pos == n.pos && et.valid(n) ? new et(n) : null;
      },
      handleClick: j_,
      handleKeyDown: G_,
      handleDOMEvents: { beforeinput: Y_ }
    }
  });
}
const G_ = lf({
  ArrowLeft: ea("horiz", -1),
  ArrowRight: ea("horiz", 1),
  ArrowUp: ea("vert", -1),
  ArrowDown: ea("vert", 1)
});
function ea(t, e) {
  const n = t == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return function(r, o, i) {
    let s = r.selection, a = e > 0 ? s.$to : s.$from, l = s.empty;
    if (s instanceof ce) {
      if (!i.endOfTextblock(n) || a.depth == 0)
        return !1;
      l = !1, a = r.doc.resolve(e > 0 ? a.after() : a.before());
    }
    let c = et.findGapCursorFrom(a, e, l);
    return c ? (o && o(r.tr.setSelection(new et(c))), !0) : !1;
  };
}
function j_(t, e, n) {
  if (!t || !t.editable)
    return !1;
  let r = t.state.doc.resolve(e);
  if (!et.valid(r))
    return !1;
  let o = t.posAtCoords({ left: n.clientX, top: n.clientY });
  return o && o.inside > -1 && se.isSelectable(t.state.doc.nodeAt(o.inside)) ? !1 : (t.dispatch(t.state.tr.setSelection(new et(r))), !0);
}
function Y_(t, e) {
  if (e.inputType != "insertCompositionText" || !(t.state.selection instanceof et))
    return !1;
  let { $from: n } = t.state.selection, r = n.parent.contentMatchAt(n.index()).findWrapping(t.state.schema.nodes.text);
  if (!r)
    return !1;
  let o = D.empty;
  for (let s = r.length - 1; s >= 0; s--)
    o = D.from(r[s].createAndFill(null, o));
  let i = t.state.tr.replace(n.pos, n.pos, new Y(o, 0, 0));
  return i.setSelection(ce.near(i.doc.resolve(n.pos + 1))), t.dispatch(i), !1;
}
function X_(t) {
  if (!(t.selection instanceof et))
    return null;
  let e = document.createElement("div");
  return e.className = "ProseMirror-gapcursor", Te.create(t.doc, [Ve.widget(t.selection.head, e, { key: "gapcursor" })]);
}
var xl = 200, pt = function() {
};
pt.prototype.append = function(e) {
  return e.length ? (e = pt.from(e), !this.length && e || e.length < xl && this.leafAppend(e) || this.length < xl && e.leafPrepend(this) || this.appendInner(e)) : this;
};
pt.prototype.prepend = function(e) {
  return e.length ? pt.from(e).append(this) : this;
};
pt.prototype.appendInner = function(e) {
  return new Z_(this, e);
};
pt.prototype.slice = function(e, n) {
  return e === void 0 && (e = 0), n === void 0 && (n = this.length), e >= n ? pt.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, n));
};
pt.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
pt.prototype.forEach = function(e, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length), n <= r ? this.forEachInner(e, n, r, 0) : this.forEachInvertedInner(e, n, r, 0);
};
pt.prototype.map = function(e, n, r) {
  n === void 0 && (n = 0), r === void 0 && (r = this.length);
  var o = [];
  return this.forEach(function(i, s) {
    return o.push(e(i, s));
  }, n, r), o;
};
pt.from = function(e) {
  return e instanceof pt ? e : e && e.length ? new xv(e) : pt.empty;
};
var xv = /* @__PURE__ */ (function(t) {
  function e(r) {
    t.call(this), this.values = r;
  }
  t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e;
  var n = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(o, i) {
    return o == 0 && i == this.length ? this : new e(this.values.slice(o, i));
  }, e.prototype.getInner = function(o) {
    return this.values[o];
  }, e.prototype.forEachInner = function(o, i, s, a) {
    for (var l = i; l < s; l++)
      if (o(this.values[l], a + l) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(o, i, s, a) {
    for (var l = i - 1; l >= s; l--)
      if (o(this.values[l], a + l) === !1)
        return !1;
  }, e.prototype.leafAppend = function(o) {
    if (this.length + o.length <= xl)
      return new e(this.values.concat(o.flatten()));
  }, e.prototype.leafPrepend = function(o) {
    if (this.length + o.length <= xl)
      return new e(o.flatten().concat(this.values));
  }, n.length.get = function() {
    return this.values.length;
  }, n.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, n), e;
})(pt);
pt.empty = new xv([]);
var Z_ = /* @__PURE__ */ (function(t) {
  function e(n, r) {
    t.call(this), this.left = n, this.right = r, this.length = n.length + r.length, this.depth = Math.max(n.depth, r.depth) + 1;
  }
  return t && (e.__proto__ = t), e.prototype = Object.create(t && t.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(r) {
    return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
  }, e.prototype.forEachInner = function(r, o, i, s) {
    var a = this.left.length;
    if (o < a && this.left.forEachInner(r, o, Math.min(i, a), s) === !1 || i > a && this.right.forEachInner(r, Math.max(o - a, 0), Math.min(this.length, i) - a, s + a) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(r, o, i, s) {
    var a = this.left.length;
    if (o > a && this.right.forEachInvertedInner(r, o - a, Math.max(i, a) - a, s + a) === !1 || i < a && this.left.forEachInvertedInner(r, Math.min(o, a), i, s) === !1)
      return !1;
  }, e.prototype.sliceInner = function(r, o) {
    if (r == 0 && o == this.length)
      return this;
    var i = this.left.length;
    return o <= i ? this.left.slice(r, o) : r >= i ? this.right.slice(r - i, o - i) : this.left.slice(r, i).append(this.right.slice(0, o - i));
  }, e.prototype.leafAppend = function(r) {
    var o = this.right.leafAppend(r);
    if (o)
      return new e(this.left, o);
  }, e.prototype.leafPrepend = function(r) {
    var o = this.left.leafPrepend(r);
    if (o)
      return new e(o, this.right);
  }, e.prototype.appendInner = function(r) {
    return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left, new e(this.right, r)) : new e(this, r);
  }, e;
})(pt);
const J_ = 500;
class hn {
  constructor(e, n) {
    this.items = e, this.eventCount = n;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, n) {
    if (this.eventCount == 0)
      return null;
    let r = this.items.length;
    for (; ; r--)
      if (this.items.get(r - 1).selection) {
        --r;
        break;
      }
    let o, i;
    n && (o = this.remapping(r, this.items.length), i = o.maps.length);
    let s = e.tr, a, l, c = [], u = [];
    return this.items.forEach((d, f) => {
      if (!d.step) {
        o || (o = this.remapping(r, f + 1), i = o.maps.length), i--, u.push(d);
        return;
      }
      if (o) {
        u.push(new sr(d.map));
        let h = d.step.map(o.slice(i)), m;
        h && s.maybeStep(h).doc && (m = s.mapping.maps[s.mapping.maps.length - 1], c.push(new sr(m, void 0, void 0, c.length + u.length))), i--, m && o.appendMap(m, i);
      } else
        s.maybeStep(d.step);
      if (d.selection)
        return a = o ? d.selection.map(o.slice(i)) : d.selection, l = new hn(this.items.slice(0, r).append(u.reverse().concat(c)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: l, transform: s, selection: a };
  }
  // Create a new branch with the given transform added.
  addTransform(e, n, r, o) {
    let i = [], s = this.eventCount, a = this.items, l = !o && a.length ? a.get(a.length - 1) : null;
    for (let u = 0; u < e.steps.length; u++) {
      let d = e.steps[u].invert(e.docs[u]), f = new sr(e.mapping.maps[u], d, n), h;
      (h = l && l.merge(f)) && (f = h, u ? i.pop() : a = a.slice(0, a.length - 1)), i.push(f), n && (s++, n = void 0), o || (l = f);
    }
    let c = s - r.depth;
    return c > eR && (a = Q_(a, c), s -= c), new hn(a.append(i), s);
  }
  remapping(e, n) {
    let r = new Qi();
    return this.items.forEach((o, i) => {
      let s = o.mirrorOffset != null && i - o.mirrorOffset >= e ? r.maps.length - o.mirrorOffset : void 0;
      r.appendMap(o.map, s);
    }, e, n), r;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new hn(this.items.append(e.map((n) => new sr(n))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, n) {
    if (!this.eventCount)
      return this;
    let r = [], o = Math.max(0, this.items.length - n), i = e.mapping, s = e.steps.length, a = this.eventCount;
    this.items.forEach((f) => {
      f.selection && a--;
    }, o);
    let l = n;
    this.items.forEach((f) => {
      let h = i.getMirror(--l);
      if (h == null)
        return;
      s = Math.min(s, h);
      let m = i.maps[h];
      if (f.step) {
        let p = e.steps[h].invert(e.docs[h]), g = f.selection && f.selection.map(i.slice(l + 1, h));
        g && a++, r.push(new sr(m, p, g));
      } else
        r.push(new sr(m));
    }, o);
    let c = [];
    for (let f = n; f < s; f++)
      c.push(new sr(i.maps[f]));
    let u = this.items.slice(0, o).append(c).append(r), d = new hn(u, a);
    return d.emptyItemCount() > J_ && (d = d.compress(this.items.length - r.length)), d;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((n) => {
      n.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let n = this.remapping(0, e), r = n.maps.length, o = [], i = 0;
    return this.items.forEach((s, a) => {
      if (a >= e)
        o.push(s), s.selection && i++;
      else if (s.step) {
        let l = s.step.map(n.slice(r)), c = l && l.getMap();
        if (r--, c && n.appendMap(c, r), l) {
          let u = s.selection && s.selection.map(n.slice(r));
          u && i++;
          let d = new sr(c.invert(), l, u), f, h = o.length - 1;
          (f = o.length && o[h].merge(d)) ? o[h] = f : o.push(d);
        }
      } else s.map && r--;
    }, this.items.length, 0), new hn(pt.from(o.reverse()), i);
  }
}
hn.empty = new hn(pt.empty, 0);
function Q_(t, e) {
  let n;
  return t.forEach((r, o) => {
    if (r.selection && e-- == 0)
      return n = o, !1;
  }), t.slice(n);
}
let sr = class Nv {
  constructor(e, n, r, o) {
    this.map = e, this.step = n, this.selection = r, this.mirrorOffset = o;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let n = e.step.merge(this.step);
      if (n)
        return new Nv(n.getMap().invert(), n, this.selection);
    }
  }
};
class pr {
  constructor(e, n, r, o, i) {
    this.done = e, this.undone = n, this.prevRanges = r, this.prevTime = o, this.prevComposition = i;
  }
}
const eR = 20;
function tR(t, e, n, r) {
  let o = n.getMeta(Xr), i;
  if (o)
    return o.historyState;
  n.getMeta(oR) && (t = new pr(t.done, t.undone, null, 0, -1));
  let s = n.getMeta("appendedTransaction");
  if (n.steps.length == 0)
    return t;
  if (s && s.getMeta(Xr))
    return s.getMeta(Xr).redo ? new pr(t.done.addTransform(n, void 0, r, Ea(e)), t.undone, Up(n.mapping.maps), t.prevTime, t.prevComposition) : new pr(t.done, t.undone.addTransform(n, void 0, r, Ea(e)), null, t.prevTime, t.prevComposition);
  if (n.getMeta("addToHistory") !== !1 && !(s && s.getMeta("addToHistory") === !1)) {
    let a = n.getMeta("composition"), l = t.prevTime == 0 || !s && t.prevComposition != a && (t.prevTime < (n.time || 0) - r.newGroupDelay || !nR(n, t.prevRanges)), c = s ? pu(t.prevRanges, n.mapping) : Up(n.mapping.maps);
    return new pr(t.done.addTransform(n, l ? e.selection.getBookmark() : void 0, r, Ea(e)), hn.empty, c, n.time, a ?? t.prevComposition);
  } else return (i = n.getMeta("rebased")) ? new pr(t.done.rebased(n, i), t.undone.rebased(n, i), pu(t.prevRanges, n.mapping), t.prevTime, t.prevComposition) : new pr(t.done.addMaps(n.mapping.maps), t.undone.addMaps(n.mapping.maps), pu(t.prevRanges, n.mapping), t.prevTime, t.prevComposition);
}
function nR(t, e) {
  if (!e)
    return !1;
  if (!t.docChanged)
    return !0;
  let n = !1;
  return t.mapping.maps[0].forEach((r, o) => {
    for (let i = 0; i < e.length; i += 2)
      r <= e[i + 1] && o >= e[i] && (n = !0);
  }), n;
}
function Up(t) {
  let e = [];
  for (let n = t.length - 1; n >= 0 && e.length == 0; n--)
    t[n].forEach((r, o, i, s) => e.push(i, s));
  return e;
}
function pu(t, e) {
  if (!t)
    return null;
  let n = [];
  for (let r = 0; r < t.length; r += 2) {
    let o = e.map(t[r], 1), i = e.map(t[r + 1], -1);
    o <= i && n.push(o, i);
  }
  return n;
}
function rR(t, e, n) {
  let r = Ea(e), o = Xr.get(e).spec.config, i = (n ? t.undone : t.done).popEvent(e, r);
  if (!i)
    return null;
  let s = i.selection.resolve(i.transform.doc), a = (n ? t.done : t.undone).addTransform(i.transform, e.selection.getBookmark(), o, r), l = new pr(n ? a : i.remaining, n ? i.remaining : a, null, 0, -1);
  return i.transform.setSelection(s).setMeta(Xr, { redo: n, historyState: l });
}
let gu = !1, Wp = null;
function Ea(t) {
  let e = t.plugins;
  if (Wp != e) {
    gu = !1, Wp = e;
    for (let n = 0; n < e.length; n++)
      if (e[n].spec.historyPreserveItems) {
        gu = !0;
        break;
      }
  }
  return gu;
}
const Xr = new Ie("history"), oR = new Ie("closeHistory");
function iR(t = {}) {
  return t = {
    depth: t.depth || 100,
    newGroupDelay: t.newGroupDelay || 500
  }, new Ce({
    key: Xr,
    state: {
      init() {
        return new pr(hn.empty, hn.empty, null, 0, -1);
      },
      apply(e, n, r) {
        return tR(n, r, e, t);
      }
    },
    config: t,
    props: {
      handleDOMEvents: {
        beforeinput(e, n) {
          let r = n.inputType, o = r == "historyUndo" ? Zf : r == "historyRedo" ? Jf : null;
          return !o || !e.editable ? !1 : (n.preventDefault(), o(e.state, e.dispatch));
        }
      }
    }
  });
}
function Ev(t, e) {
  return (n, r) => {
    let o = Xr.getState(n);
    if (!o || (t ? o.undone : o.done).eventCount == 0)
      return !1;
    if (r) {
      let i = rR(o, n, t);
      i && r(e ? i.scrollIntoView() : i);
    }
    return !0;
  };
}
const Zf = Ev(!1, !0), Jf = Ev(!0, !0);
Re.create({
  name: "characterCount",
  addOptions() {
    return {
      limit: null,
      mode: "textSize",
      textCounter: (t) => t.length,
      wordCounter: (t) => t.split(" ").filter((e) => e !== "").length
    };
  },
  addStorage() {
    return {
      characters: () => 0,
      words: () => 0
    };
  },
  onBeforeCreate() {
    this.storage.characters = (t) => {
      const e = t?.node || this.editor.state.doc;
      if ((t?.mode || this.options.mode) === "textSize") {
        const r = e.textBetween(0, e.content.size, void 0, " ");
        return this.options.textCounter(r);
      }
      return e.nodeSize;
    }, this.storage.words = (t) => {
      const e = t?.node || this.editor.state.doc, n = e.textBetween(0, e.content.size, " ", " ");
      return this.options.wordCounter(n);
    };
  },
  addProseMirrorPlugins() {
    let t = !1;
    return [
      new Ce({
        key: new Ie("characterCount"),
        appendTransaction: (e, n, r) => {
          if (t)
            return;
          const o = this.options.limit;
          if (o == null || o === 0) {
            t = !0;
            return;
          }
          const i = this.storage.characters({ node: r.doc });
          if (i > o) {
            const s = i - o, a = 0, l = s;
            console.warn(
              `[CharacterCount] Initial content exceeded limit of ${o} characters. Content was automatically trimmed.`
            );
            const c = r.tr.deleteRange(a, l);
            return t = !0, c;
          }
          t = !0;
        },
        filterTransaction: (e, n) => {
          const r = this.options.limit;
          if (!e.docChanged || r === 0 || r === null || r === void 0)
            return !0;
          const o = this.storage.characters({ node: n.doc }), i = this.storage.characters({ node: e.doc });
          if (i <= r || o > r && i > r && i <= o)
            return !0;
          if (o > r && i > r && i > o || !e.getMeta("paste"))
            return !1;
          const a = e.selection.$head.pos, l = i - r, c = a - l, u = a;
          return e.deleteRange(c, u), !(this.storage.characters({ node: e.doc }) > r);
        }
      })
    ];
  }
});
var sR = Re.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 1,
      class: void 0
    };
  },
  addProseMirrorPlugins() {
    return [U_(this.options)];
  }
});
Re.create({
  name: "focus",
  addOptions() {
    return {
      className: "has-focus",
      mode: "all"
    };
  },
  addProseMirrorPlugins() {
    return [
      new Ce({
        key: new Ie("focus"),
        props: {
          decorations: ({ doc: t, selection: e }) => {
            const { isEditable: n, isFocused: r } = this.editor, { anchor: o } = e, i = [];
            if (!n || !r)
              return Te.create(t, []);
            let s = 0;
            this.options.mode === "deepest" && t.descendants((l, c) => {
              if (l.isText)
                return;
              if (!(o >= c && o <= c + l.nodeSize - 1))
                return !1;
              s += 1;
            });
            let a = 0;
            return t.descendants((l, c) => {
              if (l.isText || !(o >= c && o <= c + l.nodeSize - 1))
                return !1;
              if (a += 1, this.options.mode === "deepest" && s - a > 0 || this.options.mode === "shallowest" && a > 1)
                return this.options.mode === "deepest";
              i.push(
                Ve.node(c, c + l.nodeSize, {
                  class: this.options.className
                })
              );
            }), Te.create(t, i);
          }
        }
      })
    ];
  }
});
var aR = Re.create({
  name: "gapCursor",
  addProseMirrorPlugins() {
    return [q_()];
  },
  extendNodeSchema(t) {
    var e;
    const n = {
      name: t.name,
      options: t.options,
      storage: t.storage
    };
    return {
      allowGapCursor: (e = ze(le(t, "allowGapCursor", n))) != null ? e : null
    };
  }
}), Vp = "placeholder";
function lR(t) {
  return t.replace(/\s+/g, "-").replace(/[^a-zA-Z0-9-]/g, "").replace(/^[0-9-]+/, "").replace(/^-+/, "").toLowerCase();
}
var cR = Re.create({
  name: "placeholder",
  addOptions() {
    return {
      emptyEditorClass: "is-editor-empty",
      emptyNodeClass: "is-empty",
      dataAttribute: Vp,
      placeholder: "Write something …",
      showOnlyWhenEditable: !0,
      showOnlyCurrent: !0,
      includeChildren: !1
    };
  },
  addProseMirrorPlugins() {
    const t = this.options.dataAttribute ? `data-${lR(this.options.dataAttribute)}` : `data-${Vp}`;
    return [
      new Ce({
        key: new Ie("placeholder"),
        props: {
          decorations: ({ doc: e, selection: n }) => {
            const r = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: o } = n, i = [];
            if (!r)
              return null;
            const s = this.editor.isEmpty;
            return e.descendants((a, l) => {
              const c = o >= l && o <= l + a.nodeSize, u = !a.isLeaf && lc(a);
              if ((c || !this.options.showOnlyCurrent) && u) {
                const d = [this.options.emptyNodeClass];
                s && d.push(this.options.emptyEditorClass);
                const f = Ve.node(l, l + a.nodeSize, {
                  class: d.join(" "),
                  [t]: typeof this.options.placeholder == "function" ? this.options.placeholder({
                    editor: this.editor,
                    node: a,
                    pos: l,
                    hasAnchor: c
                  }) : this.options.placeholder
                });
                i.push(f);
              }
              return this.options.includeChildren;
            }), Te.create(e, i);
          }
        }
      })
    ];
  }
});
Re.create({
  name: "selection",
  addOptions() {
    return {
      className: "selection"
    };
  },
  addProseMirrorPlugins() {
    const { editor: t, options: e } = this;
    return [
      new Ce({
        key: new Ie("selection"),
        props: {
          decorations(n) {
            return n.selection.empty || t.isFocused || !t.isEditable || Yy(n.selection) || t.view.dragging ? null : Te.create(n.doc, [
              Ve.inline(n.selection.from, n.selection.to, {
                class: e.className
              })
            ]);
          }
        }
      })
    ];
  }
});
function Kp({ types: t, node: e }) {
  return e && Array.isArray(t) && t.includes(e.type) || e?.type === t;
}
var uR = Re.create({
  name: "trailingNode",
  addOptions() {
    return {
      node: void 0,
      notAfter: []
    };
  },
  addProseMirrorPlugins() {
    var t;
    const e = new Ie(this.name), n = this.options.node || ((t = this.editor.schema.topNodeType.contentMatch.defaultType) == null ? void 0 : t.name) || "paragraph", r = Object.entries(this.editor.schema.nodes).map(([, o]) => o).filter((o) => (this.options.notAfter || []).concat(n).includes(o.name));
    return [
      new Ce({
        key: e,
        appendTransaction: (o, i, s) => {
          const { doc: a, tr: l, schema: c } = s, u = e.getState(s), d = a.content.size, f = c.nodes[n];
          if (u)
            return l.insert(d, f.create());
        },
        state: {
          init: (o, i) => {
            const s = i.tr.doc.lastChild;
            return !Kp({ node: s, types: r });
          },
          apply: (o, i) => {
            if (!o.docChanged || o.getMeta("__uniqueIDTransaction"))
              return i;
            const s = o.doc.lastChild;
            return !Kp({ node: s, types: r });
          }
        }
      })
    ];
  }
}), dR = Re.create({
  name: "undoRedo",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands() {
    return {
      undo: () => ({ state: t, dispatch: e }) => Zf(t, e),
      redo: () => ({ state: t, dispatch: e }) => Jf(t, e)
    };
  },
  addProseMirrorPlugins() {
    return [iR(this.options)];
  },
  addKeyboardShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Shift-Mod-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo(),
      // Russian keyboard layouts
      "Mod-я": () => this.editor.commands.undo(),
      "Shift-Mod-я": () => this.editor.commands.redo()
    };
  }
}), fR = Re.create({
  name: "starterKit",
  addExtensions() {
    var t, e, n, r;
    const o = [];
    return this.options.bold !== !1 && o.push(zA.configure(this.options.bold)), this.options.blockquote !== !1 && o.push(IA.configure(this.options.blockquote)), this.options.bulletList !== !1 && o.push(lv.configure(this.options.bulletList)), this.options.code !== !1 && o.push(FA.configure(this.options.code)), this.options.codeBlock !== !1 && o.push(Z0.configure(this.options.codeBlock)), this.options.document !== !1 && o.push(KA.configure(this.options.document)), this.options.dropcursor !== !1 && o.push(sR.configure(this.options.dropcursor)), this.options.gapcursor !== !1 && o.push(aR.configure(this.options.gapcursor)), this.options.hardBreak !== !1 && o.push(qA.configure(this.options.hardBreak)), this.options.heading !== !1 && o.push(GA.configure(this.options.heading)), this.options.undoRedo !== !1 && o.push(dR.configure(this.options.undoRedo)), this.options.horizontalRule !== !1 && o.push(jA.configure(this.options.horizontalRule)), this.options.italic !== !1 && o.push(QA.configure(this.options.italic)), this.options.listItem !== !1 && o.push(cv.configure(this.options.listItem)), this.options.listKeymap !== !1 && o.push(pv.configure((t = this.options) == null ? void 0 : t.listKeymap)), this.options.link !== !1 && o.push(av.configure((e = this.options) == null ? void 0 : e.link)), this.options.orderedList !== !1 && o.push(bv.configure(this.options.orderedList)), this.options.paragraph !== !1 && o.push(P_.configure(this.options.paragraph)), this.options.strike !== !1 && o.push($_.configure(this.options.strike)), this.options.text !== !1 && o.push(H_.configure(this.options.text)), this.options.underline !== !1 && o.push(wv.configure((n = this.options) == null ? void 0 : n.underline)), this.options.trailingNode !== !1 && o.push(uR.configure((r = this.options) == null ? void 0 : r.trailingNode)), o;
  }
}), hR = fR, mR = cR, pR = Re.create({
  name: "textAlign",
  addOptions() {
    return {
      types: [],
      alignments: ["left", "center", "right", "justify"],
      defaultAlignment: null
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textAlign: {
            default: this.options.defaultAlignment,
            parseHTML: (t) => {
              const e = t.style.textAlign;
              return this.options.alignments.includes(e) ? e : this.options.defaultAlignment;
            },
            renderHTML: (t) => t.textAlign ? { style: `text-align: ${t.textAlign}` } : {}
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextAlign: (t) => ({ commands: e }) => this.options.alignments.includes(t) ? this.options.types.map((n) => e.updateAttributes(n, { textAlign: t })).some((n) => n) : !1,
      unsetTextAlign: () => ({ commands: t }) => this.options.types.map((e) => t.resetAttributes(e, "textAlign")).some((e) => e),
      toggleTextAlign: (t) => ({ editor: e, commands: n }) => this.options.alignments.includes(t) ? e.isActive({ textAlign: t }) ? n.unsetTextAlign() : n.setTextAlign(t) : !1
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
      "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
      "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
      "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
    };
  }
}), gR = pR, bR = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))$/, yR = /(?:^|\s)(==(?!\s+==)((?:[^=]+))==(?!\s+==))/g, vR = kn.create({
  name: "highlight",
  addOptions() {
    return {
      multicolor: !1,
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    return this.options.multicolor ? {
      color: {
        default: null,
        parseHTML: (t) => t.getAttribute("data-color") || t.style.backgroundColor,
        renderHTML: (t) => t.color ? {
          "data-color": t.color,
          style: `background-color: ${t.color}; color: inherit`
        } : {}
      }
    } : {};
  },
  parseHTML() {
    return [
      {
        tag: "mark"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["mark", De(this.options.HTMLAttributes, t), 0];
  },
  renderMarkdown: (t, e) => `==${e.renderChildren(t)}==`,
  parseMarkdown: (t, e) => e.applyMark("highlight", e.parseInline(t.tokens || [])),
  markdownTokenizer: {
    name: "highlight",
    level: "inline",
    start: (t) => t.indexOf("=="),
    tokenize(t, e, n) {
      const o = /^(==)([^=]+)(==)/.exec(t);
      if (o) {
        const i = o[2].trim(), s = n.inlineTokens(i);
        return {
          type: "highlight",
          raw: o[0],
          text: i,
          tokens: s
        };
      }
    }
  },
  addCommands() {
    return {
      setHighlight: (t) => ({ commands: e }) => e.setMark(this.name, t),
      toggleHighlight: (t) => ({ commands: e }) => e.toggleMark(this.name, t),
      unsetHighlight: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  },
  addInputRules() {
    return [
      to({
        find: bR,
        type: this.type
      })
    ];
  },
  addPasteRules() {
    return [
      Ar({
        find: yR,
        type: this.type
      })
    ];
  }
}), wR = vR, Sv = rt.create({
  name: "tableCell",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (t) => {
          var e, n;
          const r = t.getAttribute("colwidth"), o = r ? r.split(",").map((i) => parseInt(i, 10)) : null;
          if (!o) {
            const i = (e = t.closest("table")) == null ? void 0 : e.querySelectorAll("colgroup > col"), s = Array.from(((n = t.parentElement) == null ? void 0 : n.children) || []).indexOf(t);
            if (s && s > -1 && i && i[s]) {
              const a = i[s].getAttribute("width");
              return a ? [parseInt(a, 10)] : null;
            }
          }
          return o;
        }
      }
    };
  },
  tableRole: "cell",
  isolating: !0,
  parseHTML() {
    return [{ tag: "td" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["td", De(this.options.HTMLAttributes, t), 0];
  }
}), Tv = rt.create({
  name: "tableHeader",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "block+",
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseHTML: (t) => {
          const e = t.getAttribute("colwidth");
          return e ? e.split(",").map((r) => parseInt(r, 10)) : null;
        }
      }
    };
  },
  tableRole: "header_cell",
  isolating: !0,
  parseHTML() {
    return [{ tag: "th" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["th", De(this.options.HTMLAttributes, t), 0];
  }
}), Cv = rt.create({
  name: "tableRow",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: "(tableCell | tableHeader)*",
  tableRole: "row",
  parseHTML() {
    return [{ tag: "tr" }];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["tr", De(this.options.HTMLAttributes, t), 0];
  }
});
function kd(t, e) {
  return e ? ["width", `${Math.max(e, t)}px`] : ["min-width", `${t}px`];
}
function qp(t, e, n, r, o, i) {
  var s;
  let a = 0, l = !0, c = e.firstChild;
  const u = t.firstChild;
  if (u !== null)
    for (let f = 0, h = 0; f < u.childCount; f += 1) {
      const { colspan: m, colwidth: p } = u.child(f).attrs;
      for (let g = 0; g < m; g += 1, h += 1) {
        const b = o === h ? i : p && p[g], v = b ? `${b}px` : "";
        if (a += b || r, b || (l = !1), c) {
          if (c.style.width !== v) {
            const [k, x] = kd(r, b);
            c.style.setProperty(k, x);
          }
          c = c.nextSibling;
        } else {
          const k = document.createElement("col"), [x, w] = kd(r, b);
          k.style.setProperty(x, w), e.appendChild(k);
        }
      }
    }
  for (; c; ) {
    const f = c.nextSibling;
    (s = c.parentNode) == null || s.removeChild(c), c = f;
  }
  const d = t.attrs.style && typeof t.attrs.style == "string" && /\bwidth\s*:/i.test(t.attrs.style);
  l && !d ? (n.style.width = `${a}px`, n.style.minWidth = "") : (n.style.width = "", n.style.minWidth = `${a}px`);
}
var kR = class {
  constructor(t, e) {
    this.node = t, this.cellMinWidth = e, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), t.attrs.style && (this.table.style.cssText = t.attrs.style), this.colgroup = this.table.appendChild(document.createElement("colgroup")), qp(t, this.colgroup, this.table, e), this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(t) {
    return t.type !== this.node.type ? !1 : (this.node = t, qp(t, this.colgroup, this.table, this.cellMinWidth), !0);
  }
  ignoreMutation(t) {
    const e = t.target, n = this.dom.contains(e), r = this.contentDOM.contains(e);
    return !!(n && !r && (t.type === "attributes" || t.type === "childList" || t.type === "characterData"));
  }
};
function xR(t, e, n, r) {
  let o = 0, i = !0;
  const s = [], a = t.firstChild;
  if (!a)
    return {};
  for (let d = 0, f = 0; d < a.childCount; d += 1) {
    const { colspan: h, colwidth: m } = a.child(d).attrs;
    for (let p = 0; p < h; p += 1, f += 1) {
      const g = n === f ? r : m && m[p];
      o += g || e, g || (i = !1);
      const [b, v] = kd(e, g);
      s.push(["col", { style: `${b}: ${v}` }]);
    }
  }
  const l = i ? `${o}px` : "", c = i ? "" : `${o}px`;
  return { colgroup: ["colgroup", {}, ...s], tableWidth: l, tableMinWidth: c };
}
function Gp(t, e) {
  return t.createAndFill();
}
function NR(t) {
  if (t.cached.tableNodeTypes)
    return t.cached.tableNodeTypes;
  const e = {};
  return Object.keys(t.nodes).forEach((n) => {
    const r = t.nodes[n];
    r.spec.tableRole && (e[r.spec.tableRole] = r);
  }), t.cached.tableNodeTypes = e, e;
}
function ER(t, e, n, r, o) {
  const i = NR(t), s = [], a = [];
  for (let c = 0; c < n; c += 1) {
    const u = Gp(i.cell);
    if (u && a.push(u), r) {
      const d = Gp(i.header_cell);
      d && s.push(d);
    }
  }
  const l = [];
  for (let c = 0; c < e; c += 1)
    l.push(i.row.createChecked(null, r && c === 0 ? s : a));
  return i.table.createChecked(null, l);
}
function SR(t) {
  return t instanceof Ke;
}
var ta = ({ editor: t }) => {
  const { selection: e } = t.state;
  if (!SR(e))
    return !1;
  let n = 0;
  const r = Fy(e.ranges[0].$from, (i) => i.type.name === "table");
  return r?.node.descendants((i) => {
    if (i.type.name === "table")
      return !1;
    ["tableCell", "tableHeader"].includes(i.type.name) && (n += 1);
  }), n === e.ranges.length ? (t.commands.deleteTable(), !0) : !1;
}, TR = "";
function CR(t) {
  return (t || "").replace(/\s+/g, " ").trim();
}
function MR(t, e, n = {}) {
  var r;
  const o = (r = n.cellLineSeparator) != null ? r : TR;
  if (!t || !t.content || t.content.length === 0)
    return "";
  const i = [];
  t.content.forEach((m) => {
    const p = [];
    m.content && m.content.forEach((g) => {
      let b = "";
      g.content && Array.isArray(g.content) && g.content.length > 1 ? b = g.content.map((w) => e.renderChildren(w)).join(o) : b = g.content ? e.renderChildren(g.content) : "";
      const v = CR(b), k = g.type === "tableHeader";
      p.push({ text: v, isHeader: k });
    }), i.push(p);
  });
  const s = i.reduce((m, p) => Math.max(m, p.length), 0);
  if (s === 0)
    return "";
  const a = new Array(s).fill(0);
  i.forEach((m) => {
    var p;
    for (let g = 0; g < s; g += 1) {
      const v = (((p = m[g]) == null ? void 0 : p.text) || "").length;
      v > a[g] && (a[g] = v), a[g] < 3 && (a[g] = 3);
    }
  });
  const l = (m, p) => m + " ".repeat(Math.max(0, p - m.length)), c = i[0], u = c.some((m) => m.isHeader);
  let d = `
`;
  const f = new Array(s).fill(0).map((m, p) => u && c[p] && c[p].text || "");
  return d += `| ${f.map((m, p) => l(m, a[p])).join(" | ")} |
`, d += `| ${a.map((m) => "-".repeat(Math.max(3, m))).join(" | ")} |
`, (u ? i.slice(1) : i).forEach((m) => {
    d += `| ${new Array(s).fill(0).map((p, g) => l(m[g] && m[g].text || "", a[g])).join(" | ")} |
`;
  }), d;
}
var AR = MR, Mv = rt.create({
  name: "table",
  // @ts-ignore
  addOptions() {
    return {
      HTMLAttributes: {},
      resizable: !1,
      renderWrapper: !1,
      handleWidth: 5,
      cellMinWidth: 25,
      // TODO: fix
      View: kR,
      lastColumnResizable: !0,
      allowTableNodeSelection: !1
    };
  },
  content: "tableRow+",
  tableRole: "table",
  isolating: !0,
  group: "block",
  parseHTML() {
    return [{ tag: "table" }];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    const { colgroup: n, tableWidth: r, tableMinWidth: o } = xR(t, this.options.cellMinWidth), i = e.style;
    function s() {
      return i || (r ? `width: ${r}` : `min-width: ${o}`);
    }
    const a = [
      "table",
      De(this.options.HTMLAttributes, e, {
        style: s()
      }),
      n,
      ["tbody", 0]
    ];
    return this.options.renderWrapper ? ["div", { class: "tableWrapper" }, a] : a;
  },
  parseMarkdown: (t, e) => {
    const n = [];
    if (t.header) {
      const r = [];
      t.header.forEach((o) => {
        r.push(e.createNode("tableHeader", {}, [{ type: "paragraph", content: e.parseInline(o.tokens) }]));
      }), n.push(e.createNode("tableRow", {}, r));
    }
    return t.rows && t.rows.forEach((r) => {
      const o = [];
      r.forEach((i) => {
        o.push(e.createNode("tableCell", {}, [{ type: "paragraph", content: e.parseInline(i.tokens) }]));
      }), n.push(e.createNode("tableRow", {}, o));
    }), e.createNode("table", void 0, n);
  },
  renderMarkdown: (t, e) => AR(t, e),
  addCommands() {
    return {
      insertTable: ({ rows: t = 3, cols: e = 3, withHeaderRow: n = !0 } = {}) => ({ tr: r, dispatch: o, editor: i }) => {
        const s = ER(i.schema, t, e, n);
        if (o) {
          const a = r.selection.from + 1;
          r.replaceSelectionWith(s).scrollIntoView().setSelection(ce.near(r.doc.resolve(a)));
        }
        return !0;
      },
      addColumnBefore: () => ({ state: t, dispatch: e }) => _M(t, e),
      addColumnAfter: () => ({ state: t, dispatch: e }) => RM(t, e),
      deleteColumn: () => ({ state: t, dispatch: e }) => IM(t, e),
      addRowBefore: () => ({ state: t, dispatch: e }) => LM(t, e),
      addRowAfter: () => ({ state: t, dispatch: e }) => PM(t, e),
      deleteRow: () => ({ state: t, dispatch: e }) => zM(t, e),
      deleteTable: () => ({ state: t, dispatch: e }) => KM(t, e),
      mergeCells: () => ({ state: t, dispatch: e }) => pp(t, e),
      splitCell: () => ({ state: t, dispatch: e }) => gp(t, e),
      toggleHeaderColumn: () => ({ state: t, dispatch: e }) => ls("column")(t, e),
      toggleHeaderRow: () => ({ state: t, dispatch: e }) => ls("row")(t, e),
      toggleHeaderCell: () => ({ state: t, dispatch: e }) => WM(t, e),
      mergeOrSplit: () => ({ state: t, dispatch: e }) => pp(t, e) ? !0 : gp(t, e),
      setCellAttribute: (t, e) => ({ state: n, dispatch: r }) => FM(t, e)(n, r),
      goToNextCell: () => ({ state: t, dispatch: e }) => yp(1)(t, e),
      goToPreviousCell: () => ({ state: t, dispatch: e }) => yp(-1)(t, e),
      fixTables: () => ({ state: t, dispatch: e }) => (e && D0(t), !0),
      setCellSelection: (t) => ({ tr: e, dispatch: n }) => {
        if (n) {
          const r = Ke.create(e.doc, t.anchorCell, t.headCell);
          e.setSelection(r);
        }
        return !0;
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      Tab: () => this.editor.commands.goToNextCell() ? !0 : this.editor.can().addRowAfter() ? this.editor.chain().addRowAfter().goToNextCell().run() : !1,
      "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
      Backspace: ta,
      "Mod-Backspace": ta,
      Delete: ta,
      "Mod-Delete": ta
    };
  },
  addProseMirrorPlugins() {
    return [
      ...this.options.resizable && this.editor.isEditable ? [
        tA({
          handleWidth: this.options.handleWidth,
          cellMinWidth: this.options.cellMinWidth,
          defaultCellMinWidth: this.options.cellMinWidth,
          View: this.options.View,
          lastColumnResizable: this.options.lastColumnResizable
        })
      ] : [],
      dA({
        allowTableNodeSelection: this.options.allowTableNodeSelection
      })
    ];
  },
  extendNodeSchema(t) {
    const e = {
      name: t.name,
      options: t.options,
      storage: t.storage
    };
    return {
      tableRole: ze(le(t, "tableRole", e))
    };
  }
});
Re.create({
  name: "tableKit",
  addExtensions() {
    const t = [];
    return this.options.table !== !1 && t.push(Mv.configure(this.options.table)), this.options.tableCell !== !1 && t.push(Sv.configure(this.options.tableCell)), this.options.tableHeader !== !1 && t.push(Tv.configure(this.options.tableHeader)), this.options.tableRow !== !1 && t.push(Cv.configure(this.options.tableRow)), t;
  }
});
var _R = Cv, RR = Sv, OR = Tv;
const IR = new Ie("tableCellMenu");
let jp = !1, na = null;
function DR() {
  jp || (jp = !0, document.addEventListener("mouseover", (t) => {
    const n = t.target.closest("td, th");
    if (n && n.closest(".ProseMirror")) {
      const r = n.querySelector(".table-cell-menu-btn");
      r && (r.style.opacity = "1");
    }
  }, !0), document.addEventListener("mouseout", (t) => {
    const e = t.target, n = t.relatedTarget, r = e.closest("td, th");
    if (r && r.closest(".ProseMirror")) {
      if (n && r.contains(n) || document.querySelector(".table-cell-menu-dropdown")) return;
      const i = r.querySelector(".table-cell-menu-btn");
      i && (i.style.opacity = "0.15");
    }
  }, !0));
}
function LR(t) {
  return DR(), new Ce({
    key: IR,
    state: {
      init() {
        return Te.empty;
      },
      apply(e, n, r, o) {
        return !e.docChanged && na ? na.map(e.mapping, e.doc) : (na = PR(o.doc, t), na);
      }
    },
    props: {
      decorations(e) {
        return this.getState(e);
      }
    }
  });
}
function PR(t, e) {
  const n = [];
  return t.descendants((r, o) => {
    if (r.type.name === "tableCell" || r.type.name === "tableHeader") {
      const i = Ve.widget(o + 1, (s) => {
        const a = document.createElement("div");
        a.className = "table-cell-menu-wrapper ProseMirror-widget", a.setAttribute("contenteditable", "false"), a.style.cssText = "position:absolute;top:2px;right:2px;z-index:50;pointer-events:auto;";
        const l = document.createElement("button");
        l.className = "table-cell-menu-btn", l.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="1.5"/><circle cx="12" cy="5" r="1.5"/><circle cx="12" cy="19" r="1.5"/></svg>', l.title = "Table options", l.type = "button";
        const c = document.documentElement.classList.contains("dark"), u = c ? "rgba(30,30,30,0.95)" : "rgba(255,255,255,0.95)", d = c ? "rgba(60,60,60,0.5)" : "rgba(200,200,200,0.5)", f = c ? "#999" : "#666", h = c ? "#2a2a2a" : "#f5f5f5";
        return l.style.cssText = "width:18px;height:18px;display:flex;align-items:center;justify-content:center;background:" + u + ";border:1px solid " + d + ";border-radius:4px;cursor:pointer;opacity:0.15;transition:opacity 0.15s ease,background-color 0.15s ease,transform 0.1s ease;color:" + f + ";pointer-events:auto;padding:0;", l.addEventListener("mouseenter", () => {
          l.style.opacity = "1", l.style.background = h, l.style.transform = "scale(1.05)";
        }), l.addEventListener("mouseleave", () => {
          document.querySelector(".table-cell-menu-dropdown"), l.style.background = u, l.style.transform = "scale(1)";
        }), l.addEventListener("click", (m) => {
          m.preventDefault(), m.stopPropagation();
          const p = l.getBoundingClientRect();
          e.chain().focus().setTextSelection(o + 1).run(), BR(m, e, o, p);
        }), a.appendChild(l), a;
      }, { side: -1, key: "menu-" + o });
      n.push(i);
    }
  }), Te.create(t, n);
}
function BR(t, e, n, r) {
  const o = document.querySelector(".table-cell-menu-dropdown");
  o && o.remove();
  const i = document.createElement("div");
  i.className = "table-cell-menu-dropdown";
  const s = 170, a = 280;
  let l = Math.max(0, Math.min(r.top, window.innerHeight)), c = Math.max(0, Math.min(r.bottom, window.innerHeight)), u = Math.max(0, Math.min(r.left, window.innerWidth)), d = c + 4, f = u - s + r.width + 8;
  f + s > window.innerWidth - 12 && (f = window.innerWidth - s - 12), f < 12 && (f = 12), d + a > window.innerHeight - 12 && (d = l - a - 4), d < 12 && (d = 12), d + a > window.innerHeight - 12 && (d = window.innerHeight - a - 12);
  const h = document.documentElement.classList.contains("dark"), m = h ? "#1f1f1f" : "#ffffff", p = h ? "#3a3a3a" : "#e5e5e5", g = h ? "#e5e5e5" : "#333333";
  i.style.cssText = "position:fixed;top:" + d + "px;left:" + f + "px;z-index:99999;display:flex;flex-direction:column;gap:2px;min-width:170px;max-width:220px;width:auto;padding:6px;background:" + m + ";border:1px solid " + p + ";border-radius:8px;box-shadow:0 8px 24px rgba(0,0,0,0.15),0 2px 6px rgba(0,0,0,0.1);color:" + g + ";font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif;pointer-events:auto;";
  const b = [
    { label: "Insert Column Left", icon: "col-left", action: () => e.chain().focus().setTextSelection(n + 1).addColumnBefore().run() },
    { label: "Insert Column Right", icon: "col-right", action: () => e.chain().focus().setTextSelection(n + 1).addColumnAfter().run() },
    { label: "Insert Row Above", icon: "row-up", action: () => e.chain().focus().setTextSelection(n + 1).addRowBefore().run() },
    { label: "Insert Row Below", icon: "row-down", action: () => e.chain().focus().setTextSelection(n + 1).addRowAfter().run() },
    { label: "divider" },
    { label: "Delete Column", icon: "delete", action: () => e.chain().focus().setTextSelection(n + 1).deleteColumn().run(), destructive: !0 },
    { label: "Delete Row", icon: "delete", action: () => e.chain().focus().setTextSelection(n + 1).deleteRow().run(), destructive: !0 },
    { label: "Delete Table", icon: "table-delete", action: () => e.chain().focus().setTextSelection(n + 1).deleteTable().run(), destructive: !0 },
    { label: "divider" },
    { label: "Copy Table", icon: "copy", action: () => zR(e) }
  ], v = {
    "col-left": '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="3" width="12" height="18" rx="2"/><line x1="12" y1="3" x2="12" y2="21"/><path d="M9 12H3m0 0l2-2m-2 2l2 2"/></svg>',
    "col-right": '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="3" width="12" height="18" rx="2"/><line x1="12" y1="3" x2="12" y2="21"/><path d="M15 12h6m0 0l-2-2m2 2l-2 2"/></svg>',
    "row-up": '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="6" width="18" height="12" rx="2"/><line x1="3" y1="12" x2="21" y2="12"/><path d="M12 9V3m0 0l-2 2m2-2l2 2"/></svg>',
    "row-down": '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="6" width="18" height="12" rx="2"/><line x1="3" y1="12" x2="21" y2="12"/><path d="M12 15v6m0 0l-2-2m2 2l2-2"/></svg>',
    delete: '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></svg>',
    "table-delete": '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2"/><line x1="3" y1="9" x2="21" y2="9"/><line x1="9" y1="3" x2="9" y2="21"/><line x1="15" y1="15" x2="21" y2="21"/><line x1="21" y1="15" x2="15" y2="21"/></svg>',
    copy: '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>'
  }, k = h ? "#2a2a2a" : "#f5f5f5", x = h ? "#ff6b6b" : "#dc2626", w = h ? "#999999" : "#666666", E = h ? "#333333" : "#e5e5e5";
  b.forEach((M) => {
    if (M.label === "divider") {
      const O = document.createElement("div");
      O.style.cssText = "height:1px;background:" + E + ";margin:4px 0;", i.appendChild(O);
    } else {
      const O = document.createElement("button");
      O.type = "button";
      const q = M.destructive ? x : g;
      O.style.cssText = "display:flex;align-items:center;gap:10px;width:100%;padding:8px 10px;font-size:13px;font-weight:450;color:" + q + ";background:transparent;border:none;border-radius:5px;cursor:pointer;text-align:left;transition:background 0.15s ease;pointer-events:auto;";
      const K = v[M.icon || ""] || "", j = M.destructive ? x : w;
      O.innerHTML = '<span style="display:flex;align-items:center;justify-content:center;width:16px;height:16px;flex-shrink:0;color:' + j + ';">' + K + '</span><span style="flex:1;white-space:nowrap;">' + M.label + "</span>", O.addEventListener("mouseenter", () => {
        O.style.background = M.destructive ? h ? "rgba(255,107,107,0.15)" : "rgba(220,38,38,0.1)" : k;
      }), O.addEventListener("mouseleave", () => {
        O.style.background = "transparent";
      }), O.addEventListener("click", (H) => {
        H.preventDefault(), H.stopPropagation(), M.action && M.action(), i.remove();
      }), i.appendChild(O);
    }
  }), document.body.appendChild(i);
  const S = (M) => {
    const O = M.target;
    if (i.contains(O) || O.classList.contains("table-cell-menu-btn"))
      return;
    const q = O.closest('[role="dialog"]');
    q && q.contains(i) || (i.remove(), document.removeEventListener("mousedown", S), document.removeEventListener("keydown", C));
  }, C = (M) => {
    M.key === "Escape" && (i.remove(), document.removeEventListener("mousedown", S), document.removeEventListener("keydown", C));
  };
  setTimeout(() => {
    document.addEventListener("mousedown", S), document.addEventListener("keydown", C);
  }, 0);
}
function zR(t) {
  const { state: e } = t, { selection: n } = e;
  let r = null;
  if (e.doc.descendants((o, i) => {
    if (o.type.name === "table" && i <= n.from && i + o.nodeSize >= n.to)
      return r = o, !1;
  }), r) {
    const o = (s) => {
      if (s.type.name === "table") return "<table>" + s.content.content.map(o).join("") + "</table>";
      if (s.type.name === "tableRow") return "<tr>" + s.content.content.map(o).join("") + "</tr>";
      if (s.type.name === "tableCell") {
        const a = s.attrs, l = a.colspan > 1 ? ' colspan="' + a.colspan + '"' : "", c = a.rowspan > 1 ? ' rowspan="' + a.rowspan + '"' : "";
        return "<td" + l + c + ">" + s.textContent + "</td>";
      }
      if (s.type.name === "tableHeader") {
        const a = s.attrs, l = a.colspan > 1 ? ' colspan="' + a.colspan + '"' : "", c = a.rowspan > 1 ? ' rowspan="' + a.rowspan + '"' : "";
        return "<th" + l + c + ">" + s.textContent + "</th>";
      }
      return s.textContent || "";
    }, i = o(r);
    navigator.clipboard.writeText(i).then(() => {
      const s = document.createElement("div");
      s.className = "tcm-toast", s.textContent = "Table copied to clipboard", s.style.cssText = "position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.8);color:white;padding:10px 20px;border-radius:6px;font-size:13px;z-index:99999;animation:fadeInOut 2s ease-in-out forwards;", document.body.appendChild(s), setTimeout(() => s.remove(), 2e3);
    });
  }
}
const $R = RR.extend({
  addProseMirrorPlugins() {
    return [
      ...this.parent?.() || [],
      LR(this.editor)
    ];
  }
}), HR = OR.extend({}), qi = new Ie("tableSorting");
let Kr = null, Ri = null;
function FR(t) {
  const e = parseFloat(t.replace(/[,$%]/g, ""));
  if (!isNaN(e) && t.match(/^[\d,.$%\-+]+$/))
    return { type: "number", value: e };
  const n = [/^\d{4}-\d{2}-\d{2}/, /^\d{1,2}\/\d{1,2}\/\d{2,4}/, /^\d{1,2}-\d{1,2}-\d{2,4}/];
  for (const r of n)
    if (r.test(t)) {
      const o = new Date(t);
      if (!isNaN(o.getTime()))
        return { type: "date", value: o };
    }
  return { type: "string", value: t.toLowerCase() };
}
function UR(t, e, n) {
  let r = 0;
  return t.type === "number" && e.type === "number" ? r = t.value - e.value : t.type === "date" && e.type === "date" ? r = t.value.getTime() - e.value.getTime() : r = String(t.value).localeCompare(String(e.value)), n === "asc" ? r : -r;
}
function WR(t, e, n) {
  const { state: r, view: o } = t;
  let i = null;
  if (r.doc.nodesBetween(e, e + 1, (m, p) => {
    if (m.type.name === "table" && p === e)
      return i = m, !1;
  }), !i) {
    console.log("Table not found at position", e);
    return;
  }
  const s = Kr?.tablePos === e && Kr?.columnIndex === n && Kr?.direction === "asc" ? "desc" : "asc";
  Kr = { tablePos: e, columnIndex: n, direction: s }, Ri = null;
  const a = [];
  i.forEach((m) => {
    if (m.type.name === "tableRow") {
      let p = !1;
      m.forEach((g) => {
        g.type.name === "tableHeader" && (p = !0);
      }), a.push({ node: m, isHeader: p });
    }
  });
  const l = a.filter((m) => m.isHeader), c = a.filter((m) => !m.isHeader);
  if (c.length < 2) {
    Yp(n, s), o.dispatch(r.tr.setMeta(qi, { updated: !0 }));
    return;
  }
  const u = c.map((m) => {
    let p = "", g = 0;
    return m.node.forEach((b) => {
      g === n && (p = b.textContent || ""), g++;
    }), { ...m, sortValue: FR(p) };
  }), d = u.map((m, p) => p);
  u.sort((m, p) => UR(m.sortValue, p.sortValue, s));
  const f = u.map((m, p) => c.indexOf(m));
  if (d.some((m, p) => m !== f[p])) {
    const m = [];
    l.forEach((b) => m.push(b.node)), u.forEach((b) => m.push(b.node));
    const p = i.type.create(i.attrs, m), { tr: g } = r;
    g.replaceWith(e, e + i.nodeSize, p), g.setMeta(qi, { updated: !0 }), o.dispatch(g);
  } else
    o.dispatch(r.tr.setMeta(qi, { updated: !0 }));
  Yp(n, s);
}
function Yp(t, e) {
  const n = document.querySelector(".table-sort-toast");
  n && n.remove();
  const r = document.createElement("div");
  r.className = "table-sort-toast";
  const o = e === "asc" ? "ascending" : "descending", i = e === "asc" ? "↑" : "↓";
  r.innerHTML = '<span style="margin-right:6px;">' + i + "</span> Sorted column " + (t + 1) + " " + o;
  const s = document.documentElement.classList.contains("dark");
  r.style.cssText = "position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:" + (s ? "rgba(30,30,30,0.95)" : "rgba(255,255,255,0.95)") + ";color:" + (s ? "#e5e5e5" : "#333") + ";padding:10px 20px;border-radius:8px;font-size:13px;font-weight:500;z-index:99999;box-shadow:0 4px 12px rgba(0,0,0,0.15);border:1px solid " + (s ? "#3a3a3a" : "#e5e5e5") + ";animation:sortToastIn 0.2s ease;", document.body.appendChild(r), setTimeout(() => {
    r.style.animation = "sortToastOut 0.2s ease forwards", setTimeout(() => r.remove(), 200);
  }, 1500);
}
function VR(t, e, n, r) {
  const o = document.createElement("span");
  o.className = "table-sort-btn-inline", o.setAttribute("contenteditable", "false"), o.style.cssText = "display:inline-flex;align-items:center;margin-left:4px;vertical-align:middle;pointer-events:auto;";
  const i = document.createElement("button");
  i.className = "table-sort-btn", i.setAttribute("contenteditable", "false"), i.type = "button";
  const s = document.documentElement.classList.contains("dark"), a = s ? "#60a5fa" : "#3b82f6", l = s ? "#666" : "#aaa", c = s ? "rgba(255,255,255,0.1)" : "rgba(0,0,0,0.05)";
  return i.style.cssText = "display:inline-flex;align-items:center;justify-content:center;width:16px;height:16px;padding:0;font-size:10px;color:" + (t ? a : l) + ";background:transparent;border:none;border-radius:3px;cursor:pointer;user-select:none;transition:all 0.15s ease;opacity:" + (t ? "1" : "0.5") + ";pointer-events:auto;vertical-align:middle;", i.addEventListener("mouseenter", () => {
    i.style.background = c, i.style.opacity = "1", i.style.color = a;
  }), i.addEventListener("mouseleave", () => {
    i.style.background = "transparent", i.style.opacity = t ? "1" : "0.5", i.style.color = t ? a : l;
  }), i.addEventListener("click", (u) => {
    u.preventDefault(), u.stopPropagation(), WR(r, e, n);
  }), t === "asc" ? (i.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19V5M5 12l7-7 7 7"/></svg>', i.title = "Sorted ascending - Click to sort descending") : t === "desc" ? (i.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14M5 12l7 7 7-7"/></svg>', i.title = "Sorted descending - Click to sort ascending") : (i.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M7 15l5 5 5-5M7 9l5-5 5 5"/></svg>', i.title = "Click to sort this column"), o.appendChild(i), o;
}
function KR(t) {
  return new Ce({
    key: qi,
    state: {
      init() {
        return Te.empty;
      },
      apply(e, n, r, o) {
        const i = e.getMeta(qi);
        return !e.docChanged && !i?.updated && Ri ? Ri.map(e.mapping, e.doc) : (Ri = qR(o.doc, t), Ri);
      }
    },
    props: {
      decorations(e) {
        return this.getState(e);
      }
    }
  });
}
function qR(t, e) {
  const n = [];
  return t.descendants((r, o) => {
    if (r.type.name === "table") {
      const i = o;
      r.forEach((s, a) => {
        if (s.type.name === "tableRow") {
          let l = 0, c = 0;
          s.forEach((u, d) => {
            if (u.type.name === "tableHeader") {
              const f = o + 1 + a + 1 + c;
              let h = f + 1;
              u.forEach((k, x) => {
                k.type.name === "paragraph" && (h = f + 1 + x + k.nodeSize - 1);
              });
              const p = Kr?.tablePos === i && Kr?.columnIndex === l ? Kr.direction : null, g = l, b = i, v = Ve.widget(h, () => VR(p, b, g, e), { side: 1, key: "sort-" + i + "-" + g });
              n.push(v);
            }
            c += u.nodeSize, l++;
          });
        }
      });
    }
  }), Te.create(t, n);
}
const GR = Re.create({
  name: "tableSorting",
  addProseMirrorPlugins() {
    return [KR(this.editor)];
  }
});
var jR = vv, YR = yv, XR = kn.create({
  name: "subscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sub"
      },
      {
        style: "vertical-align",
        getAttrs(t) {
          return t !== "sub" ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["sub", De(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setSubscript: () => ({ commands: t }) => t.setMark(this.name),
      toggleSubscript: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetSubscript: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-,": () => this.editor.commands.toggleSubscript()
    };
  }
}), ZR = XR, JR = kn.create({
  name: "superscript",
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML() {
    return [
      {
        tag: "sup"
      },
      {
        style: "vertical-align",
        getAttrs(t) {
          return t !== "super" ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["sup", De(this.options.HTMLAttributes, t), 0];
  },
  addCommands() {
    return {
      setSuperscript: () => ({ commands: t }) => t.setMark(this.name),
      toggleSuperscript: () => ({ commands: t }) => t.toggleMark(this.name),
      unsetSuperscript: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-.": () => this.editor.commands.toggleSuperscript()
    };
  }
}), QR = JR, eO = (t) => nt({
  find: /--$/,
  replace: t ?? "—"
}), tO = (t) => nt({
  find: /\.\.\.$/,
  replace: t ?? "…"
}), nO = (t) => nt({
  find: /(?:^|[\s{[(<'"\u2018\u201C])(")$/,
  replace: t ?? "“"
}), rO = (t) => nt({
  find: /"$/,
  replace: t ?? "”"
}), oO = (t) => nt({
  find: /(?:^|[\s{[(<'"\u2018\u201C])(')$/,
  replace: t ?? "‘"
}), iO = (t) => nt({
  find: /'$/,
  replace: t ?? "’"
}), sO = (t) => nt({
  find: /<-$/,
  replace: t ?? "←"
}), aO = (t) => nt({
  find: /->$/,
  replace: t ?? "→"
}), lO = (t) => nt({
  find: /\(c\)$/,
  replace: t ?? "©"
}), cO = (t) => nt({
  find: /\(tm\)$/,
  replace: t ?? "™"
}), uO = (t) => nt({
  find: /\(sm\)$/,
  replace: t ?? "℠"
}), dO = (t) => nt({
  find: /\(r\)$/,
  replace: t ?? "®"
}), fO = (t) => nt({
  find: /(?:^|\s)(1\/2)\s$/,
  replace: t ?? "½"
}), hO = (t) => nt({
  find: /\+\/-$/,
  replace: t ?? "±"
}), mO = (t) => nt({
  find: /!=$/,
  replace: t ?? "≠"
}), pO = (t) => nt({
  find: /<<$/,
  replace: t ?? "«"
}), gO = (t) => nt({
  find: />>$/,
  replace: t ?? "»"
}), bO = (t) => nt({
  find: /\d+\s?([*x])\s?\d+$/,
  replace: t ?? "×"
}), yO = (t) => nt({
  find: /\^2$/,
  replace: t ?? "²"
}), vO = (t) => nt({
  find: /\^3$/,
  replace: t ?? "³"
}), wO = (t) => nt({
  find: /(?:^|\s)(1\/4)\s$/,
  replace: t ?? "¼"
}), kO = (t) => nt({
  find: /(?:^|\s)(3\/4)\s$/,
  replace: t ?? "¾"
}), xO = Re.create({
  name: "typography",
  addOptions() {
    return {
      closeDoubleQuote: "”",
      closeSingleQuote: "’",
      copyright: "©",
      ellipsis: "…",
      emDash: "—",
      laquo: "«",
      leftArrow: "←",
      multiplication: "×",
      notEqual: "≠",
      oneHalf: "½",
      oneQuarter: "¼",
      openDoubleQuote: "“",
      openSingleQuote: "‘",
      plusMinus: "±",
      raquo: "»",
      registeredTrademark: "®",
      rightArrow: "→",
      servicemark: "℠",
      superscriptThree: "³",
      superscriptTwo: "²",
      threeQuarters: "¾",
      trademark: "™"
    };
  },
  addInputRules() {
    const t = [];
    return this.options.emDash !== !1 && t.push(eO(this.options.emDash)), this.options.ellipsis !== !1 && t.push(tO(this.options.ellipsis)), this.options.openDoubleQuote !== !1 && t.push(nO(this.options.openDoubleQuote)), this.options.closeDoubleQuote !== !1 && t.push(rO(this.options.closeDoubleQuote)), this.options.openSingleQuote !== !1 && t.push(oO(this.options.openSingleQuote)), this.options.closeSingleQuote !== !1 && t.push(iO(this.options.closeSingleQuote)), this.options.leftArrow !== !1 && t.push(sO(this.options.leftArrow)), this.options.rightArrow !== !1 && t.push(aO(this.options.rightArrow)), this.options.copyright !== !1 && t.push(lO(this.options.copyright)), this.options.trademark !== !1 && t.push(cO(this.options.trademark)), this.options.servicemark !== !1 && t.push(uO(this.options.servicemark)), this.options.registeredTrademark !== !1 && t.push(dO(this.options.registeredTrademark)), this.options.oneHalf !== !1 && t.push(fO(this.options.oneHalf)), this.options.plusMinus !== !1 && t.push(hO(this.options.plusMinus)), this.options.notEqual !== !1 && t.push(mO(this.options.notEqual)), this.options.laquo !== !1 && t.push(pO(this.options.laquo)), this.options.raquo !== !1 && t.push(gO(this.options.raquo)), this.options.multiplication !== !1 && t.push(bO(this.options.multiplication)), this.options.superscriptTwo !== !1 && t.push(yO(this.options.superscriptTwo)), this.options.superscriptThree !== !1 && t.push(vO(this.options.superscriptThree)), this.options.oneQuarter !== !1 && t.push(wO(this.options.oneQuarter)), this.options.threeQuarters !== !1 && t.push(kO(this.options.threeQuarters)), t;
  }
}), NO = xO, bu, Xp;
function EO() {
  if (Xp) return bu;
  Xp = 1;
  function t(T) {
    return T instanceof Map ? T.clear = T.delete = T.set = function() {
      throw new Error("map is read-only");
    } : T instanceof Set && (T.add = T.clear = T.delete = function() {
      throw new Error("set is read-only");
    }), Object.freeze(T), Object.getOwnPropertyNames(T).forEach((I) => {
      const W = T[I], ye = typeof W;
      (ye === "object" || ye === "function") && !Object.isFrozen(W) && t(W);
    }), T;
  }
  class e {
    /**
     * @param {CompiledMode} mode
     */
    constructor(I) {
      I.data === void 0 && (I.data = {}), this.data = I.data, this.isMatchIgnored = !1;
    }
    ignoreMatch() {
      this.isMatchIgnored = !0;
    }
  }
  function n(T) {
    return T.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;");
  }
  function r(T, ...I) {
    const W = /* @__PURE__ */ Object.create(null);
    for (const ye in T)
      W[ye] = T[ye];
    return I.forEach(function(ye) {
      for (const Ye in ye)
        W[Ye] = ye[Ye];
    }), /** @type {T} */
    W;
  }
  const o = "</span>", i = (T) => !!T.scope, s = (T, { prefix: I }) => {
    if (T.startsWith("language:"))
      return T.replace("language:", "language-");
    if (T.includes(".")) {
      const W = T.split(".");
      return [
        `${I}${W.shift()}`,
        ...W.map((ye, Ye) => `${ye}${"_".repeat(Ye + 1)}`)
      ].join(" ");
    }
    return `${I}${T}`;
  };
  class a {
    /**
     * Creates a new HTMLRenderer
     *
     * @param {Tree} parseTree - the parse tree (must support `walk` API)
     * @param {{classPrefix: string}} options
     */
    constructor(I, W) {
      this.buffer = "", this.classPrefix = W.classPrefix, I.walk(this);
    }
    /**
     * Adds texts to the output stream
     *
     * @param {string} text */
    addText(I) {
      this.buffer += n(I);
    }
    /**
     * Adds a node open to the output stream (if needed)
     *
     * @param {Node} node */
    openNode(I) {
      if (!i(I)) return;
      const W = s(
        I.scope,
        { prefix: this.classPrefix }
      );
      this.span(W);
    }
    /**
     * Adds a node close to the output stream (if needed)
     *
     * @param {Node} node */
    closeNode(I) {
      i(I) && (this.buffer += o);
    }
    /**
     * returns the accumulated buffer
    */
    value() {
      return this.buffer;
    }
    // helpers
    /**
     * Builds a span element
     *
     * @param {string} className */
    span(I) {
      this.buffer += `<span class="${I}">`;
    }
  }
  const l = (T = {}) => {
    const I = { children: [] };
    return Object.assign(I, T), I;
  };
  class c {
    constructor() {
      this.rootNode = l(), this.stack = [this.rootNode];
    }
    get top() {
      return this.stack[this.stack.length - 1];
    }
    get root() {
      return this.rootNode;
    }
    /** @param {Node} node */
    add(I) {
      this.top.children.push(I);
    }
    /** @param {string} scope */
    openNode(I) {
      const W = l({ scope: I });
      this.add(W), this.stack.push(W);
    }
    closeNode() {
      if (this.stack.length > 1)
        return this.stack.pop();
    }
    closeAllNodes() {
      for (; this.closeNode(); ) ;
    }
    toJSON() {
      return JSON.stringify(this.rootNode, null, 4);
    }
    /**
     * @typedef { import("./html_renderer").Renderer } Renderer
     * @param {Renderer} builder
     */
    walk(I) {
      return this.constructor._walk(I, this.rootNode);
    }
    /**
     * @param {Renderer} builder
     * @param {Node} node
     */
    static _walk(I, W) {
      return typeof W == "string" ? I.addText(W) : W.children && (I.openNode(W), W.children.forEach((ye) => this._walk(I, ye)), I.closeNode(W)), I;
    }
    /**
     * @param {Node} node
     */
    static _collapse(I) {
      typeof I != "string" && I.children && (I.children.every((W) => typeof W == "string") ? I.children = [I.children.join("")] : I.children.forEach((W) => {
        c._collapse(W);
      }));
    }
  }
  class u extends c {
    /**
     * @param {*} options
     */
    constructor(I) {
      super(), this.options = I;
    }
    /**
     * @param {string} text
     */
    addText(I) {
      I !== "" && this.add(I);
    }
    /** @param {string} scope */
    startScope(I) {
      this.openNode(I);
    }
    endScope() {
      this.closeNode();
    }
    /**
     * @param {Emitter & {root: DataNode}} emitter
     * @param {string} name
     */
    __addSublanguage(I, W) {
      const ye = I.root;
      W && (ye.scope = `language:${W}`), this.add(ye);
    }
    toHTML() {
      return new a(this, this.options).value();
    }
    finalize() {
      return this.closeAllNodes(), !0;
    }
  }
  function d(T) {
    return T ? typeof T == "string" ? T : T.source : null;
  }
  function f(T) {
    return p("(?=", T, ")");
  }
  function h(T) {
    return p("(?:", T, ")*");
  }
  function m(T) {
    return p("(?:", T, ")?");
  }
  function p(...T) {
    return T.map((W) => d(W)).join("");
  }
  function g(T) {
    const I = T[T.length - 1];
    return typeof I == "object" && I.constructor === Object ? (T.splice(T.length - 1, 1), I) : {};
  }
  function b(...T) {
    return "(" + (g(T).capture ? "" : "?:") + T.map((ye) => d(ye)).join("|") + ")";
  }
  function v(T) {
    return new RegExp(T.toString() + "|").exec("").length - 1;
  }
  function k(T, I) {
    const W = T && T.exec(I);
    return W && W.index === 0;
  }
  const x = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./;
  function w(T, { joinWith: I }) {
    let W = 0;
    return T.map((ye) => {
      W += 1;
      const Ye = W;
      let Ze = d(ye), oe = "";
      for (; Ze.length > 0; ) {
        const X = x.exec(Ze);
        if (!X) {
          oe += Ze;
          break;
        }
        oe += Ze.substring(0, X.index), Ze = Ze.substring(X.index + X[0].length), X[0][0] === "\\" && X[1] ? oe += "\\" + String(Number(X[1]) + Ye) : (oe += X[0], X[0] === "(" && W++);
      }
      return oe;
    }).map((ye) => `(${ye})`).join(I);
  }
  const E = /\b\B/, S = "[a-zA-Z]\\w*", C = "[a-zA-Z_]\\w*", M = "\\b\\d+(\\.\\d+)?", O = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", q = "\\b(0b[01]+)", K = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", j = (T = {}) => {
    const I = /^#![ ]*\//;
    return T.binary && (T.begin = p(
      I,
      /.*\b/,
      T.binary,
      /\b.*/
    )), r({
      scope: "meta",
      begin: I,
      end: /$/,
      relevance: 0,
      /** @type {ModeCallback} */
      "on:begin": (W, ye) => {
        W.index !== 0 && ye.ignoreMatch();
      }
    }, T);
  }, H = {
    begin: "\\\\[\\s\\S]",
    relevance: 0
  }, G = {
    scope: "string",
    begin: "'",
    end: "'",
    illegal: "\\n",
    contains: [H]
  }, V = {
    scope: "string",
    begin: '"',
    end: '"',
    illegal: "\\n",
    contains: [H]
  }, re = {
    begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
  }, A = function(T, I, W = {}) {
    const ye = r(
      {
        scope: "comment",
        begin: T,
        end: I,
        contains: []
      },
      W
    );
    ye.contains.push({
      scope: "doctag",
      // hack to avoid the space from being included. the space is necessary to
      // match here to prevent the plain text rule below from gobbling up doctags
      begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
      end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,
      excludeBegin: !0,
      relevance: 0
    });
    const Ye = b(
      // list of common 1 and 2 letter words in English
      "I",
      "a",
      "is",
      "so",
      "us",
      "to",
      "at",
      "if",
      "in",
      "it",
      "on",
      // note: this is not an exhaustive list of contractions, just popular ones
      /[A-Za-z]+['](d|ve|re|ll|t|s|n)/,
      // contractions - can't we'd they're let's, etc
      /[A-Za-z]+[-][a-z]+/,
      // `no-way`, etc.
      /[A-Za-z][a-z]{2,}/
      // allow capitalized words at beginning of sentences
    );
    return ye.contains.push(
      {
        // TODO: how to include ", (, ) without breaking grammars that use these for
        // comment delimiters?
        // begin: /[ ]+([()"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()":]?([.][ ]|[ ]|\))){3}/
        // ---
        // this tries to find sequences of 3 english words in a row (without any
        // "programming" type syntax) this gives us a strong signal that we've
        // TRULY found a comment - vs perhaps scanning with the wrong language.
        // It's possible to find something that LOOKS like the start of the
        // comment - but then if there is no readable text - good chance it is a
        // false match and not a comment.
        //
        // for a visual example please see:
        // https://github.com/highlightjs/highlight.js/issues/2827
        begin: p(
          /[ ]+/,
          // necessary to prevent us gobbling up doctags like /* @author Bob Mcgill */
          "(",
          Ye,
          /[.]?[:]?([.][ ]|[ ])/,
          "){3}"
        )
        // look for 3 words in a row
      }
    ), ye;
  }, $ = A("//", "$"), _ = A("/\\*", "\\*/"), z = A("#", "$"), Q = {
    scope: "number",
    begin: M,
    relevance: 0
  }, ue = {
    scope: "number",
    begin: O,
    relevance: 0
  }, Me = {
    scope: "number",
    begin: q,
    relevance: 0
  }, Oe = {
    scope: "regexp",
    begin: /\/(?=[^/\n]*\/)/,
    end: /\/[gimuy]*/,
    contains: [
      H,
      {
        begin: /\[/,
        end: /\]/,
        relevance: 0,
        contains: [H]
      }
    ]
  }, je = {
    scope: "title",
    begin: S,
    relevance: 0
  }, me = {
    scope: "title",
    begin: C,
    relevance: 0
  }, at = {
    // excludes method names from keyword processing
    begin: "\\.\\s*" + C,
    relevance: 0
  };
  var gt = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    APOS_STRING_MODE: G,
    BACKSLASH_ESCAPE: H,
    BINARY_NUMBER_MODE: Me,
    BINARY_NUMBER_RE: q,
    COMMENT: A,
    C_BLOCK_COMMENT_MODE: _,
    C_LINE_COMMENT_MODE: $,
    C_NUMBER_MODE: ue,
    C_NUMBER_RE: O,
    END_SAME_AS_BEGIN: function(T) {
      return Object.assign(
        T,
        {
          /** @type {ModeCallback} */
          "on:begin": (I, W) => {
            W.data._beginMatch = I[1];
          },
          /** @type {ModeCallback} */
          "on:end": (I, W) => {
            W.data._beginMatch !== I[1] && W.ignoreMatch();
          }
        }
      );
    },
    HASH_COMMENT_MODE: z,
    IDENT_RE: S,
    MATCH_NOTHING_RE: E,
    METHOD_GUARD: at,
    NUMBER_MODE: Q,
    NUMBER_RE: M,
    PHRASAL_WORDS_MODE: re,
    QUOTE_STRING_MODE: V,
    REGEXP_MODE: Oe,
    RE_STARTERS_RE: K,
    SHEBANG: j,
    TITLE_MODE: je,
    UNDERSCORE_IDENT_RE: C,
    UNDERSCORE_TITLE_MODE: me
  });
  function jt(T, I) {
    T.input[T.index - 1] === "." && I.ignoreMatch();
  }
  function Ft(T, I) {
    T.className !== void 0 && (T.scope = T.className, delete T.className);
  }
  function an(T, I) {
    I && T.beginKeywords && (T.begin = "\\b(" + T.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", T.__beforeBegin = jt, T.keywords = T.keywords || T.beginKeywords, delete T.beginKeywords, T.relevance === void 0 && (T.relevance = 0));
  }
  function mo(T, I) {
    Array.isArray(T.illegal) && (T.illegal = b(...T.illegal));
  }
  function po(T, I) {
    if (T.match) {
      if (T.begin || T.end) throw new Error("begin & end are not supported with match");
      T.begin = T.match, delete T.match;
    }
  }
  function Be(T, I) {
    T.relevance === void 0 && (T.relevance = 1);
  }
  const ln = (T, I) => {
    if (!T.beforeMatch) return;
    if (T.starts) throw new Error("beforeMatch cannot be used with starts");
    const W = Object.assign({}, T);
    Object.keys(T).forEach((ye) => {
      delete T[ye];
    }), T.keywords = W.keywords, T.begin = p(W.beforeMatch, f(W.begin)), T.starts = {
      relevance: 0,
      contains: [
        Object.assign(W, { endsParent: !0 })
      ]
    }, T.relevance = 0, delete W.beforeMatch;
  }, Nn = [
    "of",
    "and",
    "for",
    "in",
    "not",
    "or",
    "if",
    "then",
    "parent",
    // common variable name
    "list",
    // common variable name
    "value"
    // common variable name
  ], go = "keyword";
  function hi(T, I, W = go) {
    const ye = /* @__PURE__ */ Object.create(null);
    return typeof T == "string" ? Ye(W, T.split(" ")) : Array.isArray(T) ? Ye(W, T) : Object.keys(T).forEach(function(Ze) {
      Object.assign(
        ye,
        hi(T[Ze], I, Ze)
      );
    }), ye;
    function Ye(Ze, oe) {
      I && (oe = oe.map((X) => X.toLowerCase())), oe.forEach(function(X) {
        const he = X.split("|");
        ye[he[0]] = [Ze, Cs(he[0], he[1])];
      });
    }
  }
  function Cs(T, I) {
    return I ? Number(I) : _c(T) ? 0 : 1;
  }
  function _c(T) {
    return Nn.includes(T.toLowerCase());
  }
  const Ms = {}, $n = (T) => {
    console.error(T);
  }, Yt = (T, ...I) => {
    console.log(`WARN: ${T}`, ...I);
  }, Xt = (T, I) => {
    Ms[`${T}/${I}`] || (console.log(`Deprecated as of ${T}. ${I}`), Ms[`${T}/${I}`] = !0);
  }, bo = new Error();
  function As(T, I, { key: W }) {
    let ye = 0;
    const Ye = T[W], Ze = {}, oe = {};
    for (let X = 1; X <= I.length; X++)
      oe[X + ye] = Ye[X], Ze[X + ye] = !0, ye += v(I[X - 1]);
    T[W] = oe, T[W]._emit = Ze, T[W]._multi = !0;
  }
  function _s(T) {
    if (Array.isArray(T.begin)) {
      if (T.skip || T.excludeBegin || T.returnBegin)
        throw $n("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), bo;
      if (typeof T.beginScope != "object" || T.beginScope === null)
        throw $n("beginScope must be object"), bo;
      As(T, T.begin, { key: "beginScope" }), T.begin = w(T.begin, { joinWith: "" });
    }
  }
  function Zt(T) {
    if (Array.isArray(T.end)) {
      if (T.skip || T.excludeEnd || T.returnEnd)
        throw $n("skip, excludeEnd, returnEnd not compatible with endScope: {}"), bo;
      if (typeof T.endScope != "object" || T.endScope === null)
        throw $n("endScope must be object"), bo;
      As(T, T.end, { key: "endScope" }), T.end = w(T.end, { joinWith: "" });
    }
  }
  function yo(T) {
    T.scope && typeof T.scope == "object" && T.scope !== null && (T.beginScope = T.scope, delete T.scope);
  }
  function vo(T) {
    yo(T), typeof T.beginScope == "string" && (T.beginScope = { _wrap: T.beginScope }), typeof T.endScope == "string" && (T.endScope = { _wrap: T.endScope }), _s(T), Zt(T);
  }
  function Rc(T) {
    function I(oe, X) {
      return new RegExp(
        d(oe),
        "m" + (T.case_insensitive ? "i" : "") + (T.unicodeRegex ? "u" : "") + (X ? "g" : "")
      );
    }
    class W {
      constructor() {
        this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0;
      }
      // @ts-ignore
      addRule(X, he) {
        he.position = this.position++, this.matchIndexes[this.matchAt] = he, this.regexes.push([he, X]), this.matchAt += v(X) + 1;
      }
      compile() {
        this.regexes.length === 0 && (this.exec = () => null);
        const X = this.regexes.map((he) => he[1]);
        this.matcherRe = I(w(X, { joinWith: "|" }), !0), this.lastIndex = 0;
      }
      /** @param {string} s */
      exec(X) {
        this.matcherRe.lastIndex = this.lastIndex;
        const he = this.matcherRe.exec(X);
        if (!he)
          return null;
        const He = he.findIndex((Bt, wo) => wo > 0 && Bt !== void 0), Je = this.matchIndexes[He];
        return he.splice(0, He), Object.assign(he, Je);
      }
    }
    class ye {
      constructor() {
        this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0;
      }
      // @ts-ignore
      getMatcher(X) {
        if (this.multiRegexes[X]) return this.multiRegexes[X];
        const he = new W();
        return this.rules.slice(X).forEach(([He, Je]) => he.addRule(He, Je)), he.compile(), this.multiRegexes[X] = he, he;
      }
      resumingScanAtSamePosition() {
        return this.regexIndex !== 0;
      }
      considerAll() {
        this.regexIndex = 0;
      }
      // @ts-ignore
      addRule(X, he) {
        this.rules.push([X, he]), he.type === "begin" && this.count++;
      }
      /** @param {string} s */
      exec(X) {
        const he = this.getMatcher(this.regexIndex);
        he.lastIndex = this.lastIndex;
        let He = he.exec(X);
        if (this.resumingScanAtSamePosition() && !(He && He.index === this.lastIndex)) {
          const Je = this.getMatcher(0);
          Je.lastIndex = this.lastIndex + 1, He = Je.exec(X);
        }
        return He && (this.regexIndex += He.position + 1, this.regexIndex === this.count && this.considerAll()), He;
      }
    }
    function Ye(oe) {
      const X = new ye();
      return oe.contains.forEach((he) => X.addRule(he.begin, { rule: he, type: "begin" })), oe.terminatorEnd && X.addRule(oe.terminatorEnd, { type: "end" }), oe.illegal && X.addRule(oe.illegal, { type: "illegal" }), X;
    }
    function Ze(oe, X) {
      const he = (
        /** @type CompiledMode */
        oe
      );
      if (oe.isCompiled) return he;
      [
        Ft,
        // do this early so compiler extensions generally don't have to worry about
        // the distinction between match/begin
        po,
        vo,
        ln
      ].forEach((Je) => Je(oe, X)), T.compilerExtensions.forEach((Je) => Je(oe, X)), oe.__beforeBegin = null, [
        an,
        // do this later so compiler extensions that come earlier have access to the
        // raw array if they wanted to perhaps manipulate it, etc.
        mo,
        // default to 1 relevance if not specified
        Be
      ].forEach((Je) => Je(oe, X)), oe.isCompiled = !0;
      let He = null;
      return typeof oe.keywords == "object" && oe.keywords.$pattern && (oe.keywords = Object.assign({}, oe.keywords), He = oe.keywords.$pattern, delete oe.keywords.$pattern), He = He || /\w+/, oe.keywords && (oe.keywords = hi(oe.keywords, T.case_insensitive)), he.keywordPatternRe = I(He, !0), X && (oe.begin || (oe.begin = /\B|\b/), he.beginRe = I(he.begin), !oe.end && !oe.endsWithParent && (oe.end = /\B|\b/), oe.end && (he.endRe = I(he.end)), he.terminatorEnd = d(he.end) || "", oe.endsWithParent && X.terminatorEnd && (he.terminatorEnd += (oe.end ? "|" : "") + X.terminatorEnd)), oe.illegal && (he.illegalRe = I(
        /** @type {RegExp | string} */
        oe.illegal
      )), oe.contains || (oe.contains = []), oe.contains = [].concat(...oe.contains.map(function(Je) {
        return mi(Je === "self" ? oe : Je);
      })), oe.contains.forEach(function(Je) {
        Ze(
          /** @type Mode */
          Je,
          he
        );
      }), oe.starts && Ze(oe.starts, X), he.matcher = Ye(he), he;
    }
    if (T.compilerExtensions || (T.compilerExtensions = []), T.contains && T.contains.includes("self"))
      throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.");
    return T.classNameAliases = r(T.classNameAliases || {}), Ze(
      /** @type Mode */
      T
    );
  }
  function tr(T) {
    return T ? T.endsWithParent || tr(T.starts) : !1;
  }
  function mi(T) {
    return T.variants && !T.cachedVariants && (T.cachedVariants = T.variants.map(function(I) {
      return r(T, { variants: null }, I);
    })), T.cachedVariants ? T.cachedVariants : tr(T) ? r(T, { starts: T.starts ? r(T.starts) : null }) : Object.isFrozen(T) ? r(T) : T;
  }
  var pi = "11.11.1";
  class Oc extends Error {
    constructor(I, W) {
      super(I), this.name = "HTMLInjectionError", this.html = W;
    }
  }
  const L = n, Rs = r, Pr = Symbol("nomatch"), nr = 7, Br = function(T) {
    const I = /* @__PURE__ */ Object.create(null), W = /* @__PURE__ */ Object.create(null), ye = [];
    let Ye = !0;
    const Ze = "Could not find the language '{}', did you forget to load/include a language module?", oe = { disableAutodetect: !0, name: "Plain text", contains: [] };
    let X = {
      ignoreUnescapedHTML: !1,
      throwUnescapedHTML: !1,
      noHighlightRe: /^(no-?highlight)$/i,
      languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i,
      classPrefix: "hljs-",
      cssSelector: "pre code",
      languages: null,
      // beta configuration options, subject to change, welcome to discuss
      // https://github.com/highlightjs/highlight.js/issues/1086
      __emitter: u
    };
    function he(F) {
      return X.noHighlightRe.test(F);
    }
    function He(F) {
      let de = F.className + " ";
      de += F.parentNode ? F.parentNode.className : "";
      const _e = X.languageDetectRe.exec(de);
      if (_e) {
        const qe = Sn(_e[1]);
        return qe || (Yt(Ze.replace("{}", _e[1])), Yt("Falling back to no-highlight mode for this block.", F)), qe ? _e[1] : "no-highlight";
      }
      return de.split(/\s+/).find((qe) => he(qe) || Sn(qe));
    }
    function Je(F, de, _e) {
      let qe = "", lt = "";
      typeof de == "object" ? (qe = F, _e = de.ignoreIllegals, lt = de.language) : (Xt("10.7.0", "highlight(lang, code, ...args) has been deprecated."), Xt("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), lt = F, qe = de), _e === void 0 && (_e = !0);
      const cn = {
        code: qe,
        language: lt
      };
      Os("before:highlight", cn);
      const or = cn.result ? cn.result : Bt(cn.language, cn.code, _e);
      return or.code = cn.code, Os("after:highlight", or), or;
    }
    function Bt(F, de, _e, qe) {
      const lt = /* @__PURE__ */ Object.create(null);
      function cn(Z, ae) {
        return Z.keywords[ae];
      }
      function or() {
        if (!ve.keywords) {
          bt.addText(Ge);
          return;
        }
        let Z = 0;
        ve.keywordPatternRe.lastIndex = 0;
        let ae = ve.keywordPatternRe.exec(Ge), Ee = "";
        for (; ae; ) {
          Ee += Ge.substring(Z, ae.index);
          const Fe = Cn.case_insensitive ? ae[0].toLowerCase() : ae[0], Et = cn(ve, Fe);
          if (Et) {
            const [Hn, wx] = Et;
            if (bt.addText(Ee), Ee = "", lt[Fe] = (lt[Fe] || 0) + 1, lt[Fe] <= nr && (Ls += wx), Hn.startsWith("_"))
              Ee += ae[0];
            else {
              const kx = Cn.classNameAliases[Hn] || Hn;
              Tn(ae[0], kx);
            }
          } else
            Ee += ae[0];
          Z = ve.keywordPatternRe.lastIndex, ae = ve.keywordPatternRe.exec(Ge);
        }
        Ee += Ge.substring(Z), bt.addText(Ee);
      }
      function Is() {
        if (Ge === "") return;
        let Z = null;
        if (typeof ve.subLanguage == "string") {
          if (!I[ve.subLanguage]) {
            bt.addText(Ge);
            return;
          }
          Z = Bt(ve.subLanguage, Ge, !0, Bh[ve.subLanguage]), Bh[ve.subLanguage] = /** @type {CompiledMode} */
          Z._top;
        } else
          Z = ko(Ge, ve.subLanguage.length ? ve.subLanguage : null);
        ve.relevance > 0 && (Ls += Z.relevance), bt.__addSublanguage(Z._emitter, Z.language);
      }
      function Ut() {
        ve.subLanguage != null ? Is() : or(), Ge = "";
      }
      function Tn(Z, ae) {
        Z !== "" && (bt.startScope(ae), bt.addText(Z), bt.endScope());
      }
      function Ih(Z, ae) {
        let Ee = 1;
        const Fe = ae.length - 1;
        for (; Ee <= Fe; ) {
          if (!Z._emit[Ee]) {
            Ee++;
            continue;
          }
          const Et = Cn.classNameAliases[Z[Ee]] || Z[Ee], Hn = ae[Ee];
          Et ? Tn(Hn, Et) : (Ge = Hn, or(), Ge = ""), Ee++;
        }
      }
      function Dh(Z, ae) {
        return Z.scope && typeof Z.scope == "string" && bt.openNode(Cn.classNameAliases[Z.scope] || Z.scope), Z.beginScope && (Z.beginScope._wrap ? (Tn(Ge, Cn.classNameAliases[Z.beginScope._wrap] || Z.beginScope._wrap), Ge = "") : Z.beginScope._multi && (Ih(Z.beginScope, ae), Ge = "")), ve = Object.create(Z, { parent: { value: ve } }), ve;
      }
      function Lh(Z, ae, Ee) {
        let Fe = k(Z.endRe, Ee);
        if (Fe) {
          if (Z["on:end"]) {
            const Et = new e(Z);
            Z["on:end"](ae, Et), Et.isMatchIgnored && (Fe = !1);
          }
          if (Fe) {
            for (; Z.endsParent && Z.parent; )
              Z = Z.parent;
            return Z;
          }
        }
        if (Z.endsWithParent)
          return Lh(Z.parent, ae, Ee);
      }
      function px(Z) {
        return ve.matcher.regexIndex === 0 ? (Ge += Z[0], 1) : (Bc = !0, 0);
      }
      function gx(Z) {
        const ae = Z[0], Ee = Z.rule, Fe = new e(Ee), Et = [Ee.__beforeBegin, Ee["on:begin"]];
        for (const Hn of Et)
          if (Hn && (Hn(Z, Fe), Fe.isMatchIgnored))
            return px(ae);
        return Ee.skip ? Ge += ae : (Ee.excludeBegin && (Ge += ae), Ut(), !Ee.returnBegin && !Ee.excludeBegin && (Ge = ae)), Dh(Ee, Z), Ee.returnBegin ? 0 : ae.length;
      }
      function bx(Z) {
        const ae = Z[0], Ee = de.substring(Z.index), Fe = Lh(ve, Z, Ee);
        if (!Fe)
          return Pr;
        const Et = ve;
        ve.endScope && ve.endScope._wrap ? (Ut(), Tn(ae, ve.endScope._wrap)) : ve.endScope && ve.endScope._multi ? (Ut(), Ih(ve.endScope, Z)) : Et.skip ? Ge += ae : (Et.returnEnd || Et.excludeEnd || (Ge += ae), Ut(), Et.excludeEnd && (Ge = ae));
        do
          ve.scope && bt.closeNode(), !ve.skip && !ve.subLanguage && (Ls += ve.relevance), ve = ve.parent;
        while (ve !== Fe.parent);
        return Fe.starts && Dh(Fe.starts, Z), Et.returnEnd ? 0 : ae.length;
      }
      function yx() {
        const Z = [];
        for (let ae = ve; ae !== Cn; ae = ae.parent)
          ae.scope && Z.unshift(ae.scope);
        Z.forEach((ae) => bt.openNode(ae));
      }
      let Ds = {};
      function Ph(Z, ae) {
        const Ee = ae && ae[0];
        if (Ge += Z, Ee == null)
          return Ut(), 0;
        if (Ds.type === "begin" && ae.type === "end" && Ds.index === ae.index && Ee === "") {
          if (Ge += de.slice(ae.index, ae.index + 1), !Ye) {
            const Fe = new Error(`0 width match regex (${F})`);
            throw Fe.languageName = F, Fe.badRule = Ds.rule, Fe;
          }
          return 1;
        }
        if (Ds = ae, ae.type === "begin")
          return gx(ae);
        if (ae.type === "illegal" && !_e) {
          const Fe = new Error('Illegal lexeme "' + Ee + '" for mode "' + (ve.scope || "<unnamed>") + '"');
          throw Fe.mode = ve, Fe;
        } else if (ae.type === "end") {
          const Fe = bx(ae);
          if (Fe !== Pr)
            return Fe;
        }
        if (ae.type === "illegal" && Ee === "")
          return Ge += `
`, 1;
        if (Pc > 1e5 && Pc > ae.index * 3)
          throw new Error("potential infinite loop, way more iterations than matches");
        return Ge += Ee, Ee.length;
      }
      const Cn = Sn(F);
      if (!Cn)
        throw $n(Ze.replace("{}", F)), new Error('Unknown language: "' + F + '"');
      const vx = Rc(Cn);
      let Lc = "", ve = qe || vx;
      const Bh = {}, bt = new X.__emitter(X);
      yx();
      let Ge = "", Ls = 0, zr = 0, Pc = 0, Bc = !1;
      try {
        if (Cn.__emitTokens)
          Cn.__emitTokens(de, bt);
        else {
          for (ve.matcher.considerAll(); ; ) {
            Pc++, Bc ? Bc = !1 : ve.matcher.considerAll(), ve.matcher.lastIndex = zr;
            const Z = ve.matcher.exec(de);
            if (!Z) break;
            const ae = de.substring(zr, Z.index), Ee = Ph(ae, Z);
            zr = Z.index + Ee;
          }
          Ph(de.substring(zr));
        }
        return bt.finalize(), Lc = bt.toHTML(), {
          language: F,
          value: Lc,
          relevance: Ls,
          illegal: !1,
          _emitter: bt,
          _top: ve
        };
      } catch (Z) {
        if (Z.message && Z.message.includes("Illegal"))
          return {
            language: F,
            value: L(de),
            illegal: !0,
            relevance: 0,
            _illegalBy: {
              message: Z.message,
              index: zr,
              context: de.slice(zr - 100, zr + 100),
              mode: Z.mode,
              resultSoFar: Lc
            },
            _emitter: bt
          };
        if (Ye)
          return {
            language: F,
            value: L(de),
            illegal: !1,
            relevance: 0,
            errorRaised: Z,
            _emitter: bt,
            _top: ve
          };
        throw Z;
      }
    }
    function wo(F) {
      const de = {
        value: L(F),
        illegal: !1,
        relevance: 0,
        _top: oe,
        _emitter: new X.__emitter(X)
      };
      return de._emitter.addText(F), de;
    }
    function ko(F, de) {
      de = de || X.languages || Object.keys(I);
      const _e = wo(F), qe = de.filter(Sn).filter(Dc).map(
        (Ut) => Bt(Ut, F, !1)
      );
      qe.unshift(_e);
      const lt = qe.sort((Ut, Tn) => {
        if (Ut.relevance !== Tn.relevance) return Tn.relevance - Ut.relevance;
        if (Ut.language && Tn.language) {
          if (Sn(Ut.language).supersetOf === Tn.language)
            return 1;
          if (Sn(Tn.language).supersetOf === Ut.language)
            return -1;
        }
        return 0;
      }), [cn, or] = lt, Is = cn;
      return Is.secondBest = or, Is;
    }
    function Ic(F, de, _e) {
      const qe = de && W[de] || _e;
      F.classList.add("hljs"), F.classList.add(`language-${qe}`);
    }
    function P(F) {
      let de = null;
      const _e = He(F);
      if (he(_e)) return;
      if (Os(
        "before:highlightElement",
        { el: F, language: _e }
      ), F.dataset.highlighted) {
        console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", F);
        return;
      }
      if (F.children.length > 0 && (X.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(F)), X.throwUnescapedHTML))
        throw new Oc(
          "One of your code blocks includes unescaped HTML.",
          F.innerHTML
        );
      de = F;
      const qe = de.textContent, lt = _e ? Je(qe, { language: _e, ignoreIllegals: !0 }) : ko(qe);
      F.innerHTML = lt.value, F.dataset.highlighted = "yes", Ic(F, _e, lt.language), F.result = {
        language: lt.language,
        // TODO: remove with version 11.0
        re: lt.relevance,
        relevance: lt.relevance
      }, lt.secondBest && (F.secondBest = {
        language: lt.secondBest.language,
        relevance: lt.secondBest.relevance
      }), Os("after:highlightElement", { el: F, result: lt, text: qe });
    }
    function U(F) {
      X = Rs(X, F);
    }
    const we = () => {
      Ae(), Xt("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.");
    };
    function Le() {
      Ae(), Xt("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.");
    }
    let be = !1;
    function Ae() {
      function F() {
        Ae();
      }
      if (document.readyState === "loading") {
        be || window.addEventListener("DOMContentLoaded", F, !1), be = !0;
        return;
      }
      document.querySelectorAll(X.cssSelector).forEach(P);
    }
    function En(F, de) {
      let _e = null;
      try {
        _e = de(T);
      } catch (qe) {
        if ($n("Language definition for '{}' could not be registered.".replace("{}", F)), Ye)
          $n(qe);
        else
          throw qe;
        _e = oe;
      }
      _e.name || (_e.name = F), I[F] = _e, _e.rawDefinition = de.bind(null, T), _e.aliases && No(_e.aliases, { languageName: F });
    }
    function gi(F) {
      delete I[F];
      for (const de of Object.keys(W))
        W[de] === F && delete W[de];
    }
    function xo() {
      return Object.keys(I);
    }
    function Sn(F) {
      return F = (F || "").toLowerCase(), I[F] || I[W[F]];
    }
    function No(F, { languageName: de }) {
      typeof F == "string" && (F = [F]), F.forEach((_e) => {
        W[_e.toLowerCase()] = de;
      });
    }
    function Dc(F) {
      const de = Sn(F);
      return de && !de.disableAutodetect;
    }
    function dx(F) {
      F["before:highlightBlock"] && !F["before:highlightElement"] && (F["before:highlightElement"] = (de) => {
        F["before:highlightBlock"](
          Object.assign({ block: de.el }, de)
        );
      }), F["after:highlightBlock"] && !F["after:highlightElement"] && (F["after:highlightElement"] = (de) => {
        F["after:highlightBlock"](
          Object.assign({ block: de.el }, de)
        );
      });
    }
    function fx(F) {
      dx(F), ye.push(F);
    }
    function hx(F) {
      const de = ye.indexOf(F);
      de !== -1 && ye.splice(de, 1);
    }
    function Os(F, de) {
      const _e = F;
      ye.forEach(function(qe) {
        qe[_e] && qe[_e](de);
      });
    }
    function mx(F) {
      return Xt("10.7.0", "highlightBlock will be removed entirely in v12.0"), Xt("10.7.0", "Please use highlightElement now."), P(F);
    }
    Object.assign(T, {
      highlight: Je,
      highlightAuto: ko,
      highlightAll: Ae,
      highlightElement: P,
      // TODO: Remove with v12 API
      highlightBlock: mx,
      configure: U,
      initHighlighting: we,
      initHighlightingOnLoad: Le,
      registerLanguage: En,
      unregisterLanguage: gi,
      listLanguages: xo,
      getLanguage: Sn,
      registerAliases: No,
      autoDetection: Dc,
      inherit: Rs,
      addPlugin: fx,
      removePlugin: hx
    }), T.debugMode = function() {
      Ye = !1;
    }, T.safeMode = function() {
      Ye = !0;
    }, T.versionString = pi, T.regex = {
      concat: p,
      lookahead: f,
      either: b,
      optional: m,
      anyNumberOfTimes: h
    };
    for (const F in gt)
      typeof gt[F] == "object" && t(gt[F]);
    return Object.assign(T, gt), T;
  }, rr = Br({});
  return rr.newInstance = () => Br({}), bu = rr, rr.HighlightJS = rr, rr.default = rr, bu;
}
var SO = /* @__PURE__ */ EO();
const Av = /* @__PURE__ */ Sx(SO);
function _v(t, e = []) {
  return t.flatMap((n) => {
    const r = [...e, ...n.properties ? n.properties.className : []];
    return n.children ? _v(n.children, r) : {
      text: n.value,
      classes: r
    };
  });
}
function Zp(t) {
  return t.value || t.children || [];
}
function TO(t) {
  return !!Av.getLanguage(t);
}
function Jp({
  doc: t,
  name: e,
  lowlight: n,
  defaultLanguage: r
}) {
  const o = [];
  return Qu(t, (i) => i.type.name === e).forEach((i) => {
    var s;
    let a = i.pos + 1;
    const l = i.node.attrs.language || r, c = n.listLanguages(), u = l && (c.includes(l) || TO(l) || (s = n.registered) != null && s.call(n, l)) ? Zp(n.highlight(l, i.node.textContent)) : Zp(n.highlightAuto(i.node.textContent));
    _v(u).forEach((d) => {
      const f = a + d.text.length;
      if (d.classes.length) {
        const h = Ve.inline(a, f, {
          class: d.classes.join(" ")
        });
        o.push(h);
      }
      a = f;
    });
  }), Te.create(t, o);
}
function CO(t) {
  return typeof t == "function";
}
function MO({
  name: t,
  lowlight: e,
  defaultLanguage: n
}) {
  if (!["highlight", "highlightAuto", "listLanguages"].every((o) => CO(e[o])))
    throw Error("You should provide an instance of lowlight to use the code-block-lowlight extension");
  const r = new Ce({
    key: new Ie("lowlight"),
    state: {
      init: (o, { doc: i }) => Jp({
        doc: i,
        name: t,
        lowlight: e,
        defaultLanguage: n
      }),
      apply: (o, i, s, a) => {
        const l = s.selection.$head.parent.type.name, c = a.selection.$head.parent.type.name, u = Qu(s.doc, (f) => f.type.name === t), d = Qu(a.doc, (f) => f.type.name === t);
        return o.docChanged && // Apply decorations if:
        // selection includes named node,
        ([l, c].includes(t) || // OR transaction adds/removes named node,
        d.length !== u.length || // OR transaction has changes that completely encapsulte a node
        // (for example, a transaction that affects the entire document).
        // Such transactions can happen during collab syncing via y-prosemirror, for example.
        o.steps.some((f) => (
          // @ts-ignore
          f.from !== void 0 && // @ts-ignore
          f.to !== void 0 && u.some((h) => (
            // @ts-ignore
            h.pos >= f.from && // @ts-ignore
            h.pos + h.node.nodeSize <= f.to
          ))
        ))) ? Jp({
          doc: o.doc,
          name: t,
          lowlight: e,
          defaultLanguage: n
        }) : i.map(o.mapping, o.doc);
      }
    },
    props: {
      decorations(o) {
        return r.getState(o);
      }
    }
  });
  return r;
}
var AO = VA.extend({
  addOptions() {
    var t;
    return {
      ...(t = this.parent) == null ? void 0 : t.call(this),
      lowlight: {},
      languageClassPrefix: "language-",
      exitOnTripleEnter: !0,
      exitOnArrowDown: !0,
      defaultLanguage: null,
      enableTabIndentation: !1,
      tabSize: 4,
      HTMLAttributes: {}
    };
  },
  addProseMirrorPlugins() {
    var t;
    return [
      ...((t = this.parent) == null ? void 0 : t.call(this)) || [],
      MO({
        name: this.name,
        lowlight: this.options.lowlight,
        defaultLanguage: this.options.defaultLanguage
      })
    ];
  }
}), _O = AO;
function RO(t) {
  const e = t.regex, n = t.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", o = "[a-zA-Z_]\\w*::", s = "(?!struct)(" + r + "|" + e.optional(o) + "[a-zA-Z_]\\w*" + e.optional("<[^<>]+>") + ")", a = {
    className: "type",
    begin: "\\b[a-z\\d_]*_t\\b"
  }, c = {
    className: "string",
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: "\\n",
        contains: [t.BACKSLASH_ESCAPE]
      },
      {
        begin: "(u8?|U|L)?'(" + "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)" + "|.)",
        end: "'",
        illegal: "."
      },
      t.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  }, u = {
    className: "number",
    variants: [
      // Floating-point literal.
      {
        begin: "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)"
      },
      // Integer literal.
      {
        begin: "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)"
        // Note: there are user-defined literal suffixes too, but perhaps having the custom suffix not part of the
        // literal highlight actually makes it stand out more.
      }
    ],
    relevance: 0
  }, d = {
    className: "meta",
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
    contains: [
      {
        begin: /\\\n/,
        relevance: 0
      },
      t.inherit(c, { className: "string" }),
      {
        className: "string",
        begin: /<.*?>/
      },
      n,
      t.C_BLOCK_COMMENT_MODE
    ]
  }, f = {
    className: "title",
    begin: e.optional(o) + t.IDENT_RE,
    relevance: 0
  }, h = e.optional(o) + t.IDENT_RE + "\\s*\\(", m = [
    "alignas",
    "alignof",
    "and",
    "and_eq",
    "asm",
    "atomic_cancel",
    "atomic_commit",
    "atomic_noexcept",
    "auto",
    "bitand",
    "bitor",
    "break",
    "case",
    "catch",
    "class",
    "co_await",
    "co_return",
    "co_yield",
    "compl",
    "concept",
    "const_cast|10",
    "consteval",
    "constexpr",
    "constinit",
    "continue",
    "decltype",
    "default",
    "delete",
    "do",
    "dynamic_cast|10",
    "else",
    "enum",
    "explicit",
    "export",
    "extern",
    "false",
    "final",
    "for",
    "friend",
    "goto",
    "if",
    "import",
    "inline",
    "module",
    "mutable",
    "namespace",
    "new",
    "noexcept",
    "not",
    "not_eq",
    "nullptr",
    "operator",
    "or",
    "or_eq",
    "override",
    "private",
    "protected",
    "public",
    "reflexpr",
    "register",
    "reinterpret_cast|10",
    "requires",
    "return",
    "sizeof",
    "static_assert",
    "static_cast|10",
    "struct",
    "switch",
    "synchronized",
    "template",
    "this",
    "thread_local",
    "throw",
    "transaction_safe",
    "transaction_safe_dynamic",
    "true",
    "try",
    "typedef",
    "typeid",
    "typename",
    "union",
    "using",
    "virtual",
    "volatile",
    "while",
    "xor",
    "xor_eq"
  ], p = [
    "bool",
    "char",
    "char16_t",
    "char32_t",
    "char8_t",
    "double",
    "float",
    "int",
    "long",
    "short",
    "void",
    "wchar_t",
    "unsigned",
    "signed",
    "const",
    "static"
  ], g = [
    "any",
    "auto_ptr",
    "barrier",
    "binary_semaphore",
    "bitset",
    "complex",
    "condition_variable",
    "condition_variable_any",
    "counting_semaphore",
    "deque",
    "false_type",
    "flat_map",
    "flat_set",
    "future",
    "imaginary",
    "initializer_list",
    "istringstream",
    "jthread",
    "latch",
    "lock_guard",
    "multimap",
    "multiset",
    "mutex",
    "optional",
    "ostringstream",
    "packaged_task",
    "pair",
    "promise",
    "priority_queue",
    "queue",
    "recursive_mutex",
    "recursive_timed_mutex",
    "scoped_lock",
    "set",
    "shared_future",
    "shared_lock",
    "shared_mutex",
    "shared_timed_mutex",
    "shared_ptr",
    "stack",
    "string_view",
    "stringstream",
    "timed_mutex",
    "thread",
    "true_type",
    "tuple",
    "unique_lock",
    "unique_ptr",
    "unordered_map",
    "unordered_multimap",
    "unordered_multiset",
    "unordered_set",
    "variant",
    "vector",
    "weak_ptr",
    "wstring",
    "wstring_view"
  ], b = [
    "abort",
    "abs",
    "acos",
    "apply",
    "as_const",
    "asin",
    "atan",
    "atan2",
    "calloc",
    "ceil",
    "cerr",
    "cin",
    "clog",
    "cos",
    "cosh",
    "cout",
    "declval",
    "endl",
    "exchange",
    "exit",
    "exp",
    "fabs",
    "floor",
    "fmod",
    "forward",
    "fprintf",
    "fputs",
    "free",
    "frexp",
    "fscanf",
    "future",
    "invoke",
    "isalnum",
    "isalpha",
    "iscntrl",
    "isdigit",
    "isgraph",
    "islower",
    "isprint",
    "ispunct",
    "isspace",
    "isupper",
    "isxdigit",
    "labs",
    "launder",
    "ldexp",
    "log",
    "log10",
    "make_pair",
    "make_shared",
    "make_shared_for_overwrite",
    "make_tuple",
    "make_unique",
    "malloc",
    "memchr",
    "memcmp",
    "memcpy",
    "memset",
    "modf",
    "move",
    "pow",
    "printf",
    "putchar",
    "puts",
    "realloc",
    "scanf",
    "sin",
    "sinh",
    "snprintf",
    "sprintf",
    "sqrt",
    "sscanf",
    "std",
    "stderr",
    "stdin",
    "stdout",
    "strcat",
    "strchr",
    "strcmp",
    "strcpy",
    "strcspn",
    "strlen",
    "strncat",
    "strncmp",
    "strncpy",
    "strpbrk",
    "strrchr",
    "strspn",
    "strstr",
    "swap",
    "tan",
    "tanh",
    "terminate",
    "to_underlying",
    "tolower",
    "toupper",
    "vfprintf",
    "visit",
    "vprintf",
    "vsprintf"
  ], x = {
    type: p,
    keyword: m,
    literal: [
      "NULL",
      "false",
      "nullopt",
      "nullptr",
      "true"
    ],
    built_in: ["_Pragma"],
    _type_hints: g
  }, w = {
    className: "function.dispatch",
    relevance: 0,
    keywords: {
      // Only for relevance, not highlighting.
      _hint: b
    },
    begin: e.concat(
      /\b/,
      /(?!decltype)/,
      /(?!if)/,
      /(?!for)/,
      /(?!switch)/,
      /(?!while)/,
      t.IDENT_RE,
      e.lookahead(/(<[^<>]+>|)\s*\(/)
    )
  }, E = [
    w,
    d,
    a,
    n,
    t.C_BLOCK_COMMENT_MODE,
    u,
    c
  ], S = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [
      {
        begin: /=/,
        end: /;/
      },
      {
        begin: /\(/,
        end: /\)/
      },
      {
        beginKeywords: "new throw return else",
        end: /;/
      }
    ],
    keywords: x,
    contains: E.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: x,
        contains: E.concat(["self"]),
        relevance: 0
      }
    ]),
    relevance: 0
  }, C = {
    className: "function",
    begin: "(" + s + "[\\*&\\s]+)+" + h,
    returnBegin: !0,
    end: /[{;=]/,
    excludeEnd: !0,
    keywords: x,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      {
        // to prevent it from being confused as the function title
        begin: r,
        keywords: x,
        relevance: 0
      },
      {
        begin: h,
        returnBegin: !0,
        contains: [f],
        relevance: 0
      },
      // needed because we do not have look-behind on the below rule
      // to prevent it from grabbing the final : in a :: pair
      {
        begin: /::/,
        relevance: 0
      },
      // initializers
      {
        begin: /:/,
        endsWithParent: !0,
        contains: [
          c,
          u
        ]
      },
      // allow for multiple declarations, e.g.:
      // extern void f(int), g(char);
      {
        relevance: 0,
        match: /,/
      },
      {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: x,
        relevance: 0,
        contains: [
          n,
          t.C_BLOCK_COMMENT_MODE,
          c,
          u,
          a,
          // Count matching parentheses.
          {
            begin: /\(/,
            end: /\)/,
            keywords: x,
            relevance: 0,
            contains: [
              "self",
              n,
              t.C_BLOCK_COMMENT_MODE,
              c,
              u,
              a
            ]
          }
        ]
      },
      a,
      n,
      t.C_BLOCK_COMMENT_MODE,
      d
    ]
  };
  return {
    name: "C++",
    aliases: [
      "cc",
      "c++",
      "h++",
      "hpp",
      "hh",
      "hxx",
      "cxx"
    ],
    keywords: x,
    illegal: "</",
    classNameAliases: { "function.dispatch": "built_in" },
    contains: [].concat(
      S,
      C,
      w,
      E,
      [
        d,
        {
          // containers: ie, `vector <int> rooms (9);`
          begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)",
          end: ">",
          keywords: x,
          contains: [
            "self",
            a
          ]
        },
        {
          begin: t.IDENT_RE + "::",
          keywords: x
        },
        {
          match: [
            // extra complexity to deal with `enum class` and `enum struct`
            /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
            /\s+/,
            /\w+/
          ],
          className: {
            1: "keyword",
            3: "title.class"
          }
        }
      ]
    )
  };
}
function OO(t) {
  const e = {
    type: [
      "boolean",
      "byte",
      "word",
      "String"
    ],
    built_in: [
      "KeyboardController",
      "MouseController",
      "SoftwareSerial",
      "EthernetServer",
      "EthernetClient",
      "LiquidCrystal",
      "RobotControl",
      "GSMVoiceCall",
      "EthernetUDP",
      "EsploraTFT",
      "HttpClient",
      "RobotMotor",
      "WiFiClient",
      "GSMScanner",
      "FileSystem",
      "Scheduler",
      "GSMServer",
      "YunClient",
      "YunServer",
      "IPAddress",
      "GSMClient",
      "GSMModem",
      "Keyboard",
      "Ethernet",
      "Console",
      "GSMBand",
      "Esplora",
      "Stepper",
      "Process",
      "WiFiUDP",
      "GSM_SMS",
      "Mailbox",
      "USBHost",
      "Firmata",
      "PImage",
      "Client",
      "Server",
      "GSMPIN",
      "FileIO",
      "Bridge",
      "Serial",
      "EEPROM",
      "Stream",
      "Mouse",
      "Audio",
      "Servo",
      "File",
      "Task",
      "GPRS",
      "WiFi",
      "Wire",
      "TFT",
      "GSM",
      "SPI",
      "SD"
    ],
    _hints: [
      "setup",
      "loop",
      "runShellCommandAsynchronously",
      "analogWriteResolution",
      "retrieveCallingNumber",
      "printFirmwareVersion",
      "analogReadResolution",
      "sendDigitalPortPair",
      "noListenOnLocalhost",
      "readJoystickButton",
      "setFirmwareVersion",
      "readJoystickSwitch",
      "scrollDisplayRight",
      "getVoiceCallStatus",
      "scrollDisplayLeft",
      "writeMicroseconds",
      "delayMicroseconds",
      "beginTransmission",
      "getSignalStrength",
      "runAsynchronously",
      "getAsynchronously",
      "listenOnLocalhost",
      "getCurrentCarrier",
      "readAccelerometer",
      "messageAvailable",
      "sendDigitalPorts",
      "lineFollowConfig",
      "countryNameWrite",
      "runShellCommand",
      "readStringUntil",
      "rewindDirectory",
      "readTemperature",
      "setClockDivider",
      "readLightSensor",
      "endTransmission",
      "analogReference",
      "detachInterrupt",
      "countryNameRead",
      "attachInterrupt",
      "encryptionType",
      "readBytesUntil",
      "robotNameWrite",
      "readMicrophone",
      "robotNameRead",
      "cityNameWrite",
      "userNameWrite",
      "readJoystickY",
      "readJoystickX",
      "mouseReleased",
      "openNextFile",
      "scanNetworks",
      "noInterrupts",
      "digitalWrite",
      "beginSpeaker",
      "mousePressed",
      "isActionDone",
      "mouseDragged",
      "displayLogos",
      "noAutoscroll",
      "addParameter",
      "remoteNumber",
      "getModifiers",
      "keyboardRead",
      "userNameRead",
      "waitContinue",
      "processInput",
      "parseCommand",
      "printVersion",
      "readNetworks",
      "writeMessage",
      "blinkVersion",
      "cityNameRead",
      "readMessage",
      "setDataMode",
      "parsePacket",
      "isListening",
      "setBitOrder",
      "beginPacket",
      "isDirectory",
      "motorsWrite",
      "drawCompass",
      "digitalRead",
      "clearScreen",
      "serialEvent",
      "rightToLeft",
      "setTextSize",
      "leftToRight",
      "requestFrom",
      "keyReleased",
      "compassRead",
      "analogWrite",
      "interrupts",
      "WiFiServer",
      "disconnect",
      "playMelody",
      "parseFloat",
      "autoscroll",
      "getPINUsed",
      "setPINUsed",
      "setTimeout",
      "sendAnalog",
      "readSlider",
      "analogRead",
      "beginWrite",
      "createChar",
      "motorsStop",
      "keyPressed",
      "tempoWrite",
      "readButton",
      "subnetMask",
      "debugPrint",
      "macAddress",
      "writeGreen",
      "randomSeed",
      "attachGPRS",
      "readString",
      "sendString",
      "remotePort",
      "releaseAll",
      "mouseMoved",
      "background",
      "getXChange",
      "getYChange",
      "answerCall",
      "getResult",
      "voiceCall",
      "endPacket",
      "constrain",
      "getSocket",
      "writeJSON",
      "getButton",
      "available",
      "connected",
      "findUntil",
      "readBytes",
      "exitValue",
      "readGreen",
      "writeBlue",
      "startLoop",
      "IPAddress",
      "isPressed",
      "sendSysex",
      "pauseMode",
      "gatewayIP",
      "setCursor",
      "getOemKey",
      "tuneWrite",
      "noDisplay",
      "loadImage",
      "switchPIN",
      "onRequest",
      "onReceive",
      "changePIN",
      "playFile",
      "noBuffer",
      "parseInt",
      "overflow",
      "checkPIN",
      "knobRead",
      "beginTFT",
      "bitClear",
      "updateIR",
      "bitWrite",
      "position",
      "writeRGB",
      "highByte",
      "writeRed",
      "setSpeed",
      "readBlue",
      "noStroke",
      "remoteIP",
      "transfer",
      "shutdown",
      "hangCall",
      "beginSMS",
      "endWrite",
      "attached",
      "maintain",
      "noCursor",
      "checkReg",
      "checkPUK",
      "shiftOut",
      "isValid",
      "shiftIn",
      "pulseIn",
      "connect",
      "println",
      "localIP",
      "pinMode",
      "getIMEI",
      "display",
      "noBlink",
      "process",
      "getBand",
      "running",
      "beginSD",
      "drawBMP",
      "lowByte",
      "setBand",
      "release",
      "bitRead",
      "prepare",
      "pointTo",
      "readRed",
      "setMode",
      "noFill",
      "remove",
      "listen",
      "stroke",
      "detach",
      "attach",
      "noTone",
      "exists",
      "buffer",
      "height",
      "bitSet",
      "circle",
      "config",
      "cursor",
      "random",
      "IRread",
      "setDNS",
      "endSMS",
      "getKey",
      "micros",
      "millis",
      "begin",
      "print",
      "write",
      "ready",
      "flush",
      "width",
      "isPIN",
      "blink",
      "clear",
      "press",
      "mkdir",
      "rmdir",
      "close",
      "point",
      "yield",
      "image",
      "BSSID",
      "click",
      "delay",
      "read",
      "text",
      "move",
      "peek",
      "beep",
      "rect",
      "line",
      "open",
      "seek",
      "fill",
      "size",
      "turn",
      "stop",
      "home",
      "find",
      "step",
      "tone",
      "sqrt",
      "RSSI",
      "SSID",
      "end",
      "bit",
      "tan",
      "cos",
      "sin",
      "pow",
      "map",
      "abs",
      "max",
      "min",
      "get",
      "run",
      "put"
    ],
    literal: [
      "DIGITAL_MESSAGE",
      "FIRMATA_STRING",
      "ANALOG_MESSAGE",
      "REPORT_DIGITAL",
      "REPORT_ANALOG",
      "INPUT_PULLUP",
      "SET_PIN_MODE",
      "INTERNAL2V56",
      "SYSTEM_RESET",
      "LED_BUILTIN",
      "INTERNAL1V1",
      "SYSEX_START",
      "INTERNAL",
      "EXTERNAL",
      "DEFAULT",
      "OUTPUT",
      "INPUT",
      "HIGH",
      "LOW"
    ]
  }, n = RO(t), r = (
    /** @type {Record<string,any>} */
    n.keywords
  );
  return r.type = [
    ...r.type,
    ...e.type
  ], r.literal = [
    ...r.literal,
    ...e.literal
  ], r.built_in = [
    ...r.built_in,
    ...e.built_in
  ], r._hints = e._hints, n.name = "Arduino", n.aliases = ["ino"], n.supersetOf = "cpp", n;
}
function IO(t) {
  const e = t.regex, n = {}, r = {
    begin: /\$\{/,
    end: /\}/,
    contains: [
      "self",
      {
        begin: /:-/,
        contains: [n]
      }
      // default values
    ]
  };
  Object.assign(n, {
    className: "variable",
    variants: [
      { begin: e.concat(
        /\$[\w\d#@][\w\d_]*/,
        // negative look-ahead tries to avoid matching patterns that are not
        // Perl at all like $ident$, @ident@, etc.
        "(?![\\w\\d])(?![$])"
      ) },
      r
    ]
  });
  const o = {
    className: "subst",
    begin: /\$\(/,
    end: /\)/,
    contains: [t.BACKSLASH_ESCAPE]
  }, i = t.inherit(
    t.COMMENT(),
    {
      match: [
        /(^|\s)/,
        /#.*$/
      ],
      scope: {
        2: "comment"
      }
    }
  ), s = {
    begin: /<<-?\s*(?=\w+)/,
    starts: { contains: [
      t.END_SAME_AS_BEGIN({
        begin: /(\w+)/,
        end: /(\w+)/,
        className: "string"
      })
    ] }
  }, a = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      t.BACKSLASH_ESCAPE,
      n,
      o
    ]
  };
  o.contains.push(a);
  const l = {
    match: /\\"/
  }, c = {
    className: "string",
    begin: /'/,
    end: /'/
  }, u = {
    match: /\\'/
  }, d = {
    begin: /\$?\(\(/,
    end: /\)\)/,
    contains: [
      {
        begin: /\d+#[0-9a-f]+/,
        className: "number"
      },
      t.NUMBER_MODE,
      n
    ]
  }, f = [
    "fish",
    "bash",
    "zsh",
    "sh",
    "csh",
    "ksh",
    "tcsh",
    "dash",
    "scsh"
  ], h = t.SHEBANG({
    binary: `(${f.join("|")})`,
    relevance: 10
  }), m = {
    className: "function",
    begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/,
    returnBegin: !0,
    contains: [t.inherit(t.TITLE_MODE, { begin: /\w[\w\d_]*/ })],
    relevance: 0
  }, p = [
    "if",
    "then",
    "else",
    "elif",
    "fi",
    "time",
    "for",
    "while",
    "until",
    "in",
    "do",
    "done",
    "case",
    "esac",
    "coproc",
    "function",
    "select"
  ], g = [
    "true",
    "false"
  ], b = { match: /(\/[a-z._-]+)+/ }, v = [
    "break",
    "cd",
    "continue",
    "eval",
    "exec",
    "exit",
    "export",
    "getopts",
    "hash",
    "pwd",
    "readonly",
    "return",
    "shift",
    "test",
    "times",
    "trap",
    "umask",
    "unset"
  ], k = [
    "alias",
    "bind",
    "builtin",
    "caller",
    "command",
    "declare",
    "echo",
    "enable",
    "help",
    "let",
    "local",
    "logout",
    "mapfile",
    "printf",
    "read",
    "readarray",
    "source",
    "sudo",
    "type",
    "typeset",
    "ulimit",
    "unalias"
  ], x = [
    "autoload",
    "bg",
    "bindkey",
    "bye",
    "cap",
    "chdir",
    "clone",
    "comparguments",
    "compcall",
    "compctl",
    "compdescribe",
    "compfiles",
    "compgroups",
    "compquote",
    "comptags",
    "comptry",
    "compvalues",
    "dirs",
    "disable",
    "disown",
    "echotc",
    "echoti",
    "emulate",
    "fc",
    "fg",
    "float",
    "functions",
    "getcap",
    "getln",
    "history",
    "integer",
    "jobs",
    "kill",
    "limit",
    "log",
    "noglob",
    "popd",
    "print",
    "pushd",
    "pushln",
    "rehash",
    "sched",
    "setcap",
    "setopt",
    "stat",
    "suspend",
    "ttyctl",
    "unfunction",
    "unhash",
    "unlimit",
    "unsetopt",
    "vared",
    "wait",
    "whence",
    "where",
    "which",
    "zcompile",
    "zformat",
    "zftp",
    "zle",
    "zmodload",
    "zparseopts",
    "zprof",
    "zpty",
    "zregexparse",
    "zsocket",
    "zstyle",
    "ztcp"
  ], w = [
    "chcon",
    "chgrp",
    "chown",
    "chmod",
    "cp",
    "dd",
    "df",
    "dir",
    "dircolors",
    "ln",
    "ls",
    "mkdir",
    "mkfifo",
    "mknod",
    "mktemp",
    "mv",
    "realpath",
    "rm",
    "rmdir",
    "shred",
    "sync",
    "touch",
    "truncate",
    "vdir",
    "b2sum",
    "base32",
    "base64",
    "cat",
    "cksum",
    "comm",
    "csplit",
    "cut",
    "expand",
    "fmt",
    "fold",
    "head",
    "join",
    "md5sum",
    "nl",
    "numfmt",
    "od",
    "paste",
    "ptx",
    "pr",
    "sha1sum",
    "sha224sum",
    "sha256sum",
    "sha384sum",
    "sha512sum",
    "shuf",
    "sort",
    "split",
    "sum",
    "tac",
    "tail",
    "tr",
    "tsort",
    "unexpand",
    "uniq",
    "wc",
    "arch",
    "basename",
    "chroot",
    "date",
    "dirname",
    "du",
    "echo",
    "env",
    "expr",
    "factor",
    // "false", // keyword literal already
    "groups",
    "hostid",
    "id",
    "link",
    "logname",
    "nice",
    "nohup",
    "nproc",
    "pathchk",
    "pinky",
    "printenv",
    "printf",
    "pwd",
    "readlink",
    "runcon",
    "seq",
    "sleep",
    "stat",
    "stdbuf",
    "stty",
    "tee",
    "test",
    "timeout",
    // "true", // keyword literal already
    "tty",
    "uname",
    "unlink",
    "uptime",
    "users",
    "who",
    "whoami",
    "yes"
  ];
  return {
    name: "Bash",
    aliases: [
      "sh",
      "zsh"
    ],
    keywords: {
      $pattern: /\b[a-z][a-z0-9._-]+\b/,
      keyword: p,
      literal: g,
      built_in: [
        ...v,
        ...k,
        // Shell modifiers
        "set",
        "shopt",
        ...x,
        ...w
      ]
    },
    contains: [
      h,
      // to catch known shells and boost relevancy
      t.SHEBANG(),
      // to catch unknown shells but still highlight the shebang
      m,
      d,
      i,
      s,
      b,
      a,
      l,
      c,
      u,
      n
    ]
  };
}
function DO(t) {
  const e = t.regex, n = t.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", o = "[a-zA-Z_]\\w*::", s = "(" + r + "|" + e.optional(o) + "[a-zA-Z_]\\w*" + e.optional("<[^<>]+>") + ")", a = {
    className: "type",
    variants: [
      { begin: "\\b[a-z\\d_]*_t\\b" },
      { match: /\batomic_[a-z]{3,6}\b/ }
    ]
  }, c = {
    className: "string",
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: "\\n",
        contains: [t.BACKSLASH_ESCAPE]
      },
      {
        begin: "(u8?|U|L)?'(" + "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)" + "|.)",
        end: "'",
        illegal: "."
      },
      t.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  }, u = {
    className: "number",
    variants: [
      { match: /\b(0b[01']+)/ },
      { match: /(-?)\b([\d']+(\.[\d']*)?|\.[\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)/ },
      { match: /(-?)\b(0[xX][a-fA-F0-9]+(?:'[a-fA-F0-9]+)*(?:\.[a-fA-F0-9]*(?:'[a-fA-F0-9]*)*)?(?:[pP][-+]?[0-9]+)?(l|L)?(u|U)?)/ },
      { match: /(-?)\b\d+(?:'\d+)*(?:\.\d*(?:'\d*)*)?(?:[eE][-+]?\d+)?/ }
    ],
    relevance: 0
  }, d = {
    className: "meta",
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef elifdef elifndef include" },
    contains: [
      {
        begin: /\\\n/,
        relevance: 0
      },
      t.inherit(c, { className: "string" }),
      {
        className: "string",
        begin: /<.*?>/
      },
      n,
      t.C_BLOCK_COMMENT_MODE
    ]
  }, f = {
    className: "title",
    begin: e.optional(o) + t.IDENT_RE,
    relevance: 0
  }, h = e.optional(o) + t.IDENT_RE + "\\s*\\(", g = {
    keyword: [
      "asm",
      "auto",
      "break",
      "case",
      "continue",
      "default",
      "do",
      "else",
      "enum",
      "extern",
      "for",
      "fortran",
      "goto",
      "if",
      "inline",
      "register",
      "restrict",
      "return",
      "sizeof",
      "typeof",
      "typeof_unqual",
      "struct",
      "switch",
      "typedef",
      "union",
      "volatile",
      "while",
      "_Alignas",
      "_Alignof",
      "_Atomic",
      "_Generic",
      "_Noreturn",
      "_Static_assert",
      "_Thread_local",
      // aliases
      "alignas",
      "alignof",
      "noreturn",
      "static_assert",
      "thread_local",
      // not a C keyword but is, for all intents and purposes, treated exactly like one.
      "_Pragma"
    ],
    type: [
      "float",
      "double",
      "signed",
      "unsigned",
      "int",
      "short",
      "long",
      "char",
      "void",
      "_Bool",
      "_BitInt",
      "_Complex",
      "_Imaginary",
      "_Decimal32",
      "_Decimal64",
      "_Decimal96",
      "_Decimal128",
      "_Decimal64x",
      "_Decimal128x",
      "_Float16",
      "_Float32",
      "_Float64",
      "_Float128",
      "_Float32x",
      "_Float64x",
      "_Float128x",
      // modifiers
      "const",
      "static",
      "constexpr",
      // aliases
      "complex",
      "bool",
      "imaginary"
    ],
    literal: "true false NULL",
    // TODO: apply hinting work similar to what was done in cpp.js
    built_in: "std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr"
  }, b = [
    d,
    a,
    n,
    t.C_BLOCK_COMMENT_MODE,
    u,
    c
  ], v = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [
      {
        begin: /=/,
        end: /;/
      },
      {
        begin: /\(/,
        end: /\)/
      },
      {
        beginKeywords: "new throw return else",
        end: /;/
      }
    ],
    keywords: g,
    contains: b.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: g,
        contains: b.concat(["self"]),
        relevance: 0
      }
    ]),
    relevance: 0
  }, k = {
    begin: "(" + s + "[\\*&\\s]+)+" + h,
    returnBegin: !0,
    end: /[{;=]/,
    excludeEnd: !0,
    keywords: g,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      {
        // to prevent it from being confused as the function title
        begin: r,
        keywords: g,
        relevance: 0
      },
      {
        begin: h,
        returnBegin: !0,
        contains: [t.inherit(f, { className: "title.function" })],
        relevance: 0
      },
      // allow for multiple declarations, e.g.:
      // extern void f(int), g(char);
      {
        relevance: 0,
        match: /,/
      },
      {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: g,
        relevance: 0,
        contains: [
          n,
          t.C_BLOCK_COMMENT_MODE,
          c,
          u,
          a,
          // Count matching parentheses.
          {
            begin: /\(/,
            end: /\)/,
            keywords: g,
            relevance: 0,
            contains: [
              "self",
              n,
              t.C_BLOCK_COMMENT_MODE,
              c,
              u,
              a
            ]
          }
        ]
      },
      a,
      n,
      t.C_BLOCK_COMMENT_MODE,
      d
    ]
  };
  return {
    name: "C",
    aliases: ["h"],
    keywords: g,
    // Until differentiations are added between `c` and `cpp`, `c` will
    // not be auto-detected to avoid auto-detect conflicts between C and C++
    disableAutodetect: !0,
    illegal: "</",
    contains: [].concat(
      v,
      k,
      b,
      [
        d,
        {
          begin: t.IDENT_RE + "::",
          keywords: g
        },
        {
          className: "class",
          beginKeywords: "enum class struct union",
          end: /[{;:<>=]/,
          contains: [
            { beginKeywords: "final class struct" },
            t.TITLE_MODE
          ]
        }
      ]
    ),
    exports: {
      preprocessor: d,
      strings: c,
      keywords: g
    }
  };
}
function LO(t) {
  const e = t.regex, n = t.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", o = "[a-zA-Z_]\\w*::", s = "(?!struct)(" + r + "|" + e.optional(o) + "[a-zA-Z_]\\w*" + e.optional("<[^<>]+>") + ")", a = {
    className: "type",
    begin: "\\b[a-z\\d_]*_t\\b"
  }, c = {
    className: "string",
    variants: [
      {
        begin: '(u8?|U|L)?"',
        end: '"',
        illegal: "\\n",
        contains: [t.BACKSLASH_ESCAPE]
      },
      {
        begin: "(u8?|U|L)?'(" + "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)" + "|.)",
        end: "'",
        illegal: "."
      },
      t.END_SAME_AS_BEGIN({
        begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,
        end: /\)([^()\\ ]{0,16})"/
      })
    ]
  }, u = {
    className: "number",
    variants: [
      // Floating-point literal.
      {
        begin: "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)"
      },
      // Integer literal.
      {
        begin: "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)"
        // Note: there are user-defined literal suffixes too, but perhaps having the custom suffix not part of the
        // literal highlight actually makes it stand out more.
      }
    ],
    relevance: 0
  }, d = {
    className: "meta",
    begin: /#\s*[a-z]+\b/,
    end: /$/,
    keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" },
    contains: [
      {
        begin: /\\\n/,
        relevance: 0
      },
      t.inherit(c, { className: "string" }),
      {
        className: "string",
        begin: /<.*?>/
      },
      n,
      t.C_BLOCK_COMMENT_MODE
    ]
  }, f = {
    className: "title",
    begin: e.optional(o) + t.IDENT_RE,
    relevance: 0
  }, h = e.optional(o) + t.IDENT_RE + "\\s*\\(", m = [
    "alignas",
    "alignof",
    "and",
    "and_eq",
    "asm",
    "atomic_cancel",
    "atomic_commit",
    "atomic_noexcept",
    "auto",
    "bitand",
    "bitor",
    "break",
    "case",
    "catch",
    "class",
    "co_await",
    "co_return",
    "co_yield",
    "compl",
    "concept",
    "const_cast|10",
    "consteval",
    "constexpr",
    "constinit",
    "continue",
    "decltype",
    "default",
    "delete",
    "do",
    "dynamic_cast|10",
    "else",
    "enum",
    "explicit",
    "export",
    "extern",
    "false",
    "final",
    "for",
    "friend",
    "goto",
    "if",
    "import",
    "inline",
    "module",
    "mutable",
    "namespace",
    "new",
    "noexcept",
    "not",
    "not_eq",
    "nullptr",
    "operator",
    "or",
    "or_eq",
    "override",
    "private",
    "protected",
    "public",
    "reflexpr",
    "register",
    "reinterpret_cast|10",
    "requires",
    "return",
    "sizeof",
    "static_assert",
    "static_cast|10",
    "struct",
    "switch",
    "synchronized",
    "template",
    "this",
    "thread_local",
    "throw",
    "transaction_safe",
    "transaction_safe_dynamic",
    "true",
    "try",
    "typedef",
    "typeid",
    "typename",
    "union",
    "using",
    "virtual",
    "volatile",
    "while",
    "xor",
    "xor_eq"
  ], p = [
    "bool",
    "char",
    "char16_t",
    "char32_t",
    "char8_t",
    "double",
    "float",
    "int",
    "long",
    "short",
    "void",
    "wchar_t",
    "unsigned",
    "signed",
    "const",
    "static"
  ], g = [
    "any",
    "auto_ptr",
    "barrier",
    "binary_semaphore",
    "bitset",
    "complex",
    "condition_variable",
    "condition_variable_any",
    "counting_semaphore",
    "deque",
    "false_type",
    "flat_map",
    "flat_set",
    "future",
    "imaginary",
    "initializer_list",
    "istringstream",
    "jthread",
    "latch",
    "lock_guard",
    "multimap",
    "multiset",
    "mutex",
    "optional",
    "ostringstream",
    "packaged_task",
    "pair",
    "promise",
    "priority_queue",
    "queue",
    "recursive_mutex",
    "recursive_timed_mutex",
    "scoped_lock",
    "set",
    "shared_future",
    "shared_lock",
    "shared_mutex",
    "shared_timed_mutex",
    "shared_ptr",
    "stack",
    "string_view",
    "stringstream",
    "timed_mutex",
    "thread",
    "true_type",
    "tuple",
    "unique_lock",
    "unique_ptr",
    "unordered_map",
    "unordered_multimap",
    "unordered_multiset",
    "unordered_set",
    "variant",
    "vector",
    "weak_ptr",
    "wstring",
    "wstring_view"
  ], b = [
    "abort",
    "abs",
    "acos",
    "apply",
    "as_const",
    "asin",
    "atan",
    "atan2",
    "calloc",
    "ceil",
    "cerr",
    "cin",
    "clog",
    "cos",
    "cosh",
    "cout",
    "declval",
    "endl",
    "exchange",
    "exit",
    "exp",
    "fabs",
    "floor",
    "fmod",
    "forward",
    "fprintf",
    "fputs",
    "free",
    "frexp",
    "fscanf",
    "future",
    "invoke",
    "isalnum",
    "isalpha",
    "iscntrl",
    "isdigit",
    "isgraph",
    "islower",
    "isprint",
    "ispunct",
    "isspace",
    "isupper",
    "isxdigit",
    "labs",
    "launder",
    "ldexp",
    "log",
    "log10",
    "make_pair",
    "make_shared",
    "make_shared_for_overwrite",
    "make_tuple",
    "make_unique",
    "malloc",
    "memchr",
    "memcmp",
    "memcpy",
    "memset",
    "modf",
    "move",
    "pow",
    "printf",
    "putchar",
    "puts",
    "realloc",
    "scanf",
    "sin",
    "sinh",
    "snprintf",
    "sprintf",
    "sqrt",
    "sscanf",
    "std",
    "stderr",
    "stdin",
    "stdout",
    "strcat",
    "strchr",
    "strcmp",
    "strcpy",
    "strcspn",
    "strlen",
    "strncat",
    "strncmp",
    "strncpy",
    "strpbrk",
    "strrchr",
    "strspn",
    "strstr",
    "swap",
    "tan",
    "tanh",
    "terminate",
    "to_underlying",
    "tolower",
    "toupper",
    "vfprintf",
    "visit",
    "vprintf",
    "vsprintf"
  ], x = {
    type: p,
    keyword: m,
    literal: [
      "NULL",
      "false",
      "nullopt",
      "nullptr",
      "true"
    ],
    built_in: ["_Pragma"],
    _type_hints: g
  }, w = {
    className: "function.dispatch",
    relevance: 0,
    keywords: {
      // Only for relevance, not highlighting.
      _hint: b
    },
    begin: e.concat(
      /\b/,
      /(?!decltype)/,
      /(?!if)/,
      /(?!for)/,
      /(?!switch)/,
      /(?!while)/,
      t.IDENT_RE,
      e.lookahead(/(<[^<>]+>|)\s*\(/)
    )
  }, E = [
    w,
    d,
    a,
    n,
    t.C_BLOCK_COMMENT_MODE,
    u,
    c
  ], S = {
    // This mode covers expression context where we can't expect a function
    // definition and shouldn't highlight anything that looks like one:
    // `return some()`, `else if()`, `(x*sum(1, 2))`
    variants: [
      {
        begin: /=/,
        end: /;/
      },
      {
        begin: /\(/,
        end: /\)/
      },
      {
        beginKeywords: "new throw return else",
        end: /;/
      }
    ],
    keywords: x,
    contains: E.concat([
      {
        begin: /\(/,
        end: /\)/,
        keywords: x,
        contains: E.concat(["self"]),
        relevance: 0
      }
    ]),
    relevance: 0
  }, C = {
    className: "function",
    begin: "(" + s + "[\\*&\\s]+)+" + h,
    returnBegin: !0,
    end: /[{;=]/,
    excludeEnd: !0,
    keywords: x,
    illegal: /[^\w\s\*&:<>.]/,
    contains: [
      {
        // to prevent it from being confused as the function title
        begin: r,
        keywords: x,
        relevance: 0
      },
      {
        begin: h,
        returnBegin: !0,
        contains: [f],
        relevance: 0
      },
      // needed because we do not have look-behind on the below rule
      // to prevent it from grabbing the final : in a :: pair
      {
        begin: /::/,
        relevance: 0
      },
      // initializers
      {
        begin: /:/,
        endsWithParent: !0,
        contains: [
          c,
          u
        ]
      },
      // allow for multiple declarations, e.g.:
      // extern void f(int), g(char);
      {
        relevance: 0,
        match: /,/
      },
      {
        className: "params",
        begin: /\(/,
        end: /\)/,
        keywords: x,
        relevance: 0,
        contains: [
          n,
          t.C_BLOCK_COMMENT_MODE,
          c,
          u,
          a,
          // Count matching parentheses.
          {
            begin: /\(/,
            end: /\)/,
            keywords: x,
            relevance: 0,
            contains: [
              "self",
              n,
              t.C_BLOCK_COMMENT_MODE,
              c,
              u,
              a
            ]
          }
        ]
      },
      a,
      n,
      t.C_BLOCK_COMMENT_MODE,
      d
    ]
  };
  return {
    name: "C++",
    aliases: [
      "cc",
      "c++",
      "h++",
      "hpp",
      "hh",
      "hxx",
      "cxx"
    ],
    keywords: x,
    illegal: "</",
    classNameAliases: { "function.dispatch": "built_in" },
    contains: [].concat(
      S,
      C,
      w,
      E,
      [
        d,
        {
          // containers: ie, `vector <int> rooms (9);`
          begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)",
          end: ">",
          keywords: x,
          contains: [
            "self",
            a
          ]
        },
        {
          begin: t.IDENT_RE + "::",
          keywords: x
        },
        {
          match: [
            // extra complexity to deal with `enum class` and `enum struct`
            /\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/,
            /\s+/,
            /\w+/
          ],
          className: {
            1: "keyword",
            3: "title.class"
          }
        }
      ]
    )
  };
}
function PO(t) {
  const e = [
    "bool",
    "byte",
    "char",
    "decimal",
    "delegate",
    "double",
    "dynamic",
    "enum",
    "float",
    "int",
    "long",
    "nint",
    "nuint",
    "object",
    "sbyte",
    "short",
    "string",
    "ulong",
    "uint",
    "ushort"
  ], n = [
    "public",
    "private",
    "protected",
    "static",
    "internal",
    "protected",
    "abstract",
    "async",
    "extern",
    "override",
    "unsafe",
    "virtual",
    "new",
    "sealed",
    "partial"
  ], r = [
    "default",
    "false",
    "null",
    "true"
  ], o = [
    "abstract",
    "as",
    "base",
    "break",
    "case",
    "catch",
    "class",
    "const",
    "continue",
    "do",
    "else",
    "event",
    "explicit",
    "extern",
    "finally",
    "fixed",
    "for",
    "foreach",
    "goto",
    "if",
    "implicit",
    "in",
    "interface",
    "internal",
    "is",
    "lock",
    "namespace",
    "new",
    "operator",
    "out",
    "override",
    "params",
    "private",
    "protected",
    "public",
    "readonly",
    "record",
    "ref",
    "return",
    "scoped",
    "sealed",
    "sizeof",
    "stackalloc",
    "static",
    "struct",
    "switch",
    "this",
    "throw",
    "try",
    "typeof",
    "unchecked",
    "unsafe",
    "using",
    "virtual",
    "void",
    "volatile",
    "while"
  ], i = [
    "add",
    "alias",
    "and",
    "ascending",
    "args",
    "async",
    "await",
    "by",
    "descending",
    "dynamic",
    "equals",
    "file",
    "from",
    "get",
    "global",
    "group",
    "init",
    "into",
    "join",
    "let",
    "nameof",
    "not",
    "notnull",
    "on",
    "or",
    "orderby",
    "partial",
    "record",
    "remove",
    "required",
    "scoped",
    "select",
    "set",
    "unmanaged",
    "value|0",
    "var",
    "when",
    "where",
    "with",
    "yield"
  ], s = {
    keyword: o.concat(i),
    built_in: e,
    literal: r
  }, a = t.inherit(t.TITLE_MODE, { begin: "[a-zA-Z](\\.?\\w)*" }), l = {
    className: "number",
    variants: [
      { begin: "\\b(0b[01']+)" },
      { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)" },
      { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }
    ],
    relevance: 0
  }, c = {
    className: "string",
    begin: /"""("*)(?!")(.|\n)*?"""\1/,
    relevance: 1
  }, u = {
    className: "string",
    begin: '@"',
    end: '"',
    contains: [{ begin: '""' }]
  }, d = t.inherit(u, { illegal: /\n/ }), f = {
    className: "subst",
    begin: /\{/,
    end: /\}/,
    keywords: s
  }, h = t.inherit(f, { illegal: /\n/ }), m = {
    className: "string",
    begin: /\$"/,
    end: '"',
    illegal: /\n/,
    contains: [
      { begin: /\{\{/ },
      { begin: /\}\}/ },
      t.BACKSLASH_ESCAPE,
      h
    ]
  }, p = {
    className: "string",
    begin: /\$@"/,
    end: '"',
    contains: [
      { begin: /\{\{/ },
      { begin: /\}\}/ },
      { begin: '""' },
      f
    ]
  }, g = t.inherit(p, {
    illegal: /\n/,
    contains: [
      { begin: /\{\{/ },
      { begin: /\}\}/ },
      { begin: '""' },
      h
    ]
  });
  f.contains = [
    p,
    m,
    u,
    t.APOS_STRING_MODE,
    t.QUOTE_STRING_MODE,
    l,
    t.C_BLOCK_COMMENT_MODE
  ], h.contains = [
    g,
    m,
    d,
    t.APOS_STRING_MODE,
    t.QUOTE_STRING_MODE,
    l,
    t.inherit(t.C_BLOCK_COMMENT_MODE, { illegal: /\n/ })
  ];
  const b = { variants: [
    c,
    p,
    m,
    u,
    t.APOS_STRING_MODE,
    t.QUOTE_STRING_MODE
  ] }, v = {
    begin: "<",
    end: ">",
    contains: [
      { beginKeywords: "in out" },
      a
    ]
  }, k = t.IDENT_RE + "(<" + t.IDENT_RE + "(\\s*,\\s*" + t.IDENT_RE + ")*>)?(\\[\\])?", x = {
    // prevents expressions like `@class` from incorrect flagging
    // `class` as a keyword
    begin: "@" + t.IDENT_RE,
    relevance: 0
  };
  return {
    name: "C#",
    aliases: [
      "cs",
      "c#"
    ],
    keywords: s,
    illegal: /::/,
    contains: [
      t.COMMENT(
        "///",
        "$",
        {
          returnBegin: !0,
          contains: [
            {
              className: "doctag",
              variants: [
                {
                  begin: "///",
                  relevance: 0
                },
                { begin: "<!--|-->" },
                {
                  begin: "</?",
                  end: ">"
                }
              ]
            }
          ]
        }
      ),
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      {
        className: "meta",
        begin: "#",
        end: "$",
        keywords: { keyword: "if else elif endif define undef warning error line region endregion pragma checksum" }
      },
      b,
      l,
      {
        beginKeywords: "class interface",
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:,]/,
        contains: [
          { beginKeywords: "where class" },
          a,
          v,
          t.C_LINE_COMMENT_MODE,
          t.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        beginKeywords: "namespace",
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:]/,
        contains: [
          a,
          t.C_LINE_COMMENT_MODE,
          t.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        beginKeywords: "record",
        relevance: 0,
        end: /[{;=]/,
        illegal: /[^\s:]/,
        contains: [
          a,
          v,
          t.C_LINE_COMMENT_MODE,
          t.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        // [Attributes("")]
        className: "meta",
        begin: "^\\s*\\[(?=[\\w])",
        excludeBegin: !0,
        end: "\\]",
        excludeEnd: !0,
        contains: [
          {
            className: "string",
            begin: /"/,
            end: /"/
          }
        ]
      },
      {
        // Expression keywords prevent 'keyword Name(...)' from being
        // recognized as a function definition
        beginKeywords: "new return throw await else",
        relevance: 0
      },
      {
        className: "function",
        begin: "(" + k + "\\s+)+" + t.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
        returnBegin: !0,
        end: /\s*[{;=]/,
        excludeEnd: !0,
        keywords: s,
        contains: [
          // prevents these from being highlighted `title`
          {
            beginKeywords: n.join(" "),
            relevance: 0
          },
          {
            begin: t.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(",
            returnBegin: !0,
            contains: [
              t.TITLE_MODE,
              v
            ],
            relevance: 0
          },
          { match: /\(\)/ },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            excludeBegin: !0,
            excludeEnd: !0,
            keywords: s,
            relevance: 0,
            contains: [
              b,
              l,
              t.C_BLOCK_COMMENT_MODE
            ]
          },
          t.C_LINE_COMMENT_MODE,
          t.C_BLOCK_COMMENT_MODE
        ]
      },
      x
    ]
  };
}
const BO = (t) => ({
  IMPORTANT: {
    scope: "meta",
    begin: "!important"
  },
  BLOCK_COMMENT: t.C_BLOCK_COMMENT_MODE,
  HEXCOLOR: {
    scope: "number",
    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
  },
  FUNCTION_DISPATCH: {
    className: "built_in",
    begin: /[\w-]+(?=\()/
  },
  ATTRIBUTE_SELECTOR_MODE: {
    scope: "selector-attr",
    begin: /\[/,
    end: /\]/,
    illegal: "$",
    contains: [
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE
    ]
  },
  CSS_NUMBER_MODE: {
    scope: "number",
    begin: t.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
    relevance: 0
  },
  CSS_VARIABLE: {
    className: "attr",
    begin: /--[A-Za-z_][A-Za-z0-9_-]*/
  }
}), zO = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "optgroup",
  "option",
  "p",
  "picture",
  "q",
  "quote",
  "samp",
  "section",
  "select",
  "source",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
], $O = [
  "defs",
  "g",
  "marker",
  "mask",
  "pattern",
  "svg",
  "switch",
  "symbol",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feFlood",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMorphology",
  "feOffset",
  "feSpecularLighting",
  "feTile",
  "feTurbulence",
  "linearGradient",
  "radialGradient",
  "stop",
  "circle",
  "ellipse",
  "image",
  "line",
  "path",
  "polygon",
  "polyline",
  "rect",
  "text",
  "use",
  "textPath",
  "tspan",
  "foreignObject",
  "clipPath"
], HO = [
  ...zO,
  ...$O
], FO = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
].sort().reverse(), UO = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
].sort().reverse(), WO = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
].sort().reverse(), VO = [
  "accent-color",
  "align-content",
  "align-items",
  "align-self",
  "alignment-baseline",
  "all",
  "anchor-name",
  "animation",
  "animation-composition",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-range",
  "animation-range-end",
  "animation-range-start",
  "animation-timeline",
  "animation-timing-function",
  "appearance",
  "aspect-ratio",
  "backdrop-filter",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-position-x",
  "background-position-y",
  "background-repeat",
  "background-size",
  "baseline-shift",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-end-end-radius",
  "border-end-start-radius",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-start-end-radius",
  "border-start-start-radius",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-align",
  "box-decoration-break",
  "box-direction",
  "box-flex",
  "box-flex-group",
  "box-lines",
  "box-ordinal-group",
  "box-orient",
  "box-pack",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "color-scheme",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "contain-intrinsic-block-size",
  "contain-intrinsic-height",
  "contain-intrinsic-inline-size",
  "contain-intrinsic-size",
  "contain-intrinsic-width",
  "container",
  "container-name",
  "container-type",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "counter-set",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "cx",
  "cy",
  "direction",
  "display",
  "dominant-baseline",
  "empty-cells",
  "enable-background",
  "field-sizing",
  "fill",
  "fill-opacity",
  "fill-rule",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flood-color",
  "flood-opacity",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-optical-sizing",
  "font-palette",
  "font-size",
  "font-size-adjust",
  "font-smooth",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-synthesis-position",
  "font-synthesis-small-caps",
  "font-synthesis-style",
  "font-synthesis-weight",
  "font-variant",
  "font-variant-alternates",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-emoji",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "forced-color-adjust",
  "gap",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphenate-character",
  "hyphenate-limit-chars",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "initial-letter",
  "initial-letter-align",
  "inline-size",
  "inset",
  "inset-area",
  "inset-block",
  "inset-block-end",
  "inset-block-start",
  "inset-inline",
  "inset-inline-end",
  "inset-inline-start",
  "isolation",
  "justify-content",
  "justify-items",
  "justify-self",
  "kerning",
  "left",
  "letter-spacing",
  "lighting-color",
  "line-break",
  "line-height",
  "line-height-step",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "margin-trim",
  "marker",
  "marker-end",
  "marker-mid",
  "marker-start",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "masonry-auto-flow",
  "math-depth",
  "math-shift",
  "math-style",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "offset",
  "offset-anchor",
  "offset-distance",
  "offset-path",
  "offset-position",
  "offset-rotate",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-anchor",
  "overflow-block",
  "overflow-clip-margin",
  "overflow-inline",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "overlay",
  "overscroll-behavior",
  "overscroll-behavior-block",
  "overscroll-behavior-inline",
  "overscroll-behavior-x",
  "overscroll-behavior-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "paint-order",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "place-content",
  "place-items",
  "place-self",
  "pointer-events",
  "position",
  "position-anchor",
  "position-visibility",
  "print-color-adjust",
  "quotes",
  "r",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "rotate",
  "row-gap",
  "ruby-align",
  "ruby-position",
  "scale",
  "scroll-behavior",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scroll-timeline",
  "scroll-timeline-axis",
  "scroll-timeline-name",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "shape-rendering",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "stop-color",
  "stop-opacity",
  "stroke",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-anchor",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-skip",
  "text-decoration-skip-ink",
  "text-decoration-style",
  "text-decoration-thickness",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-size-adjust",
  "text-transform",
  "text-underline-offset",
  "text-underline-position",
  "text-wrap",
  "text-wrap-mode",
  "text-wrap-style",
  "timeline-scope",
  "top",
  "touch-action",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-behavior",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "translate",
  "unicode-bidi",
  "user-modify",
  "user-select",
  "vector-effect",
  "vertical-align",
  "view-timeline",
  "view-timeline-axis",
  "view-timeline-inset",
  "view-timeline-name",
  "view-transition-name",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "white-space-collapse",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "x",
  "y",
  "z-index",
  "zoom"
].sort().reverse();
function KO(t) {
  const e = t.regex, n = BO(t), r = { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ }, o = "and or not only", i = /@-?\w[\w]*(-\w+)*/, s = "[a-zA-Z-][a-zA-Z0-9_-]*", a = [
    t.APOS_STRING_MODE,
    t.QUOTE_STRING_MODE
  ];
  return {
    name: "CSS",
    case_insensitive: !0,
    illegal: /[=|'\$]/,
    keywords: { keyframePosition: "from to" },
    classNameAliases: {
      // for visual continuity with `tag {}` and because we
      // don't have a great class for this?
      keyframePosition: "selector-tag"
    },
    contains: [
      n.BLOCK_COMMENT,
      r,
      // to recognize keyframe 40% etc which are outside the scope of our
      // attribute value mode
      n.CSS_NUMBER_MODE,
      {
        className: "selector-id",
        begin: /#[A-Za-z0-9_-]+/,
        relevance: 0
      },
      {
        className: "selector-class",
        begin: "\\." + s,
        relevance: 0
      },
      n.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-pseudo",
        variants: [
          { begin: ":(" + UO.join("|") + ")" },
          { begin: ":(:)?(" + WO.join("|") + ")" }
        ]
      },
      // we may actually need this (12/2020)
      // { // pseudo-selector params
      //   begin: /\(/,
      //   end: /\)/,
      //   contains: [ hljs.CSS_NUMBER_MODE ]
      // },
      n.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + VO.join("|") + ")\\b"
      },
      // attribute values
      {
        begin: /:/,
        end: /[;}{]/,
        contains: [
          n.BLOCK_COMMENT,
          n.HEXCOLOR,
          n.IMPORTANT,
          n.CSS_NUMBER_MODE,
          ...a,
          // needed to highlight these as strings and to avoid issues with
          // illegal characters that might be inside urls that would tigger the
          // languages illegal stack
          {
            begin: /(url|data-uri)\(/,
            end: /\)/,
            relevance: 0,
            // from keywords
            keywords: { built_in: "url data-uri" },
            contains: [
              ...a,
              {
                className: "string",
                // any character other than `)` as in `url()` will be the start
                // of a string, which ends with `)` (from the parent mode)
                begin: /[^)]/,
                endsWithParent: !0,
                excludeEnd: !0
              }
            ]
          },
          n.FUNCTION_DISPATCH
        ]
      },
      {
        begin: e.lookahead(/@/),
        end: "[{;]",
        relevance: 0,
        illegal: /:/,
        // break on Less variables @var: ...
        contains: [
          {
            className: "keyword",
            begin: i
          },
          {
            begin: /\s/,
            endsWithParent: !0,
            excludeEnd: !0,
            relevance: 0,
            keywords: {
              $pattern: /[a-z-]+/,
              keyword: o,
              attribute: FO.join(" ")
            },
            contains: [
              {
                begin: /[a-z-]+(?=:)/,
                className: "attribute"
              },
              ...a,
              n.CSS_NUMBER_MODE
            ]
          }
        ]
      },
      {
        className: "selector-tag",
        begin: "\\b(" + HO.join("|") + ")\\b"
      }
    ]
  };
}
function qO(t) {
  const e = t.regex;
  return {
    name: "Diff",
    aliases: ["patch"],
    contains: [
      {
        className: "meta",
        relevance: 10,
        match: e.either(
          /^@@ +-\d+,\d+ +\+\d+,\d+ +@@/,
          /^\*\*\* +\d+,\d+ +\*\*\*\*$/,
          /^--- +\d+,\d+ +----$/
        )
      },
      {
        className: "comment",
        variants: [
          {
            begin: e.either(
              /Index: /,
              /^index/,
              /={3,}/,
              /^-{3}/,
              /^\*{3} /,
              /^\+{3}/,
              /^diff --git/
            ),
            end: /$/
          },
          { match: /^\*{15}$/ }
        ]
      },
      {
        className: "addition",
        begin: /^\+/,
        end: /$/
      },
      {
        className: "deletion",
        begin: /^-/,
        end: /$/
      },
      {
        className: "addition",
        begin: /^!/,
        end: /$/
      }
    ]
  };
}
function GO(t) {
  const i = {
    keyword: [
      "break",
      "case",
      "chan",
      "const",
      "continue",
      "default",
      "defer",
      "else",
      "fallthrough",
      "for",
      "func",
      "go",
      "goto",
      "if",
      "import",
      "interface",
      "map",
      "package",
      "range",
      "return",
      "select",
      "struct",
      "switch",
      "type",
      "var"
    ],
    type: [
      "bool",
      "byte",
      "complex64",
      "complex128",
      "error",
      "float32",
      "float64",
      "int8",
      "int16",
      "int32",
      "int64",
      "string",
      "uint8",
      "uint16",
      "uint32",
      "uint64",
      "int",
      "uint",
      "uintptr",
      "rune"
    ],
    literal: [
      "true",
      "false",
      "iota",
      "nil"
    ],
    built_in: [
      "append",
      "cap",
      "close",
      "complex",
      "copy",
      "imag",
      "len",
      "make",
      "new",
      "panic",
      "print",
      "println",
      "real",
      "recover",
      "delete"
    ]
  };
  return {
    name: "Go",
    aliases: ["golang"],
    keywords: i,
    illegal: "</",
    contains: [
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      {
        className: "string",
        variants: [
          t.QUOTE_STRING_MODE,
          t.APOS_STRING_MODE,
          {
            begin: "`",
            end: "`"
          }
        ]
      },
      {
        className: "number",
        variants: [
          {
            match: /-?\b0[xX]\.[a-fA-F0-9](_?[a-fA-F0-9])*[pP][+-]?\d(_?\d)*i?/,
            // hex without a present digit before . (making a digit afterwards required)
            relevance: 0
          },
          {
            match: /-?\b0[xX](_?[a-fA-F0-9])+((\.([a-fA-F0-9](_?[a-fA-F0-9])*)?)?[pP][+-]?\d(_?\d)*)?i?/,
            // hex with a present digit before . (making a digit afterwards optional)
            relevance: 0
          },
          {
            match: /-?\b0[oO](_?[0-7])*i?/,
            // leading 0o octal
            relevance: 0
          },
          {
            match: /-?\.\d(_?\d)*([eE][+-]?\d(_?\d)*)?i?/,
            // decimal without a present digit before . (making a digit afterwards required)
            relevance: 0
          },
          {
            match: /-?\b\d(_?\d)*(\.(\d(_?\d)*)?)?([eE][+-]?\d(_?\d)*)?i?/,
            // decimal with a present digit before . (making a digit afterwards optional)
            relevance: 0
          }
        ]
      },
      {
        begin: /:=/
        // relevance booster
      },
      {
        className: "function",
        beginKeywords: "func",
        end: "\\s*(\\{|$)",
        excludeEnd: !0,
        contains: [
          t.TITLE_MODE,
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            endsParent: !0,
            keywords: i,
            illegal: /["']/
          }
        ]
      }
    ]
  };
}
function jO(t) {
  const e = t.regex, n = /[_A-Za-z][_0-9A-Za-z]*/;
  return {
    name: "GraphQL",
    aliases: ["gql"],
    case_insensitive: !0,
    disableAutodetect: !1,
    keywords: {
      keyword: [
        "query",
        "mutation",
        "subscription",
        "type",
        "input",
        "schema",
        "directive",
        "interface",
        "union",
        "scalar",
        "fragment",
        "enum",
        "on"
      ],
      literal: [
        "true",
        "false",
        "null"
      ]
    },
    contains: [
      t.HASH_COMMENT_MODE,
      t.QUOTE_STRING_MODE,
      t.NUMBER_MODE,
      {
        scope: "punctuation",
        match: /[.]{3}/,
        relevance: 0
      },
      {
        scope: "punctuation",
        begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/,
        relevance: 0
      },
      {
        scope: "variable",
        begin: /\$/,
        end: /\W/,
        excludeEnd: !0,
        relevance: 0
      },
      {
        scope: "meta",
        match: /@\w+/,
        excludeEnd: !0
      },
      {
        scope: "symbol",
        begin: e.concat(n, e.lookahead(/\s*:/)),
        relevance: 0
      }
    ],
    illegal: [
      /[;<']/,
      /BEGIN/
    ]
  };
}
function YO(t) {
  const e = t.regex, n = {
    className: "number",
    relevance: 0,
    variants: [
      { begin: /([+-]+)?[\d]+_[\d_]+/ },
      { begin: t.NUMBER_RE }
    ]
  }, r = t.COMMENT();
  r.variants = [
    {
      begin: /;/,
      end: /$/
    },
    {
      begin: /#/,
      end: /$/
    }
  ];
  const o = {
    className: "variable",
    variants: [
      { begin: /\$[\w\d"][\w\d_]*/ },
      { begin: /\$\{(.*?)\}/ }
    ]
  }, i = {
    className: "literal",
    begin: /\bon|off|true|false|yes|no\b/
  }, s = {
    className: "string",
    contains: [t.BACKSLASH_ESCAPE],
    variants: [
      {
        begin: "'''",
        end: "'''",
        relevance: 10
      },
      {
        begin: '"""',
        end: '"""',
        relevance: 10
      },
      {
        begin: '"',
        end: '"'
      },
      {
        begin: "'",
        end: "'"
      }
    ]
  }, a = {
    begin: /\[/,
    end: /\]/,
    contains: [
      r,
      i,
      o,
      s,
      n,
      "self"
    ],
    relevance: 0
  }, l = /[A-Za-z0-9_-]+/, c = /"(\\"|[^"])*"/, u = /'[^']*'/, d = e.either(
    l,
    c,
    u
  ), f = e.concat(
    d,
    "(\\s*\\.\\s*",
    d,
    ")*",
    e.lookahead(/\s*=\s*[^#\s]/)
  );
  return {
    name: "TOML, also INI",
    aliases: ["toml"],
    case_insensitive: !0,
    illegal: /\S/,
    contains: [
      r,
      {
        className: "section",
        begin: /\[+/,
        end: /\]+/
      },
      {
        begin: f,
        className: "attr",
        starts: {
          end: /$/,
          contains: [
            r,
            a,
            i,
            o,
            s,
            n
          ]
        }
      }
    ]
  };
}
var Bo = "[0-9](_*[0-9])*", ra = `\\.(${Bo})`, oa = "[0-9a-fA-F](_*[0-9a-fA-F])*", Qp = {
  className: "number",
  variants: [
    // DecimalFloatingPointLiteral
    // including ExponentPart
    { begin: `(\\b(${Bo})((${ra})|\\.)?|(${ra}))[eE][+-]?(${Bo})[fFdD]?\\b` },
    // excluding ExponentPart
    { begin: `\\b(${Bo})((${ra})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
    { begin: `(${ra})[fFdD]?\\b` },
    { begin: `\\b(${Bo})[fFdD]\\b` },
    // HexadecimalFloatingPointLiteral
    { begin: `\\b0[xX]((${oa})\\.?|(${oa})?\\.(${oa}))[pP][+-]?(${Bo})[fFdD]?\\b` },
    // DecimalIntegerLiteral
    { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
    // HexIntegerLiteral
    { begin: `\\b0[xX](${oa})[lL]?\\b` },
    // OctalIntegerLiteral
    { begin: "\\b0(_*[0-7])*[lL]?\\b" },
    // BinaryIntegerLiteral
    { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
  ],
  relevance: 0
};
function Rv(t, e, n) {
  return n === -1 ? "" : t.replace(e, (r) => Rv(t, e, n - 1));
}
function XO(t) {
  const e = t.regex, n = "[À-ʸa-zA-Z_$][À-ʸa-zA-Z_$0-9]*", r = n + Rv("(?:<" + n + "~~~(?:\\s*,\\s*" + n + "~~~)*>)?", /~~~/g, 2), l = {
    keyword: [
      "synchronized",
      "abstract",
      "private",
      "var",
      "static",
      "if",
      "const ",
      "for",
      "while",
      "strictfp",
      "finally",
      "protected",
      "import",
      "native",
      "final",
      "void",
      "enum",
      "else",
      "break",
      "transient",
      "catch",
      "instanceof",
      "volatile",
      "case",
      "assert",
      "package",
      "default",
      "public",
      "try",
      "switch",
      "continue",
      "throws",
      "protected",
      "public",
      "private",
      "module",
      "requires",
      "exports",
      "do",
      "sealed",
      "yield",
      "permits",
      "goto",
      "when"
    ],
    literal: [
      "false",
      "true",
      "null"
    ],
    type: [
      "char",
      "boolean",
      "long",
      "float",
      "int",
      "byte",
      "short",
      "double"
    ],
    built_in: [
      "super",
      "this"
    ]
  }, c = {
    className: "meta",
    begin: "@" + n,
    contains: [
      {
        begin: /\(/,
        end: /\)/,
        contains: ["self"]
        // allow nested () inside our annotation
      }
    ]
  }, u = {
    className: "params",
    begin: /\(/,
    end: /\)/,
    keywords: l,
    relevance: 0,
    contains: [t.C_BLOCK_COMMENT_MODE],
    endsParent: !0
  };
  return {
    name: "Java",
    aliases: ["jsp"],
    keywords: l,
    illegal: /<\/|#/,
    contains: [
      t.COMMENT(
        "/\\*\\*",
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              // eat up @'s in emails to prevent them to be recognized as doctags
              begin: /\w+@/,
              relevance: 0
            },
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            }
          ]
        }
      ),
      // relevance boost
      {
        begin: /import java\.[a-z]+\./,
        keywords: "import",
        relevance: 2
      },
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      {
        begin: /"""/,
        end: /"""/,
        className: "string",
        contains: [t.BACKSLASH_ESCAPE]
      },
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE,
      {
        match: [
          /\b(?:class|interface|enum|extends|implements|new)/,
          /\s+/,
          n
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        // Exceptions for hyphenated keywords
        match: /non-sealed/,
        scope: "keyword"
      },
      {
        begin: [
          e.concat(/(?!else)/, n),
          /\s+/,
          n,
          /\s+/,
          /=(?!=)/
        ],
        className: {
          1: "type",
          3: "variable",
          5: "operator"
        }
      },
      {
        begin: [
          /record/,
          /\s+/,
          n
        ],
        className: {
          1: "keyword",
          3: "title.class"
        },
        contains: [
          u,
          t.C_LINE_COMMENT_MODE,
          t.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        // Expression keywords prevent 'keyword Name(...)' from being
        // recognized as a function definition
        beginKeywords: "new throw return else",
        relevance: 0
      },
      {
        begin: [
          "(?:" + r + "\\s+)",
          t.UNDERSCORE_IDENT_RE,
          /\s*(?=\()/
        ],
        className: { 2: "title.function" },
        keywords: l,
        contains: [
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            keywords: l,
            relevance: 0,
            contains: [
              c,
              t.APOS_STRING_MODE,
              t.QUOTE_STRING_MODE,
              Qp,
              t.C_BLOCK_COMMENT_MODE
            ]
          },
          t.C_LINE_COMMENT_MODE,
          t.C_BLOCK_COMMENT_MODE
        ]
      },
      Qp,
      c
    ]
  };
}
const eg = "[A-Za-z$_][0-9A-Za-z$_]*", ZO = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends",
  // It's reached stage 3, which is "recommended for implementation":
  "using"
], JO = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
], Ov = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
], Iv = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
], Dv = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
], QO = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
], eI = [].concat(
  Dv,
  Ov,
  Iv
);
function tI(t) {
  const e = t.regex, n = (A, { after: $ }) => {
    const _ = "</" + A[0].slice(1);
    return A.input.indexOf(_, $) !== -1;
  }, r = eg, o = {
    begin: "<>",
    end: "</>"
  }, i = /<[A-Za-z0-9\\._:-]+\s*\/>/, s = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (A, $) => {
      const _ = A[0].length + A.index, z = A.input[_];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        z === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        z === ","
      ) {
        $.ignoreMatch();
        return;
      }
      z === ">" && (n(A, { after: _ }) || $.ignoreMatch());
      let Q;
      const ue = A.input.substring(_);
      if (Q = ue.match(/^\s*=/)) {
        $.ignoreMatch();
        return;
      }
      if ((Q = ue.match(/^\s+extends\s+/)) && Q.index === 0) {
        $.ignoreMatch();
        return;
      }
    }
  }, a = {
    $pattern: eg,
    keyword: ZO,
    literal: JO,
    built_in: eI,
    "variable.language": QO
  }, l = "[0-9](_?[0-9])*", c = `\\.(${l})`, u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", d = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${u})((${c})|\\.)?|(${c}))[eE][+-]?(${l})\\b` },
      { begin: `\\b(${u})\\b((${c})\\b|\\.)?|(${c})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, f = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: a,
    contains: []
    // defined later
  }, h = {
    begin: ".?html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        t.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "xml"
    }
  }, m = {
    begin: ".?css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        t.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "css"
    }
  }, p = {
    begin: ".?gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        t.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "graphql"
    }
  }, g = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      t.BACKSLASH_ESCAPE,
      f
    ]
  }, v = {
    className: "comment",
    variants: [
      t.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: !0,
                  excludeBegin: !0,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: r + "(?=\\s*(-)|$)",
                  endsParent: !0,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      t.C_BLOCK_COMMENT_MODE,
      t.C_LINE_COMMENT_MODE
    ]
  }, k = [
    t.APOS_STRING_MODE,
    t.QUOTE_STRING_MODE,
    h,
    m,
    p,
    g,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    d
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  f.contains = k.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: a,
    contains: [
      "self"
    ].concat(k)
  });
  const x = [].concat(v, f.contains), w = x.concat([
    // eat recursive parens in sub expressions
    {
      begin: /(\s*)\(/,
      end: /\)/,
      keywords: a,
      contains: ["self"].concat(x)
    }
  ]), E = {
    className: "params",
    // convert this to negative lookbehind in v12
    begin: /(\s*)\(/,
    // to match the parms with
    end: /\)/,
    excludeBegin: !0,
    excludeEnd: !0,
    keywords: a,
    contains: w
  }, S = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          r,
          /\s+/,
          /extends/,
          /\s+/,
          e.concat(r, "(", e.concat(/\./, r), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          r
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, C = {
    relevance: 0,
    match: e.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...Ov,
        ...Iv
      ]
    }
  }, M = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, O = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          r,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [E],
    illegal: /%/
  }, q = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function K(A) {
    return e.concat("(?!", A.join("|"), ")");
  }
  const j = {
    match: e.concat(
      /\b/,
      K([
        ...Dv,
        "super",
        "import"
      ].map((A) => `${A}\\s*\\(`)),
      r,
      e.lookahead(/\s*\(/)
    ),
    className: "title.function",
    relevance: 0
  }, H = {
    begin: e.concat(/\./, e.lookahead(
      e.concat(r, /(?![0-9A-Za-z$_(])/)
    )),
    end: r,
    excludeBegin: !0,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, G = {
    match: [
      /get|set/,
      /\s+/,
      r,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      E
    ]
  }, V = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + t.UNDERSCORE_IDENT_RE + ")\\s*=>", re = {
    match: [
      /const|var|let/,
      /\s+/,
      r,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      e.lookahead(V)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      E
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: a,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: w, CLASS_REFERENCE: C },
    illegal: /#(?![$_A-z])/,
    contains: [
      t.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      M,
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE,
      h,
      m,
      p,
      g,
      v,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      d,
      C,
      {
        scope: "attr",
        match: r + e.lookahead(":"),
        relevance: 0
      },
      re,
      {
        // "value" container
        begin: "(" + t.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          v,
          t.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: V,
            returnBegin: !0,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: t.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: !0
                  },
                  {
                    begin: /(\s*)\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: a,
                    contains: w
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: o.begin, end: o.end },
              { match: i },
              {
                begin: s.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": s.isTrulyOpeningTag,
                end: s.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: s.begin,
                end: s.end,
                skip: !0,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      O,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + t.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: !0,
        label: "func.def",
        contains: [
          E,
          t.inherit(t.TITLE_MODE, { begin: r, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      H,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + r,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [E]
      },
      j,
      q,
      S,
      G,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function nI(t) {
  const e = {
    className: "attr",
    begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/,
    relevance: 1.01
  }, n = {
    match: /[{}[\],:]/,
    className: "punctuation",
    relevance: 0
  }, r = [
    "true",
    "false",
    "null"
  ], o = {
    scope: "literal",
    beginKeywords: r.join(" ")
  };
  return {
    name: "JSON",
    aliases: ["jsonc"],
    keywords: {
      literal: r
    },
    contains: [
      e,
      n,
      t.QUOTE_STRING_MODE,
      o,
      t.C_NUMBER_MODE,
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE
    ],
    illegal: "\\S"
  };
}
var zo = "[0-9](_*[0-9])*", ia = `\\.(${zo})`, sa = "[0-9a-fA-F](_*[0-9a-fA-F])*", rI = {
  className: "number",
  variants: [
    // DecimalFloatingPointLiteral
    // including ExponentPart
    { begin: `(\\b(${zo})((${ia})|\\.)?|(${ia}))[eE][+-]?(${zo})[fFdD]?\\b` },
    // excluding ExponentPart
    { begin: `\\b(${zo})((${ia})[fFdD]?\\b|\\.([fFdD]\\b)?)` },
    { begin: `(${ia})[fFdD]?\\b` },
    { begin: `\\b(${zo})[fFdD]\\b` },
    // HexadecimalFloatingPointLiteral
    { begin: `\\b0[xX]((${sa})\\.?|(${sa})?\\.(${sa}))[pP][+-]?(${zo})[fFdD]?\\b` },
    // DecimalIntegerLiteral
    { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" },
    // HexIntegerLiteral
    { begin: `\\b0[xX](${sa})[lL]?\\b` },
    // OctalIntegerLiteral
    { begin: "\\b0(_*[0-7])*[lL]?\\b" },
    // BinaryIntegerLiteral
    { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }
  ],
  relevance: 0
};
function oI(t) {
  const e = {
    keyword: "abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual",
    built_in: "Byte Short Char Int Long Boolean Float Double Void Unit Nothing",
    literal: "true false null"
  }, n = {
    className: "keyword",
    begin: /\b(break|continue|return|this)\b/,
    starts: { contains: [
      {
        className: "symbol",
        begin: /@\w+/
      }
    ] }
  }, r = {
    className: "symbol",
    begin: t.UNDERSCORE_IDENT_RE + "@"
  }, o = {
    className: "subst",
    begin: /\$\{/,
    end: /\}/,
    contains: [t.C_NUMBER_MODE]
  }, i = {
    className: "variable",
    begin: "\\$" + t.UNDERSCORE_IDENT_RE
  }, s = {
    className: "string",
    variants: [
      {
        begin: '"""',
        end: '"""(?=[^"])',
        contains: [
          i,
          o
        ]
      },
      // Can't use built-in modes easily, as we want to use STRING in the meta
      // context as 'meta-string' and there's no syntax to remove explicitly set
      // classNames in built-in modes.
      {
        begin: "'",
        end: "'",
        illegal: /\n/,
        contains: [t.BACKSLASH_ESCAPE]
      },
      {
        begin: '"',
        end: '"',
        illegal: /\n/,
        contains: [
          t.BACKSLASH_ESCAPE,
          i,
          o
        ]
      }
    ]
  };
  o.contains.push(s);
  const a = {
    className: "meta",
    begin: "@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*" + t.UNDERSCORE_IDENT_RE + ")?"
  }, l = {
    className: "meta",
    begin: "@" + t.UNDERSCORE_IDENT_RE,
    contains: [
      {
        begin: /\(/,
        end: /\)/,
        contains: [
          t.inherit(s, { className: "string" }),
          "self"
        ]
      }
    ]
  }, c = rI, u = t.COMMENT(
    "/\\*",
    "\\*/",
    { contains: [t.C_BLOCK_COMMENT_MODE] }
  ), d = { variants: [
    {
      className: "type",
      begin: t.UNDERSCORE_IDENT_RE
    },
    {
      begin: /\(/,
      end: /\)/,
      contains: []
      // defined later
    }
  ] }, f = d;
  return f.variants[1].contains = [d], d.variants[1].contains = [f], {
    name: "Kotlin",
    aliases: [
      "kt",
      "kts"
    ],
    keywords: e,
    contains: [
      t.COMMENT(
        "/\\*\\*",
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              className: "doctag",
              begin: "@[A-Za-z]+"
            }
          ]
        }
      ),
      t.C_LINE_COMMENT_MODE,
      u,
      n,
      r,
      a,
      l,
      {
        className: "function",
        beginKeywords: "fun",
        end: "[(]|$",
        returnBegin: !0,
        excludeEnd: !0,
        keywords: e,
        relevance: 5,
        contains: [
          {
            begin: t.UNDERSCORE_IDENT_RE + "\\s*\\(",
            returnBegin: !0,
            relevance: 0,
            contains: [t.UNDERSCORE_TITLE_MODE]
          },
          {
            className: "type",
            begin: /</,
            end: />/,
            keywords: "reified",
            relevance: 0
          },
          {
            className: "params",
            begin: /\(/,
            end: /\)/,
            endsParent: !0,
            keywords: e,
            relevance: 0,
            contains: [
              {
                begin: /:/,
                end: /[=,\/]/,
                endsWithParent: !0,
                contains: [
                  d,
                  t.C_LINE_COMMENT_MODE,
                  u
                ],
                relevance: 0
              },
              t.C_LINE_COMMENT_MODE,
              u,
              a,
              l,
              s,
              t.C_NUMBER_MODE
            ]
          },
          u
        ]
      },
      {
        begin: [
          /class|interface|trait/,
          /\s+/,
          t.UNDERSCORE_IDENT_RE
        ],
        beginScope: {
          3: "title.class"
        },
        keywords: "class interface trait",
        end: /[:\{(]|$/,
        excludeEnd: !0,
        illegal: "extends implements",
        contains: [
          { beginKeywords: "public protected internal private constructor" },
          t.UNDERSCORE_TITLE_MODE,
          {
            className: "type",
            begin: /</,
            end: />/,
            excludeBegin: !0,
            excludeEnd: !0,
            relevance: 0
          },
          {
            className: "type",
            begin: /[,:]\s*/,
            end: /[<\(,){\s]|$/,
            excludeBegin: !0,
            returnEnd: !0
          },
          a,
          l
        ]
      },
      s,
      {
        className: "meta",
        begin: "^#!/usr/bin/env",
        end: "$",
        illegal: `
`
      },
      c
    ]
  };
}
const iI = (t) => ({
  IMPORTANT: {
    scope: "meta",
    begin: "!important"
  },
  BLOCK_COMMENT: t.C_BLOCK_COMMENT_MODE,
  HEXCOLOR: {
    scope: "number",
    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
  },
  FUNCTION_DISPATCH: {
    className: "built_in",
    begin: /[\w-]+(?=\()/
  },
  ATTRIBUTE_SELECTOR_MODE: {
    scope: "selector-attr",
    begin: /\[/,
    end: /\]/,
    illegal: "$",
    contains: [
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE
    ]
  },
  CSS_NUMBER_MODE: {
    scope: "number",
    begin: t.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
    relevance: 0
  },
  CSS_VARIABLE: {
    className: "attr",
    begin: /--[A-Za-z_][A-Za-z0-9_-]*/
  }
}), sI = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "optgroup",
  "option",
  "p",
  "picture",
  "q",
  "quote",
  "samp",
  "section",
  "select",
  "source",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
], aI = [
  "defs",
  "g",
  "marker",
  "mask",
  "pattern",
  "svg",
  "switch",
  "symbol",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feFlood",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMorphology",
  "feOffset",
  "feSpecularLighting",
  "feTile",
  "feTurbulence",
  "linearGradient",
  "radialGradient",
  "stop",
  "circle",
  "ellipse",
  "image",
  "line",
  "path",
  "polygon",
  "polyline",
  "rect",
  "text",
  "use",
  "textPath",
  "tspan",
  "foreignObject",
  "clipPath"
], lI = [
  ...sI,
  ...aI
], cI = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
].sort().reverse(), Lv = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
].sort().reverse(), Pv = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
].sort().reverse(), uI = [
  "accent-color",
  "align-content",
  "align-items",
  "align-self",
  "alignment-baseline",
  "all",
  "anchor-name",
  "animation",
  "animation-composition",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-range",
  "animation-range-end",
  "animation-range-start",
  "animation-timeline",
  "animation-timing-function",
  "appearance",
  "aspect-ratio",
  "backdrop-filter",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-position-x",
  "background-position-y",
  "background-repeat",
  "background-size",
  "baseline-shift",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-end-end-radius",
  "border-end-start-radius",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-start-end-radius",
  "border-start-start-radius",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-align",
  "box-decoration-break",
  "box-direction",
  "box-flex",
  "box-flex-group",
  "box-lines",
  "box-ordinal-group",
  "box-orient",
  "box-pack",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "color-scheme",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "contain-intrinsic-block-size",
  "contain-intrinsic-height",
  "contain-intrinsic-inline-size",
  "contain-intrinsic-size",
  "contain-intrinsic-width",
  "container",
  "container-name",
  "container-type",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "counter-set",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "cx",
  "cy",
  "direction",
  "display",
  "dominant-baseline",
  "empty-cells",
  "enable-background",
  "field-sizing",
  "fill",
  "fill-opacity",
  "fill-rule",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flood-color",
  "flood-opacity",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-optical-sizing",
  "font-palette",
  "font-size",
  "font-size-adjust",
  "font-smooth",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-synthesis-position",
  "font-synthesis-small-caps",
  "font-synthesis-style",
  "font-synthesis-weight",
  "font-variant",
  "font-variant-alternates",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-emoji",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "forced-color-adjust",
  "gap",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphenate-character",
  "hyphenate-limit-chars",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "initial-letter",
  "initial-letter-align",
  "inline-size",
  "inset",
  "inset-area",
  "inset-block",
  "inset-block-end",
  "inset-block-start",
  "inset-inline",
  "inset-inline-end",
  "inset-inline-start",
  "isolation",
  "justify-content",
  "justify-items",
  "justify-self",
  "kerning",
  "left",
  "letter-spacing",
  "lighting-color",
  "line-break",
  "line-height",
  "line-height-step",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "margin-trim",
  "marker",
  "marker-end",
  "marker-mid",
  "marker-start",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "masonry-auto-flow",
  "math-depth",
  "math-shift",
  "math-style",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "offset",
  "offset-anchor",
  "offset-distance",
  "offset-path",
  "offset-position",
  "offset-rotate",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-anchor",
  "overflow-block",
  "overflow-clip-margin",
  "overflow-inline",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "overlay",
  "overscroll-behavior",
  "overscroll-behavior-block",
  "overscroll-behavior-inline",
  "overscroll-behavior-x",
  "overscroll-behavior-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "paint-order",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "place-content",
  "place-items",
  "place-self",
  "pointer-events",
  "position",
  "position-anchor",
  "position-visibility",
  "print-color-adjust",
  "quotes",
  "r",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "rotate",
  "row-gap",
  "ruby-align",
  "ruby-position",
  "scale",
  "scroll-behavior",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scroll-timeline",
  "scroll-timeline-axis",
  "scroll-timeline-name",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "shape-rendering",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "stop-color",
  "stop-opacity",
  "stroke",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-anchor",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-skip",
  "text-decoration-skip-ink",
  "text-decoration-style",
  "text-decoration-thickness",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-size-adjust",
  "text-transform",
  "text-underline-offset",
  "text-underline-position",
  "text-wrap",
  "text-wrap-mode",
  "text-wrap-style",
  "timeline-scope",
  "top",
  "touch-action",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-behavior",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "translate",
  "unicode-bidi",
  "user-modify",
  "user-select",
  "vector-effect",
  "vertical-align",
  "view-timeline",
  "view-timeline-axis",
  "view-timeline-inset",
  "view-timeline-name",
  "view-transition-name",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "white-space-collapse",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "x",
  "y",
  "z-index",
  "zoom"
].sort().reverse(), dI = Lv.concat(Pv).sort().reverse();
function fI(t) {
  const e = iI(t), n = dI, r = "and or not only", o = "[\\w-]+", i = "(" + o + "|@\\{" + o + "\\})", s = [], a = [], l = function(k) {
    return {
      // Less strings are not multiline (also include '~' for more consistent coloring of "escaped" strings)
      className: "string",
      begin: "~?" + k + ".*?" + k
    };
  }, c = function(k, x, w) {
    return {
      className: k,
      begin: x,
      relevance: w
    };
  }, u = {
    $pattern: /[a-z-]+/,
    keyword: r,
    attribute: cI.join(" ")
  }, d = {
    // used only to properly balance nested parens inside mixin call, def. arg list
    begin: "\\(",
    end: "\\)",
    contains: a,
    keywords: u,
    relevance: 0
  };
  a.push(
    t.C_LINE_COMMENT_MODE,
    t.C_BLOCK_COMMENT_MODE,
    l("'"),
    l('"'),
    e.CSS_NUMBER_MODE,
    // fixme: it does not include dot for numbers like .5em :(
    {
      begin: "(url|data-uri)\\(",
      starts: {
        className: "string",
        end: "[\\)\\n]",
        excludeEnd: !0
      }
    },
    e.HEXCOLOR,
    d,
    c("variable", "@@?" + o, 10),
    c("variable", "@\\{" + o + "\\}"),
    c("built_in", "~?`[^`]*?`"),
    // inline javascript (or whatever host language) *multiline* string
    {
      // @media features (it’s here to not duplicate things in AT_RULE_MODE with extra PARENS_MODE overriding):
      className: "attribute",
      begin: o + "\\s*:",
      end: ":",
      returnBegin: !0,
      excludeEnd: !0
    },
    e.IMPORTANT,
    { beginKeywords: "and not" },
    e.FUNCTION_DISPATCH
  );
  const f = a.concat({
    begin: /\{/,
    end: /\}/,
    contains: s
  }), h = {
    beginKeywords: "when",
    endsWithParent: !0,
    contains: [{ beginKeywords: "and not" }].concat(a)
    // using this form to override VALUE’s 'function' match
  }, m = {
    begin: i + "\\s*:",
    returnBegin: !0,
    end: /[;}]/,
    relevance: 0,
    contains: [
      { begin: /-(webkit|moz|ms|o)-/ },
      e.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + uI.join("|") + ")\\b",
        end: /(?=:)/,
        starts: {
          endsWithParent: !0,
          illegal: "[<=$]",
          relevance: 0,
          contains: a
        }
      }
    ]
  }, p = {
    className: "keyword",
    begin: "@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b",
    starts: {
      end: "[;{}]",
      keywords: u,
      returnEnd: !0,
      contains: a,
      relevance: 0
    }
  }, g = {
    className: "variable",
    variants: [
      // using more strict pattern for higher relevance to increase chances of Less detection.
      // this is *the only* Less specific statement used in most of the sources, so...
      // (we’ll still often loose to the css-parser unless there's '//' comment,
      // simply because 1 variable just can't beat 99 properties :)
      {
        begin: "@" + o + "\\s*:",
        relevance: 15
      },
      { begin: "@" + o }
    ],
    starts: {
      end: "[;}]",
      returnEnd: !0,
      contains: f
    }
  }, b = {
    // first parse unambiguous selectors (i.e. those not starting with tag)
    // then fall into the scary lookahead-discriminator variant.
    // this mode also handles mixin definitions and calls
    variants: [
      {
        begin: "[\\.#:&\\[>]",
        end: "[;{}]"
        // mixin calls end with ';'
      },
      {
        begin: i,
        end: /\{/
      }
    ],
    returnBegin: !0,
    returnEnd: !0,
    illegal: `[<='$"]`,
    relevance: 0,
    contains: [
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      h,
      c("keyword", "all\\b"),
      c("variable", "@\\{" + o + "\\}"),
      // otherwise it’s identified as tag
      {
        begin: "\\b(" + lI.join("|") + ")\\b",
        className: "selector-tag"
      },
      e.CSS_NUMBER_MODE,
      c("selector-tag", i, 0),
      c("selector-id", "#" + i),
      c("selector-class", "\\." + i, 0),
      c("selector-tag", "&", 0),
      e.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-pseudo",
        begin: ":(" + Lv.join("|") + ")"
      },
      {
        className: "selector-pseudo",
        begin: ":(:)?(" + Pv.join("|") + ")"
      },
      {
        begin: /\(/,
        end: /\)/,
        relevance: 0,
        contains: f
      },
      // argument list of parametric mixins
      { begin: "!important" },
      // eat !important after mixin call or it will be colored as tag
      e.FUNCTION_DISPATCH
    ]
  }, v = {
    begin: o + `:(:)?(${n.join("|")})`,
    returnBegin: !0,
    contains: [b]
  };
  return s.push(
    t.C_LINE_COMMENT_MODE,
    t.C_BLOCK_COMMENT_MODE,
    p,
    g,
    v,
    m,
    b,
    h,
    e.FUNCTION_DISPATCH
  ), {
    name: "Less",
    case_insensitive: !0,
    illegal: `[=>'/<($"]`,
    contains: s
  };
}
function hI(t) {
  const e = "\\[=*\\[", n = "\\]=*\\]", r = {
    begin: e,
    end: n,
    contains: ["self"]
  }, o = [
    t.COMMENT("--(?!" + e + ")", "$"),
    t.COMMENT(
      "--" + e,
      n,
      {
        contains: [r],
        relevance: 10
      }
    )
  ];
  return {
    name: "Lua",
    aliases: ["pluto"],
    keywords: {
      $pattern: t.UNDERSCORE_IDENT_RE,
      literal: "true false nil",
      keyword: "and break do else elseif end for goto if in local not or repeat return then until while",
      built_in: (
        // Metatags and globals:
        "_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove"
      )
    },
    contains: o.concat([
      {
        className: "function",
        beginKeywords: "function",
        end: "\\)",
        contains: [
          t.inherit(t.TITLE_MODE, { begin: "([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*" }),
          {
            className: "params",
            begin: "\\(",
            endsWithParent: !0,
            contains: o
          }
        ].concat(o)
      },
      t.C_NUMBER_MODE,
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE,
      {
        className: "string",
        begin: e,
        end: n,
        contains: [r],
        relevance: 5
      }
    ])
  };
}
function mI(t) {
  const e = {
    className: "variable",
    variants: [
      {
        begin: "\\$\\(" + t.UNDERSCORE_IDENT_RE + "\\)",
        contains: [t.BACKSLASH_ESCAPE]
      },
      { begin: /\$[@%<?\^\+\*]/ }
    ]
  }, n = {
    className: "string",
    begin: /"/,
    end: /"/,
    contains: [
      t.BACKSLASH_ESCAPE,
      e
    ]
  }, r = {
    className: "variable",
    begin: /\$\([\w-]+\s/,
    end: /\)/,
    keywords: { built_in: "subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value" },
    contains: [
      e,
      n
      // Added QUOTE_STRING as they can be a part of functions
    ]
  }, o = { begin: "^" + t.UNDERSCORE_IDENT_RE + "\\s*(?=[:+?]?=)" }, i = {
    className: "meta",
    begin: /^\.PHONY:/,
    end: /$/,
    keywords: {
      $pattern: /[\.\w]+/,
      keyword: ".PHONY"
    }
  }, s = {
    className: "section",
    begin: /^[^\s]+:/,
    end: /$/,
    contains: [e]
  };
  return {
    name: "Makefile",
    aliases: [
      "mk",
      "mak",
      "make"
    ],
    keywords: {
      $pattern: /[\w-]+/,
      keyword: "define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath"
    },
    contains: [
      t.HASH_COMMENT_MODE,
      e,
      n,
      r,
      o,
      i,
      s
    ]
  };
}
function pI(t) {
  const e = t.regex, n = {
    begin: /<\/?[A-Za-z_]/,
    end: ">",
    subLanguage: "xml",
    relevance: 0
  }, r = {
    begin: "^[-\\*]{3,}",
    end: "$"
  }, o = {
    className: "code",
    variants: [
      // TODO: fix to allow these to work with sublanguage also
      { begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*" },
      { begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*" },
      // needed to allow markdown as a sublanguage to work
      {
        begin: "```",
        end: "```+[ ]*$"
      },
      {
        begin: "~~~",
        end: "~~~+[ ]*$"
      },
      { begin: "`.+?`" },
      {
        begin: "(?=^( {4}|\\t))",
        // use contains to gobble up multiple lines to allow the block to be whatever size
        // but only have a single open/close tag vs one per line
        contains: [
          {
            begin: "^( {4}|\\t)",
            end: "(\\n)$"
          }
        ],
        relevance: 0
      }
    ]
  }, i = {
    className: "bullet",
    begin: "^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)",
    end: "\\s+",
    excludeEnd: !0
  }, s = {
    begin: /^\[[^\n]+\]:/,
    returnBegin: !0,
    contains: [
      {
        className: "symbol",
        begin: /\[/,
        end: /\]/,
        excludeBegin: !0,
        excludeEnd: !0
      },
      {
        className: "link",
        begin: /:\s*/,
        end: /$/,
        excludeBegin: !0
      }
    ]
  }, a = /[A-Za-z][A-Za-z0-9+.-]*/, l = {
    variants: [
      // too much like nested array access in so many languages
      // to have any real relevance
      {
        begin: /\[.+?\]\[.*?\]/,
        relevance: 0
      },
      // popular internet URLs
      {
        begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/,
        relevance: 2
      },
      {
        begin: e.concat(/\[.+?\]\(/, a, /:\/\/.*?\)/),
        relevance: 2
      },
      // relative urls
      {
        begin: /\[.+?\]\([./?&#].*?\)/,
        relevance: 1
      },
      // whatever else, lower relevance (might not be a link at all)
      {
        begin: /\[.*?\]\(.*?\)/,
        relevance: 0
      }
    ],
    returnBegin: !0,
    contains: [
      {
        // empty strings for alt or link text
        match: /\[(?=\])/
      },
      {
        className: "string",
        relevance: 0,
        begin: "\\[",
        end: "\\]",
        excludeBegin: !0,
        returnEnd: !0
      },
      {
        className: "link",
        relevance: 0,
        begin: "\\]\\(",
        end: "\\)",
        excludeBegin: !0,
        excludeEnd: !0
      },
      {
        className: "symbol",
        relevance: 0,
        begin: "\\]\\[",
        end: "\\]",
        excludeBegin: !0,
        excludeEnd: !0
      }
    ]
  }, c = {
    className: "strong",
    contains: [],
    // defined later
    variants: [
      {
        begin: /_{2}(?!\s)/,
        end: /_{2}/
      },
      {
        begin: /\*{2}(?!\s)/,
        end: /\*{2}/
      }
    ]
  }, u = {
    className: "emphasis",
    contains: [],
    // defined later
    variants: [
      {
        begin: /\*(?![*\s])/,
        end: /\*/
      },
      {
        begin: /_(?![_\s])/,
        end: /_/,
        relevance: 0
      }
    ]
  }, d = t.inherit(c, { contains: [] }), f = t.inherit(u, { contains: [] });
  c.contains.push(f), u.contains.push(d);
  let h = [
    n,
    l
  ];
  return [
    c,
    u,
    d,
    f
  ].forEach((b) => {
    b.contains = b.contains.concat(h);
  }), h = h.concat(c, u), {
    name: "Markdown",
    aliases: [
      "md",
      "mkdown",
      "mkd"
    ],
    contains: [
      {
        className: "section",
        variants: [
          {
            begin: "^#{1,6}",
            end: "$",
            contains: h
          },
          {
            begin: "(?=^.+?\\n[=-]{2,}$)",
            contains: [
              { begin: "^[=-]*$" },
              {
                begin: "^",
                end: "\\n",
                contains: h
              }
            ]
          }
        ]
      },
      n,
      i,
      c,
      u,
      {
        className: "quote",
        begin: "^>\\s+",
        contains: h,
        end: "$"
      },
      o,
      r,
      l,
      s,
      {
        //https://spec.commonmark.org/0.31.2/#entity-references
        scope: "literal",
        match: /&([a-zA-Z0-9]+|#[0-9]{1,7}|#[Xx][0-9a-fA-F]{1,6});/
      }
    ]
  };
}
function gI(t) {
  const e = {
    className: "built_in",
    begin: "\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+"
  }, n = /[a-zA-Z@][a-zA-Z0-9_]*/, a = {
    "variable.language": [
      "this",
      "super"
    ],
    $pattern: n,
    keyword: [
      "while",
      "export",
      "sizeof",
      "typedef",
      "const",
      "struct",
      "for",
      "union",
      "volatile",
      "static",
      "mutable",
      "if",
      "do",
      "return",
      "goto",
      "enum",
      "else",
      "break",
      "extern",
      "asm",
      "case",
      "default",
      "register",
      "explicit",
      "typename",
      "switch",
      "continue",
      "inline",
      "readonly",
      "assign",
      "readwrite",
      "self",
      "@synchronized",
      "id",
      "typeof",
      "nonatomic",
      "IBOutlet",
      "IBAction",
      "strong",
      "weak",
      "copy",
      "in",
      "out",
      "inout",
      "bycopy",
      "byref",
      "oneway",
      "__strong",
      "__weak",
      "__block",
      "__autoreleasing",
      "@private",
      "@protected",
      "@public",
      "@try",
      "@property",
      "@end",
      "@throw",
      "@catch",
      "@finally",
      "@autoreleasepool",
      "@synthesize",
      "@dynamic",
      "@selector",
      "@optional",
      "@required",
      "@encode",
      "@package",
      "@import",
      "@defs",
      "@compatibility_alias",
      "__bridge",
      "__bridge_transfer",
      "__bridge_retained",
      "__bridge_retain",
      "__covariant",
      "__contravariant",
      "__kindof",
      "_Nonnull",
      "_Nullable",
      "_Null_unspecified",
      "__FUNCTION__",
      "__PRETTY_FUNCTION__",
      "__attribute__",
      "getter",
      "setter",
      "retain",
      "unsafe_unretained",
      "nonnull",
      "nullable",
      "null_unspecified",
      "null_resettable",
      "class",
      "instancetype",
      "NS_DESIGNATED_INITIALIZER",
      "NS_UNAVAILABLE",
      "NS_REQUIRES_SUPER",
      "NS_RETURNS_INNER_POINTER",
      "NS_INLINE",
      "NS_AVAILABLE",
      "NS_DEPRECATED",
      "NS_ENUM",
      "NS_OPTIONS",
      "NS_SWIFT_UNAVAILABLE",
      "NS_ASSUME_NONNULL_BEGIN",
      "NS_ASSUME_NONNULL_END",
      "NS_REFINED_FOR_SWIFT",
      "NS_SWIFT_NAME",
      "NS_SWIFT_NOTHROW",
      "NS_DURING",
      "NS_HANDLER",
      "NS_ENDHANDLER",
      "NS_VALUERETURN",
      "NS_VOIDRETURN"
    ],
    literal: [
      "false",
      "true",
      "FALSE",
      "TRUE",
      "nil",
      "YES",
      "NO",
      "NULL"
    ],
    built_in: [
      "dispatch_once_t",
      "dispatch_queue_t",
      "dispatch_sync",
      "dispatch_async",
      "dispatch_once"
    ],
    type: [
      "int",
      "float",
      "char",
      "unsigned",
      "signed",
      "short",
      "long",
      "double",
      "wchar_t",
      "unichar",
      "void",
      "bool",
      "BOOL",
      "id|0",
      "_Bool"
    ]
  }, l = {
    $pattern: n,
    keyword: [
      "@interface",
      "@class",
      "@protocol",
      "@implementation"
    ]
  };
  return {
    name: "Objective-C",
    aliases: [
      "mm",
      "objc",
      "obj-c",
      "obj-c++",
      "objective-c++"
    ],
    keywords: a,
    illegal: "</",
    contains: [
      e,
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      t.C_NUMBER_MODE,
      t.QUOTE_STRING_MODE,
      t.APOS_STRING_MODE,
      {
        className: "string",
        variants: [
          {
            begin: '@"',
            end: '"',
            illegal: "\\n",
            contains: [t.BACKSLASH_ESCAPE]
          }
        ]
      },
      {
        className: "meta",
        begin: /#\s*[a-z]+\b/,
        end: /$/,
        keywords: { keyword: "if else elif endif define undef warning error line pragma ifdef ifndef include" },
        contains: [
          {
            begin: /\\\n/,
            relevance: 0
          },
          t.inherit(t.QUOTE_STRING_MODE, { className: "string" }),
          {
            className: "string",
            begin: /<.*?>/,
            end: /$/,
            illegal: "\\n"
          },
          t.C_LINE_COMMENT_MODE,
          t.C_BLOCK_COMMENT_MODE
        ]
      },
      {
        className: "class",
        begin: "(" + l.keyword.join("|") + ")\\b",
        end: /(\{|$)/,
        excludeEnd: !0,
        keywords: l,
        contains: [t.UNDERSCORE_TITLE_MODE]
      },
      {
        begin: "\\." + t.UNDERSCORE_IDENT_RE,
        relevance: 0
      }
    ]
  };
}
function bI(t) {
  const e = t.regex, n = [
    "abs",
    "accept",
    "alarm",
    "and",
    "atan2",
    "bind",
    "binmode",
    "bless",
    "break",
    "caller",
    "chdir",
    "chmod",
    "chomp",
    "chop",
    "chown",
    "chr",
    "chroot",
    "class",
    "close",
    "closedir",
    "connect",
    "continue",
    "cos",
    "crypt",
    "dbmclose",
    "dbmopen",
    "defined",
    "delete",
    "die",
    "do",
    "dump",
    "each",
    "else",
    "elsif",
    "endgrent",
    "endhostent",
    "endnetent",
    "endprotoent",
    "endpwent",
    "endservent",
    "eof",
    "eval",
    "exec",
    "exists",
    "exit",
    "exp",
    "fcntl",
    "field",
    "fileno",
    "flock",
    "for",
    "foreach",
    "fork",
    "format",
    "formline",
    "getc",
    "getgrent",
    "getgrgid",
    "getgrnam",
    "gethostbyaddr",
    "gethostbyname",
    "gethostent",
    "getlogin",
    "getnetbyaddr",
    "getnetbyname",
    "getnetent",
    "getpeername",
    "getpgrp",
    "getpriority",
    "getprotobyname",
    "getprotobynumber",
    "getprotoent",
    "getpwent",
    "getpwnam",
    "getpwuid",
    "getservbyname",
    "getservbyport",
    "getservent",
    "getsockname",
    "getsockopt",
    "given",
    "glob",
    "gmtime",
    "goto",
    "grep",
    "gt",
    "hex",
    "if",
    "index",
    "int",
    "ioctl",
    "join",
    "keys",
    "kill",
    "last",
    "lc",
    "lcfirst",
    "length",
    "link",
    "listen",
    "local",
    "localtime",
    "log",
    "lstat",
    "lt",
    "ma",
    "map",
    "method",
    "mkdir",
    "msgctl",
    "msgget",
    "msgrcv",
    "msgsnd",
    "my",
    "ne",
    "next",
    "no",
    "not",
    "oct",
    "open",
    "opendir",
    "or",
    "ord",
    "our",
    "pack",
    "package",
    "pipe",
    "pop",
    "pos",
    "print",
    "printf",
    "prototype",
    "push",
    "q|0",
    "qq",
    "quotemeta",
    "qw",
    "qx",
    "rand",
    "read",
    "readdir",
    "readline",
    "readlink",
    "readpipe",
    "recv",
    "redo",
    "ref",
    "rename",
    "require",
    "reset",
    "return",
    "reverse",
    "rewinddir",
    "rindex",
    "rmdir",
    "say",
    "scalar",
    "seek",
    "seekdir",
    "select",
    "semctl",
    "semget",
    "semop",
    "send",
    "setgrent",
    "sethostent",
    "setnetent",
    "setpgrp",
    "setpriority",
    "setprotoent",
    "setpwent",
    "setservent",
    "setsockopt",
    "shift",
    "shmctl",
    "shmget",
    "shmread",
    "shmwrite",
    "shutdown",
    "sin",
    "sleep",
    "socket",
    "socketpair",
    "sort",
    "splice",
    "split",
    "sprintf",
    "sqrt",
    "srand",
    "stat",
    "state",
    "study",
    "sub",
    "substr",
    "symlink",
    "syscall",
    "sysopen",
    "sysread",
    "sysseek",
    "system",
    "syswrite",
    "tell",
    "telldir",
    "tie",
    "tied",
    "time",
    "times",
    "tr",
    "truncate",
    "uc",
    "ucfirst",
    "umask",
    "undef",
    "unless",
    "unlink",
    "unpack",
    "unshift",
    "untie",
    "until",
    "use",
    "utime",
    "values",
    "vec",
    "wait",
    "waitpid",
    "wantarray",
    "warn",
    "when",
    "while",
    "write",
    "x|0",
    "xor",
    "y|0"
  ], r = /[dualxmsipngr]{0,12}/, o = {
    $pattern: /[\w.]+/,
    keyword: n.join(" ")
  }, i = {
    className: "subst",
    begin: "[$@]\\{",
    end: "\\}",
    keywords: o
  }, s = {
    begin: /->\{/,
    end: /\}/
    // contains defined later
  }, a = {
    scope: "attr",
    match: /\s+:\s*\w+(\s*\(.*?\))?/
  }, l = {
    scope: "variable",
    variants: [
      { begin: /\$\d/ },
      {
        begin: e.concat(
          /[$%@](?!")(\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/,
          // negative look-ahead tries to avoid matching patterns that are not
          // Perl at all like $ident$, @ident@, etc.
          "(?![A-Za-z])(?![@$%])"
        )
      },
      {
        // Only $= is a special Perl variable and one can't declare @= or %=.
        begin: /[$%@](?!")[^\s\w{=]|\$=/,
        relevance: 0
      }
    ],
    contains: [a]
  }, c = {
    className: "number",
    variants: [
      // decimal numbers:
      // include the case where a number starts with a dot (eg. .9), and
      // the leading 0? avoids mixing the first and second match on 0.x cases
      { match: /0?\.[0-9][0-9_]+\b/ },
      // include the special versioned number (eg. v5.38)
      { match: /\bv?(0|[1-9][0-9_]*(\.[0-9_]+)?|[1-9][0-9_]*)\b/ },
      // non-decimal numbers:
      { match: /\b0[0-7][0-7_]*\b/ },
      { match: /\b0x[0-9a-fA-F][0-9a-fA-F_]*\b/ },
      { match: /\b0b[0-1][0-1_]*\b/ }
    ],
    relevance: 0
  }, u = [
    t.BACKSLASH_ESCAPE,
    i,
    l
  ], d = [
    /!/,
    /\//,
    /\|/,
    /\?/,
    /'/,
    /"/,
    // valid but infrequent and weird
    /#/
    // valid but infrequent and weird
  ], f = (p, g, b = "\\1") => {
    const v = b === "\\1" ? b : e.concat(b, g);
    return e.concat(
      e.concat("(?:", p, ")"),
      g,
      /(?:\\.|[^\\\/])*?/,
      v,
      /(?:\\.|[^\\\/])*?/,
      b,
      r
    );
  }, h = (p, g, b) => e.concat(
    e.concat("(?:", p, ")"),
    g,
    /(?:\\.|[^\\\/])*?/,
    b,
    r
  ), m = [
    l,
    t.HASH_COMMENT_MODE,
    t.COMMENT(
      /^=\w/,
      /=cut/,
      { endsWithParent: !0 }
    ),
    s,
    {
      className: "string",
      contains: u,
      variants: [
        {
          begin: "q[qwxr]?\\s*\\(",
          end: "\\)",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*\\[",
          end: "\\]",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*\\{",
          end: "\\}",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*\\|",
          end: "\\|",
          relevance: 5
        },
        {
          begin: "q[qwxr]?\\s*<",
          end: ">",
          relevance: 5
        },
        {
          begin: "qw\\s+q",
          end: "q",
          relevance: 5
        },
        {
          begin: "'",
          end: "'",
          contains: [t.BACKSLASH_ESCAPE]
        },
        {
          begin: '"',
          end: '"'
        },
        {
          begin: "`",
          end: "`",
          contains: [t.BACKSLASH_ESCAPE]
        },
        {
          begin: /\{\w+\}/,
          relevance: 0
        },
        {
          begin: "-?\\w+\\s*=>",
          relevance: 0
        }
      ]
    },
    c,
    {
      // regexp container
      begin: "(\\/\\/|" + t.RE_STARTERS_RE + "|\\b(split|return|print|reverse|grep)\\b)\\s*",
      keywords: "split return print reverse grep",
      relevance: 0,
      contains: [
        t.HASH_COMMENT_MODE,
        {
          className: "regexp",
          variants: [
            // allow matching common delimiters
            { begin: f("s|tr|y", e.either(...d, { capture: !0 })) },
            // and then paired delmis
            { begin: f("s|tr|y", "\\(", "\\)") },
            { begin: f("s|tr|y", "\\[", "\\]") },
            { begin: f("s|tr|y", "\\{", "\\}") }
          ],
          relevance: 2
        },
        {
          className: "regexp",
          variants: [
            {
              // could be a comment in many languages so do not count
              // as relevant
              begin: /(m|qr)\/\//,
              relevance: 0
            },
            // prefix is optional with /regex/
            { begin: h("(?:m|qr)?", /\//, /\//) },
            // allow matching common delimiters
            { begin: h("m|qr", e.either(...d, { capture: !0 }), /\1/) },
            // allow common paired delmins
            { begin: h("m|qr", /\(/, /\)/) },
            { begin: h("m|qr", /\[/, /\]/) },
            { begin: h("m|qr", /\{/, /\}/) }
          ]
        }
      ]
    },
    {
      className: "function",
      beginKeywords: "sub method",
      end: "(\\s*\\(.*?\\))?[;{]",
      excludeEnd: !0,
      relevance: 5,
      contains: [t.TITLE_MODE, a]
    },
    {
      className: "class",
      beginKeywords: "class",
      end: "[;{]",
      excludeEnd: !0,
      relevance: 5,
      contains: [t.TITLE_MODE, a, c]
    },
    {
      begin: "-\\w\\b",
      relevance: 0
    },
    {
      begin: "^__DATA__$",
      end: "^__END__$",
      subLanguage: "mojolicious",
      contains: [
        {
          begin: "^@@.*",
          end: "$",
          className: "comment"
        }
      ]
    }
  ];
  return i.contains = m, s.contains = m, {
    name: "Perl",
    aliases: [
      "pl",
      "pm"
    ],
    keywords: o,
    contains: m
  };
}
function yI(t) {
  const e = t.regex, n = /(?![A-Za-z0-9])(?![$])/, r = e.concat(
    /[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/,
    n
  ), o = e.concat(
    /(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/,
    n
  ), i = e.concat(
    /[A-Z]+/,
    n
  ), s = {
    scope: "variable",
    match: "\\$+" + r
  }, a = {
    scope: "meta",
    variants: [
      { begin: /<\?php/, relevance: 10 },
      // boost for obvious PHP
      { begin: /<\?=/ },
      // less relevant per PSR-1 which says not to use short-tags
      { begin: /<\?/, relevance: 0.1 },
      { begin: /\?>/ }
      // end php tag
    ]
  }, l = {
    scope: "subst",
    variants: [
      { begin: /\$\w+/ },
      {
        begin: /\{\$/,
        end: /\}/
      }
    ]
  }, c = t.inherit(t.APOS_STRING_MODE, { illegal: null }), u = t.inherit(t.QUOTE_STRING_MODE, {
    illegal: null,
    contains: t.QUOTE_STRING_MODE.contains.concat(l)
  }), d = {
    begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/,
    end: /[ \t]*(\w+)\b/,
    contains: t.QUOTE_STRING_MODE.contains.concat(l),
    "on:begin": (H, G) => {
      G.data._beginMatch = H[1] || H[2];
    },
    "on:end": (H, G) => {
      G.data._beginMatch !== H[1] && G.ignoreMatch();
    }
  }, f = t.END_SAME_AS_BEGIN({
    begin: /<<<[ \t]*'(\w+)'\n/,
    end: /[ \t]*(\w+)\b/
  }), h = `[ 	
]`, m = {
    scope: "string",
    variants: [
      u,
      c,
      d,
      f
    ]
  }, p = {
    scope: "number",
    variants: [
      { begin: "\\b0[bB][01]+(?:_[01]+)*\\b" },
      // Binary w/ underscore support
      { begin: "\\b0[oO][0-7]+(?:_[0-7]+)*\\b" },
      // Octals w/ underscore support
      { begin: "\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b" },
      // Hex w/ underscore support
      // Decimals w/ underscore support, with optional fragments and scientific exponent (e) suffix.
      { begin: "(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?" }
    ],
    relevance: 0
  }, g = [
    "false",
    "null",
    "true"
  ], b = [
    // Magic constants:
    // <https://www.php.net/manual/en/language.constants.predefined.php>
    "__CLASS__",
    "__DIR__",
    "__FILE__",
    "__FUNCTION__",
    "__COMPILER_HALT_OFFSET__",
    "__LINE__",
    "__METHOD__",
    "__NAMESPACE__",
    "__TRAIT__",
    // Function that look like language construct or language construct that look like function:
    // List of keywords that may not require parenthesis
    "die",
    "echo",
    "exit",
    "include",
    "include_once",
    "print",
    "require",
    "require_once",
    // These are not language construct (function) but operate on the currently-executing function and can access the current symbol table
    // 'compact extract func_get_arg func_get_args func_num_args get_called_class get_parent_class ' +
    // Other keywords:
    // <https://www.php.net/manual/en/reserved.php>
    // <https://www.php.net/manual/en/language.types.type-juggling.php>
    "array",
    "abstract",
    "and",
    "as",
    "binary",
    "bool",
    "boolean",
    "break",
    "callable",
    "case",
    "catch",
    "class",
    "clone",
    "const",
    "continue",
    "declare",
    "default",
    "do",
    "double",
    "else",
    "elseif",
    "empty",
    "enddeclare",
    "endfor",
    "endforeach",
    "endif",
    "endswitch",
    "endwhile",
    "enum",
    "eval",
    "extends",
    "final",
    "finally",
    "float",
    "for",
    "foreach",
    "from",
    "global",
    "goto",
    "if",
    "implements",
    "instanceof",
    "insteadof",
    "int",
    "integer",
    "interface",
    "isset",
    "iterable",
    "list",
    "match|0",
    "mixed",
    "new",
    "never",
    "object",
    "or",
    "private",
    "protected",
    "public",
    "readonly",
    "real",
    "return",
    "string",
    "switch",
    "throw",
    "trait",
    "try",
    "unset",
    "use",
    "var",
    "void",
    "while",
    "xor",
    "yield"
  ], v = [
    // Standard PHP library:
    // <https://www.php.net/manual/en/book.spl.php>
    "Error|0",
    "AppendIterator",
    "ArgumentCountError",
    "ArithmeticError",
    "ArrayIterator",
    "ArrayObject",
    "AssertionError",
    "BadFunctionCallException",
    "BadMethodCallException",
    "CachingIterator",
    "CallbackFilterIterator",
    "CompileError",
    "Countable",
    "DirectoryIterator",
    "DivisionByZeroError",
    "DomainException",
    "EmptyIterator",
    "ErrorException",
    "Exception",
    "FilesystemIterator",
    "FilterIterator",
    "GlobIterator",
    "InfiniteIterator",
    "InvalidArgumentException",
    "IteratorIterator",
    "LengthException",
    "LimitIterator",
    "LogicException",
    "MultipleIterator",
    "NoRewindIterator",
    "OutOfBoundsException",
    "OutOfRangeException",
    "OuterIterator",
    "OverflowException",
    "ParentIterator",
    "ParseError",
    "RangeException",
    "RecursiveArrayIterator",
    "RecursiveCachingIterator",
    "RecursiveCallbackFilterIterator",
    "RecursiveDirectoryIterator",
    "RecursiveFilterIterator",
    "RecursiveIterator",
    "RecursiveIteratorIterator",
    "RecursiveRegexIterator",
    "RecursiveTreeIterator",
    "RegexIterator",
    "RuntimeException",
    "SeekableIterator",
    "SplDoublyLinkedList",
    "SplFileInfo",
    "SplFileObject",
    "SplFixedArray",
    "SplHeap",
    "SplMaxHeap",
    "SplMinHeap",
    "SplObjectStorage",
    "SplObserver",
    "SplPriorityQueue",
    "SplQueue",
    "SplStack",
    "SplSubject",
    "SplTempFileObject",
    "TypeError",
    "UnderflowException",
    "UnexpectedValueException",
    "UnhandledMatchError",
    // Reserved interfaces:
    // <https://www.php.net/manual/en/reserved.interfaces.php>
    "ArrayAccess",
    "BackedEnum",
    "Closure",
    "Fiber",
    "Generator",
    "Iterator",
    "IteratorAggregate",
    "Serializable",
    "Stringable",
    "Throwable",
    "Traversable",
    "UnitEnum",
    "WeakReference",
    "WeakMap",
    // Reserved classes:
    // <https://www.php.net/manual/en/reserved.classes.php>
    "Directory",
    "__PHP_Incomplete_Class",
    "parent",
    "php_user_filter",
    "self",
    "static",
    "stdClass"
  ], x = {
    keyword: b,
    literal: ((H) => {
      const G = [];
      return H.forEach((V) => {
        G.push(V), V.toLowerCase() === V ? G.push(V.toUpperCase()) : G.push(V.toLowerCase());
      }), G;
    })(g),
    built_in: v
  }, w = (H) => H.map((G) => G.replace(/\|\d+$/, "")), E = { variants: [
    {
      match: [
        /new/,
        e.concat(h, "+"),
        // to prevent built ins from being confused as the class constructor call
        e.concat("(?!", w(v).join("\\b|"), "\\b)"),
        o
      ],
      scope: {
        1: "keyword",
        4: "title.class"
      }
    }
  ] }, S = e.concat(r, "\\b(?!\\()"), C = { variants: [
    {
      match: [
        e.concat(
          /::/,
          e.lookahead(/(?!class\b)/)
        ),
        S
      ],
      scope: { 2: "variable.constant" }
    },
    {
      match: [
        /::/,
        /class/
      ],
      scope: { 2: "variable.language" }
    },
    {
      match: [
        o,
        e.concat(
          /::/,
          e.lookahead(/(?!class\b)/)
        ),
        S
      ],
      scope: {
        1: "title.class",
        3: "variable.constant"
      }
    },
    {
      match: [
        o,
        e.concat(
          "::",
          e.lookahead(/(?!class\b)/)
        )
      ],
      scope: { 1: "title.class" }
    },
    {
      match: [
        o,
        /::/,
        /class/
      ],
      scope: {
        1: "title.class",
        3: "variable.language"
      }
    }
  ] }, M = {
    scope: "attr",
    match: e.concat(r, e.lookahead(":"), e.lookahead(/(?!::)/))
  }, O = {
    relevance: 0,
    begin: /\(/,
    end: /\)/,
    keywords: x,
    contains: [
      M,
      s,
      C,
      t.C_BLOCK_COMMENT_MODE,
      m,
      p,
      E
    ]
  }, q = {
    relevance: 0,
    match: [
      /\b/,
      // to prevent keywords from being confused as the function title
      e.concat("(?!fn\\b|function\\b|", w(b).join("\\b|"), "|", w(v).join("\\b|"), "\\b)"),
      r,
      e.concat(h, "*"),
      e.lookahead(/(?=\()/)
    ],
    scope: { 3: "title.function.invoke" },
    contains: [O]
  };
  O.contains.push(q);
  const K = [
    M,
    C,
    t.C_BLOCK_COMMENT_MODE,
    m,
    p,
    E
  ], j = {
    begin: e.concat(
      /#\[\s*\\?/,
      e.either(
        o,
        i
      )
    ),
    beginScope: "meta",
    end: /]/,
    endScope: "meta",
    keywords: {
      literal: g,
      keyword: [
        "new",
        "array"
      ]
    },
    contains: [
      {
        begin: /\[/,
        end: /]/,
        keywords: {
          literal: g,
          keyword: [
            "new",
            "array"
          ]
        },
        contains: [
          "self",
          ...K
        ]
      },
      ...K,
      {
        scope: "meta",
        variants: [
          { match: o },
          { match: i }
        ]
      }
    ]
  };
  return {
    case_insensitive: !1,
    keywords: x,
    contains: [
      j,
      t.HASH_COMMENT_MODE,
      t.COMMENT("//", "$"),
      t.COMMENT(
        "/\\*",
        "\\*/",
        { contains: [
          {
            scope: "doctag",
            match: "@[A-Za-z]+"
          }
        ] }
      ),
      {
        match: /__halt_compiler\(\);/,
        keywords: "__halt_compiler",
        starts: {
          scope: "comment",
          end: t.MATCH_NOTHING_RE,
          contains: [
            {
              match: /\?>/,
              scope: "meta",
              endsParent: !0
            }
          ]
        }
      },
      a,
      {
        scope: "variable.language",
        match: /\$this\b/
      },
      s,
      q,
      C,
      {
        match: [
          /const/,
          /\s/,
          r
        ],
        scope: {
          1: "keyword",
          3: "variable.constant"
        }
      },
      E,
      {
        scope: "function",
        relevance: 0,
        beginKeywords: "fn function",
        end: /[;{]/,
        excludeEnd: !0,
        illegal: "[$%\\[]",
        contains: [
          { beginKeywords: "use" },
          t.UNDERSCORE_TITLE_MODE,
          {
            begin: "=>",
            // No markup, just a relevance booster
            endsParent: !0
          },
          {
            scope: "params",
            begin: "\\(",
            end: "\\)",
            excludeBegin: !0,
            excludeEnd: !0,
            keywords: x,
            contains: [
              "self",
              j,
              s,
              C,
              t.C_BLOCK_COMMENT_MODE,
              m,
              p
            ]
          }
        ]
      },
      {
        scope: "class",
        variants: [
          {
            beginKeywords: "enum",
            illegal: /[($"]/
          },
          {
            beginKeywords: "class interface trait",
            illegal: /[:($"]/
          }
        ],
        relevance: 0,
        end: /\{/,
        excludeEnd: !0,
        contains: [
          { beginKeywords: "extends implements" },
          t.UNDERSCORE_TITLE_MODE
        ]
      },
      // both use and namespace still use "old style" rules (vs multi-match)
      // because the namespace name can include `\` and we still want each
      // element to be treated as its own *individual* title
      {
        beginKeywords: "namespace",
        relevance: 0,
        end: ";",
        illegal: /[.']/,
        contains: [t.inherit(t.UNDERSCORE_TITLE_MODE, { scope: "title.class" })]
      },
      {
        beginKeywords: "use",
        relevance: 0,
        end: ";",
        contains: [
          // TODO: title.function vs title.class
          {
            match: /\b(as|const|function)\b/,
            scope: "keyword"
          },
          // TODO: could be title.class or title.function
          t.UNDERSCORE_TITLE_MODE
        ]
      },
      m,
      p
    ]
  };
}
function vI(t) {
  return {
    name: "PHP template",
    subLanguage: "xml",
    contains: [
      {
        begin: /<\?(php|=)?/,
        end: /\?>/,
        subLanguage: "php",
        contains: [
          // We don't want the php closing tag ?> to close the PHP block when
          // inside any of the following blocks:
          {
            begin: "/\\*",
            end: "\\*/",
            skip: !0
          },
          {
            begin: 'b"',
            end: '"',
            skip: !0
          },
          {
            begin: "b'",
            end: "'",
            skip: !0
          },
          t.inherit(t.APOS_STRING_MODE, {
            illegal: null,
            className: null,
            contains: null,
            skip: !0
          }),
          t.inherit(t.QUOTE_STRING_MODE, {
            illegal: null,
            className: null,
            contains: null,
            skip: !0
          })
        ]
      }
    ]
  };
}
function wI(t) {
  return {
    name: "Plain text",
    aliases: [
      "text",
      "txt"
    ],
    disableAutodetect: !0
  };
}
function kI(t) {
  const e = t.regex, n = new RegExp("[\\p{XID_Start}_]\\p{XID_Continue}*", "u"), r = [
    "and",
    "as",
    "assert",
    "async",
    "await",
    "break",
    "case",
    "class",
    "continue",
    "def",
    "del",
    "elif",
    "else",
    "except",
    "finally",
    "for",
    "from",
    "global",
    "if",
    "import",
    "in",
    "is",
    "lambda",
    "match",
    "nonlocal|10",
    "not",
    "or",
    "pass",
    "raise",
    "return",
    "try",
    "while",
    "with",
    "yield"
  ], a = {
    $pattern: /[A-Za-z]\w+|__\w+__/,
    keyword: r,
    built_in: [
      "__import__",
      "abs",
      "all",
      "any",
      "ascii",
      "bin",
      "bool",
      "breakpoint",
      "bytearray",
      "bytes",
      "callable",
      "chr",
      "classmethod",
      "compile",
      "complex",
      "delattr",
      "dict",
      "dir",
      "divmod",
      "enumerate",
      "eval",
      "exec",
      "filter",
      "float",
      "format",
      "frozenset",
      "getattr",
      "globals",
      "hasattr",
      "hash",
      "help",
      "hex",
      "id",
      "input",
      "int",
      "isinstance",
      "issubclass",
      "iter",
      "len",
      "list",
      "locals",
      "map",
      "max",
      "memoryview",
      "min",
      "next",
      "object",
      "oct",
      "open",
      "ord",
      "pow",
      "print",
      "property",
      "range",
      "repr",
      "reversed",
      "round",
      "set",
      "setattr",
      "slice",
      "sorted",
      "staticmethod",
      "str",
      "sum",
      "super",
      "tuple",
      "type",
      "vars",
      "zip"
    ],
    literal: [
      "__debug__",
      "Ellipsis",
      "False",
      "None",
      "NotImplemented",
      "True"
    ],
    type: [
      "Any",
      "Callable",
      "Coroutine",
      "Dict",
      "List",
      "Literal",
      "Generic",
      "Optional",
      "Sequence",
      "Set",
      "Tuple",
      "Type",
      "Union"
    ]
  }, l = {
    className: "meta",
    begin: /^(>>>|\.\.\.) /
  }, c = {
    className: "subst",
    begin: /\{/,
    end: /\}/,
    keywords: a,
    illegal: /#/
  }, u = {
    begin: /\{\{/,
    relevance: 0
  }, d = {
    className: "string",
    contains: [t.BACKSLASH_ESCAPE],
    variants: [
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/,
        end: /'''/,
        contains: [
          t.BACKSLASH_ESCAPE,
          l
        ],
        relevance: 10
      },
      {
        begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/,
        end: /"""/,
        contains: [
          t.BACKSLASH_ESCAPE,
          l
        ],
        relevance: 10
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'''/,
        end: /'''/,
        contains: [
          t.BACKSLASH_ESCAPE,
          l,
          u,
          c
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"""/,
        end: /"""/,
        contains: [
          t.BACKSLASH_ESCAPE,
          l,
          u,
          c
        ]
      },
      {
        begin: /([uU]|[rR])'/,
        end: /'/,
        relevance: 10
      },
      {
        begin: /([uU]|[rR])"/,
        end: /"/,
        relevance: 10
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])'/,
        end: /'/
      },
      {
        begin: /([bB]|[bB][rR]|[rR][bB])"/,
        end: /"/
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])'/,
        end: /'/,
        contains: [
          t.BACKSLASH_ESCAPE,
          u,
          c
        ]
      },
      {
        begin: /([fF][rR]|[rR][fF]|[fF])"/,
        end: /"/,
        contains: [
          t.BACKSLASH_ESCAPE,
          u,
          c
        ]
      },
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE
    ]
  }, f = "[0-9](_?[0-9])*", h = `(\\b(${f}))?\\.(${f})|\\b(${f})\\.`, m = `\\b|${r.join("|")}`, p = {
    className: "number",
    relevance: 0,
    variants: [
      // exponentfloat, pointfloat
      // https://docs.python.org/3.9/reference/lexical_analysis.html#floating-point-literals
      // optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      // Note: no leading \b because floats can start with a decimal point
      // and we don't want to mishandle e.g. `fn(.5)`,
      // no trailing \b for pointfloat because it can end with a decimal point
      // and we don't want to mishandle e.g. `0..hex()`; this should be safe
      // because both MUST contain a decimal point and so cannot be confused with
      // the interior part of an identifier
      {
        begin: `(\\b(${f})|(${h}))[eE][+-]?(${f})[jJ]?(?=${m})`
      },
      {
        begin: `(${h})[jJ]?`
      },
      // decinteger, bininteger, octinteger, hexinteger
      // https://docs.python.org/3.9/reference/lexical_analysis.html#integer-literals
      // optionally "long" in Python 2
      // https://docs.python.org/2.7/reference/lexical_analysis.html#integer-and-long-integer-literals
      // decinteger is optionally imaginary
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${m})`
      },
      {
        begin: `\\b0[bB](_?[01])+[lL]?(?=${m})`
      },
      {
        begin: `\\b0[oO](_?[0-7])+[lL]?(?=${m})`
      },
      {
        begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${m})`
      },
      // imagnumber (digitpart-based)
      // https://docs.python.org/3.9/reference/lexical_analysis.html#imaginary-literals
      {
        begin: `\\b(${f})[jJ](?=${m})`
      }
    ]
  }, g = {
    className: "comment",
    begin: e.lookahead(/# type:/),
    end: /$/,
    keywords: a,
    contains: [
      {
        // prevent keywords from coloring `type`
        begin: /# type:/
      },
      // comment within a datatype comment includes no keywords
      {
        begin: /#/,
        end: /\b\B/,
        endsWithParent: !0
      }
    ]
  }, b = {
    className: "params",
    variants: [
      // Exclude params in functions without params
      {
        className: "",
        begin: /\(\s*\)/,
        skip: !0
      },
      {
        begin: /\(/,
        end: /\)/,
        excludeBegin: !0,
        excludeEnd: !0,
        keywords: a,
        contains: [
          "self",
          l,
          p,
          d,
          t.HASH_COMMENT_MODE
        ]
      }
    ]
  };
  return c.contains = [
    d,
    p,
    l
  ], {
    name: "Python",
    aliases: [
      "py",
      "gyp",
      "ipython"
    ],
    unicodeRegex: !0,
    keywords: a,
    illegal: /(<\/|\?)|=>/,
    contains: [
      l,
      p,
      {
        // very common convention
        scope: "variable.language",
        match: /\bself\b/
      },
      {
        // eat "if" prior to string so that it won't accidentally be
        // labeled as an f-string
        beginKeywords: "if",
        relevance: 0
      },
      { match: /\bor\b/, scope: "keyword" },
      d,
      g,
      t.HASH_COMMENT_MODE,
      {
        match: [
          /\bdef/,
          /\s+/,
          n
        ],
        scope: {
          1: "keyword",
          3: "title.function"
        },
        contains: [b]
      },
      {
        variants: [
          {
            match: [
              /\bclass/,
              /\s+/,
              n,
              /\s*/,
              /\(\s*/,
              n,
              /\s*\)/
            ]
          },
          {
            match: [
              /\bclass/,
              /\s+/,
              n
            ]
          }
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          6: "title.class.inherited"
        }
      },
      {
        className: "meta",
        begin: /^[\t ]*@/,
        end: /(?=#)|$/,
        contains: [
          p,
          b,
          d
        ]
      }
    ]
  };
}
function xI(t) {
  return {
    aliases: ["pycon"],
    contains: [
      {
        className: "meta.prompt",
        starts: {
          // a space separates the REPL prefix from the actual code
          // this is purely for cleaner HTML output
          end: / |$/,
          starts: {
            end: "$",
            subLanguage: "python"
          }
        },
        variants: [
          { begin: /^>>>(?=[ ]|$)/ },
          { begin: /^\.\.\.(?=[ ]|$)/ }
        ]
      }
    ]
  };
}
function NI(t) {
  const e = t.regex, n = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/, r = e.either(
    // Special case: only hexadecimal binary powers can contain fractions
    /0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/,
    // Hexadecimal numbers without fraction and optional binary power
    /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/,
    // Decimal numbers
    /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/
  ), o = /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/, i = e.either(
    /[()]/,
    /[{}]/,
    /\[\[/,
    /[[\]]/,
    /\\/,
    /,/
  );
  return {
    name: "R",
    keywords: {
      $pattern: n,
      keyword: "function if in break next repeat else for while",
      literal: "NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10",
      built_in: (
        // Builtin constants
        "LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm"
      )
    },
    contains: [
      // Roxygen comments
      t.COMMENT(
        /#'/,
        /$/,
        { contains: [
          {
            // Handle `@examples` separately to cause all subsequent code
            // until the next `@`-tag on its own line to be kept as-is,
            // preventing highlighting. This code is example R code, so nested
            // doctags shouldn’t be treated as such. See
            // `test/markup/r/roxygen.txt` for an example.
            scope: "doctag",
            match: /@examples/,
            starts: {
              end: e.lookahead(e.either(
                // end if another doc comment
                /\n^#'\s*(?=@[a-zA-Z]+)/,
                // or a line with no comment
                /\n^(?!#')/
              )),
              endsParent: !0
            }
          },
          {
            // Handle `@param` to highlight the parameter name following
            // after.
            scope: "doctag",
            begin: "@param",
            end: /$/,
            contains: [
              {
                scope: "variable",
                variants: [
                  { match: n },
                  { match: /`(?:\\.|[^`\\])+`/ }
                ],
                endsParent: !0
              }
            ]
          },
          {
            scope: "doctag",
            match: /@[a-zA-Z]+/
          },
          {
            scope: "keyword",
            match: /\\[a-zA-Z]+/
          }
        ] }
      ),
      t.HASH_COMMENT_MODE,
      {
        scope: "string",
        contains: [t.BACKSLASH_ESCAPE],
        variants: [
          t.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\(/,
            end: /\)(-*)"/
          }),
          t.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\{/,
            end: /\}(-*)"/
          }),
          t.END_SAME_AS_BEGIN({
            begin: /[rR]"(-*)\[/,
            end: /\](-*)"/
          }),
          t.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\(/,
            end: /\)(-*)'/
          }),
          t.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\{/,
            end: /\}(-*)'/
          }),
          t.END_SAME_AS_BEGIN({
            begin: /[rR]'(-*)\[/,
            end: /\](-*)'/
          }),
          {
            begin: '"',
            end: '"',
            relevance: 0
          },
          {
            begin: "'",
            end: "'",
            relevance: 0
          }
        ]
      },
      // Matching numbers immediately following punctuation and operators is
      // tricky since we need to look at the character ahead of a number to
      // ensure the number is not part of an identifier, and we cannot use
      // negative look-behind assertions. So instead we explicitly handle all
      // possible combinations of (operator|punctuation), number.
      // TODO: replace with negative look-behind when available
      // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/ },
      // { begin: /(?<![a-zA-Z0-9._])0[xX][0-9a-fA-F]+([pP][+-]?\d+)?[Li]?/ },
      // { begin: /(?<![a-zA-Z0-9._])(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?[Li]?/ }
      {
        relevance: 0,
        variants: [
          {
            scope: {
              1: "operator",
              2: "number"
            },
            match: [
              o,
              r
            ]
          },
          {
            scope: {
              1: "operator",
              2: "number"
            },
            match: [
              /%[^%]*%/,
              r
            ]
          },
          {
            scope: {
              1: "punctuation",
              2: "number"
            },
            match: [
              i,
              r
            ]
          },
          {
            scope: { 2: "number" },
            match: [
              /[^a-zA-Z0-9._]|^/,
              // not part of an identifier, or start of document
              r
            ]
          }
        ]
      },
      // Operators/punctuation when they're not directly followed by numbers
      {
        // Relevance boost for the most common assignment form.
        scope: { 3: "operator" },
        match: [
          n,
          /\s+/,
          /<-/,
          /\s+/
        ]
      },
      {
        scope: "operator",
        relevance: 0,
        variants: [
          { match: o },
          { match: /%[^%]*%/ }
        ]
      },
      {
        scope: "punctuation",
        relevance: 0,
        match: i
      },
      {
        // Escaped identifier
        begin: "`",
        end: "`",
        contains: [{ begin: /\\./ }]
      }
    ]
  };
}
function EI(t) {
  const e = t.regex, n = "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)", r = e.either(
    /\b([A-Z]+[a-z0-9]+)+/,
    // ends in caps
    /\b([A-Z]+[a-z0-9]+)+[A-Z]+/
  ), o = e.concat(r, /(::\w+)*/), s = {
    "variable.constant": [
      "__FILE__",
      "__LINE__",
      "__ENCODING__"
    ],
    "variable.language": [
      "self",
      "super"
    ],
    keyword: [
      "alias",
      "and",
      "begin",
      "BEGIN",
      "break",
      "case",
      "class",
      "defined",
      "do",
      "else",
      "elsif",
      "end",
      "END",
      "ensure",
      "for",
      "if",
      "in",
      "module",
      "next",
      "not",
      "or",
      "redo",
      "require",
      "rescue",
      "retry",
      "return",
      "then",
      "undef",
      "unless",
      "until",
      "when",
      "while",
      "yield",
      ...[
        "include",
        "extend",
        "prepend",
        "public",
        "private",
        "protected",
        "raise",
        "throw"
      ]
    ],
    built_in: [
      "proc",
      "lambda",
      "attr_accessor",
      "attr_reader",
      "attr_writer",
      "define_method",
      "private_constant",
      "module_function"
    ],
    literal: [
      "true",
      "false",
      "nil"
    ]
  }, a = {
    className: "doctag",
    begin: "@[A-Za-z]+"
  }, l = {
    begin: "#<",
    end: ">"
  }, c = [
    t.COMMENT(
      "#",
      "$",
      { contains: [a] }
    ),
    t.COMMENT(
      "^=begin",
      "^=end",
      {
        contains: [a],
        relevance: 10
      }
    ),
    t.COMMENT("^__END__", t.MATCH_NOTHING_RE)
  ], u = {
    className: "subst",
    begin: /#\{/,
    end: /\}/,
    keywords: s
  }, d = {
    className: "string",
    contains: [
      t.BACKSLASH_ESCAPE,
      u
    ],
    variants: [
      {
        begin: /'/,
        end: /'/
      },
      {
        begin: /"/,
        end: /"/
      },
      {
        begin: /`/,
        end: /`/
      },
      {
        begin: /%[qQwWx]?\(/,
        end: /\)/
      },
      {
        begin: /%[qQwWx]?\[/,
        end: /\]/
      },
      {
        begin: /%[qQwWx]?\{/,
        end: /\}/
      },
      {
        begin: /%[qQwWx]?</,
        end: />/
      },
      {
        begin: /%[qQwWx]?\//,
        end: /\//
      },
      {
        begin: /%[qQwWx]?%/,
        end: /%/
      },
      {
        begin: /%[qQwWx]?-/,
        end: /-/
      },
      {
        begin: /%[qQwWx]?\|/,
        end: /\|/
      },
      // in the following expressions, \B in the beginning suppresses recognition of ?-sequences
      // where ? is the last character of a preceding identifier, as in: `func?4`
      { begin: /\B\?(\\\d{1,3})/ },
      { begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ },
      { begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ },
      { begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/ },
      { begin: /\B\?\\(c|C-)[\x20-\x7e]/ },
      { begin: /\B\?\\?\S/ },
      // heredocs
      {
        // this guard makes sure that we have an entire heredoc and not a false
        // positive (auto-detect, etc.)
        begin: e.concat(
          /<<[-~]?'?/,
          e.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)
        ),
        contains: [
          t.END_SAME_AS_BEGIN({
            begin: /(\w+)/,
            end: /(\w+)/,
            contains: [
              t.BACKSLASH_ESCAPE,
              u
            ]
          })
        ]
      }
    ]
  }, f = "[1-9](_?[0-9])*|0", h = "[0-9](_?[0-9])*", m = {
    className: "number",
    relevance: 0,
    variants: [
      // decimal integer/float, optionally exponential or rational, optionally imaginary
      { begin: `\\b(${f})(\\.(${h}))?([eE][+-]?(${h})|r)?i?\\b` },
      // explicit decimal/binary/octal/hexadecimal integer,
      // optionally rational and/or imaginary
      { begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b" },
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b" },
      // 0-prefixed implicit octal integer, optionally rational and/or imaginary
      { begin: "\\b0(_?[0-7])+r?i?\\b" }
    ]
  }, p = {
    variants: [
      {
        match: /\(\)/
      },
      {
        className: "params",
        begin: /\(/,
        end: /(?=\))/,
        excludeBegin: !0,
        endsParent: !0,
        keywords: s
      }
    ]
  }, E = [
    d,
    {
      variants: [
        {
          match: [
            /class\s+/,
            o,
            /\s+<\s+/,
            o
          ]
        },
        {
          match: [
            /\b(class|module)\s+/,
            o
          ]
        }
      ],
      scope: {
        2: "title.class",
        4: "title.class.inherited"
      },
      keywords: s
    },
    {
      match: [
        /(include|extend)\s+/,
        o
      ],
      scope: {
        2: "title.class"
      },
      keywords: s
    },
    {
      relevance: 0,
      match: [
        o,
        /\.new[. (]/
      ],
      scope: {
        1: "title.class"
      }
    },
    {
      relevance: 0,
      match: /\b[A-Z][A-Z_0-9]+\b/,
      className: "variable.constant"
    },
    {
      relevance: 0,
      match: r,
      scope: "title.class"
    },
    {
      match: [
        /def/,
        /\s+/,
        n
      ],
      scope: {
        1: "keyword",
        3: "title.function"
      },
      contains: [
        p
      ]
    },
    {
      // swallow namespace qualifiers before symbols
      begin: t.IDENT_RE + "::"
    },
    {
      className: "symbol",
      begin: t.UNDERSCORE_IDENT_RE + "(!|\\?)?:",
      relevance: 0
    },
    {
      className: "symbol",
      begin: ":(?!\\s)",
      contains: [
        d,
        { begin: n }
      ],
      relevance: 0
    },
    m,
    {
      // negative-look forward attempts to prevent false matches like:
      // @ident@ or $ident$ that might indicate this is not ruby at all
      className: "variable",
      begin: "(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])"
    },
    {
      className: "params",
      begin: /\|(?!=)/,
      end: /\|/,
      excludeBegin: !0,
      excludeEnd: !0,
      relevance: 0,
      // this could be a lot of things (in other languages) other than params
      keywords: s
    },
    {
      // regexp container
      begin: "(" + t.RE_STARTERS_RE + "|unless)\\s*",
      keywords: "unless",
      contains: [
        {
          className: "regexp",
          contains: [
            t.BACKSLASH_ESCAPE,
            u
          ],
          illegal: /\n/,
          variants: [
            {
              begin: "/",
              end: "/[a-z]*"
            },
            {
              begin: /%r\{/,
              end: /\}[a-z]*/
            },
            {
              begin: "%r\\(",
              end: "\\)[a-z]*"
            },
            {
              begin: "%r!",
              end: "![a-z]*"
            },
            {
              begin: "%r\\[",
              end: "\\][a-z]*"
            }
          ]
        }
      ].concat(l, c),
      relevance: 0
    }
  ].concat(l, c);
  u.contains = E, p.contains = E;
  const O = [
    {
      begin: /^\s*=>/,
      starts: {
        end: "$",
        contains: E
      }
    },
    {
      className: "meta.prompt",
      begin: "^(" + "[>?]>" + "|" + "[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]" + "|" + "(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>" + ")(?=[ ])",
      starts: {
        end: "$",
        keywords: s,
        contains: E
      }
    }
  ];
  return c.unshift(l), {
    name: "Ruby",
    aliases: [
      "rb",
      "gemspec",
      "podspec",
      "thor",
      "irb"
    ],
    keywords: s,
    illegal: /\/\*/,
    contains: [t.SHEBANG({ binary: "ruby" })].concat(O).concat(c).concat(E)
  };
}
function SI(t) {
  const e = t.regex, n = /(r#)?/, r = e.concat(n, t.UNDERSCORE_IDENT_RE), o = e.concat(n, t.IDENT_RE), i = {
    className: "title.function.invoke",
    relevance: 0,
    begin: e.concat(
      /\b/,
      /(?!let|for|while|if|else|match\b)/,
      o,
      e.lookahead(/\s*\(/)
    )
  }, s = "([ui](8|16|32|64|128|size)|f(32|64))?", a = [
    "abstract",
    "as",
    "async",
    "await",
    "become",
    "box",
    "break",
    "const",
    "continue",
    "crate",
    "do",
    "dyn",
    "else",
    "enum",
    "extern",
    "false",
    "final",
    "fn",
    "for",
    "if",
    "impl",
    "in",
    "let",
    "loop",
    "macro",
    "match",
    "mod",
    "move",
    "mut",
    "override",
    "priv",
    "pub",
    "ref",
    "return",
    "self",
    "Self",
    "static",
    "struct",
    "super",
    "trait",
    "true",
    "try",
    "type",
    "typeof",
    "union",
    "unsafe",
    "unsized",
    "use",
    "virtual",
    "where",
    "while",
    "yield"
  ], l = [
    "true",
    "false",
    "Some",
    "None",
    "Ok",
    "Err"
  ], c = [
    // functions
    "drop ",
    // traits
    "Copy",
    "Send",
    "Sized",
    "Sync",
    "Drop",
    "Fn",
    "FnMut",
    "FnOnce",
    "ToOwned",
    "Clone",
    "Debug",
    "PartialEq",
    "PartialOrd",
    "Eq",
    "Ord",
    "AsRef",
    "AsMut",
    "Into",
    "From",
    "Default",
    "Iterator",
    "Extend",
    "IntoIterator",
    "DoubleEndedIterator",
    "ExactSizeIterator",
    "SliceConcatExt",
    "ToString",
    // macros
    "assert!",
    "assert_eq!",
    "bitflags!",
    "bytes!",
    "cfg!",
    "col!",
    "concat!",
    "concat_idents!",
    "debug_assert!",
    "debug_assert_eq!",
    "env!",
    "eprintln!",
    "panic!",
    "file!",
    "format!",
    "format_args!",
    "include_bytes!",
    "include_str!",
    "line!",
    "local_data_key!",
    "module_path!",
    "option_env!",
    "print!",
    "println!",
    "select!",
    "stringify!",
    "try!",
    "unimplemented!",
    "unreachable!",
    "vec!",
    "write!",
    "writeln!",
    "macro_rules!",
    "assert_ne!",
    "debug_assert_ne!"
  ], u = [
    "i8",
    "i16",
    "i32",
    "i64",
    "i128",
    "isize",
    "u8",
    "u16",
    "u32",
    "u64",
    "u128",
    "usize",
    "f32",
    "f64",
    "str",
    "char",
    "bool",
    "Box",
    "Option",
    "Result",
    "String",
    "Vec"
  ];
  return {
    name: "Rust",
    aliases: ["rs"],
    keywords: {
      $pattern: t.IDENT_RE + "!?",
      type: u,
      keyword: a,
      literal: l,
      built_in: c
    },
    illegal: "</",
    contains: [
      t.C_LINE_COMMENT_MODE,
      t.COMMENT("/\\*", "\\*/", { contains: ["self"] }),
      t.inherit(t.QUOTE_STRING_MODE, {
        begin: /b?"/,
        illegal: null
      }),
      {
        className: "symbol",
        // negative lookahead to avoid matching `'`
        begin: /'[a-zA-Z_][a-zA-Z0-9_]*(?!')/
      },
      {
        scope: "string",
        variants: [
          { begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ },
          {
            begin: /b?'/,
            end: /'/,
            contains: [
              {
                scope: "char.escape",
                match: /\\('|\w|x\w{2}|u\w{4}|U\w{8})/
              }
            ]
          }
        ]
      },
      {
        className: "number",
        variants: [
          { begin: "\\b0b([01_]+)" + s },
          { begin: "\\b0o([0-7_]+)" + s },
          { begin: "\\b0x([A-Fa-f0-9_]+)" + s },
          { begin: "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + s }
        ],
        relevance: 0
      },
      {
        begin: [
          /fn/,
          /\s+/,
          r
        ],
        className: {
          1: "keyword",
          3: "title.function"
        }
      },
      {
        className: "meta",
        begin: "#!?\\[",
        end: "\\]",
        contains: [
          {
            className: "string",
            begin: /"/,
            end: /"/,
            contains: [
              t.BACKSLASH_ESCAPE
            ]
          }
        ]
      },
      {
        begin: [
          /let/,
          /\s+/,
          /(?:mut\s+)?/,
          r
        ],
        className: {
          1: "keyword",
          3: "keyword",
          4: "variable"
        }
      },
      // must come before impl/for rule later
      {
        begin: [
          /for/,
          /\s+/,
          r,
          /\s+/,
          /in/
        ],
        className: {
          1: "keyword",
          3: "variable",
          5: "keyword"
        }
      },
      {
        begin: [
          /type/,
          /\s+/,
          r
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        begin: [
          /(?:trait|enum|struct|union|impl|for)/,
          /\s+/,
          r
        ],
        className: {
          1: "keyword",
          3: "title.class"
        }
      },
      {
        begin: t.IDENT_RE + "::",
        keywords: {
          keyword: "Self",
          built_in: c,
          type: u
        }
      },
      {
        className: "punctuation",
        begin: "->"
      },
      i
    ]
  };
}
const TI = (t) => ({
  IMPORTANT: {
    scope: "meta",
    begin: "!important"
  },
  BLOCK_COMMENT: t.C_BLOCK_COMMENT_MODE,
  HEXCOLOR: {
    scope: "number",
    begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/
  },
  FUNCTION_DISPATCH: {
    className: "built_in",
    begin: /[\w-]+(?=\()/
  },
  ATTRIBUTE_SELECTOR_MODE: {
    scope: "selector-attr",
    begin: /\[/,
    end: /\]/,
    illegal: "$",
    contains: [
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE
    ]
  },
  CSS_NUMBER_MODE: {
    scope: "number",
    begin: t.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?",
    relevance: 0
  },
  CSS_VARIABLE: {
    className: "attr",
    begin: /--[A-Za-z_][A-Za-z0-9_-]*/
  }
}), CI = [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "audio",
  "b",
  "blockquote",
  "body",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "header",
  "hgroup",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "mark",
  "menu",
  "nav",
  "object",
  "ol",
  "optgroup",
  "option",
  "p",
  "picture",
  "q",
  "quote",
  "samp",
  "section",
  "select",
  "source",
  "span",
  "strong",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "ul",
  "var",
  "video"
], MI = [
  "defs",
  "g",
  "marker",
  "mask",
  "pattern",
  "svg",
  "switch",
  "symbol",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feFlood",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMorphology",
  "feOffset",
  "feSpecularLighting",
  "feTile",
  "feTurbulence",
  "linearGradient",
  "radialGradient",
  "stop",
  "circle",
  "ellipse",
  "image",
  "line",
  "path",
  "polygon",
  "polyline",
  "rect",
  "text",
  "use",
  "textPath",
  "tspan",
  "foreignObject",
  "clipPath"
], AI = [
  ...CI,
  ...MI
], _I = [
  "any-hover",
  "any-pointer",
  "aspect-ratio",
  "color",
  "color-gamut",
  "color-index",
  "device-aspect-ratio",
  "device-height",
  "device-width",
  "display-mode",
  "forced-colors",
  "grid",
  "height",
  "hover",
  "inverted-colors",
  "monochrome",
  "orientation",
  "overflow-block",
  "overflow-inline",
  "pointer",
  "prefers-color-scheme",
  "prefers-contrast",
  "prefers-reduced-motion",
  "prefers-reduced-transparency",
  "resolution",
  "scan",
  "scripting",
  "update",
  "width",
  // TODO: find a better solution?
  "min-width",
  "max-width",
  "min-height",
  "max-height"
].sort().reverse(), RI = [
  "active",
  "any-link",
  "blank",
  "checked",
  "current",
  "default",
  "defined",
  "dir",
  // dir()
  "disabled",
  "drop",
  "empty",
  "enabled",
  "first",
  "first-child",
  "first-of-type",
  "fullscreen",
  "future",
  "focus",
  "focus-visible",
  "focus-within",
  "has",
  // has()
  "host",
  // host or host()
  "host-context",
  // host-context()
  "hover",
  "indeterminate",
  "in-range",
  "invalid",
  "is",
  // is()
  "lang",
  // lang()
  "last-child",
  "last-of-type",
  "left",
  "link",
  "local-link",
  "not",
  // not()
  "nth-child",
  // nth-child()
  "nth-col",
  // nth-col()
  "nth-last-child",
  // nth-last-child()
  "nth-last-col",
  // nth-last-col()
  "nth-last-of-type",
  //nth-last-of-type()
  "nth-of-type",
  //nth-of-type()
  "only-child",
  "only-of-type",
  "optional",
  "out-of-range",
  "past",
  "placeholder-shown",
  "read-only",
  "read-write",
  "required",
  "right",
  "root",
  "scope",
  "target",
  "target-within",
  "user-invalid",
  "valid",
  "visited",
  "where"
  // where()
].sort().reverse(), OI = [
  "after",
  "backdrop",
  "before",
  "cue",
  "cue-region",
  "first-letter",
  "first-line",
  "grammar-error",
  "marker",
  "part",
  "placeholder",
  "selection",
  "slotted",
  "spelling-error"
].sort().reverse(), II = [
  "accent-color",
  "align-content",
  "align-items",
  "align-self",
  "alignment-baseline",
  "all",
  "anchor-name",
  "animation",
  "animation-composition",
  "animation-delay",
  "animation-direction",
  "animation-duration",
  "animation-fill-mode",
  "animation-iteration-count",
  "animation-name",
  "animation-play-state",
  "animation-range",
  "animation-range-end",
  "animation-range-start",
  "animation-timeline",
  "animation-timing-function",
  "appearance",
  "aspect-ratio",
  "backdrop-filter",
  "backface-visibility",
  "background",
  "background-attachment",
  "background-blend-mode",
  "background-clip",
  "background-color",
  "background-image",
  "background-origin",
  "background-position",
  "background-position-x",
  "background-position-y",
  "background-repeat",
  "background-size",
  "baseline-shift",
  "block-size",
  "border",
  "border-block",
  "border-block-color",
  "border-block-end",
  "border-block-end-color",
  "border-block-end-style",
  "border-block-end-width",
  "border-block-start",
  "border-block-start-color",
  "border-block-start-style",
  "border-block-start-width",
  "border-block-style",
  "border-block-width",
  "border-bottom",
  "border-bottom-color",
  "border-bottom-left-radius",
  "border-bottom-right-radius",
  "border-bottom-style",
  "border-bottom-width",
  "border-collapse",
  "border-color",
  "border-end-end-radius",
  "border-end-start-radius",
  "border-image",
  "border-image-outset",
  "border-image-repeat",
  "border-image-slice",
  "border-image-source",
  "border-image-width",
  "border-inline",
  "border-inline-color",
  "border-inline-end",
  "border-inline-end-color",
  "border-inline-end-style",
  "border-inline-end-width",
  "border-inline-start",
  "border-inline-start-color",
  "border-inline-start-style",
  "border-inline-start-width",
  "border-inline-style",
  "border-inline-width",
  "border-left",
  "border-left-color",
  "border-left-style",
  "border-left-width",
  "border-radius",
  "border-right",
  "border-right-color",
  "border-right-style",
  "border-right-width",
  "border-spacing",
  "border-start-end-radius",
  "border-start-start-radius",
  "border-style",
  "border-top",
  "border-top-color",
  "border-top-left-radius",
  "border-top-right-radius",
  "border-top-style",
  "border-top-width",
  "border-width",
  "bottom",
  "box-align",
  "box-decoration-break",
  "box-direction",
  "box-flex",
  "box-flex-group",
  "box-lines",
  "box-ordinal-group",
  "box-orient",
  "box-pack",
  "box-shadow",
  "box-sizing",
  "break-after",
  "break-before",
  "break-inside",
  "caption-side",
  "caret-color",
  "clear",
  "clip",
  "clip-path",
  "clip-rule",
  "color",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "color-scheme",
  "column-count",
  "column-fill",
  "column-gap",
  "column-rule",
  "column-rule-color",
  "column-rule-style",
  "column-rule-width",
  "column-span",
  "column-width",
  "columns",
  "contain",
  "contain-intrinsic-block-size",
  "contain-intrinsic-height",
  "contain-intrinsic-inline-size",
  "contain-intrinsic-size",
  "contain-intrinsic-width",
  "container",
  "container-name",
  "container-type",
  "content",
  "content-visibility",
  "counter-increment",
  "counter-reset",
  "counter-set",
  "cue",
  "cue-after",
  "cue-before",
  "cursor",
  "cx",
  "cy",
  "direction",
  "display",
  "dominant-baseline",
  "empty-cells",
  "enable-background",
  "field-sizing",
  "fill",
  "fill-opacity",
  "fill-rule",
  "filter",
  "flex",
  "flex-basis",
  "flex-direction",
  "flex-flow",
  "flex-grow",
  "flex-shrink",
  "flex-wrap",
  "float",
  "flood-color",
  "flood-opacity",
  "flow",
  "font",
  "font-display",
  "font-family",
  "font-feature-settings",
  "font-kerning",
  "font-language-override",
  "font-optical-sizing",
  "font-palette",
  "font-size",
  "font-size-adjust",
  "font-smooth",
  "font-smoothing",
  "font-stretch",
  "font-style",
  "font-synthesis",
  "font-synthesis-position",
  "font-synthesis-small-caps",
  "font-synthesis-style",
  "font-synthesis-weight",
  "font-variant",
  "font-variant-alternates",
  "font-variant-caps",
  "font-variant-east-asian",
  "font-variant-emoji",
  "font-variant-ligatures",
  "font-variant-numeric",
  "font-variant-position",
  "font-variation-settings",
  "font-weight",
  "forced-color-adjust",
  "gap",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "grid",
  "grid-area",
  "grid-auto-columns",
  "grid-auto-flow",
  "grid-auto-rows",
  "grid-column",
  "grid-column-end",
  "grid-column-start",
  "grid-gap",
  "grid-row",
  "grid-row-end",
  "grid-row-start",
  "grid-template",
  "grid-template-areas",
  "grid-template-columns",
  "grid-template-rows",
  "hanging-punctuation",
  "height",
  "hyphenate-character",
  "hyphenate-limit-chars",
  "hyphens",
  "icon",
  "image-orientation",
  "image-rendering",
  "image-resolution",
  "ime-mode",
  "initial-letter",
  "initial-letter-align",
  "inline-size",
  "inset",
  "inset-area",
  "inset-block",
  "inset-block-end",
  "inset-block-start",
  "inset-inline",
  "inset-inline-end",
  "inset-inline-start",
  "isolation",
  "justify-content",
  "justify-items",
  "justify-self",
  "kerning",
  "left",
  "letter-spacing",
  "lighting-color",
  "line-break",
  "line-height",
  "line-height-step",
  "list-style",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "margin",
  "margin-block",
  "margin-block-end",
  "margin-block-start",
  "margin-bottom",
  "margin-inline",
  "margin-inline-end",
  "margin-inline-start",
  "margin-left",
  "margin-right",
  "margin-top",
  "margin-trim",
  "marker",
  "marker-end",
  "marker-mid",
  "marker-start",
  "marks",
  "mask",
  "mask-border",
  "mask-border-mode",
  "mask-border-outset",
  "mask-border-repeat",
  "mask-border-slice",
  "mask-border-source",
  "mask-border-width",
  "mask-clip",
  "mask-composite",
  "mask-image",
  "mask-mode",
  "mask-origin",
  "mask-position",
  "mask-repeat",
  "mask-size",
  "mask-type",
  "masonry-auto-flow",
  "math-depth",
  "math-shift",
  "math-style",
  "max-block-size",
  "max-height",
  "max-inline-size",
  "max-width",
  "min-block-size",
  "min-height",
  "min-inline-size",
  "min-width",
  "mix-blend-mode",
  "nav-down",
  "nav-index",
  "nav-left",
  "nav-right",
  "nav-up",
  "none",
  "normal",
  "object-fit",
  "object-position",
  "offset",
  "offset-anchor",
  "offset-distance",
  "offset-path",
  "offset-position",
  "offset-rotate",
  "opacity",
  "order",
  "orphans",
  "outline",
  "outline-color",
  "outline-offset",
  "outline-style",
  "outline-width",
  "overflow",
  "overflow-anchor",
  "overflow-block",
  "overflow-clip-margin",
  "overflow-inline",
  "overflow-wrap",
  "overflow-x",
  "overflow-y",
  "overlay",
  "overscroll-behavior",
  "overscroll-behavior-block",
  "overscroll-behavior-inline",
  "overscroll-behavior-x",
  "overscroll-behavior-y",
  "padding",
  "padding-block",
  "padding-block-end",
  "padding-block-start",
  "padding-bottom",
  "padding-inline",
  "padding-inline-end",
  "padding-inline-start",
  "padding-left",
  "padding-right",
  "padding-top",
  "page",
  "page-break-after",
  "page-break-before",
  "page-break-inside",
  "paint-order",
  "pause",
  "pause-after",
  "pause-before",
  "perspective",
  "perspective-origin",
  "place-content",
  "place-items",
  "place-self",
  "pointer-events",
  "position",
  "position-anchor",
  "position-visibility",
  "print-color-adjust",
  "quotes",
  "r",
  "resize",
  "rest",
  "rest-after",
  "rest-before",
  "right",
  "rotate",
  "row-gap",
  "ruby-align",
  "ruby-position",
  "scale",
  "scroll-behavior",
  "scroll-margin",
  "scroll-margin-block",
  "scroll-margin-block-end",
  "scroll-margin-block-start",
  "scroll-margin-bottom",
  "scroll-margin-inline",
  "scroll-margin-inline-end",
  "scroll-margin-inline-start",
  "scroll-margin-left",
  "scroll-margin-right",
  "scroll-margin-top",
  "scroll-padding",
  "scroll-padding-block",
  "scroll-padding-block-end",
  "scroll-padding-block-start",
  "scroll-padding-bottom",
  "scroll-padding-inline",
  "scroll-padding-inline-end",
  "scroll-padding-inline-start",
  "scroll-padding-left",
  "scroll-padding-right",
  "scroll-padding-top",
  "scroll-snap-align",
  "scroll-snap-stop",
  "scroll-snap-type",
  "scroll-timeline",
  "scroll-timeline-axis",
  "scroll-timeline-name",
  "scrollbar-color",
  "scrollbar-gutter",
  "scrollbar-width",
  "shape-image-threshold",
  "shape-margin",
  "shape-outside",
  "shape-rendering",
  "speak",
  "speak-as",
  "src",
  // @font-face
  "stop-color",
  "stop-opacity",
  "stroke",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "tab-size",
  "table-layout",
  "text-align",
  "text-align-all",
  "text-align-last",
  "text-anchor",
  "text-combine-upright",
  "text-decoration",
  "text-decoration-color",
  "text-decoration-line",
  "text-decoration-skip",
  "text-decoration-skip-ink",
  "text-decoration-style",
  "text-decoration-thickness",
  "text-emphasis",
  "text-emphasis-color",
  "text-emphasis-position",
  "text-emphasis-style",
  "text-indent",
  "text-justify",
  "text-orientation",
  "text-overflow",
  "text-rendering",
  "text-shadow",
  "text-size-adjust",
  "text-transform",
  "text-underline-offset",
  "text-underline-position",
  "text-wrap",
  "text-wrap-mode",
  "text-wrap-style",
  "timeline-scope",
  "top",
  "touch-action",
  "transform",
  "transform-box",
  "transform-origin",
  "transform-style",
  "transition",
  "transition-behavior",
  "transition-delay",
  "transition-duration",
  "transition-property",
  "transition-timing-function",
  "translate",
  "unicode-bidi",
  "user-modify",
  "user-select",
  "vector-effect",
  "vertical-align",
  "view-timeline",
  "view-timeline-axis",
  "view-timeline-inset",
  "view-timeline-name",
  "view-transition-name",
  "visibility",
  "voice-balance",
  "voice-duration",
  "voice-family",
  "voice-pitch",
  "voice-range",
  "voice-rate",
  "voice-stress",
  "voice-volume",
  "white-space",
  "white-space-collapse",
  "widows",
  "width",
  "will-change",
  "word-break",
  "word-spacing",
  "word-wrap",
  "writing-mode",
  "x",
  "y",
  "z-index",
  "zoom"
].sort().reverse();
function DI(t) {
  const e = TI(t), n = OI, r = RI, o = "@[a-z-]+", i = "and or not only", a = {
    className: "variable",
    begin: "(\\$" + "[a-zA-Z-][a-zA-Z0-9_-]*" + ")\\b",
    relevance: 0
  };
  return {
    name: "SCSS",
    case_insensitive: !0,
    illegal: "[=/|']",
    contains: [
      t.C_LINE_COMMENT_MODE,
      t.C_BLOCK_COMMENT_MODE,
      // to recognize keyframe 40% etc which are outside the scope of our
      // attribute value mode
      e.CSS_NUMBER_MODE,
      {
        className: "selector-id",
        begin: "#[A-Za-z0-9_-]+",
        relevance: 0
      },
      {
        className: "selector-class",
        begin: "\\.[A-Za-z0-9_-]+",
        relevance: 0
      },
      e.ATTRIBUTE_SELECTOR_MODE,
      {
        className: "selector-tag",
        begin: "\\b(" + AI.join("|") + ")\\b",
        // was there, before, but why?
        relevance: 0
      },
      {
        className: "selector-pseudo",
        begin: ":(" + r.join("|") + ")"
      },
      {
        className: "selector-pseudo",
        begin: ":(:)?(" + n.join("|") + ")"
      },
      a,
      {
        // pseudo-selector params
        begin: /\(/,
        end: /\)/,
        contains: [e.CSS_NUMBER_MODE]
      },
      e.CSS_VARIABLE,
      {
        className: "attribute",
        begin: "\\b(" + II.join("|") + ")\\b"
      },
      { begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b" },
      {
        begin: /:/,
        end: /[;}{]/,
        relevance: 0,
        contains: [
          e.BLOCK_COMMENT,
          a,
          e.HEXCOLOR,
          e.CSS_NUMBER_MODE,
          t.QUOTE_STRING_MODE,
          t.APOS_STRING_MODE,
          e.IMPORTANT,
          e.FUNCTION_DISPATCH
        ]
      },
      // matching these here allows us to treat them more like regular CSS
      // rules so everything between the {} gets regular rule highlighting,
      // which is what we want for page and font-face
      {
        begin: "@(page|font-face)",
        keywords: {
          $pattern: o,
          keyword: "@page @font-face"
        }
      },
      {
        begin: "@",
        end: "[{;]",
        returnBegin: !0,
        keywords: {
          $pattern: /[a-z-]+/,
          keyword: i,
          attribute: _I.join(" ")
        },
        contains: [
          {
            begin: o,
            className: "keyword"
          },
          {
            begin: /[a-z-]+(?=:)/,
            className: "attribute"
          },
          a,
          t.QUOTE_STRING_MODE,
          t.APOS_STRING_MODE,
          e.HEXCOLOR,
          e.CSS_NUMBER_MODE
        ]
      },
      e.FUNCTION_DISPATCH
    ]
  };
}
function LI(t) {
  return {
    name: "Shell Session",
    aliases: [
      "console",
      "shellsession"
    ],
    contains: [
      {
        className: "meta.prompt",
        // We cannot add \s (spaces) in the regular expression otherwise it will be too broad and produce unexpected result.
        // For instance, in the following example, it would match "echo /path/to/home >" as a prompt:
        // echo /path/to/home > t.exe
        begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/,
        starts: {
          end: /[^\\](?=\s*$)/,
          subLanguage: "bash"
        }
      }
    ]
  };
}
function PI(t) {
  const e = t.regex, n = t.COMMENT("--", "$"), r = {
    scope: "string",
    variants: [
      {
        begin: /'/,
        end: /'/,
        contains: [{ match: /''/ }]
      }
    ]
  }, o = {
    begin: /"/,
    end: /"/,
    contains: [{ match: /""/ }]
  }, i = [
    "true",
    "false",
    // Not sure it's correct to call NULL literal, and clauses like IS [NOT] NULL look strange that way.
    // "null",
    "unknown"
  ], s = [
    "double precision",
    "large object",
    "with timezone",
    "without timezone"
  ], a = [
    "bigint",
    "binary",
    "blob",
    "boolean",
    "char",
    "character",
    "clob",
    "date",
    "dec",
    "decfloat",
    "decimal",
    "float",
    "int",
    "integer",
    "interval",
    "nchar",
    "nclob",
    "national",
    "numeric",
    "real",
    "row",
    "smallint",
    "time",
    "timestamp",
    "varchar",
    "varying",
    // modifier (character varying)
    "varbinary"
  ], l = [
    "add",
    "asc",
    "collation",
    "desc",
    "final",
    "first",
    "last",
    "view"
  ], c = [
    "abs",
    "acos",
    "all",
    "allocate",
    "alter",
    "and",
    "any",
    "are",
    "array",
    "array_agg",
    "array_max_cardinality",
    "as",
    "asensitive",
    "asin",
    "asymmetric",
    "at",
    "atan",
    "atomic",
    "authorization",
    "avg",
    "begin",
    "begin_frame",
    "begin_partition",
    "between",
    "bigint",
    "binary",
    "blob",
    "boolean",
    "both",
    "by",
    "call",
    "called",
    "cardinality",
    "cascaded",
    "case",
    "cast",
    "ceil",
    "ceiling",
    "char",
    "char_length",
    "character",
    "character_length",
    "check",
    "classifier",
    "clob",
    "close",
    "coalesce",
    "collate",
    "collect",
    "column",
    "commit",
    "condition",
    "connect",
    "constraint",
    "contains",
    "convert",
    "copy",
    "corr",
    "corresponding",
    "cos",
    "cosh",
    "count",
    "covar_pop",
    "covar_samp",
    "create",
    "cross",
    "cube",
    "cume_dist",
    "current",
    "current_catalog",
    "current_date",
    "current_default_transform_group",
    "current_path",
    "current_role",
    "current_row",
    "current_schema",
    "current_time",
    "current_timestamp",
    "current_path",
    "current_role",
    "current_transform_group_for_type",
    "current_user",
    "cursor",
    "cycle",
    "date",
    "day",
    "deallocate",
    "dec",
    "decimal",
    "decfloat",
    "declare",
    "default",
    "define",
    "delete",
    "dense_rank",
    "deref",
    "describe",
    "deterministic",
    "disconnect",
    "distinct",
    "double",
    "drop",
    "dynamic",
    "each",
    "element",
    "else",
    "empty",
    "end",
    "end_frame",
    "end_partition",
    "end-exec",
    "equals",
    "escape",
    "every",
    "except",
    "exec",
    "execute",
    "exists",
    "exp",
    "external",
    "extract",
    "false",
    "fetch",
    "filter",
    "first_value",
    "float",
    "floor",
    "for",
    "foreign",
    "frame_row",
    "free",
    "from",
    "full",
    "function",
    "fusion",
    "get",
    "global",
    "grant",
    "group",
    "grouping",
    "groups",
    "having",
    "hold",
    "hour",
    "identity",
    "in",
    "indicator",
    "initial",
    "inner",
    "inout",
    "insensitive",
    "insert",
    "int",
    "integer",
    "intersect",
    "intersection",
    "interval",
    "into",
    "is",
    "join",
    "json_array",
    "json_arrayagg",
    "json_exists",
    "json_object",
    "json_objectagg",
    "json_query",
    "json_table",
    "json_table_primitive",
    "json_value",
    "lag",
    "language",
    "large",
    "last_value",
    "lateral",
    "lead",
    "leading",
    "left",
    "like",
    "like_regex",
    "listagg",
    "ln",
    "local",
    "localtime",
    "localtimestamp",
    "log",
    "log10",
    "lower",
    "match",
    "match_number",
    "match_recognize",
    "matches",
    "max",
    "member",
    "merge",
    "method",
    "min",
    "minute",
    "mod",
    "modifies",
    "module",
    "month",
    "multiset",
    "national",
    "natural",
    "nchar",
    "nclob",
    "new",
    "no",
    "none",
    "normalize",
    "not",
    "nth_value",
    "ntile",
    "null",
    "nullif",
    "numeric",
    "octet_length",
    "occurrences_regex",
    "of",
    "offset",
    "old",
    "omit",
    "on",
    "one",
    "only",
    "open",
    "or",
    "order",
    "out",
    "outer",
    "over",
    "overlaps",
    "overlay",
    "parameter",
    "partition",
    "pattern",
    "per",
    "percent",
    "percent_rank",
    "percentile_cont",
    "percentile_disc",
    "period",
    "portion",
    "position",
    "position_regex",
    "power",
    "precedes",
    "precision",
    "prepare",
    "primary",
    "procedure",
    "ptf",
    "range",
    "rank",
    "reads",
    "real",
    "recursive",
    "ref",
    "references",
    "referencing",
    "regr_avgx",
    "regr_avgy",
    "regr_count",
    "regr_intercept",
    "regr_r2",
    "regr_slope",
    "regr_sxx",
    "regr_sxy",
    "regr_syy",
    "release",
    "result",
    "return",
    "returns",
    "revoke",
    "right",
    "rollback",
    "rollup",
    "row",
    "row_number",
    "rows",
    "running",
    "savepoint",
    "scope",
    "scroll",
    "search",
    "second",
    "seek",
    "select",
    "sensitive",
    "session_user",
    "set",
    "show",
    "similar",
    "sin",
    "sinh",
    "skip",
    "smallint",
    "some",
    "specific",
    "specifictype",
    "sql",
    "sqlexception",
    "sqlstate",
    "sqlwarning",
    "sqrt",
    "start",
    "static",
    "stddev_pop",
    "stddev_samp",
    "submultiset",
    "subset",
    "substring",
    "substring_regex",
    "succeeds",
    "sum",
    "symmetric",
    "system",
    "system_time",
    "system_user",
    "table",
    "tablesample",
    "tan",
    "tanh",
    "then",
    "time",
    "timestamp",
    "timezone_hour",
    "timezone_minute",
    "to",
    "trailing",
    "translate",
    "translate_regex",
    "translation",
    "treat",
    "trigger",
    "trim",
    "trim_array",
    "true",
    "truncate",
    "uescape",
    "union",
    "unique",
    "unknown",
    "unnest",
    "update",
    "upper",
    "user",
    "using",
    "value",
    "values",
    "value_of",
    "var_pop",
    "var_samp",
    "varbinary",
    "varchar",
    "varying",
    "versioning",
    "when",
    "whenever",
    "where",
    "width_bucket",
    "window",
    "with",
    "within",
    "without",
    "year"
  ], u = [
    "abs",
    "acos",
    "array_agg",
    "asin",
    "atan",
    "avg",
    "cast",
    "ceil",
    "ceiling",
    "coalesce",
    "corr",
    "cos",
    "cosh",
    "count",
    "covar_pop",
    "covar_samp",
    "cume_dist",
    "dense_rank",
    "deref",
    "element",
    "exp",
    "extract",
    "first_value",
    "floor",
    "json_array",
    "json_arrayagg",
    "json_exists",
    "json_object",
    "json_objectagg",
    "json_query",
    "json_table",
    "json_table_primitive",
    "json_value",
    "lag",
    "last_value",
    "lead",
    "listagg",
    "ln",
    "log",
    "log10",
    "lower",
    "max",
    "min",
    "mod",
    "nth_value",
    "ntile",
    "nullif",
    "percent_rank",
    "percentile_cont",
    "percentile_disc",
    "position",
    "position_regex",
    "power",
    "rank",
    "regr_avgx",
    "regr_avgy",
    "regr_count",
    "regr_intercept",
    "regr_r2",
    "regr_slope",
    "regr_sxx",
    "regr_sxy",
    "regr_syy",
    "row_number",
    "sin",
    "sinh",
    "sqrt",
    "stddev_pop",
    "stddev_samp",
    "substring",
    "substring_regex",
    "sum",
    "tan",
    "tanh",
    "translate",
    "translate_regex",
    "treat",
    "trim",
    "trim_array",
    "unnest",
    "upper",
    "value_of",
    "var_pop",
    "var_samp",
    "width_bucket"
  ], d = [
    "current_catalog",
    "current_date",
    "current_default_transform_group",
    "current_path",
    "current_role",
    "current_schema",
    "current_transform_group_for_type",
    "current_user",
    "session_user",
    "system_time",
    "system_user",
    "current_time",
    "localtime",
    "current_timestamp",
    "localtimestamp"
  ], f = [
    "create table",
    "insert into",
    "primary key",
    "foreign key",
    "not null",
    "alter table",
    "add constraint",
    "grouping sets",
    "on overflow",
    "character set",
    "respect nulls",
    "ignore nulls",
    "nulls first",
    "nulls last",
    "depth first",
    "breadth first"
  ], h = u, m = [
    ...c,
    ...l
  ].filter((w) => !u.includes(w)), p = {
    scope: "variable",
    match: /@[a-z0-9][a-z0-9_]*/
  }, g = {
    scope: "operator",
    match: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/,
    relevance: 0
  }, b = {
    match: e.concat(/\b/, e.either(...h), /\s*\(/),
    relevance: 0,
    keywords: { built_in: h }
  };
  function v(w) {
    return e.concat(
      /\b/,
      e.either(...w.map((E) => E.replace(/\s+/, "\\s+"))),
      /\b/
    );
  }
  const k = {
    scope: "keyword",
    match: v(f),
    relevance: 0
  };
  function x(w, {
    exceptions: E,
    when: S
  } = {}) {
    const C = S;
    return E = E || [], w.map((M) => M.match(/\|\d+$/) || E.includes(M) ? M : C(M) ? `${M}|0` : M);
  }
  return {
    name: "SQL",
    case_insensitive: !0,
    // does not include {} or HTML tags `</`
    illegal: /[{}]|<\//,
    keywords: {
      $pattern: /\b[\w\.]+/,
      keyword: x(m, { when: (w) => w.length < 3 }),
      literal: i,
      type: a,
      built_in: d
    },
    contains: [
      {
        scope: "type",
        match: v(s)
      },
      k,
      b,
      p,
      r,
      o,
      t.C_NUMBER_MODE,
      t.C_BLOCK_COMMENT_MODE,
      n,
      g
    ]
  };
}
function Bv(t) {
  return t ? typeof t == "string" ? t : t.source : null;
}
function wi(t) {
  return Ue("(?=", t, ")");
}
function Ue(...t) {
  return t.map((n) => Bv(n)).join("");
}
function BI(t) {
  const e = t[t.length - 1];
  return typeof e == "object" && e.constructor === Object ? (t.splice(t.length - 1, 1), e) : {};
}
function It(...t) {
  return "(" + (BI(t).capture ? "" : "?:") + t.map((r) => Bv(r)).join("|") + ")";
}
const Qf = (t) => Ue(
  /\b/,
  t,
  /\w$/.test(t) ? /\b/ : /\B/
), zI = [
  "Protocol",
  // contextual
  "Type"
  // contextual
].map(Qf), tg = [
  "init",
  "self"
].map(Qf), $I = [
  "Any",
  "Self"
], yu = [
  // strings below will be fed into the regular `keywords` engine while regex
  // will result in additional modes being created to scan for those keywords to
  // avoid conflicts with other rules
  "actor",
  "any",
  // contextual
  "associatedtype",
  "async",
  "await",
  /as\?/,
  // operator
  /as!/,
  // operator
  "as",
  // operator
  "borrowing",
  // contextual
  "break",
  "case",
  "catch",
  "class",
  "consume",
  // contextual
  "consuming",
  // contextual
  "continue",
  "convenience",
  // contextual
  "copy",
  // contextual
  "default",
  "defer",
  "deinit",
  "didSet",
  // contextual
  "distributed",
  "do",
  "dynamic",
  // contextual
  "each",
  "else",
  "enum",
  "extension",
  "fallthrough",
  /fileprivate\(set\)/,
  "fileprivate",
  "final",
  // contextual
  "for",
  "func",
  "get",
  // contextual
  "guard",
  "if",
  "import",
  "indirect",
  // contextual
  "infix",
  // contextual
  /init\?/,
  /init!/,
  "inout",
  /internal\(set\)/,
  "internal",
  "in",
  "is",
  // operator
  "isolated",
  // contextual
  "nonisolated",
  // contextual
  "lazy",
  // contextual
  "let",
  "macro",
  "mutating",
  // contextual
  "nonmutating",
  // contextual
  /open\(set\)/,
  // contextual
  "open",
  // contextual
  "operator",
  "optional",
  // contextual
  "override",
  // contextual
  "package",
  "postfix",
  // contextual
  "precedencegroup",
  "prefix",
  // contextual
  /private\(set\)/,
  "private",
  "protocol",
  /public\(set\)/,
  "public",
  "repeat",
  "required",
  // contextual
  "rethrows",
  "return",
  "set",
  // contextual
  "some",
  // contextual
  "static",
  "struct",
  "subscript",
  "super",
  "switch",
  "throws",
  "throw",
  /try\?/,
  // operator
  /try!/,
  // operator
  "try",
  // operator
  "typealias",
  /unowned\(safe\)/,
  // contextual
  /unowned\(unsafe\)/,
  // contextual
  "unowned",
  // contextual
  "var",
  "weak",
  // contextual
  "where",
  "while",
  "willSet"
  // contextual
], ng = [
  "false",
  "nil",
  "true"
], HI = [
  "assignment",
  "associativity",
  "higherThan",
  "left",
  "lowerThan",
  "none",
  "right"
], FI = [
  "#colorLiteral",
  "#column",
  "#dsohandle",
  "#else",
  "#elseif",
  "#endif",
  "#error",
  "#file",
  "#fileID",
  "#fileLiteral",
  "#filePath",
  "#function",
  "#if",
  "#imageLiteral",
  "#keyPath",
  "#line",
  "#selector",
  "#sourceLocation",
  "#warning"
], rg = [
  "abs",
  "all",
  "any",
  "assert",
  "assertionFailure",
  "debugPrint",
  "dump",
  "fatalError",
  "getVaList",
  "isKnownUniquelyReferenced",
  "max",
  "min",
  "numericCast",
  "pointwiseMax",
  "pointwiseMin",
  "precondition",
  "preconditionFailure",
  "print",
  "readLine",
  "repeatElement",
  "sequence",
  "stride",
  "swap",
  "swift_unboxFromSwiftValueWithType",
  "transcode",
  "type",
  "unsafeBitCast",
  "unsafeDowncast",
  "withExtendedLifetime",
  "withUnsafeMutablePointer",
  "withUnsafePointer",
  "withVaList",
  "withoutActuallyEscaping",
  "zip"
], zv = It(
  /[/=\-+!*%<>&|^~?]/,
  /[\u00A1-\u00A7]/,
  /[\u00A9\u00AB]/,
  /[\u00AC\u00AE]/,
  /[\u00B0\u00B1]/,
  /[\u00B6\u00BB\u00BF\u00D7\u00F7]/,
  /[\u2016-\u2017]/,
  /[\u2020-\u2027]/,
  /[\u2030-\u203E]/,
  /[\u2041-\u2053]/,
  /[\u2055-\u205E]/,
  /[\u2190-\u23FF]/,
  /[\u2500-\u2775]/,
  /[\u2794-\u2BFF]/,
  /[\u2E00-\u2E7F]/,
  /[\u3001-\u3003]/,
  /[\u3008-\u3020]/,
  /[\u3030]/
), $v = It(
  zv,
  /[\u0300-\u036F]/,
  /[\u1DC0-\u1DFF]/,
  /[\u20D0-\u20FF]/,
  /[\uFE00-\uFE0F]/,
  /[\uFE20-\uFE2F]/
  // TODO: The following characters are also allowed, but the regex isn't supported yet.
  // /[\u{E0100}-\u{E01EF}]/u
), vu = Ue(zv, $v, "*"), Hv = It(
  /[a-zA-Z_]/,
  /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/,
  /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/,
  /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/,
  /[\u1E00-\u1FFF]/,
  /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/,
  /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/,
  /[\u2C00-\u2DFF\u2E80-\u2FFF]/,
  /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/,
  /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/,
  /[\uFE47-\uFEFE\uFF00-\uFFFD]/
  // Should be /[\uFE47-\uFFFD]/, but we have to exclude FEFF.
  // The following characters are also allowed, but the regexes aren't supported yet.
  // /[\u{10000}-\u{1FFFD}\u{20000-\u{2FFFD}\u{30000}-\u{3FFFD}\u{40000}-\u{4FFFD}]/u,
  // /[\u{50000}-\u{5FFFD}\u{60000-\u{6FFFD}\u{70000}-\u{7FFFD}\u{80000}-\u{8FFFD}]/u,
  // /[\u{90000}-\u{9FFFD}\u{A0000-\u{AFFFD}\u{B0000}-\u{BFFFD}\u{C0000}-\u{CFFFD}]/u,
  // /[\u{D0000}-\u{DFFFD}\u{E0000-\u{EFFFD}]/u
), Nl = It(
  Hv,
  /\d/,
  /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/
), Mn = Ue(Hv, Nl, "*"), aa = Ue(/[A-Z]/, Nl, "*"), UI = [
  "attached",
  "autoclosure",
  Ue(/convention\(/, It("swift", "block", "c"), /\)/),
  "discardableResult",
  "dynamicCallable",
  "dynamicMemberLookup",
  "escaping",
  "freestanding",
  "frozen",
  "GKInspectable",
  "IBAction",
  "IBDesignable",
  "IBInspectable",
  "IBOutlet",
  "IBSegueAction",
  "inlinable",
  "main",
  "nonobjc",
  "NSApplicationMain",
  "NSCopying",
  "NSManaged",
  Ue(/objc\(/, Mn, /\)/),
  "objc",
  "objcMembers",
  "propertyWrapper",
  "requires_stored_property_inits",
  "resultBuilder",
  "Sendable",
  "testable",
  "UIApplicationMain",
  "unchecked",
  "unknown",
  "usableFromInline",
  "warn_unqualified_access"
], WI = [
  "iOS",
  "iOSApplicationExtension",
  "macOS",
  "macOSApplicationExtension",
  "macCatalyst",
  "macCatalystApplicationExtension",
  "watchOS",
  "watchOSApplicationExtension",
  "tvOS",
  "tvOSApplicationExtension",
  "swift"
];
function VI(t) {
  const e = {
    match: /\s+/,
    relevance: 0
  }, n = t.COMMENT(
    "/\\*",
    "\\*/",
    { contains: ["self"] }
  ), r = [
    t.C_LINE_COMMENT_MODE,
    n
  ], o = {
    match: [
      /\./,
      It(...zI, ...tg)
    ],
    className: { 2: "keyword" }
  }, i = {
    // Consume .keyword to prevent highlighting properties and methods as keywords.
    match: Ue(/\./, It(...yu)),
    relevance: 0
  }, s = yu.filter((Be) => typeof Be == "string").concat(["_|0"]), a = yu.filter((Be) => typeof Be != "string").concat($I).map(Qf), l = { variants: [
    {
      className: "keyword",
      match: It(...a, ...tg)
    }
  ] }, c = {
    $pattern: It(
      /\b\w+/,
      // regular keywords
      /#\w+/
      // number keywords
    ),
    keyword: s.concat(FI),
    literal: ng
  }, u = [
    o,
    i,
    l
  ], d = {
    // Consume .built_in to prevent highlighting properties and methods.
    match: Ue(/\./, It(...rg)),
    relevance: 0
  }, f = {
    className: "built_in",
    match: Ue(/\b/, It(...rg), /(?=\()/)
  }, h = [
    d,
    f
  ], m = {
    // Prevent -> from being highlighting as an operator.
    match: /->/,
    relevance: 0
  }, p = {
    className: "operator",
    relevance: 0,
    variants: [
      { match: vu },
      {
        // dot-operator: only operators that start with a dot are allowed to use dots as
        // characters (..., ...<, .*, etc). So there rule here is: a dot followed by one or more
        // characters that may also include dots.
        match: `\\.(\\.|${$v})+`
      }
    ]
  }, g = [
    m,
    p
  ], b = "([0-9]_*)+", v = "([0-9a-fA-F]_*)+", k = {
    className: "number",
    relevance: 0,
    variants: [
      // decimal floating-point-literal (subsumes decimal-literal)
      { match: `\\b(${b})(\\.(${b}))?([eE][+-]?(${b}))?\\b` },
      // hexadecimal floating-point-literal (subsumes hexadecimal-literal)
      { match: `\\b0x(${v})(\\.(${v}))?([pP][+-]?(${b}))?\\b` },
      // octal-literal
      { match: /\b0o([0-7]_*)+\b/ },
      // binary-literal
      { match: /\b0b([01]_*)+\b/ }
    ]
  }, x = (Be = "") => ({
    className: "subst",
    variants: [
      { match: Ue(/\\/, Be, /[0\\tnr"']/) },
      { match: Ue(/\\/, Be, /u\{[0-9a-fA-F]{1,8}\}/) }
    ]
  }), w = (Be = "") => ({
    className: "subst",
    match: Ue(/\\/, Be, /[\t ]*(?:[\r\n]|\r\n)/)
  }), E = (Be = "") => ({
    className: "subst",
    label: "interpol",
    begin: Ue(/\\/, Be, /\(/),
    end: /\)/
  }), S = (Be = "") => ({
    begin: Ue(Be, /"""/),
    end: Ue(/"""/, Be),
    contains: [
      x(Be),
      w(Be),
      E(Be)
    ]
  }), C = (Be = "") => ({
    begin: Ue(Be, /"/),
    end: Ue(/"/, Be),
    contains: [
      x(Be),
      E(Be)
    ]
  }), M = {
    className: "string",
    variants: [
      S(),
      S("#"),
      S("##"),
      S("###"),
      C(),
      C("#"),
      C("##"),
      C("###")
    ]
  }, O = [
    t.BACKSLASH_ESCAPE,
    {
      begin: /\[/,
      end: /\]/,
      relevance: 0,
      contains: [t.BACKSLASH_ESCAPE]
    }
  ], q = {
    begin: /\/[^\s](?=[^/\n]*\/)/,
    end: /\//,
    contains: O
  }, K = (Be) => {
    const ln = Ue(Be, /\//), Nn = Ue(/\//, Be);
    return {
      begin: ln,
      end: Nn,
      contains: [
        ...O,
        {
          scope: "comment",
          begin: `#(?!.*${Nn})`,
          end: /$/
        }
      ]
    };
  }, j = {
    scope: "regexp",
    variants: [
      K("###"),
      K("##"),
      K("#"),
      q
    ]
  }, H = { match: Ue(/`/, Mn, /`/) }, G = {
    className: "variable",
    match: /\$\d+/
  }, V = {
    className: "variable",
    match: `\\$${Nl}+`
  }, re = [
    H,
    G,
    V
  ], A = {
    match: /(@|#(un)?)available/,
    scope: "keyword",
    starts: { contains: [
      {
        begin: /\(/,
        end: /\)/,
        keywords: WI,
        contains: [
          ...g,
          k,
          M
        ]
      }
    ] }
  }, $ = {
    scope: "keyword",
    match: Ue(/@/, It(...UI), wi(It(/\(/, /\s+/)))
  }, _ = {
    scope: "meta",
    match: Ue(/@/, Mn)
  }, z = [
    A,
    $,
    _
  ], Q = {
    match: wi(/\b[A-Z]/),
    relevance: 0,
    contains: [
      {
        // Common Apple frameworks, for relevance boost
        className: "type",
        match: Ue(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, Nl, "+")
      },
      {
        // Type identifier
        className: "type",
        match: aa,
        relevance: 0
      },
      {
        // Optional type
        match: /[?!]+/,
        relevance: 0
      },
      {
        // Variadic parameter
        match: /\.\.\./,
        relevance: 0
      },
      {
        // Protocol composition
        match: Ue(/\s+&\s+/, wi(aa)),
        relevance: 0
      }
    ]
  }, ue = {
    begin: /</,
    end: />/,
    keywords: c,
    contains: [
      ...r,
      ...u,
      ...z,
      m,
      Q
    ]
  };
  Q.contains.push(ue);
  const Me = {
    match: Ue(Mn, /\s*:/),
    keywords: "_|0",
    relevance: 0
  }, Oe = {
    begin: /\(/,
    end: /\)/,
    relevance: 0,
    keywords: c,
    contains: [
      "self",
      Me,
      ...r,
      j,
      ...u,
      ...h,
      ...g,
      k,
      M,
      ...re,
      ...z,
      Q
    ]
  }, je = {
    begin: /</,
    end: />/,
    keywords: "repeat each",
    contains: [
      ...r,
      Q
    ]
  }, me = {
    begin: It(
      wi(Ue(Mn, /\s*:/)),
      wi(Ue(Mn, /\s+/, Mn, /\s*:/))
    ),
    end: /:/,
    relevance: 0,
    contains: [
      {
        className: "keyword",
        match: /\b_\b/
      },
      {
        className: "params",
        match: Mn
      }
    ]
  }, at = {
    begin: /\(/,
    end: /\)/,
    keywords: c,
    contains: [
      me,
      ...r,
      ...u,
      ...g,
      k,
      M,
      ...z,
      Q,
      Oe
    ],
    endsParent: !0,
    illegal: /["']/
  }, Ht = {
    match: [
      /(func|macro)/,
      /\s+/,
      It(H.match, Mn, vu)
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      je,
      at,
      e
    ],
    illegal: [
      /\[/,
      /%/
    ]
  }, gt = {
    match: [
      /\b(?:subscript|init[?!]?)/,
      /\s*(?=[<(])/
    ],
    className: { 1: "keyword" },
    contains: [
      je,
      at,
      e
    ],
    illegal: /\[|%/
  }, jt = {
    match: [
      /operator/,
      /\s+/,
      vu
    ],
    className: {
      1: "keyword",
      3: "title"
    }
  }, Ft = {
    begin: [
      /precedencegroup/,
      /\s+/,
      aa
    ],
    className: {
      1: "keyword",
      3: "title"
    },
    contains: [Q],
    keywords: [
      ...HI,
      ...ng
    ],
    end: /}/
  }, an = {
    match: [
      /class\b/,
      /\s+/,
      /func\b/,
      /\s+/,
      /\b[A-Za-z_][A-Za-z0-9_]*\b/
    ],
    scope: {
      1: "keyword",
      3: "keyword",
      5: "title.function"
    }
  }, mo = {
    match: [
      /class\b/,
      /\s+/,
      /var\b/
    ],
    scope: {
      1: "keyword",
      3: "keyword"
    }
  }, po = {
    begin: [
      /(struct|protocol|class|extension|enum|actor)/,
      /\s+/,
      Mn,
      /\s*/
    ],
    beginScope: {
      1: "keyword",
      3: "title.class"
    },
    keywords: c,
    contains: [
      je,
      ...u,
      {
        begin: /:/,
        end: /\{/,
        keywords: c,
        contains: [
          {
            scope: "title.class.inherited",
            match: aa
          },
          ...u
        ],
        relevance: 0
      }
    ]
  };
  for (const Be of M.variants) {
    const ln = Be.contains.find((go) => go.label === "interpol");
    ln.keywords = c;
    const Nn = [
      ...u,
      ...h,
      ...g,
      k,
      M,
      ...re
    ];
    ln.contains = [
      ...Nn,
      {
        begin: /\(/,
        end: /\)/,
        contains: [
          "self",
          ...Nn
        ]
      }
    ];
  }
  return {
    name: "Swift",
    keywords: c,
    contains: [
      ...r,
      Ht,
      gt,
      an,
      mo,
      po,
      jt,
      Ft,
      {
        beginKeywords: "import",
        end: /$/,
        contains: [...r],
        relevance: 0
      },
      j,
      ...u,
      ...h,
      ...g,
      k,
      M,
      ...re,
      ...z,
      Q,
      Oe
    ]
  };
}
const El = "[A-Za-z$_][0-9A-Za-z$_]*", Fv = [
  "as",
  // for exports
  "in",
  "of",
  "if",
  "for",
  "while",
  "finally",
  "var",
  "new",
  "function",
  "do",
  "return",
  "void",
  "else",
  "break",
  "catch",
  "instanceof",
  "with",
  "throw",
  "case",
  "default",
  "try",
  "switch",
  "continue",
  "typeof",
  "delete",
  "let",
  "yield",
  "const",
  "class",
  // JS handles these with a special rule
  // "get",
  // "set",
  "debugger",
  "async",
  "await",
  "static",
  "import",
  "from",
  "export",
  "extends",
  // It's reached stage 3, which is "recommended for implementation":
  "using"
], Uv = [
  "true",
  "false",
  "null",
  "undefined",
  "NaN",
  "Infinity"
], Wv = [
  // Fundamental objects
  "Object",
  "Function",
  "Boolean",
  "Symbol",
  // numbers and dates
  "Math",
  "Date",
  "Number",
  "BigInt",
  // text
  "String",
  "RegExp",
  // Indexed collections
  "Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Int32Array",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array",
  // Keyed collections
  "Set",
  "Map",
  "WeakSet",
  "WeakMap",
  // Structured data
  "ArrayBuffer",
  "SharedArrayBuffer",
  "Atomics",
  "DataView",
  "JSON",
  // Control abstraction objects
  "Promise",
  "Generator",
  "GeneratorFunction",
  "AsyncFunction",
  // Reflection
  "Reflect",
  "Proxy",
  // Internationalization
  "Intl",
  // WebAssembly
  "WebAssembly"
], Vv = [
  "Error",
  "EvalError",
  "InternalError",
  "RangeError",
  "ReferenceError",
  "SyntaxError",
  "TypeError",
  "URIError"
], Kv = [
  "setInterval",
  "setTimeout",
  "clearInterval",
  "clearTimeout",
  "require",
  "exports",
  "eval",
  "isFinite",
  "isNaN",
  "parseFloat",
  "parseInt",
  "decodeURI",
  "decodeURIComponent",
  "encodeURI",
  "encodeURIComponent",
  "escape",
  "unescape"
], qv = [
  "arguments",
  "this",
  "super",
  "console",
  "window",
  "document",
  "localStorage",
  "sessionStorage",
  "module",
  "global"
  // Node.js
], Gv = [].concat(
  Kv,
  Wv,
  Vv
);
function KI(t) {
  const e = t.regex, n = (A, { after: $ }) => {
    const _ = "</" + A[0].slice(1);
    return A.input.indexOf(_, $) !== -1;
  }, r = El, o = {
    begin: "<>",
    end: "</>"
  }, i = /<[A-Za-z0-9\\._:-]+\s*\/>/, s = {
    begin: /<[A-Za-z0-9\\._:-]+/,
    end: /\/[A-Za-z0-9\\._:-]+>|\/>/,
    /**
     * @param {RegExpMatchArray} match
     * @param {CallbackResponse} response
     */
    isTrulyOpeningTag: (A, $) => {
      const _ = A[0].length + A.index, z = A.input[_];
      if (
        // HTML should not include another raw `<` inside a tag
        // nested type?
        // `<Array<Array<number>>`, etc.
        z === "<" || // the , gives away that this is not HTML
        // `<T, A extends keyof T, V>`
        z === ","
      ) {
        $.ignoreMatch();
        return;
      }
      z === ">" && (n(A, { after: _ }) || $.ignoreMatch());
      let Q;
      const ue = A.input.substring(_);
      if (Q = ue.match(/^\s*=/)) {
        $.ignoreMatch();
        return;
      }
      if ((Q = ue.match(/^\s+extends\s+/)) && Q.index === 0) {
        $.ignoreMatch();
        return;
      }
    }
  }, a = {
    $pattern: El,
    keyword: Fv,
    literal: Uv,
    built_in: Gv,
    "variable.language": qv
  }, l = "[0-9](_?[0-9])*", c = `\\.(${l})`, u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", d = {
    className: "number",
    variants: [
      // DecimalLiteral
      { begin: `(\\b(${u})((${c})|\\.)?|(${c}))[eE][+-]?(${l})\\b` },
      { begin: `\\b(${u})\\b((${c})\\b|\\.)?|(${c})\\b` },
      // DecimalBigIntegerLiteral
      { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" },
      // NonDecimalIntegerLiteral
      { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" },
      { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" },
      { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" },
      // LegacyOctalIntegerLiteral (does not include underscore separators)
      // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals
      { begin: "\\b0[0-7]+n?\\b" }
    ],
    relevance: 0
  }, f = {
    className: "subst",
    begin: "\\$\\{",
    end: "\\}",
    keywords: a,
    contains: []
    // defined later
  }, h = {
    begin: ".?html`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        t.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "xml"
    }
  }, m = {
    begin: ".?css`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        t.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "css"
    }
  }, p = {
    begin: ".?gql`",
    end: "",
    starts: {
      end: "`",
      returnEnd: !1,
      contains: [
        t.BACKSLASH_ESCAPE,
        f
      ],
      subLanguage: "graphql"
    }
  }, g = {
    className: "string",
    begin: "`",
    end: "`",
    contains: [
      t.BACKSLASH_ESCAPE,
      f
    ]
  }, v = {
    className: "comment",
    variants: [
      t.COMMENT(
        /\/\*\*(?!\/)/,
        "\\*/",
        {
          relevance: 0,
          contains: [
            {
              begin: "(?=@[A-Za-z]+)",
              relevance: 0,
              contains: [
                {
                  className: "doctag",
                  begin: "@[A-Za-z]+"
                },
                {
                  className: "type",
                  begin: "\\{",
                  end: "\\}",
                  excludeEnd: !0,
                  excludeBegin: !0,
                  relevance: 0
                },
                {
                  className: "variable",
                  begin: r + "(?=\\s*(-)|$)",
                  endsParent: !0,
                  relevance: 0
                },
                // eat spaces (not newlines) so we can find
                // types or variables
                {
                  begin: /(?=[^\n])\s/,
                  relevance: 0
                }
              ]
            }
          ]
        }
      ),
      t.C_BLOCK_COMMENT_MODE,
      t.C_LINE_COMMENT_MODE
    ]
  }, k = [
    t.APOS_STRING_MODE,
    t.QUOTE_STRING_MODE,
    h,
    m,
    p,
    g,
    // Skip numbers when they are part of a variable name
    { match: /\$\d+/ },
    d
    // This is intentional:
    // See https://github.com/highlightjs/highlight.js/issues/3288
    // hljs.REGEXP_MODE
  ];
  f.contains = k.concat({
    // we need to pair up {} inside our subst to prevent
    // it from ending too early by matching another }
    begin: /\{/,
    end: /\}/,
    keywords: a,
    contains: [
      "self"
    ].concat(k)
  });
  const x = [].concat(v, f.contains), w = x.concat([
    // eat recursive parens in sub expressions
    {
      begin: /(\s*)\(/,
      end: /\)/,
      keywords: a,
      contains: ["self"].concat(x)
    }
  ]), E = {
    className: "params",
    // convert this to negative lookbehind in v12
    begin: /(\s*)\(/,
    // to match the parms with
    end: /\)/,
    excludeBegin: !0,
    excludeEnd: !0,
    keywords: a,
    contains: w
  }, S = {
    variants: [
      // class Car extends vehicle
      {
        match: [
          /class/,
          /\s+/,
          r,
          /\s+/,
          /extends/,
          /\s+/,
          e.concat(r, "(", e.concat(/\./, r), ")*")
        ],
        scope: {
          1: "keyword",
          3: "title.class",
          5: "keyword",
          7: "title.class.inherited"
        }
      },
      // class Car
      {
        match: [
          /class/,
          /\s+/,
          r
        ],
        scope: {
          1: "keyword",
          3: "title.class"
        }
      }
    ]
  }, C = {
    relevance: 0,
    match: e.either(
      // Hard coded exceptions
      /\bJSON/,
      // Float32Array, OutT
      /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/,
      // CSSFactory, CSSFactoryT
      /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/,
      // FPs, FPsT
      /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/
      // P
      // single letters are not highlighted
      // BLAH
      // this will be flagged as a UPPER_CASE_CONSTANT instead
    ),
    className: "title.class",
    keywords: {
      _: [
        // se we still get relevance credit for JS library classes
        ...Wv,
        ...Vv
      ]
    }
  }, M = {
    label: "use_strict",
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use (strict|asm)['"]/
  }, O = {
    variants: [
      {
        match: [
          /function/,
          /\s+/,
          r,
          /(?=\s*\()/
        ]
      },
      // anonymous function
      {
        match: [
          /function/,
          /\s*(?=\()/
        ]
      }
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    label: "func.def",
    contains: [E],
    illegal: /%/
  }, q = {
    relevance: 0,
    match: /\b[A-Z][A-Z_0-9]+\b/,
    className: "variable.constant"
  };
  function K(A) {
    return e.concat("(?!", A.join("|"), ")");
  }
  const j = {
    match: e.concat(
      /\b/,
      K([
        ...Kv,
        "super",
        "import"
      ].map((A) => `${A}\\s*\\(`)),
      r,
      e.lookahead(/\s*\(/)
    ),
    className: "title.function",
    relevance: 0
  }, H = {
    begin: e.concat(/\./, e.lookahead(
      e.concat(r, /(?![0-9A-Za-z$_(])/)
    )),
    end: r,
    excludeBegin: !0,
    keywords: "prototype",
    className: "property",
    relevance: 0
  }, G = {
    match: [
      /get|set/,
      /\s+/,
      r,
      /(?=\()/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      {
        // eat to avoid empty params
        begin: /\(\)/
      },
      E
    ]
  }, V = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + t.UNDERSCORE_IDENT_RE + ")\\s*=>", re = {
    match: [
      /const|var|let/,
      /\s+/,
      r,
      /\s*/,
      /=\s*/,
      /(async\s*)?/,
      // async is optional
      e.lookahead(V)
    ],
    keywords: "async",
    className: {
      1: "keyword",
      3: "title.function"
    },
    contains: [
      E
    ]
  };
  return {
    name: "JavaScript",
    aliases: ["js", "jsx", "mjs", "cjs"],
    keywords: a,
    // this will be extended by TypeScript
    exports: { PARAMS_CONTAINS: w, CLASS_REFERENCE: C },
    illegal: /#(?![$_A-z])/,
    contains: [
      t.SHEBANG({
        label: "shebang",
        binary: "node",
        relevance: 5
      }),
      M,
      t.APOS_STRING_MODE,
      t.QUOTE_STRING_MODE,
      h,
      m,
      p,
      g,
      v,
      // Skip numbers when they are part of a variable name
      { match: /\$\d+/ },
      d,
      C,
      {
        scope: "attr",
        match: r + e.lookahead(":"),
        relevance: 0
      },
      re,
      {
        // "value" container
        begin: "(" + t.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*",
        keywords: "return throw case",
        relevance: 0,
        contains: [
          v,
          t.REGEXP_MODE,
          {
            className: "function",
            // we have to count the parens to make sure we actually have the
            // correct bounding ( ) before the =>.  There could be any number of
            // sub-expressions inside also surrounded by parens.
            begin: V,
            returnBegin: !0,
            end: "\\s*=>",
            contains: [
              {
                className: "params",
                variants: [
                  {
                    begin: t.UNDERSCORE_IDENT_RE,
                    relevance: 0
                  },
                  {
                    className: null,
                    begin: /\(\s*\)/,
                    skip: !0
                  },
                  {
                    begin: /(\s*)\(/,
                    end: /\)/,
                    excludeBegin: !0,
                    excludeEnd: !0,
                    keywords: a,
                    contains: w
                  }
                ]
              }
            ]
          },
          {
            // could be a comma delimited list of params to a function call
            begin: /,/,
            relevance: 0
          },
          {
            match: /\s+/,
            relevance: 0
          },
          {
            // JSX
            variants: [
              { begin: o.begin, end: o.end },
              { match: i },
              {
                begin: s.begin,
                // we carefully check the opening tag to see if it truly
                // is a tag and not a false positive
                "on:begin": s.isTrulyOpeningTag,
                end: s.end
              }
            ],
            subLanguage: "xml",
            contains: [
              {
                begin: s.begin,
                end: s.end,
                skip: !0,
                contains: ["self"]
              }
            ]
          }
        ]
      },
      O,
      {
        // prevent this from getting swallowed up by function
        // since they appear "function like"
        beginKeywords: "while if switch catch for"
      },
      {
        // we have to count the parens to make sure we actually have the correct
        // bounding ( ).  There could be any number of sub-expressions inside
        // also surrounded by parens.
        begin: "\\b(?!function)" + t.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{",
        // end parens
        returnBegin: !0,
        label: "func.def",
        contains: [
          E,
          t.inherit(t.TITLE_MODE, { begin: r, className: "title.function" })
        ]
      },
      // catch ... so it won't trigger the property rule below
      {
        match: /\.\.\./,
        relevance: 0
      },
      H,
      // hack: prevents detection of keywords in some circumstances
      // .keyword()
      // $keyword = x
      {
        match: "\\$" + r,
        relevance: 0
      },
      {
        match: [/\bconstructor(?=\s*\()/],
        className: { 1: "title.function" },
        contains: [E]
      },
      j,
      q,
      S,
      G,
      {
        match: /\$[(.]/
        // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`
      }
    ]
  };
}
function qI(t) {
  const e = t.regex, n = KI(t), r = El, o = [
    "any",
    "void",
    "number",
    "boolean",
    "string",
    "object",
    "never",
    "symbol",
    "bigint",
    "unknown"
  ], i = {
    begin: [
      /namespace/,
      /\s+/,
      t.IDENT_RE
    ],
    beginScope: {
      1: "keyword",
      3: "title.class"
    }
  }, s = {
    beginKeywords: "interface",
    end: /\{/,
    excludeEnd: !0,
    keywords: {
      keyword: "interface extends",
      built_in: o
    },
    contains: [n.exports.CLASS_REFERENCE]
  }, a = {
    className: "meta",
    relevance: 10,
    begin: /^\s*['"]use strict['"]/
  }, l = [
    "type",
    // "namespace",
    "interface",
    "public",
    "private",
    "protected",
    "implements",
    "declare",
    "abstract",
    "readonly",
    "enum",
    "override",
    "satisfies"
  ], c = {
    $pattern: El,
    keyword: Fv.concat(l),
    literal: Uv,
    built_in: Gv.concat(o),
    "variable.language": qv
  }, u = {
    className: "meta",
    begin: "@" + r
  }, d = (p, g, b) => {
    const v = p.contains.findIndex((k) => k.label === g);
    if (v === -1)
      throw new Error("can not find mode to replace");
    p.contains.splice(v, 1, b);
  };
  Object.assign(n.keywords, c), n.exports.PARAMS_CONTAINS.push(u);
  const f = n.contains.find((p) => p.scope === "attr"), h = Object.assign(
    {},
    f,
    { match: e.concat(r, e.lookahead(/\s*\?:/)) }
  );
  n.exports.PARAMS_CONTAINS.push([
    n.exports.CLASS_REFERENCE,
    // class reference for highlighting the params types
    f,
    // highlight the params key
    h
    // Added for optional property assignment highlighting
  ]), n.contains = n.contains.concat([
    u,
    i,
    s,
    h
    // Added for optional property assignment highlighting
  ]), d(n, "shebang", t.SHEBANG()), d(n, "use_strict", a);
  const m = n.contains.find((p) => p.label === "func.def");
  return m.relevance = 0, Object.assign(n, {
    name: "TypeScript",
    aliases: [
      "ts",
      "tsx",
      "mts",
      "cts"
    ]
  }), n;
}
function GI(t) {
  const e = t.regex, n = {
    className: "string",
    begin: /"(""|[^/n])"C\b/
  }, r = {
    className: "string",
    begin: /"/,
    end: /"/,
    illegal: /\n/,
    contains: [
      {
        // double quote escape
        begin: /""/
      }
    ]
  }, o = /\d{1,2}\/\d{1,2}\/\d{4}/, i = /\d{4}-\d{1,2}-\d{1,2}/, s = /(\d|1[012])(:\d+){0,2} *(AM|PM)/, a = /\d{1,2}(:\d{1,2}){1,2}/, l = {
    className: "literal",
    variants: [
      {
        // #YYYY-MM-DD# (ISO-Date) or #M/D/YYYY# (US-Date)
        begin: e.concat(/# */, e.either(i, o), / *#/)
      },
      {
        // #H:mm[:ss]# (24h Time)
        begin: e.concat(/# */, a, / *#/)
      },
      {
        // #h[:mm[:ss]] A# (12h Time)
        begin: e.concat(/# */, s, / *#/)
      },
      {
        // date plus time
        begin: e.concat(
          /# */,
          e.either(i, o),
          / +/,
          e.either(s, a),
          / *#/
        )
      }
    ]
  }, c = {
    className: "number",
    relevance: 0,
    variants: [
      {
        // Float
        begin: /\b\d[\d_]*((\.[\d_]+(E[+-]?[\d_]+)?)|(E[+-]?[\d_]+))[RFD@!#]?/
      },
      {
        // Integer (base 10)
        begin: /\b\d[\d_]*((U?[SIL])|[%&])?/
      },
      {
        // Integer (base 16)
        begin: /&H[\dA-F_]+((U?[SIL])|[%&])?/
      },
      {
        // Integer (base 8)
        begin: /&O[0-7_]+((U?[SIL])|[%&])?/
      },
      {
        // Integer (base 2)
        begin: /&B[01_]+((U?[SIL])|[%&])?/
      }
    ]
  }, u = {
    className: "label",
    begin: /^\w+:/
  }, d = t.COMMENT(/'''/, /$/, { contains: [
    {
      className: "doctag",
      begin: /<\/?/,
      end: />/
    }
  ] }), f = t.COMMENT(null, /$/, { variants: [
    { begin: /'/ },
    {
      // TODO: Use multi-class for leading spaces
      begin: /([\t ]|^)REM(?=\s)/
    }
  ] });
  return {
    name: "Visual Basic .NET",
    aliases: ["vb"],
    case_insensitive: !0,
    classNameAliases: { label: "symbol" },
    keywords: {
      keyword: "addhandler alias aggregate ansi as async assembly auto binary by byref byval call case catch class compare const continue custom declare default delegate dim distinct do each equals else elseif end enum erase error event exit explicit finally for friend from function get global goto group handles if implements imports in inherits interface into iterator join key let lib loop me mid module mustinherit mustoverride mybase myclass namespace narrowing new next notinheritable notoverridable of off on operator option optional order overloads overridable overrides paramarray partial preserve private property protected public raiseevent readonly redim removehandler resume return select set shadows shared skip static step stop structure strict sub synclock take text then throw to try unicode until using when where while widening with withevents writeonly yield",
      built_in: (
        // Operators https://docs.microsoft.com/dotnet/visual-basic/language-reference/operators
        "addressof and andalso await directcast gettype getxmlnamespace is isfalse isnot istrue like mod nameof new not or orelse trycast typeof xor cbool cbyte cchar cdate cdbl cdec cint clng cobj csbyte cshort csng cstr cuint culng cushort"
      ),
      type: (
        // Data types https://docs.microsoft.com/dotnet/visual-basic/language-reference/data-types
        "boolean byte char date decimal double integer long object sbyte short single string uinteger ulong ushort"
      ),
      literal: "true false nothing"
    },
    illegal: "//|\\{|\\}|endif|gosub|variant|wend|^\\$ ",
    contains: [
      n,
      r,
      l,
      c,
      u,
      d,
      f,
      {
        className: "meta",
        // TODO: Use multi-class for indentation once available
        begin: /[\t ]*#(const|disable|else|elseif|enable|end|externalsource|if|region)\b/,
        end: /$/,
        keywords: { keyword: "const disable else elseif enable end externalsource if region then" },
        contains: [f]
      }
    ]
  };
}
function jI(t) {
  t.regex;
  const e = t.COMMENT(/\(;/, /;\)/);
  e.contains.push("self");
  const n = t.COMMENT(/;;/, /$/), r = [
    "anyfunc",
    "block",
    "br",
    "br_if",
    "br_table",
    "call",
    "call_indirect",
    "data",
    "drop",
    "elem",
    "else",
    "end",
    "export",
    "func",
    "global.get",
    "global.set",
    "local.get",
    "local.set",
    "local.tee",
    "get_global",
    "get_local",
    "global",
    "if",
    "import",
    "local",
    "loop",
    "memory",
    "memory.grow",
    "memory.size",
    "module",
    "mut",
    "nop",
    "offset",
    "param",
    "result",
    "return",
    "select",
    "set_global",
    "set_local",
    "start",
    "table",
    "tee_local",
    "then",
    "type",
    "unreachable"
  ], o = {
    begin: [
      /(?:func|call|call_indirect)/,
      /\s+/,
      /\$[^\s)]+/
    ],
    className: {
      1: "keyword",
      3: "title.function"
    }
  }, i = {
    className: "variable",
    begin: /\$[\w_]+/
  }, s = {
    match: /(\((?!;)|\))+/,
    className: "punctuation",
    relevance: 0
  }, a = {
    className: "number",
    relevance: 0,
    // borrowed from Prism, TODO: split out into variants
    match: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/
  }, l = {
    // look-ahead prevents us from gobbling up opcodes
    match: /(i32|i64|f32|f64)(?!\.)/,
    className: "type"
  }, c = {
    className: "keyword",
    // borrowed from Prism, TODO: split out into variants
    match: /\b(f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|nearest|neg?|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|store(?:8|16|32)?|sqrt|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))\b/
  };
  return {
    name: "WebAssembly",
    keywords: {
      $pattern: /[\w.]+/,
      keyword: r
    },
    contains: [
      n,
      e,
      {
        match: [
          /(?:offset|align)/,
          /\s*/,
          /=/
        ],
        className: {
          1: "keyword",
          3: "operator"
        }
      },
      i,
      s,
      o,
      t.QUOTE_STRING_MODE,
      l,
      c,
      a
    ]
  };
}
function YI(t) {
  const e = t.regex, n = e.concat(/[\p{L}_]/u, e.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u), r = /[\p{L}0-9._:-]+/u, o = {
    className: "symbol",
    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/
  }, i = {
    begin: /\s/,
    contains: [
      {
        className: "keyword",
        begin: /#?[a-z_][a-z1-9_-]+/,
        illegal: /\n/
      }
    ]
  }, s = t.inherit(i, {
    begin: /\(/,
    end: /\)/
  }), a = t.inherit(t.APOS_STRING_MODE, { className: "string" }), l = t.inherit(t.QUOTE_STRING_MODE, { className: "string" }), c = {
    endsWithParent: !0,
    illegal: /</,
    relevance: 0,
    contains: [
      {
        className: "attr",
        begin: r,
        relevance: 0
      },
      {
        begin: /=\s*/,
        relevance: 0,
        contains: [
          {
            className: "string",
            endsParent: !0,
            variants: [
              {
                begin: /"/,
                end: /"/,
                contains: [o]
              },
              {
                begin: /'/,
                end: /'/,
                contains: [o]
              },
              { begin: /[^\s"'=<>`]+/ }
            ]
          }
        ]
      }
    ]
  };
  return {
    name: "HTML, XML",
    aliases: [
      "html",
      "xhtml",
      "rss",
      "atom",
      "xjb",
      "xsd",
      "xsl",
      "plist",
      "wsf",
      "svg"
    ],
    case_insensitive: !0,
    unicodeRegex: !0,
    contains: [
      {
        className: "meta",
        begin: /<![a-z]/,
        end: />/,
        relevance: 10,
        contains: [
          i,
          l,
          a,
          s,
          {
            begin: /\[/,
            end: /\]/,
            contains: [
              {
                className: "meta",
                begin: /<![a-z]/,
                end: />/,
                contains: [
                  i,
                  s,
                  l,
                  a
                ]
              }
            ]
          }
        ]
      },
      t.COMMENT(
        /<!--/,
        /-->/,
        { relevance: 10 }
      ),
      {
        begin: /<!\[CDATA\[/,
        end: /\]\]>/,
        relevance: 10
      },
      o,
      // xml processing instructions
      {
        className: "meta",
        end: /\?>/,
        variants: [
          {
            begin: /<\?xml/,
            relevance: 10,
            contains: [
              l
            ]
          },
          {
            begin: /<\?[a-z][a-z0-9]+/
          }
        ]
      },
      {
        className: "tag",
        /*
        The lookahead pattern (?=...) ensures that 'begin' only matches
        '<style' as a single word, followed by a whitespace or an
        ending bracket.
        */
        begin: /<style(?=\s|>)/,
        end: />/,
        keywords: { name: "style" },
        contains: [c],
        starts: {
          end: /<\/style>/,
          returnEnd: !0,
          subLanguage: [
            "css",
            "xml"
          ]
        }
      },
      {
        className: "tag",
        // See the comment in the <style tag about the lookahead pattern
        begin: /<script(?=\s|>)/,
        end: />/,
        keywords: { name: "script" },
        contains: [c],
        starts: {
          end: /<\/script>/,
          returnEnd: !0,
          subLanguage: [
            "javascript",
            "handlebars",
            "xml"
          ]
        }
      },
      // we need this for now for jSX
      {
        className: "tag",
        begin: /<>|<\/>/
      },
      // open tag
      {
        className: "tag",
        begin: e.concat(
          /</,
          e.lookahead(e.concat(
            n,
            // <tag/>
            // <tag>
            // <tag ...
            e.either(/\/>/, />/, /\s/)
          ))
        ),
        end: /\/?>/,
        contains: [
          {
            className: "name",
            begin: n,
            relevance: 0,
            starts: c
          }
        ]
      },
      // close tag
      {
        className: "tag",
        begin: e.concat(
          /<\//,
          e.lookahead(e.concat(
            n,
            />/
          ))
        ),
        contains: [
          {
            className: "name",
            begin: n,
            relevance: 0
          },
          {
            begin: />/,
            relevance: 0,
            endsParent: !0
          }
        ]
      }
    ]
  };
}
function XI(t) {
  const e = "true false yes no null", n = "[\\w#;/?:@&=+$,.~*'()[\\]]+", r = {
    className: "attr",
    variants: [
      // added brackets support and special char support
      { begin: /[\w*@][\w*@ :()\./-]*:(?=[ \t]|$)/ },
      {
        // double quoted keys - with brackets and special char support
        begin: /"[\w*@][\w*@ :()\./-]*":(?=[ \t]|$)/
      },
      {
        // single quoted keys - with brackets and special char support
        begin: /'[\w*@][\w*@ :()\./-]*':(?=[ \t]|$)/
      }
    ]
  }, o = {
    className: "template-variable",
    variants: [
      {
        // jinja templates Ansible
        begin: /\{\{/,
        end: /\}\}/
      },
      {
        // Ruby i18n
        begin: /%\{/,
        end: /\}/
      }
    ]
  }, i = {
    className: "string",
    relevance: 0,
    begin: /'/,
    end: /'/,
    contains: [
      {
        match: /''/,
        scope: "char.escape",
        relevance: 0
      }
    ]
  }, s = {
    className: "string",
    relevance: 0,
    variants: [
      {
        begin: /"/,
        end: /"/
      },
      { begin: /\S+/ }
    ],
    contains: [
      t.BACKSLASH_ESCAPE,
      o
    ]
  }, a = t.inherit(s, { variants: [
    {
      begin: /'/,
      end: /'/,
      contains: [
        {
          begin: /''/,
          relevance: 0
        }
      ]
    },
    {
      begin: /"/,
      end: /"/
    },
    { begin: /[^\s,{}[\]]+/ }
  ] }), f = {
    className: "number",
    begin: "\\b" + "[0-9]{4}(-[0-9][0-9]){0,2}" + "([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?" + "(\\.[0-9]*)?" + "([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?" + "\\b"
  }, h = {
    end: ",",
    endsWithParent: !0,
    excludeEnd: !0,
    keywords: e,
    relevance: 0
  }, m = {
    begin: /\{/,
    end: /\}/,
    contains: [h],
    illegal: "\\n",
    relevance: 0
  }, p = {
    begin: "\\[",
    end: "\\]",
    contains: [h],
    illegal: "\\n",
    relevance: 0
  }, g = [
    r,
    {
      className: "meta",
      begin: "^---\\s*$",
      relevance: 10
    },
    {
      // multi line string
      // Blocks start with a | or > followed by a newline
      //
      // Indentation of subsequent lines must be the same to
      // be considered part of the block
      className: "string",
      begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*"
    },
    {
      // Ruby/Rails erb
      begin: "<%[%=-]?",
      end: "[%-]?%>",
      subLanguage: "ruby",
      excludeBegin: !0,
      excludeEnd: !0,
      relevance: 0
    },
    {
      // named tags
      className: "type",
      begin: "!\\w+!" + n
    },
    // https://yaml.org/spec/1.2/spec.html#id2784064
    {
      // verbatim tags
      className: "type",
      begin: "!<" + n + ">"
    },
    {
      // primary tags
      className: "type",
      begin: "!" + n
    },
    {
      // secondary tags
      className: "type",
      begin: "!!" + n
    },
    {
      // fragment id &ref
      className: "meta",
      begin: "&" + t.UNDERSCORE_IDENT_RE + "$"
    },
    {
      // fragment reference *ref
      className: "meta",
      begin: "\\*" + t.UNDERSCORE_IDENT_RE + "$"
    },
    {
      // array listing
      className: "bullet",
      // TODO: remove |$ hack when we have proper look-ahead support
      begin: "-(?=[ ]|$)",
      relevance: 0
    },
    t.HASH_COMMENT_MODE,
    {
      beginKeywords: e,
      keywords: { literal: e }
    },
    f,
    // numbers are any valid C-style number that
    // sit isolated from other words
    {
      className: "number",
      begin: t.C_NUMBER_RE + "\\b",
      relevance: 0
    },
    m,
    p,
    i,
    s
  ], b = [...g];
  return b.pop(), b.push(a), h.contains = b, {
    name: "YAML",
    case_insensitive: !0,
    aliases: ["yml"],
    contains: g
  };
}
const ZI = {
  arduino: OO,
  bash: IO,
  c: DO,
  cpp: LO,
  csharp: PO,
  css: KO,
  diff: qO,
  go: GO,
  graphql: jO,
  ini: YO,
  java: XO,
  javascript: tI,
  json: nI,
  kotlin: oI,
  less: fI,
  lua: hI,
  makefile: mI,
  markdown: pI,
  objectivec: gI,
  perl: bI,
  php: yI,
  "php-template": vI,
  plaintext: wI,
  python: kI,
  "python-repl": xI,
  r: NI,
  ruby: EI,
  rust: SI,
  scss: DI,
  shell: LI,
  sql: PI,
  swift: VI,
  typescript: qI,
  vbnet: GI,
  wasm: jI,
  xml: YI,
  yaml: XI
};
class JI extends Error {
  name = (
    /** @type {const} */
    "Assertion"
  );
  code = (
    /** @type {const} */
    "ERR_ASSERTION"
  );
  /**
   * Create an assertion error.
   *
   * @param {string} message
   *   Message explaining error.
   * @param {unknown} actual
   *   Value.
   * @param {unknown} expected
   *   Baseline.
   * @param {string} operator
   *   Name of equality operation.
   * @param {boolean} generated
   *   Whether `message` is a custom message or not
   * @returns
   *   Instance.
   */
  // eslint-disable-next-line max-params
  constructor(e, n, r, o, i) {
    super(e), Error.captureStackTrace && Error.captureStackTrace(this, this.constructor), this.actual = n, this.expected = r, this.generated = i, this.operator = o;
  }
}
function ki(t, e) {
  QI(
    !!t,
    !1,
    !0,
    "ok",
    "Expected value to be truthy",
    e
  );
}
function QI(t, e, n, r, o, i) {
  if (!t)
    throw i instanceof Error ? i : new JI(
      i || o,
      e,
      n,
      r,
      !i
    );
}
const og = {}, e2 = "hljs-";
function t2(t) {
  const e = Av.newInstance();
  return t && i(t), {
    highlight: n,
    highlightAuto: r,
    listLanguages: o,
    register: i,
    registerAlias: s,
    registered: a
  };
  function n(l, c, u) {
    ki(typeof l == "string", "expected `string` as `name`"), ki(typeof c == "string", "expected `string` as `value`");
    const d = u || og, f = typeof d.prefix == "string" ? d.prefix : e2;
    if (!e.getLanguage(l))
      throw new Error("Unknown language: `" + l + "` is not registered");
    e.configure({ __emitter: n2, classPrefix: f });
    const h = (
      /** @type {HighlightResult & {_emitter: HastEmitter}} */
      e.highlight(c, { ignoreIllegals: !0, language: l })
    );
    if (h.errorRaised)
      throw new Error("Could not highlight with `Highlight.js`", {
        cause: h.errorRaised
      });
    const m = h._emitter.root, p = (
      /** @type {RootData} */
      m.data
    );
    return p.language = h.language, p.relevance = h.relevance, m;
  }
  function r(l, c) {
    ki(typeof l == "string", "expected `string` as `value`");
    const d = (c || og).subset || o();
    let f = -1, h = 0, m;
    for (; ++f < d.length; ) {
      const p = d[f];
      if (!e.getLanguage(p)) continue;
      const g = n(p, l, c);
      g.data && g.data.relevance !== void 0 && g.data.relevance > h && (h = g.data.relevance, m = g);
    }
    return m || {
      type: "root",
      children: [],
      data: { language: void 0, relevance: h }
    };
  }
  function o() {
    return e.listLanguages();
  }
  function i(l, c) {
    if (typeof l == "string")
      ki(c !== void 0, "expected `grammar`"), e.registerLanguage(l, c);
    else {
      let u;
      for (u in l)
        Object.hasOwn(l, u) && e.registerLanguage(u, l[u]);
    }
  }
  function s(l, c) {
    if (typeof l == "string")
      ki(c !== void 0), e.registerAliases(
        // Note: copy needed because hljs doesn’t accept readonly arrays yet.
        typeof c == "string" ? c : [...c],
        { languageName: l }
      );
    else {
      let u;
      for (u in l)
        if (Object.hasOwn(l, u)) {
          const d = l[u];
          e.registerAliases(
            // Note: copy needed because hljs doesn’t accept readonly arrays yet.
            typeof d == "string" ? d : [...d],
            { languageName: u }
          );
        }
    }
  }
  function a(l) {
    return !!e.getLanguage(l);
  }
}
class n2 {
  /**
   * @param {Readonly<HljsOptions>} options
   *   Configuration.
   * @returns
   *   Instance.
   */
  constructor(e) {
    this.options = e, this.root = {
      type: "root",
      children: [],
      data: { language: void 0, relevance: 0 }
    }, this.stack = [this.root];
  }
  /**
   * @param {string} value
   *   Text to add.
   * @returns {undefined}
   *   Nothing.
   *
   */
  addText(e) {
    if (e === "") return;
    const n = this.stack[this.stack.length - 1], r = n.children[n.children.length - 1];
    r && r.type === "text" ? r.value += e : n.children.push({ type: "text", value: e });
  }
  /**
   *
   * @param {unknown} rawName
   *   Name to add.
   * @returns {undefined}
   *   Nothing.
   */
  startScope(e) {
    this.openNode(String(e));
  }
  /**
   * @returns {undefined}
   *   Nothing.
   */
  endScope() {
    this.closeNode();
  }
  /**
   * @param {HastEmitter} other
   *   Other emitter.
   * @param {string} name
   *   Name of the sublanguage.
   * @returns {undefined}
   *   Nothing.
   */
  __addSublanguage(e, n) {
    const r = this.stack[this.stack.length - 1], o = (
      /** @type {Array<ElementContent>} */
      e.root.children
    );
    n ? r.children.push({
      type: "element",
      tagName: "span",
      properties: { className: [n] },
      children: o
    }) : r.children.push(...o);
  }
  /**
   * @param {string} name
   *   Name to add.
   * @returns {undefined}
   *   Nothing.
   */
  openNode(e) {
    const n = this, r = e.split(".").map(function(s, a) {
      return a ? s + "_".repeat(a) : n.options.classPrefix + s;
    }), o = this.stack[this.stack.length - 1], i = {
      type: "element",
      tagName: "span",
      properties: { className: r },
      children: []
    };
    o.children.push(i), this.stack.push(i);
  }
  /**
   * @returns {undefined}
   *   Nothing.
   */
  closeNode() {
    this.stack.pop();
  }
  /**
   * @returns {undefined}
   *   Nothing.
   */
  finalize() {
  }
  /**
   * @returns {string}
   *   Nothing.
   */
  toHTML() {
    return "";
  }
}
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const r2 = (t) => t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), jv = (...t) => t.filter((e, n, r) => !!e && r.indexOf(e) === n).join(" ");
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var o2 = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const i2 = Xl(
  ({
    color: t = "currentColor",
    size: e = 24,
    strokeWidth: n = 2,
    absoluteStrokeWidth: r,
    className: o = "",
    children: i,
    iconNode: s,
    ...a
  }, l) => Aa(
    "svg",
    {
      ref: l,
      ...o2,
      width: e,
      height: e,
      stroke: t,
      strokeWidth: r ? Number(n) * 24 / Number(e) : n,
      className: jv("lucide", o),
      ...a
    },
    [
      ...s.map(([c, u]) => Aa(c, u)),
      ...Array.isArray(i) ? i : [i]
    ]
  )
);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ee = (t, e) => {
  const n = Xl(
    ({ className: r, ...o }, i) => Aa(i2, {
      ref: i,
      iconNode: e,
      className: jv(`lucide-${r2(t)}`, r),
      ...o
    })
  );
  return n.displayName = `${t}`, n;
};
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const s2 = ee("Activity", [
  [
    "path",
    {
      d: "M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2",
      key: "169zse"
    }
  ]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Sl = ee("Bold", [
  [
    "path",
    { d: "M6 12h9a4 4 0 0 1 0 8H7a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h7a4 4 0 0 1 0 8", key: "mg9rjx" }
  ]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Yv = ee("Calendar", [
  ["path", { d: "M8 2v4", key: "1cmpym" }],
  ["path", { d: "M16 2v4", key: "4m81vk" }],
  ["rect", { width: "18", height: "18", x: "3", y: "4", rx: "2", key: "1hopcy" }],
  ["path", { d: "M3 10h18", key: "8toen8" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const a2 = ee("CaseSensitive", [
  ["path", { d: "m3 15 4-8 4 8", key: "1vwr6u" }],
  ["path", { d: "M4 13h6", key: "1r9ots" }],
  ["circle", { cx: "18", cy: "12", r: "3", key: "1kchzo" }],
  ["path", { d: "M21 9v6", key: "anns31" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const yc = ee("Check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const vc = ee("ChevronDown", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const l2 = ee("ChevronRight", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const c2 = ee("ChevronUp", [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Tl = ee("CircleAlert", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }],
  ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Cl = ee("CircleCheckBig", [
  ["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }],
  ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const u2 = ee("CirclePlus", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M8 12h8", key: "1wcyev" }],
  ["path", { d: "M12 8v8", key: "napkw2" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const d2 = ee("CircleX", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "m15 9-6 6", key: "1uzhvr" }],
  ["path", { d: "m9 9 6 6", key: "z0biqf" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const f2 = ee("CloudOff", [
  ["path", { d: "m2 2 20 20", key: "1ooewy" }],
  ["path", { d: "M5.782 5.782A7 7 0 0 0 9 19h8.5a4.5 4.5 0 0 0 1.307-.193", key: "yfwify" }],
  [
    "path",
    { d: "M21.532 16.5A4.5 4.5 0 0 0 17.5 10h-1.79A7.008 7.008 0 0 0 10 5.07", key: "jlfiyv" }
  ]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const h2 = ee("Cloud", [
  ["path", { d: "M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z", key: "p7xjir" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const xd = ee("CodeXml", [
  ["path", { d: "m18 16 4-4-4-4", key: "1inbqp" }],
  ["path", { d: "m6 8-4 4 4 4", key: "15zrgr" }],
  ["path", { d: "m14.5 4-5 16", key: "e7oirm" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Nd = ee("Code", [
  ["polyline", { points: "16 18 22 12 16 6", key: "z7tu5w" }],
  ["polyline", { points: "8 6 2 12 8 18", key: "1eg1df" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ig = ee("Columns2", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M12 3v18", key: "108xh3" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const eh = ee("Copy", [
  ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
  ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const m2 = ee("ExternalLink", [
  ["path", { d: "M15 3h6v6", key: "1q9fwt" }],
  ["path", { d: "M10 14 21 3", key: "gplh6r" }],
  ["path", { d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6", key: "a6xqqp" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const p2 = ee("Eye", [
  [
    "path",
    {
      d: "M2.062 12.348a1 1 0 0 1 0-.696 10.75 10.75 0 0 1 19.876 0 1 1 0 0 1 0 .696 10.75 10.75 0 0 1-19.876 0",
      key: "1nclc0"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const g2 = ee("FileCode", [
  ["path", { d: "M10 12.5 8 15l2 2.5", key: "1tg20x" }],
  ["path", { d: "m14 12.5 2 2.5-2 2.5", key: "yinavb" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7z", key: "1mlx9k" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Vo = ee("FileText", [
  ["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }],
  ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }],
  ["path", { d: "M10 9H8", key: "b1mrlr" }],
  ["path", { d: "M16 13H8", key: "t4e002" }],
  ["path", { d: "M16 17H8", key: "z1uh3a" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ml = ee("Heading1", [
  ["path", { d: "M4 12h8", key: "17cfdx" }],
  ["path", { d: "M4 18V6", key: "1rz3zl" }],
  ["path", { d: "M12 18V6", key: "zqpxq5" }],
  ["path", { d: "m17 12 3-2v8", key: "1hhhft" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const th = ee("Heading2", [
  ["path", { d: "M4 12h8", key: "17cfdx" }],
  ["path", { d: "M4 18V6", key: "1rz3zl" }],
  ["path", { d: "M12 18V6", key: "zqpxq5" }],
  ["path", { d: "M21 18h-4c0-4 4-3 4-6 0-1.5-2-2.5-4-1", key: "9jr5yi" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const nh = ee("Heading3", [
  ["path", { d: "M4 12h8", key: "17cfdx" }],
  ["path", { d: "M4 18V6", key: "1rz3zl" }],
  ["path", { d: "M12 18V6", key: "zqpxq5" }],
  ["path", { d: "M17.5 10.5c1.7-1 3.5 0 3.5 1.5a2 2 0 0 1-2 2", key: "68ncm8" }],
  ["path", { d: "M17 17.5c2 1.5 4 .3 4-1.5a2 2 0 0 0-2-2", key: "1ejuhz" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ed = ee("Highlighter", [
  ["path", { d: "m9 11-6 6v3h9l3-3", key: "1a3l36" }],
  ["path", { d: "m22 12-4.6 4.6a2 2 0 0 1-2.8 0l-5.2-5.2a2 2 0 0 1 0-2.8L14 4", key: "14a9rk" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const b2 = ee("ImagePlus", [
  ["path", { d: "M16 5h6", key: "1vod17" }],
  ["path", { d: "M19 2v6", key: "4bpg5p" }],
  ["path", { d: "M21 11.5V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h7.5", key: "1ue2ih" }],
  ["path", { d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21", key: "1xmnt7" }],
  ["circle", { cx: "9", cy: "9", r: "2", key: "af1f0g" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Al = ee("Image", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2", key: "1m3agn" }],
  ["circle", { cx: "9", cy: "9", r: "2", key: "af1f0g" }],
  ["path", { d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21", key: "1xmnt7" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const sg = ee("IndentDecrease", [
  ["path", { d: "M21 12H11", key: "wd7e0v" }],
  ["path", { d: "M21 18H11", key: "4wu86t" }],
  ["path", { d: "M21 6H11", key: "6dy1d6" }],
  ["path", { d: "m7 8-4 4 4 4", key: "o5hrat" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ag = ee("IndentIncrease", [
  ["path", { d: "M21 12H11", key: "wd7e0v" }],
  ["path", { d: "M21 18H11", key: "4wu86t" }],
  ["path", { d: "M21 6H11", key: "6dy1d6" }],
  ["path", { d: "m3 8 4 4-4 4", key: "1a3j6y" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ho = ee("Info", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M12 16v-4", key: "1dtifu" }],
  ["path", { d: "M12 8h.01", key: "e9boi3" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const _l = ee("Italic", [
  ["line", { x1: "19", x2: "10", y1: "4", y2: "4", key: "15jd3p" }],
  ["line", { x1: "14", x2: "5", y1: "20", y2: "20", key: "bu0au3" }],
  ["line", { x1: "15", x2: "9", y1: "4", y2: "20", key: "uljnxc" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const rh = ee("Link2", [
  ["path", { d: "M9 17H7A5 5 0 0 1 7 7h2", key: "8i5ue5" }],
  ["path", { d: "M15 7h2a5 5 0 1 1 0 10h-2", key: "1b9ql8" }],
  ["line", { x1: "8", x2: "16", y1: "12", y2: "12", key: "1jonct" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Rl = ee("Link", [
  ["path", { d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71", key: "1cjeqo" }],
  ["path", { d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71", key: "19qd67" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ol = ee("ListOrdered", [
  ["path", { d: "M10 12h11", key: "6m4ad9" }],
  ["path", { d: "M10 18h11", key: "11hvi2" }],
  ["path", { d: "M10 6h11", key: "c7qv1k" }],
  ["path", { d: "M4 10h2", key: "16xx2s" }],
  ["path", { d: "M4 6h1v4", key: "cnovpq" }],
  ["path", { d: "M6 18H4c0-1 2-2 2-3s-1-1.5-2-1", key: "m9a95d" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Gi = ee("List", [
  ["path", { d: "M3 12h.01", key: "nlz23k" }],
  ["path", { d: "M3 18h.01", key: "1tta3j" }],
  ["path", { d: "M3 6h.01", key: "1rqtza" }],
  ["path", { d: "M8 12h13", key: "1za7za" }],
  ["path", { d: "M8 18h13", key: "1lx6n3" }],
  ["path", { d: "M8 6h13", key: "ik3vkj" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const y2 = ee("LoaderCircle", [
  ["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const v2 = ee("Maximize2", [
  ["polyline", { points: "15 3 21 3 21 9", key: "mznyad" }],
  ["polyline", { points: "9 21 3 21 3 15", key: "1avn1i" }],
  ["line", { x1: "21", x2: "14", y1: "3", y2: "10", key: "ota7mn" }],
  ["line", { x1: "3", x2: "10", y1: "21", y2: "14", key: "1atl0r" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const w2 = ee("Minimize2", [
  ["polyline", { points: "4 14 10 14 10 20", key: "11kfnr" }],
  ["polyline", { points: "20 10 14 10 14 4", key: "rlmsce" }],
  ["line", { x1: "14", x2: "21", y1: "10", y2: "3", key: "o5lafz" }],
  ["line", { x1: "3", x2: "10", y1: "21", y2: "14", key: "1atl0r" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Sd = ee("Minus", [["path", { d: "M5 12h14", key: "1ays0h" }]]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const k2 = ee("MousePointerClick", [
  ["path", { d: "M14 4.1 12 6", key: "ita8i4" }],
  ["path", { d: "m5.1 8-2.9-.8", key: "1go3kf" }],
  ["path", { d: "m6 12-1.9 2", key: "mnht97" }],
  ["path", { d: "M7.2 2.2 8 5.1", key: "1cfko1" }],
  [
    "path",
    {
      d: "M9.037 9.69a.498.498 0 0 1 .653-.653l11 4.5a.5.5 0 0 1-.074.949l-4.349 1.041a1 1 0 0 0-.74.739l-1.04 4.35a.5.5 0 0 1-.95.074z",
      key: "s0h3yz"
    }
  ]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const x2 = ee("Palette", [
  ["circle", { cx: "13.5", cy: "6.5", r: ".5", fill: "currentColor", key: "1okk4w" }],
  ["circle", { cx: "17.5", cy: "10.5", r: ".5", fill: "currentColor", key: "f64h9f" }],
  ["circle", { cx: "8.5", cy: "7.5", r: ".5", fill: "currentColor", key: "fotxhn" }],
  ["circle", { cx: "6.5", cy: "12.5", r: ".5", fill: "currentColor", key: "qy21gx" }],
  [
    "path",
    {
      d: "M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z",
      key: "12rzf8"
    }
  ]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const N2 = ee("PanelRightClose", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M15 3v18", key: "14nvp0" }],
  ["path", { d: "m8 9 3 3-3 3", key: "12hl5m" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const E2 = ee("PanelRightOpen", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M15 3v18", key: "14nvp0" }],
  ["path", { d: "m10 15-3-3 3-3", key: "1pgupc" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const S2 = ee("Pilcrow", [
  ["path", { d: "M13 4v16", key: "8vvj80" }],
  ["path", { d: "M17 4v16", key: "7dpous" }],
  ["path", { d: "M19 4H9.5a4.5 4.5 0 0 0 0 9H13", key: "sh4n9v" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const T2 = ee("Plus", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Il = ee("Quote", [
  [
    "path",
    {
      d: "M16 3a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2 1 1 0 0 1 1 1v1a2 2 0 0 1-2 2 1 1 0 0 0-1 1v2a1 1 0 0 0 1 1 6 6 0 0 0 6-6V5a2 2 0 0 0-2-2z",
      key: "rib7q0"
    }
  ],
  [
    "path",
    {
      d: "M5 3a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2 1 1 0 0 1 1 1v1a2 2 0 0 1-2 2 1 1 0 0 0-1 1v2a1 1 0 0 0 1 1 6 6 0 0 0 6-6V5a2 2 0 0 0-2-2z",
      key: "1ymkrd"
    }
  ]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const C2 = ee("Redo", [
  ["path", { d: "M21 7v6h-6", key: "3ptur4" }],
  ["path", { d: "M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7", key: "1kgawr" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const M2 = ee("Regex", [
  ["path", { d: "M17 3v10", key: "15fgeh" }],
  ["path", { d: "m12.67 5.5 8.66 5", key: "1gpheq" }],
  ["path", { d: "m12.67 10.5 8.66-5", key: "1dkfa6" }],
  [
    "path",
    { d: "M9 17a2 2 0 0 0-2-2H5a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h2a2 2 0 0 0 2-2v-2z", key: "swwfx4" }
  ]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const A2 = ee("ReplaceAll", [
  ["path", { d: "M14 14a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2", key: "1yyzbs" }],
  ["path", { d: "M14 4a2 2 0 0 1 2-2", key: "1w2hp7" }],
  ["path", { d: "M16 10a2 2 0 0 1-2-2", key: "shjach" }],
  ["path", { d: "M20 14a2 2 0 0 1 2 2v4a2 2 0 0 1-2 2", key: "zfj4xr" }],
  ["path", { d: "M20 2a2 2 0 0 1 2 2", key: "188mtx" }],
  ["path", { d: "M22 8a2 2 0 0 1-2 2", key: "ddf4tu" }],
  ["path", { d: "m3 7 3 3 3-3", key: "x25e72" }],
  ["path", { d: "M6 10V5a 3 3 0 0 1 3-3h1", key: "1ageje" }],
  ["rect", { x: "2", y: "14", width: "8", height: "8", rx: "2", key: "4rksxw" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const lg = ee("Replace", [
  ["path", { d: "M14 4a2 2 0 0 1 2-2", key: "1w2hp7" }],
  ["path", { d: "M16 10a2 2 0 0 1-2-2", key: "shjach" }],
  ["path", { d: "M20 2a2 2 0 0 1 2 2", key: "188mtx" }],
  ["path", { d: "M22 8a2 2 0 0 1-2 2", key: "ddf4tu" }],
  ["path", { d: "m3 7 3 3 3-3", key: "x25e72" }],
  ["path", { d: "M6 10V5a3 3 0 0 1 3-3h1", key: "3y3t5z" }],
  ["rect", { x: "2", y: "14", width: "8", height: "8", rx: "2", key: "4rksxw" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const _2 = ee("RotateCcw", [
  ["path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "1357e3" }],
  ["path", { d: "M3 3v5h5", key: "1xhq8a" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const cg = ee("Rows2", [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M3 12h18", key: "1i2n21" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const R2 = ee("Search", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Dl = ee("SquareCheckBig", [
  ["path", { d: "M21 10.5V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h12.5", key: "1uzm8b" }],
  ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ll = ee("Strikethrough", [
  ["path", { d: "M16 4H9a3 3 0 0 0-2.83 4", key: "43sutm" }],
  ["path", { d: "M14 12a4 4 0 0 1 0 8H6", key: "nlfj13" }],
  ["line", { x1: "4", x2: "20", y1: "12", y2: "12", key: "1e0a9i" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Sa = ee("Table", [
  ["path", { d: "M12 3v18", key: "108xh3" }],
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M3 9h18", key: "1pudct" }],
  ["path", { d: "M3 15h18", key: "5xshup" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ug = ee("ToggleLeft", [
  ["rect", { width: "20", height: "12", x: "2", y: "6", rx: "6", ry: "6", key: "f2vt7d" }],
  ["circle", { cx: "8", cy: "12", r: "2", key: "1nvbw3" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ji = ee("Trash2", [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }],
  ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }],
  ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Pl = ee("TriangleAlert", [
  [
    "path",
    {
      d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3",
      key: "wmoenq"
    }
  ],
  ["path", { d: "M12 9v4", key: "juzpu7" }],
  ["path", { d: "M12 17h.01", key: "p32p05" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ws = ee("Type", [
  ["polyline", { points: "4 7 4 4 20 4 20 7", key: "1nosan" }],
  ["line", { x1: "9", x2: "15", y1: "20", y2: "20", key: "swin9y" }],
  ["line", { x1: "12", x2: "12", y1: "4", y2: "20", key: "1tx1rr" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Bl = ee("Underline", [
  ["path", { d: "M6 4v6a6 6 0 0 0 12 0V4", key: "9kb039" }],
  ["line", { x1: "4", x2: "20", y1: "20", y2: "20", key: "nun2al" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const O2 = ee("Undo", [
  ["path", { d: "M3 7v6h6", key: "1v2h90" }],
  ["path", { d: "M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13", key: "1r6uu6" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const I2 = ee("Unlink", [
  [
    "path",
    {
      d: "m18.84 12.25 1.72-1.71h-.02a5.004 5.004 0 0 0-.12-7.07 5.006 5.006 0 0 0-6.95 0l-1.72 1.71",
      key: "yqzxt4"
    }
  ],
  [
    "path",
    {
      d: "m5.17 11.75-1.71 1.71a5.004 5.004 0 0 0 .12 7.07 5.006 5.006 0 0 0 6.95 0l1.71-1.71",
      key: "4qinb0"
    }
  ],
  ["line", { x1: "8", x2: "8", y1: "2", y2: "5", key: "1041cp" }],
  ["line", { x1: "2", x2: "5", y1: "8", y2: "8", key: "14m1p5" }],
  ["line", { x1: "16", x2: "16", y1: "19", y2: "22", key: "rzdirn" }],
  ["line", { x1: "19", x2: "22", y1: "16", y2: "16", key: "ox905f" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const D2 = ee("WholeWord", [
  ["circle", { cx: "7", cy: "12", r: "3", key: "12clwm" }],
  ["path", { d: "M10 9v6", key: "17i7lo" }],
  ["circle", { cx: "17", cy: "12", r: "3", key: "gl7c2s" }],
  ["path", { d: "M14 7v8", key: "dl84cr" }],
  ["path", { d: "M22 17v1c0 .5-.5 1-1 1H3c-.5 0-1-.5-1-1v-1", key: "lt2kga" }]
]);
/**
 * @license lucide-react v0.453.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const lo = ee("X", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]), L2 = t2(ZI);
function P2({ node: t, updateAttributes: e, extension: n }) {
  const [r, o] = J(!1), [i, s] = J(!1), a = fe(null);
  ge(() => {
    const f = a.current;
    if (!f || i) return;
    const h = new IntersectionObserver(
      (m) => {
        for (const p of m)
          p.isIntersecting && (s(!0), h.unobserve(f));
      },
      {
        // Start highlighting 200px before the block enters viewport
        rootMargin: "200px 0px",
        threshold: 0
      }
    );
    return h.observe(f), () => {
      h.disconnect();
    };
  }, [i]);
  const l = ie(async () => {
    try {
      await navigator.clipboard.writeText(t.textContent), o(!0), setTimeout(() => o(!1), 2e3);
    } catch (f) {
      console.error("Failed to copy:", f);
    }
  }, [t.textContent]), c = n.options.lowlight?.listLanguages?.() || [], u = t.attrs.language || "plaintext", d = u === "plaintext" ? "Plain Text" : u.charAt(0).toUpperCase() + u.slice(1);
  return /* @__PURE__ */ y(pc, { className: "code-block-wrapper", ref: a, children: [
    /* @__PURE__ */ y("div", { className: "code-block-controls", contentEditable: !1, children: [
      /* @__PURE__ */ y("div", { className: "code-block-language-wrapper", children: [
        /* @__PURE__ */ y(
          "select",
          {
            value: u,
            onChange: (f) => e({ language: f.target.value }),
            className: "code-block-language-select",
            children: [
              /* @__PURE__ */ y("option", { value: "plaintext", children: "Plain Text" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/extensions/CodeBlockWithFeatures.tsx",
                lineNumber: 89,
                columnNumber: 13
              }, this),
              c.map((f) => /* @__PURE__ */ y("option", { value: f, children: f.charAt(0).toUpperCase() + f.slice(1) }, f, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/extensions/CodeBlockWithFeatures.tsx",
                lineNumber: 91,
                columnNumber: 15
              }, this))
            ]
          },
          void 0,
          !0,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/extensions/CodeBlockWithFeatures.tsx",
            lineNumber: 84,
            columnNumber: 11
          },
          this
        ),
        /* @__PURE__ */ y("span", { className: "code-block-language-label", children: d }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/extensions/CodeBlockWithFeatures.tsx",
          lineNumber: 96,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ y(vc, { size: 12, className: "code-block-language-chevron" }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/extensions/CodeBlockWithFeatures.tsx",
          lineNumber: 97,
          columnNumber: 11
        }, this)
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/extensions/CodeBlockWithFeatures.tsx",
        lineNumber: 83,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ y(
        "button",
        {
          type: "button",
          onClick: l,
          className: `code-block-copy-btn ${r ? "copied" : ""}`,
          title: r ? "Copied!" : "Copy code",
          children: r ? /* @__PURE__ */ y(yc, { size: 14 }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/extensions/CodeBlockWithFeatures.tsx",
            lineNumber: 105,
            columnNumber: 21
          }, this) : /* @__PURE__ */ y(eh, { size: 14 }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/extensions/CodeBlockWithFeatures.tsx",
            lineNumber: 105,
            columnNumber: 43
          }, this)
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/extensions/CodeBlockWithFeatures.tsx",
          lineNumber: 99,
          columnNumber: 9
        },
        this
      )
    ] }, void 0, !0, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/extensions/CodeBlockWithFeatures.tsx",
      lineNumber: 82,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ y("pre", { className: `code-block-pre ${i ? "" : "code-block-deferred"}`, children: /* @__PURE__ */ y(Bf, { className: i ? `language-${u}` : "language-plaintext" }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/extensions/CodeBlockWithFeatures.tsx",
      lineNumber: 112,
      columnNumber: 9
    }, this) }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/extensions/CodeBlockWithFeatures.tsx",
      lineNumber: 111,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/extensions/CodeBlockWithFeatures.tsx",
    lineNumber: 80,
    columnNumber: 5
  }, this);
}
const B2 = _O.extend({
  addNodeView() {
    return zf(P2);
  }
}).configure({
  lowlight: L2,
  defaultLanguage: "plaintext",
  HTMLAttributes: {
    class: "code-block"
  }
});
function z2({ editor: t, isOpen: e, onClose: n }) {
  const [r, o] = J(""), [i, s] = J({ top: 0, left: 0 }), a = fe(null), l = fe(null), c = ie(() => {
    if (!(!t || t.isDestroyed))
      try {
        const { view: f } = t, { from: h } = f.state.selection, m = f.coordsAtPos(h), p = 320, g = 80, b = 8, v = window.innerWidth, k = window.innerHeight;
        let x = m.bottom + 8, w = m.left;
        x + g > k - b && (x = m.top - g - 8), w + p > v - b && (w = v - p - b), w < b && (w = b), x = Math.max(b, x), s({ top: x, left: w });
      } catch {
        s({
          top: window.innerHeight / 2 - 40,
          left: window.innerWidth / 2 - 160
        });
      }
  }, [t]);
  ge(() => {
    if (e) {
      const f = t.getAttributes("link").href || "";
      o(f), c(), setTimeout(() => {
        a.current?.focus(), a.current?.select();
      }, 50);
    }
  }, [e, t, c]), ge(() => {
    if (!e) return;
    const f = () => {
      requestAnimationFrame(c);
    };
    return window.addEventListener("scroll", f, !0), window.addEventListener("resize", f), () => {
      window.removeEventListener("scroll", f, !0), window.removeEventListener("resize", f);
    };
  }, [e, c]), ge(() => {
    if (!e) return;
    const f = (h) => {
      l.current && !l.current.contains(h.target) && n();
    };
    return document.addEventListener("mousedown", f), () => document.removeEventListener("mousedown", f);
  }, [e, n]);
  const u = ie((f) => {
    if (f?.preventDefault(), r.trim()) {
      let h = r.trim();
      !/^https?:\/\//i.test(h) && !h.startsWith("mailto:") && (h = "https://" + h), t.chain().focus().extendMarkRange("link").setLink({ href: h }).run();
    } else
      t.chain().focus().unsetLink().run();
    n();
  }, [r, t, n]), d = ie((f) => {
    f.key === "Escape" ? (f.preventDefault(), n()) : f.key === "Enter" && (f.preventDefault(), u());
  }, [n, u]);
  return e ? ai(
    /* @__PURE__ */ y(
      "div",
      {
        ref: l,
        className: "link-popover",
        style: {
          position: "fixed",
          top: `${i.top}px`,
          left: `${i.left}px`,
          zIndex: 9999
        },
        children: /* @__PURE__ */ y("form", { onSubmit: u, className: "link-popover-form", children: [
          /* @__PURE__ */ y("div", { className: "link-popover-input-wrapper", children: [
            /* @__PURE__ */ y(rh, { className: "link-popover-icon", size: 16 }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/LinkPopover.tsx",
              lineNumber: 163,
              columnNumber: 11
            }, this),
            /* @__PURE__ */ y(
              "input",
              {
                ref: a,
                type: "text",
                value: r,
                onChange: (f) => o(f.target.value),
                onKeyDown: d,
                placeholder: "Enter URL or paste link",
                className: "link-popover-input",
                autoComplete: "off",
                spellCheck: !1
              },
              void 0,
              !1,
              {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/LinkPopover.tsx",
                lineNumber: 164,
                columnNumber: 11
              },
              this
            )
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/LinkPopover.tsx",
            lineNumber: 162,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ y("div", { className: "link-popover-hint", children: "Press Enter to save · Escape to cancel" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/LinkPopover.tsx",
            lineNumber: 176,
            columnNumber: 9
          }, this)
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/LinkPopover.tsx",
          lineNumber: 161,
          columnNumber: 7
        }, this)
      },
      void 0,
      !1,
      {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/LinkPopover.tsx",
        lineNumber: 151,
        columnNumber: 5
      },
      this
    ),
    document.body
  ) : null;
}
function $2({ editor: t, onEditLink: e }) {
  const [n, r] = J({
    isVisible: !1,
    url: "",
    position: { top: 0, left: 0 },
    linkElement: null
  }), o = fe(null), i = fe(null), s = ie((h) => {
    if (!(!t || t.isDestroyed)) {
      i.current && (clearTimeout(i.current), i.current = null);
      try {
        const m = h.getAttribute("href") || "", p = h.getBoundingClientRect(), g = 320, b = 40, v = 8, k = window.innerWidth, x = window.innerHeight;
        let w = p.bottom + 8, E = p.left;
        w + b > x - v && (w = p.top - b - 8), E + g > k - v && (E = k - g - v), E < v && (E = v), r({
          isVisible: !0,
          url: m,
          position: { top: w, left: E },
          linkElement: h
        });
      } catch (m) {
        console.warn("LinkHoverTooltip: Error showing tooltip", m);
      }
    }
  }, [t]), a = ie(() => {
    i.current = setTimeout(() => {
      r((h) => ({ ...h, isVisible: !1, linkElement: null }));
    }, 150);
  }, []), l = ie(() => {
    i.current && (clearTimeout(i.current), i.current = null);
  }, []);
  ge(() => {
    if (!t || t.isDestroyed) return;
    const h = t.view.dom;
    if (!h) return;
    const m = (g) => {
      const v = g.target.closest("a");
      v && h.contains(v) && s(v);
    }, p = (g) => {
      const b = g.target, v = g.relatedTarget;
      if (b.closest("a")) {
        if (v && o.current?.contains(v))
          return;
        a();
      }
    };
    return h.addEventListener("mouseover", m), h.addEventListener("mouseout", p), () => {
      h.removeEventListener("mouseover", m), h.removeEventListener("mouseout", p), i.current && clearTimeout(i.current);
    };
  }, [t, s, a]);
  const c = ie(() => {
    n.url && window.open(n.url, "_blank", "noopener,noreferrer"), r((h) => ({ ...h, isVisible: !1 }));
  }, [n.url]), u = ie(() => {
    if (n.linkElement) {
      const { view: h } = t, { doc: m } = h.state;
      let p = null, g = null;
      m.descendants((b, v) => {
        if (b.isText && b.marks.some((k) => k.type.name === "link")) {
          const k = h.nodeDOM(v);
          if (k && (k === n.linkElement || k.parentElement === n.linkElement))
            return p = v, g = v + b.nodeSize, !1;
        }
        return !0;
      }), p !== null && g !== null ? t.chain().focus().setTextSelection({ from: p, to: g }).unsetLink().run() : t.chain().focus().unsetLink().run();
    }
    r((h) => ({ ...h, isVisible: !1 }));
  }, [t, n.linkElement]), d = ie(() => {
    if (n.linkElement) {
      const { view: h } = t, { doc: m } = h.state;
      m.descendants((p, g) => {
        if (p.isText && p.marks.some((b) => b.type.name === "link")) {
          const b = h.nodeDOM(g);
          if (b && (b === n.linkElement || b.parentElement === n.linkElement))
            return t.chain().focus().setTextSelection({ from: g, to: g + p.nodeSize }).run(), !1;
        }
        return !0;
      });
    }
    r((h) => ({ ...h, isVisible: !1 })), e();
  }, [t, n.linkElement, e]);
  if (!n.isVisible) return null;
  const f = n.url.length > 40 ? n.url.substring(0, 40) + "..." : n.url;
  return ai(
    /* @__PURE__ */ y(
      "div",
      {
        ref: o,
        className: "link-hover-tooltip",
        style: {
          position: "fixed",
          top: `${n.position.top}px`,
          left: `${n.position.left}px`,
          zIndex: 9999
        },
        onMouseEnter: l,
        onMouseLeave: a,
        children: /* @__PURE__ */ y("div", { className: "link-hover-tooltip-content", children: [
          /* @__PURE__ */ y(
            "button",
            {
              onClick: d,
              className: "link-hover-tooltip-edit",
              title: "Edit link",
              children: /* @__PURE__ */ y("span", { className: "link-hover-tooltip-url", children: f || "Edit link" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/LinkHoverTooltip.tsx",
                lineNumber: 223,
                columnNumber: 11
              }, this)
            },
            void 0,
            !1,
            {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/LinkHoverTooltip.tsx",
              lineNumber: 218,
              columnNumber: 9
            },
            this
          ),
          /* @__PURE__ */ y("div", { className: "link-hover-tooltip-actions", children: [
            /* @__PURE__ */ y(
              "button",
              {
                onClick: c,
                className: "link-hover-tooltip-btn",
                title: "Open link",
                children: /* @__PURE__ */ y(m2, { size: 14 }, void 0, !1, {
                  fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/LinkHoverTooltip.tsx",
                  lineNumber: 231,
                  columnNumber: 13
                }, this)
              },
              void 0,
              !1,
              {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/LinkHoverTooltip.tsx",
                lineNumber: 226,
                columnNumber: 11
              },
              this
            ),
            /* @__PURE__ */ y(
              "button",
              {
                onClick: u,
                className: "link-hover-tooltip-btn link-hover-tooltip-btn-danger",
                title: "Remove link",
                children: /* @__PURE__ */ y(I2, { size: 14 }, void 0, !1, {
                  fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/LinkHoverTooltip.tsx",
                  lineNumber: 238,
                  columnNumber: 13
                }, this)
              },
              void 0,
              !1,
              {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/LinkHoverTooltip.tsx",
                lineNumber: 233,
                columnNumber: 11
              },
              this
            )
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/LinkHoverTooltip.tsx",
            lineNumber: 225,
            columnNumber: 9
          }, this)
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/LinkHoverTooltip.tsx",
          lineNumber: 217,
          columnNumber: 7
        }, this)
      },
      void 0,
      !1,
      {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/LinkHoverTooltip.tsx",
        lineNumber: 205,
        columnNumber: 5
      },
      this
    ),
    document.body
  );
}
const St = ({ onMouseDown: t, isActive: e, disabled: n, children: r, title: o }) => /* @__PURE__ */ y(
  "button",
  {
    onMouseDown: t,
    disabled: n,
    title: o,
    className: `
      flex items-center justify-center w-7 h-7 rounded-md flex-shrink-0
      transition-all duration-100 ease-out touch-manipulation
      ${e ? "bg-primary text-primary-foreground" : "bg-transparent text-foreground hover:bg-secondary active:bg-secondary/80"}
      ${n ? "opacity-50 cursor-not-allowed" : ""}
    `,
    children: r
  },
  void 0,
  !1,
  {
    fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
    lineNumber: 47,
    columnNumber: 3
  },
  void 0
), dg = () => /* @__PURE__ */ y("div", { className: "w-px h-5 bg-border mx-0.5 flex-shrink-0" }, void 0, !1, {
  fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
  lineNumber: 66,
  columnNumber: 3
}, void 0), H2 = si(function({ editor: e, className: n = "" }) {
  const r = Lf({
    editor: e,
    selector: ({ editor: w }) => ({
      isBold: w.isActive("bold"),
      isItalic: w.isActive("italic"),
      isUnderline: w.isActive("underline"),
      isStrike: w.isActive("strike"),
      isCode: w.isActive("code"),
      isHighlight: w.isActive("highlight"),
      isLink: w.isActive("link"),
      isH1: w.isActive("heading", { level: 1 }),
      isH2: w.isActive("heading", { level: 2 }),
      isH3: w.isActive("heading", { level: 3 }),
      isBulletList: w.isActive("bulletList"),
      isOrderedList: w.isActive("orderedList"),
      isTaskList: w.isActive("taskList"),
      isBlockquote: w.isActive("blockquote"),
      isCodeBlock: w.isActive("codeBlock")
    })
  }), [o, i] = J(!1), [s, a] = J(""), [l, c] = J(!1), [u, d] = J({ top: 0, left: 0 }), f = fe(null), h = fe(null), m = fe(null), p = ie(() => {
    if (s) {
      let w = s.trim();
      !/^https?:\/\//i.test(w) && !w.startsWith("mailto:") && (w = "https://" + w), e.chain().focus().extendMarkRange("link").setLink({ href: w }).run();
    } else
      e.chain().focus().extendMarkRange("link").unsetLink().run();
    i(!1), a("");
  }, [e, s]), g = (w) => {
    w.preventDefault(), w.stopPropagation();
    const E = e.getAttributes("link").href;
    a(E || ""), i(!0);
  }, b = ie((w, E) => {
    w.preventDefault(), w.stopPropagation(), E();
  }, []);
  ge(() => {
    if (!e || e.isDestroyed) return;
    const w = () => {
      if (!e.isDestroyed)
        try {
          const { selection: E } = e.state, { empty: S, from: C, to: M } = E, K = ("node" in E && E.node ? E.node : e.state.doc.nodeAt(C))?.type?.name === "resizableImage";
          if (S && !K || e.isActive("codeBlock")) {
            m.current && (clearTimeout(m.current), m.current = null), h.current && clearTimeout(h.current), h.current = setTimeout(() => {
              c(!1), i(!1);
            }, 150);
            return;
          }
          h.current && (clearTimeout(h.current), h.current = null);
          const j = e.view.coordsAtPos(C), H = e.view.coordsAtPos(M), G = f.current?.offsetWidth || 500, V = f.current?.offsetHeight || 40, re = 8, A = window.innerWidth;
          let _ = (j.left + H.left) / 2 - G / 2;
          _ = Math.max(re, Math.min(A - G - re, _));
          let z = j.top - V - 10;
          z < re && (z = H.bottom + 10), l ? d({ top: Math.max(re, z), left: _ }) : (m.current && clearTimeout(m.current), m.current = setTimeout(() => {
            d({ top: Math.max(re, z), left: _ }), c(!0);
          }, 50));
        } catch (E) {
          console.warn("FloatingToolbar: Error updating position", E);
        }
    };
    return e.on("selectionUpdate", w), () => {
      e.off("selectionUpdate", w), h.current && clearTimeout(h.current), m.current && clearTimeout(m.current);
    };
  }, [e, l]);
  const v = (w) => {
    h.current && (clearTimeout(h.current), h.current = null);
  };
  if (!l)
    return null;
  const k = 15, x = o ? /* @__PURE__ */ y(
    "div",
    {
      ref: f,
      className: `floating-toolbar ${n}`,
      style: {
        position: "fixed",
        top: u.top,
        left: u.left,
        zIndex: 9999
      },
      onMouseDown: v,
      children: /* @__PURE__ */ y("div", { className: "flex flex-col sm:flex-row items-stretch sm:items-center gap-2 px-2 w-[280px] sm:w-auto", children: [
        /* @__PURE__ */ y(
          "input",
          {
            type: "url",
            placeholder: "Enter URL...",
            value: s,
            onChange: (w) => a(w.target.value),
            onKeyDown: (w) => {
              w.key === "Enter" && (w.preventDefault(), p()), w.key === "Escape" && (i(!1), a(""));
            },
            className: `
            bg-secondary/50 rounded px-3 py-2 sm:py-1
            text-sm text-foreground placeholder:text-muted-foreground
            outline-none border border-border/50
            w-full sm:w-48
          `,
            autoFocus: !0
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
            lineNumber: 252,
            columnNumber: 9
          },
          this
        ),
        /* @__PURE__ */ y("div", { className: "flex gap-2", children: [
          /* @__PURE__ */ y(
            "button",
            {
              onMouseDown: (w) => {
                w.preventDefault(), p();
              },
              className: `
              flex-1 sm:flex-none px-4 sm:px-3 py-2 sm:py-1 text-sm sm:text-xs font-medium rounded
              bg-primary text-primary-foreground
              hover:opacity-90 active:opacity-80 transition-opacity touch-manipulation
            `,
              children: "Apply"
            },
            void 0,
            !1,
            {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
              lineNumber: 276,
              columnNumber: 11
            },
            this
          ),
          /* @__PURE__ */ y(
            "button",
            {
              onMouseDown: (w) => {
                w.preventDefault(), i(!1), a("");
              },
              className: `
              flex-1 sm:flex-none px-4 sm:px-2 py-2 sm:py-1 text-sm sm:text-xs font-medium rounded
              bg-secondary text-secondary-foreground
              hover:bg-accent active:bg-accent/80 transition-colors touch-manipulation
            `,
              children: "Cancel"
            },
            void 0,
            !1,
            {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
              lineNumber: 289,
              columnNumber: 11
            },
            this
          )
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
          lineNumber: 275,
          columnNumber: 9
        }, this)
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
        lineNumber: 251,
        columnNumber: 7
      }, this)
    },
    void 0,
    !1,
    {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
      lineNumber: 240,
      columnNumber: 5
    },
    this
  ) : /* @__PURE__ */ y(
    "div",
    {
      ref: f,
      className: `floating-toolbar ${n}`,
      style: {
        position: "fixed",
        top: u.top,
        left: u.left,
        zIndex: 9999
      },
      onMouseDown: v,
      children: [
        /* @__PURE__ */ y(
          St,
          {
            onMouseDown: (w) => b(w, () => e.chain().focus().setParagraph().run()),
            isActive: !r?.isH1 && !r?.isH2 && !r?.isH3 && !r?.isBulletList && !r?.isOrderedList && !r?.isTaskList && !r?.isBlockquote && !r?.isCodeBlock,
            title: "Paragraph",
            children: /* @__PURE__ */ y(S2, { size: k }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
              lineNumber: 324,
              columnNumber: 9
            }, this)
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
            lineNumber: 319,
            columnNumber: 7
          },
          this
        ),
        /* @__PURE__ */ y(
          St,
          {
            onMouseDown: (w) => b(w, () => e.chain().focus().toggleHeading({ level: 1 }).run()),
            isActive: r?.isH1,
            title: "Heading 1",
            children: /* @__PURE__ */ y(Ml, { size: k }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
              lineNumber: 333,
              columnNumber: 9
            }, this)
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
            lineNumber: 328,
            columnNumber: 7
          },
          this
        ),
        /* @__PURE__ */ y(
          St,
          {
            onMouseDown: (w) => b(w, () => e.chain().focus().toggleHeading({ level: 2 }).run()),
            isActive: r?.isH2,
            title: "Heading 2",
            children: /* @__PURE__ */ y(th, { size: k }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
              lineNumber: 340,
              columnNumber: 9
            }, this)
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
            lineNumber: 335,
            columnNumber: 7
          },
          this
        ),
        /* @__PURE__ */ y(
          St,
          {
            onMouseDown: (w) => b(w, () => e.chain().focus().toggleHeading({ level: 3 }).run()),
            isActive: r?.isH3,
            title: "Heading 3",
            children: /* @__PURE__ */ y(nh, { size: k }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
              lineNumber: 347,
              columnNumber: 9
            }, this)
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
            lineNumber: 342,
            columnNumber: 7
          },
          this
        ),
        /* @__PURE__ */ y(dg, {}, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
          lineNumber: 350,
          columnNumber: 7
        }, this),
        /* @__PURE__ */ y(
          St,
          {
            onMouseDown: (w) => b(w, () => e.chain().focus().toggleBold().run()),
            isActive: r?.isBold,
            title: "Bold (Ctrl+B)",
            children: /* @__PURE__ */ y(Sl, { size: k }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
              lineNumber: 358,
              columnNumber: 9
            }, this)
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
            lineNumber: 353,
            columnNumber: 7
          },
          this
        ),
        /* @__PURE__ */ y(
          St,
          {
            onMouseDown: (w) => b(w, () => e.chain().focus().toggleItalic().run()),
            isActive: r?.isItalic,
            title: "Italic (Ctrl+I)",
            children: /* @__PURE__ */ y(_l, { size: k }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
              lineNumber: 365,
              columnNumber: 9
            }, this)
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
            lineNumber: 360,
            columnNumber: 7
          },
          this
        ),
        /* @__PURE__ */ y(
          St,
          {
            onMouseDown: (w) => b(w, () => e.chain().focus().toggleUnderline().run()),
            isActive: r?.isUnderline,
            title: "Underline (Ctrl+U)",
            children: /* @__PURE__ */ y(Bl, { size: k }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
              lineNumber: 372,
              columnNumber: 9
            }, this)
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
            lineNumber: 367,
            columnNumber: 7
          },
          this
        ),
        /* @__PURE__ */ y(
          St,
          {
            onMouseDown: (w) => b(w, () => e.chain().focus().toggleStrike().run()),
            isActive: r?.isStrike,
            title: "Strikethrough",
            children: /* @__PURE__ */ y(Ll, { size: k }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
              lineNumber: 379,
              columnNumber: 9
            }, this)
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
            lineNumber: 374,
            columnNumber: 7
          },
          this
        ),
        /* @__PURE__ */ y(
          St,
          {
            onMouseDown: (w) => b(w, () => e.chain().focus().toggleCode().run()),
            isActive: r?.isCode,
            title: "Inline Code (Ctrl+E)",
            children: /* @__PURE__ */ y(Nd, { size: k }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
              lineNumber: 386,
              columnNumber: 9
            }, this)
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
            lineNumber: 381,
            columnNumber: 7
          },
          this
        ),
        /* @__PURE__ */ y(
          St,
          {
            onMouseDown: (w) => b(w, () => e.chain().focus().toggleHighlight().run()),
            isActive: r?.isHighlight,
            title: "Highlight",
            children: /* @__PURE__ */ y(Ed, { size: k }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
              lineNumber: 393,
              columnNumber: 9
            }, this)
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
            lineNumber: 388,
            columnNumber: 7
          },
          this
        ),
        /* @__PURE__ */ y(
          St,
          {
            onMouseDown: g,
            isActive: r?.isLink,
            title: "Link (Ctrl+K)",
            children: /* @__PURE__ */ y(Rl, { size: k }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
              lineNumber: 401,
              columnNumber: 9
            }, this)
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
            lineNumber: 396,
            columnNumber: 7
          },
          this
        ),
        /* @__PURE__ */ y(dg, {}, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
          lineNumber: 404,
          columnNumber: 7
        }, this),
        /* @__PURE__ */ y(
          St,
          {
            onMouseDown: (w) => b(w, () => e.chain().focus().toggleBlockquote().run()),
            isActive: r?.isBlockquote,
            title: "Quote",
            children: /* @__PURE__ */ y(Il, { size: k }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
              lineNumber: 412,
              columnNumber: 9
            }, this)
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
            lineNumber: 407,
            columnNumber: 7
          },
          this
        ),
        /* @__PURE__ */ y(
          St,
          {
            onMouseDown: (w) => b(w, () => e.chain().focus().toggleBulletList().run()),
            isActive: r?.isBulletList,
            title: "Bullet List",
            children: /* @__PURE__ */ y(Gi, { size: k }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
              lineNumber: 419,
              columnNumber: 9
            }, this)
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
            lineNumber: 414,
            columnNumber: 7
          },
          this
        ),
        /* @__PURE__ */ y(
          St,
          {
            onMouseDown: (w) => b(w, () => e.chain().focus().toggleOrderedList().run()),
            isActive: r?.isOrderedList,
            title: "Numbered List",
            children: /* @__PURE__ */ y(Ol, { size: k }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
              lineNumber: 426,
              columnNumber: 9
            }, this)
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
            lineNumber: 421,
            columnNumber: 7
          },
          this
        ),
        /* @__PURE__ */ y(
          St,
          {
            onMouseDown: (w) => b(w, () => e.chain().focus().toggleTaskList().run()),
            isActive: r?.isTaskList,
            title: "Task List",
            children: /* @__PURE__ */ y(Dl, { size: k }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
              lineNumber: 433,
              columnNumber: 9
            }, this)
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
            lineNumber: 428,
            columnNumber: 7
          },
          this
        ),
        /* @__PURE__ */ y(
          St,
          {
            onMouseDown: (w) => b(w, () => e.chain().focus().toggleCodeBlock().run()),
            isActive: r?.isCodeBlock,
            title: "Code Block",
            children: /* @__PURE__ */ y(g2, { size: k }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
              lineNumber: 440,
              columnNumber: 9
            }, this)
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
            lineNumber: 435,
            columnNumber: 7
          },
          this
        )
      ]
    },
    void 0,
    !0,
    {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FloatingToolbar.tsx",
      lineNumber: 307,
      columnNumber: 5
    },
    this
  );
  return ai(x, document.body);
}), zl = {
  info: { icon: Ho, label: "Info", color: "var(--callout-info)" },
  warning: { icon: Pl, label: "Warning", color: "var(--callout-warning)" },
  error: { icon: d2, label: "Error", color: "var(--callout-error)" },
  success: { icon: Cl, label: "Success", color: "var(--callout-success)" },
  note: { icon: Vo, label: "Note", color: "var(--callout-note)" }
};
function F2({
  buttonRef: t,
  type: e,
  onTypeChange: n,
  onClose: r,
  theme: o
}) {
  const i = fe(null), [s, a] = J(null), l = 185, c = ie(() => {
    if (!t.current) return;
    const d = t.current.getBoundingClientRect(), h = window.innerHeight - d.bottom, m = d.top, p = h < l + 8 && m > l + 8;
    a({
      top: p ? d.top - l - 4 : d.bottom + 4,
      left: d.left,
      flipped: p
    });
  }, [t]);
  if (ge(() => {
    c();
    const d = () => c();
    return window.addEventListener("scroll", d, !0), window.addEventListener("resize", d), () => {
      window.removeEventListener("scroll", d, !0), window.removeEventListener("resize", d);
    };
  }, [c]), ge(() => {
    const d = (f) => {
      i.current && !i.current.contains(f.target) && t.current && !t.current.contains(f.target) && r();
    };
    return document.addEventListener("mousedown", d), () => document.removeEventListener("mousedown", d);
  }, [t, r]), ge(() => {
    const d = (f) => {
      f.key === "Escape" && r();
    };
    return document.addEventListener("keydown", d), () => document.removeEventListener("keydown", d);
  }, [r]), !s) return null;
  const u = /* @__PURE__ */ y(
    "div",
    {
      ref: i,
      className: `callout-type-dropdown-portal ${o === "dark" ? "dark-theme" : "light-theme"}`,
      style: {
        position: "fixed",
        top: s.top,
        left: s.left,
        zIndex: 99999,
        maxHeight: l,
        overflowY: "auto"
      },
      children: Object.keys(zl).map((d) => {
        const f = zl[d], h = f.icon;
        return /* @__PURE__ */ y(
          "button",
          {
            className: `callout-type-option ${d === e ? "active" : ""}`,
            onClick: () => n(d),
            style: { "--callout-option-color": f.color },
            children: [
              /* @__PURE__ */ y(h, { size: 16, style: { color: f.color } }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/extensions/CalloutWithMenu.tsx",
                lineNumber: 124,
                columnNumber: 13
              }, this),
              /* @__PURE__ */ y("span", { children: f.label }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/extensions/CalloutWithMenu.tsx",
                lineNumber: 125,
                columnNumber: 13
              }, this)
            ]
          },
          d,
          !0,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/extensions/CalloutWithMenu.tsx",
            lineNumber: 118,
            columnNumber: 11
          },
          this
        );
      })
    },
    void 0,
    !1,
    {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/extensions/CalloutWithMenu.tsx",
      lineNumber: 102,
      columnNumber: 5
    },
    this
  );
  return ai(u, document.body);
}
function U2({ node: t, updateAttributes: e, editor: n }) {
  const [r, o] = J(!1), i = fe(null), s = t.attrs.type || "info", a = zl[s] || zl.info, l = a.icon, [c, u] = J("light");
  ge(() => {
    const h = n.view.dom.closest("[data-theme]");
    h ? u(h.getAttribute("data-theme") || "light") : document.documentElement.classList.contains("dark") && u("dark");
  }, [n]);
  const d = ie((h) => {
    e({ type: h }), o(!1);
  }, [e]), f = ie(() => {
    o(!1);
  }, []);
  return /* @__PURE__ */ y(pc, { className: `callout callout-${s}`, "data-callout": "", "data-type": s, children: [
    /* @__PURE__ */ y("div", { className: "callout-icon-container", children: [
      /* @__PURE__ */ y(
        "button",
        {
          ref: i,
          className: "callout-icon-button",
          onClick: () => n.isEditable && o(!r),
          title: n.isEditable ? "Click to change callout type" : a.label,
          style: { color: a.color },
          contentEditable: !1,
          children: [
            /* @__PURE__ */ y(l, { size: 20 }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/extensions/CalloutWithMenu.tsx",
              lineNumber: 173,
              columnNumber: 11
            }, this),
            n.isEditable && /* @__PURE__ */ y(vc, { size: 12, className: "callout-chevron" }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/extensions/CalloutWithMenu.tsx",
              lineNumber: 174,
              columnNumber: 33
            }, this)
          ]
        },
        void 0,
        !0,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/extensions/CalloutWithMenu.tsx",
          lineNumber: 165,
          columnNumber: 9
        },
        this
      ),
      r && n.isEditable && /* @__PURE__ */ y(
        F2,
        {
          buttonRef: i,
          type: s,
          onTypeChange: d,
          onClose: f,
          theme: c
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/extensions/CalloutWithMenu.tsx",
          lineNumber: 178,
          columnNumber: 11
        },
        this
      )
    ] }, void 0, !0, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/extensions/CalloutWithMenu.tsx",
      lineNumber: 164,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ y("div", { className: "callout-content", children: /* @__PURE__ */ y(Bf, {}, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/extensions/CalloutWithMenu.tsx",
      lineNumber: 188,
      columnNumber: 9
    }, this) }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/extensions/CalloutWithMenu.tsx",
      lineNumber: 187,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/extensions/CalloutWithMenu.tsx",
    lineNumber: 163,
    columnNumber: 5
  }, this);
}
const W2 = rt.create({
  name: "callout",
  addOptions() {
    return {
      HTMLAttributes: {},
      types: ["info", "warning", "error", "success", "note"]
    };
  },
  content: "block+",
  group: "block",
  defining: !0,
  addAttributes() {
    return {
      type: {
        default: "info",
        parseHTML: (t) => t.getAttribute("data-type") || "info",
        renderHTML: (t) => ({
          "data-type": t.type
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "div[data-callout]"
      }
    ];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    const n = t.attrs.type;
    return [
      "div",
      De(this.options.HTMLAttributes, e, {
        "data-callout": "",
        "data-type": n,
        class: `callout callout-${n}`
      }),
      0
    ];
  },
  addNodeView() {
    return zf(U2);
  },
  addCommands() {
    return {
      setCallout: (t) => ({ commands: e }) => e.wrapIn(this.name, t),
      toggleCallout: (t) => ({ commands: e }) => e.toggleWrap(this.name, t),
      unsetCallout: () => ({ commands: t }) => t.lift(this.name),
      insertCallout: (t) => ({ chain: e }) => {
        const n = t?.type || "info";
        return e().insertContent({
          type: this.name,
          attrs: { type: n },
          content: [{ type: "paragraph" }]
        }).focus().run();
      },
      updateCalloutType: (t) => ({ commands: e }) => e.updateAttributes(this.name, { type: t })
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-c": () => this.editor.commands.toggleCallout({ type: "info" })
    };
  }
});
var V2 = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/, K2 = rt.create({
  name: "image",
  addOptions() {
    return {
      inline: !1,
      allowBase64: !1,
      HTMLAttributes: {},
      resize: !1
    };
  },
  inline() {
    return this.options.inline;
  },
  group() {
    return this.options.inline ? "inline" : "block";
  },
  draggable: !0,
  addAttributes() {
    return {
      src: {
        default: null
      },
      alt: {
        default: null
      },
      title: {
        default: null
      },
      width: {
        default: null
      },
      height: {
        default: null
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return ["img", De(this.options.HTMLAttributes, t)];
  },
  parseMarkdown: (t, e) => e.createNode("image", {
    src: t.href,
    title: t.title,
    alt: t.text
  }),
  renderMarkdown: (t) => {
    var e, n, r, o, i, s;
    const a = (n = (e = t.attrs) == null ? void 0 : e.src) != null ? n : "", l = (o = (r = t.attrs) == null ? void 0 : r.alt) != null ? o : "", c = (s = (i = t.attrs) == null ? void 0 : i.title) != null ? s : "";
    return c ? `![${l}](${a} "${c}")` : `![${l}](${a})`;
  },
  addNodeView() {
    if (!this.options.resize || !this.options.resize.enabled || typeof document > "u")
      return null;
    const { directions: t, minWidth: e, minHeight: n, alwaysPreserveAspectRatio: r } = this.options.resize;
    return ({ node: o, getPos: i, HTMLAttributes: s, editor: a }) => {
      const l = document.createElement("img");
      Object.entries(s).forEach(([d, f]) => {
        if (f != null)
          switch (d) {
            case "width":
            case "height":
              break;
            default:
              l.setAttribute(d, f);
              break;
          }
      }), l.src = s.src;
      const c = new kT({
        element: l,
        editor: a,
        node: o,
        getPos: i,
        onResize: (d, f) => {
          l.style.width = `${d}px`, l.style.height = `${f}px`;
        },
        onCommit: (d, f) => {
          const h = i();
          h !== void 0 && this.editor.chain().setNodeSelection(h).updateAttributes(this.name, {
            width: d,
            height: f
          }).run();
        },
        onUpdate: (d, f, h) => d.type === o.type,
        options: {
          directions: t,
          min: {
            width: e,
            height: n
          },
          preserveAspectRatio: r === !0
        }
      }), u = c.dom;
      return u.style.visibility = "hidden", u.style.pointerEvents = "none", l.onload = () => {
        u.style.visibility = "", u.style.pointerEvents = "";
      }, c;
    };
  },
  addCommands() {
    return {
      setImage: (t) => ({ commands: e }) => e.insertContent({
        type: this.name,
        attrs: t
      })
    };
  },
  addInputRules() {
    return [
      h0({
        find: V2,
        type: this.type,
        getAttributes: (t) => {
          const [, , e, n, r] = t;
          return { src: n, alt: e, title: r };
        }
      })
    ];
  }
}), q2 = K2;
const G2 = q2.extend({
  name: "resizableImage",
  addOptions() {
    return {
      ...this.parent?.(),
      HTMLAttributes: {},
      allowBase64: !0,
      onImageClick: void 0
    };
  },
  addAttributes() {
    return {
      ...this.parent?.(),
      width: {
        default: null,
        parseHTML: (t) => {
          const e = t.getAttribute("width") || t.style.width;
          return e ? parseInt(e, 10) : null;
        },
        renderHTML: (t) => t.width ? {
          width: t.width,
          style: `width: ${t.width}px`
        } : {}
      },
      height: {
        default: null,
        parseHTML: (t) => {
          const e = t.getAttribute("height") || t.style.height;
          return e ? parseInt(e, 10) : null;
        },
        renderHTML: (t) => t.height ? {
          height: t.height
        } : {}
      },
      align: {
        default: "left",
        parseHTML: (t) => t.getAttribute("data-align") || "left",
        renderHTML: (t) => ({
          "data-align": t.align
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "img[src]"
      },
      {
        tag: "figure.image-resizer img[src]"
      }
    ];
  },
  addCommands() {
    return {
      ...this.parent?.(),
      updateImage: (t) => ({ commands: e }) => e.updateAttributes("resizableImage", t),
      setImageAlign: (t) => ({ commands: e }) => e.updateAttributes("resizableImage", { align: t })
    };
  },
  renderHTML({ HTMLAttributes: t }) {
    const e = t["data-align"] || "center";
    return [
      "figure",
      {
        class: "image-resizer",
        style: {
          left: "margin-right: auto;",
          center: "margin-left: auto; margin-right: auto;",
          right: "margin-left: auto;"
        }[e] || "margin-left: auto; margin-right: auto;"
      },
      [
        "img",
        De(this.options.HTMLAttributes, t)
      ]
    ];
  },
  addNodeView() {
    return ({ node: t, editor: e, getPos: n }) => {
      const r = document.createElement("figure");
      r.classList.add("image-resizer");
      const o = (x) => {
        const w = {
          left: "margin-right: auto; margin-left: 0;",
          center: "margin-left: auto; margin-right: auto;",
          right: "margin-left: auto; margin-right: 0;"
        }[x] || "margin-left: auto; margin-right: auto;";
        r.style.cssText = `display: block; position: relative; width: fit-content; ${w}`;
      };
      o(t.attrs.align || "left");
      const i = document.createElement("img");
      i.src = t.attrs.src, i.alt = t.attrs.alt || "", t.attrs.width && (i.style.width = `${t.attrs.width}px`);
      const s = document.createElement("div");
      s.classList.add("resize-handle"), s.style.cssText = `
        position: absolute;
        bottom: 4px;
        right: 4px;
        width: 24px;
        height: 24px;
        background: oklch(0.98 0 0 / 0.95);
        border: 1px solid oklch(0.85 0 0);
        border-radius: 6px;
        cursor: se-resize;
        opacity: 0;
        transition: opacity 0.15s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 8px oklch(0 0 0 / 0.15);
      `, s.innerHTML = `
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="oklch(0.4 0 0)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="transform: rotate(90deg);">
          <polyline points="15 3 21 3 21 9"></polyline>
          <polyline points="9 21 3 21 3 15"></polyline>
          <line x1="21" y1="3" x2="14" y2="10"></line>
          <line x1="3" y1="21" x2="10" y2="14"></line>
        </svg>
      `;
      const a = document.createElement("button");
      a.classList.add("image-menu-btn"), a.setAttribute("type", "button"), a.setAttribute("title", "Image options"), a.style.cssText = `
        position: absolute;
        top: 8px;
        right: 8px;
        width: 28px;
        height: 28px;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: oklch(0.98 0 0 / 0.95);
        border: 1px solid oklch(0.85 0 0);
        border-radius: 6px;
        cursor: pointer;
        opacity: 0;
        transition: opacity 0.15s ease, background 0.15s ease;
        box-shadow: 0 2px 8px oklch(0 0 0 / 0.15);
        z-index: 10;
      `, a.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="5" r="1"></circle>
          <circle cx="12" cy="12" r="1"></circle>
          <circle cx="12" cy="19" r="1"></circle>
        </svg>
      `;
      const l = document.createElement("div");
      l.classList.add("image-menu-dropdown"), l.style.cssText = `
        position: fixed;
        display: none;
        flex-direction: column;
        min-width: 140px;
        padding: 4px;
        background: oklch(0.99 0 0);
        border: 1px solid oklch(0.9 0 0);
        border-radius: 8px;
        box-shadow: 0 4px 16px oklch(0 0 0 / 0.15);
        z-index: 9999;
      `;
      const c = (x, w, E) => {
        const S = document.createElement("button");
        return S.setAttribute("type", "button"), S.style.cssText = `
          display: flex;
          align-items: center;
          gap: 8px;
          width: 100%;
          padding: 8px 12px;
          font-size: 13px;
          color: oklch(0.3 0 0);
          background: transparent;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          text-align: left;
          transition: background 0.15s ease;
        `, S.innerHTML = `${w}<span>${x}</span>`, S.addEventListener("mouseenter", () => {
          S.style.background = "oklch(0.95 0 0)";
        }), S.addEventListener("mouseleave", () => {
          S.style.background = "transparent";
        }), S.addEventListener("click", (C) => {
          C.preventDefault(), C.stopPropagation(), E(), l.style.display = "none";
        }), S;
      }, u = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>', d = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>', f = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>';
      l.appendChild(c("Edit", u, () => {
        const x = typeof n == "function" ? n() : null;
        if (x != null && this.options.onImageClick) {
          const w = i.getBoundingClientRect();
          this.options.onImageClick({
            src: t.attrs.src,
            alt: t.attrs.alt || "",
            pos: x,
            rect: w
          });
        }
      })), l.appendChild(c("Copy image", d, async () => {
        try {
          const w = await (await fetch(t.attrs.src)).blob();
          await navigator.clipboard.write([
            new ClipboardItem({ [w.type]: w })
          ]);
        } catch {
          await navigator.clipboard.writeText(t.attrs.src);
        }
      })), l.appendChild(c("Save image", f, () => {
        const x = document.createElement("a");
        x.href = t.attrs.src, x.download = t.attrs.alt || "image", x.click();
      }));
      let h = !1;
      a.addEventListener("click", (x) => {
        if (x.preventDefault(), x.stopPropagation(), h)
          l.style.display = "none", h = !1;
        else {
          const w = a.getBoundingClientRect();
          l.style.top = `${w.bottom + 4}px`, l.style.left = `${w.right - 140}px`, l.style.display = "flex", h = !0;
        }
      });
      const m = (x) => {
        !l.contains(x.target) && !a.contains(x.target) && (l.style.display = "none", h = !1);
      };
      document.addEventListener("click", m), r.appendChild(i), r.appendChild(s), r.appendChild(a), document.body.appendChild(l), r.addEventListener("mouseenter", () => {
        s.style.opacity = "1", a.style.opacity = "1";
      }), r.addEventListener("mouseleave", () => {
        s.style.opacity = "0", h || (a.style.opacity = "0");
      }), a.addEventListener("mouseenter", () => {
        a.style.background = "oklch(0.95 0 0)";
      }), a.addEventListener("mouseleave", () => {
        a.style.background = "oklch(0.98 0 0 / 0.95)";
      });
      let p, g;
      const b = (x) => {
        x.preventDefault(), p = x.clientX, g = i.offsetWidth, document.addEventListener("mousemove", v), document.addEventListener("mouseup", k);
      }, v = (x) => {
        const w = x.clientX - p, E = Math.max(100, g + w);
        i.style.width = `${E}px`;
      }, k = () => {
        document.removeEventListener("mousemove", v), document.removeEventListener("mouseup", k);
        const x = typeof n == "function" ? n() : null;
        x != null && e.chain().focus().updateAttributes("resizableImage", {
          width: i.offsetWidth
        }).run();
      };
      return s.addEventListener("mousedown", b), {
        dom: r,
        update: (x) => x.type.name !== "resizableImage" ? !1 : (i.src = x.attrs.src, i.alt = x.attrs.alt || "", x.attrs.width && (i.style.width = `${x.attrs.width}px`), o(x.attrs.align || "left"), !0),
        destroy: () => {
          s.removeEventListener("mousedown", b), document.removeEventListener("click", m), l.remove();
        }
      };
    };
  }
});
function j2(t) {
  const e = new Date(t), n = /* @__PURE__ */ new Date(), r = new Date(n);
  r.setDate(r.getDate() + 1);
  const o = new Date(n);
  if (o.setDate(o.getDate() - 1), n.setHours(0, 0, 0, 0), r.setHours(0, 0, 0, 0), o.setHours(0, 0, 0, 0), e.setHours(0, 0, 0, 0), e.getTime() === n.getTime())
    return "Today";
  if (e.getTime() === r.getTime())
    return "Tomorrow";
  if (e.getTime() === o.getTime())
    return "Yesterday";
  const i = {
    month: "short",
    day: "numeric"
  };
  return e.getFullYear() !== n.getFullYear() && (i.year = "numeric"), e.toLocaleDateString("en-US", i);
}
function Y2(t) {
  const e = new Date(t), n = /* @__PURE__ */ new Date(), r = new Date(n);
  return r.setDate(r.getDate() + 7), n.setHours(0, 0, 0, 0), e.setHours(0, 0, 0, 0), e.getTime() === n.getTime() ? "date-today" : e < n ? "date-overdue" : e <= r ? "date-upcoming" : "";
}
function X2({ node: t, updateAttributes: e, selected: n }) {
  const [r, o] = J(!1), [i, s] = J({ top: 0, left: 0 }), a = fe(null), l = fe(null), c = fe(null), u = t.attrs.date || (/* @__PURE__ */ new Date()).toISOString().split("T")[0], d = j2(u), f = Y2(u), h = (g) => {
    if (g.preventDefault(), g.stopPropagation(), a.current) {
      const b = a.current.getBoundingClientRect();
      s({
        top: b.bottom + 8,
        left: b.left
      });
    }
    o(!0);
  }, m = (g) => {
    const b = g.target.value;
    b && (e({ date: b }), o(!1));
  }, p = (g) => {
    const b = /* @__PURE__ */ new Date();
    b.setDate(b.getDate() + g), e({ date: b.toISOString().split("T")[0] }), o(!1);
  };
  return ge(() => {
    const g = (v) => {
      l.current && !l.current.contains(v.target) && a.current && !a.current.contains(v.target) && o(!1);
    }, b = (v) => {
      v.key === "Escape" && o(!1);
    };
    return r && (document.addEventListener("mousedown", g), document.addEventListener("keydown", b), setTimeout(() => c.current?.focus(), 50)), () => {
      document.removeEventListener("mousedown", g), document.removeEventListener("keydown", b);
    };
  }, [r]), /* @__PURE__ */ y(pc, { as: "span", className: "inline", children: [
    /* @__PURE__ */ y(
      "span",
      {
        ref: a,
        onClick: h,
        className: `date-pill ${f} ${n ? "ProseMirror-selectednode" : ""} cursor-pointer`,
        contentEditable: !1,
        "data-type": "date-pill",
        "data-date": u,
        children: [
          /* @__PURE__ */ y(Yv, { size: 14, className: "date-icon" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/DatePillComponent.tsx",
            lineNumber: 158,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ y("span", { className: "date-text", children: d }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/DatePillComponent.tsx",
            lineNumber: 159,
            columnNumber: 9
          }, this)
        ]
      },
      void 0,
      !0,
      {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/DatePillComponent.tsx",
        lineNumber: 150,
        columnNumber: 7
      },
      this
    ),
    r && /* @__PURE__ */ y(
      "div",
      {
        ref: l,
        className: "date-picker-popup",
        style: {
          position: "fixed",
          top: i.top,
          left: i.left,
          zIndex: 100
        },
        children: [
          /* @__PURE__ */ y("div", { className: "flex gap-1 mb-3", children: [
            /* @__PURE__ */ y(
              "button",
              {
                type: "button",
                onClick: () => p(0),
                className: "quick-date-btn",
                children: "Today"
              },
              void 0,
              !1,
              {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/DatePillComponent.tsx",
                lineNumber: 175,
                columnNumber: 13
              },
              this
            ),
            /* @__PURE__ */ y(
              "button",
              {
                type: "button",
                onClick: () => p(1),
                className: "quick-date-btn",
                children: "Tomorrow"
              },
              void 0,
              !1,
              {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/DatePillComponent.tsx",
                lineNumber: 182,
                columnNumber: 13
              },
              this
            ),
            /* @__PURE__ */ y(
              "button",
              {
                type: "button",
                onClick: () => p(7),
                className: "quick-date-btn",
                children: "Next Week"
              },
              void 0,
              !1,
              {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/DatePillComponent.tsx",
                lineNumber: 189,
                columnNumber: 13
              },
              this
            )
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/DatePillComponent.tsx",
            lineNumber: 174,
            columnNumber: 11
          }, this),
          /* @__PURE__ */ y("div", { className: "relative", children: /* @__PURE__ */ y(
            "input",
            {
              ref: c,
              type: "date",
              value: u,
              onChange: m,
              className: "date-picker-input"
            },
            void 0,
            !1,
            {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/DatePillComponent.tsx",
              lineNumber: 200,
              columnNumber: 13
            },
            this
          ) }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/DatePillComponent.tsx",
            lineNumber: 199,
            columnNumber: 11
          }, this),
          /* @__PURE__ */ y("div", { className: "mt-2 pt-2 border-t border-border", children: /* @__PURE__ */ y(
            "button",
            {
              type: "button",
              onClick: () => {
                o(!1);
              },
              className: "text-xs text-muted-foreground hover:text-foreground transition-colors",
              children: "Close"
            },
            void 0,
            !1,
            {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/DatePillComponent.tsx",
              lineNumber: 211,
              columnNumber: 13
            },
            this
          ) }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/DatePillComponent.tsx",
            lineNumber: 210,
            columnNumber: 11
          }, this)
        ]
      },
      void 0,
      !0,
      {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/DatePillComponent.tsx",
        lineNumber: 163,
        columnNumber: 9
      },
      this
    )
  ] }, void 0, !0, {
    fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/DatePillComponent.tsx",
    lineNumber: 149,
    columnNumber: 5
  }, this);
}
function Z2(t) {
  const e = new Date(t), n = /* @__PURE__ */ new Date(), r = new Date(n);
  r.setDate(r.getDate() + 1);
  const o = new Date(n);
  if (o.setDate(o.getDate() - 1), n.setHours(0, 0, 0, 0), r.setHours(0, 0, 0, 0), o.setHours(0, 0, 0, 0), e.setHours(0, 0, 0, 0), e.getTime() === n.getTime())
    return "Today";
  if (e.getTime() === r.getTime())
    return "Tomorrow";
  if (e.getTime() === o.getTime())
    return "Yesterday";
  const i = {
    month: "short",
    day: "numeric"
  };
  return e.getFullYear() !== n.getFullYear() && (i.year = "numeric"), e.toLocaleDateString("en-US", i);
}
function J2(t) {
  const e = new Date(t), n = /* @__PURE__ */ new Date(), r = new Date(n);
  return r.setDate(r.getDate() + 7), n.setHours(0, 0, 0, 0), e.setHours(0, 0, 0, 0), e.getTime() === n.getTime() ? "date-today" : e < n ? "date-overdue" : e <= r ? "date-upcoming" : "";
}
const Q2 = rt.create({
  name: "datePill",
  group: "inline",
  inline: !0,
  atom: !0,
  addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  addAttributes() {
    return {
      date: {
        default: (/* @__PURE__ */ new Date()).toISOString().split("T")[0],
        parseHTML: (t) => t.getAttribute("data-date"),
        renderHTML: (t) => ({
          "data-date": t.date
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: 'span[data-type="date-pill"]'
      }
    ];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    const n = t.attrs.date, r = Z2(n), o = J2(n);
    return [
      "span",
      De(
        this.options.HTMLAttributes,
        e,
        {
          "data-type": "date-pill",
          class: `date-pill ${o}`.trim()
        }
      ),
      [
        "span",
        { class: "date-icon" },
        "📅"
      ],
      [
        "span",
        { class: "date-text" },
        r
      ]
    ];
  },
  // Use React component for interactive editing
  addNodeView() {
    return zf(X2);
  },
  addCommands() {
    return {
      insertDatePill: (t) => ({ commands: e }) => {
        const n = t || (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
        return e.insertContent({
          type: this.name,
          attrs: { date: n }
        });
      },
      updateDatePill: (t) => ({ commands: e }) => e.updateAttributes(this.name, { date: t })
    };
  },
  addKeyboardShortcuts() {
    return {
      // Type Ctrl+Shift+D to insert a date pill
      "Mod-Shift-d": () => this.editor.commands.insertDatePill()
    };
  },
  addInputRules() {
    const t = new nn({
      find: /@today\s$/,
      handler: ({ state: i, range: s, chain: a }) => {
        const l = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
        a().deleteRange(s).insertDatePill(l).run();
      }
    }), e = new nn({
      find: /@tomorrow\s$/,
      handler: ({ state: i, range: s, chain: a }) => {
        const l = /* @__PURE__ */ new Date();
        l.setDate(l.getDate() + 1), a().deleteRange(s).insertDatePill(l.toISOString().split("T")[0]).run();
      }
    }), n = new nn({
      find: /@yesterday\s$/,
      handler: ({ state: i, range: s, chain: a }) => {
        const l = /* @__PURE__ */ new Date();
        l.setDate(l.getDate() - 1), a().deleteRange(s).insertDatePill(l.toISOString().split("T")[0]).run();
      }
    }), r = new nn({
      find: /@(\d{4}-\d{2}-\d{2})\s$/,
      handler: ({ state: i, range: s, chain: a, match: l }) => {
        const c = l[1];
        a().deleteRange(s).insertDatePill(c).run();
      }
    }), o = new nn({
      find: /@([A-Za-z]{3})\s?(\d{1,2})\s$/,
      handler: ({ state: i, range: s, chain: a, match: l }) => {
        const c = l[1], u = parseInt(l[2], 10), f = {
          jan: 0,
          feb: 1,
          mar: 2,
          apr: 3,
          may: 4,
          jun: 5,
          jul: 6,
          aug: 7,
          sep: 8,
          oct: 9,
          nov: 10,
          dec: 11
        }[c.toLowerCase()];
        if (f !== void 0) {
          const h = (/* @__PURE__ */ new Date()).getFullYear(), m = new Date(h, f, u);
          a().deleteRange(s).insertDatePill(m.toISOString().split("T")[0]).run();
        }
      }
    });
    return [t, e, n, r, o];
  }
});
function eD({ isOpen: t, onClose: e, onInsert: n, position: r }) {
  const [o, i] = J(""), [s, a] = J(""), [l, c] = J(""), [u, d] = J(!1), f = fe(null), h = fe(null);
  ge(() => {
    t && (i(""), a(""), c(""), setTimeout(() => {
      f.current?.focus();
    }, 100));
  }, [t]), ge(() => {
    if (!t) return;
    const v = (x) => {
      h.current && !h.current.contains(x.target) && e();
    }, k = (x) => {
      x.key === "Escape" && e();
    };
    return document.addEventListener("mousedown", v), document.addEventListener("keydown", k), () => {
      document.removeEventListener("mousedown", v), document.removeEventListener("keydown", k);
    };
  }, [t, e]);
  const m = (v) => {
    if (!v.trim())
      return c("Please enter an image URL"), !1;
    try {
      const k = new URL(v);
      if (!["http:", "https:", "data:"].includes(k.protocol))
        return c("URL must start with http://, https://, or be a data URL"), !1;
    } catch {
      return c("Please enter a valid URL"), !1;
    }
    return c(""), !0;
  }, p = async () => {
    if (!m(o)) return;
    d(!0);
    const v = new window.Image();
    v.onload = () => {
      d(!1), n(o.trim(), s.trim()), e();
    }, v.onerror = () => {
      d(!1), n(o.trim(), s.trim()), e();
    }, setTimeout(() => {
      u && (d(!1), n(o.trim(), s.trim()), e());
    }, 3e3), v.src = o.trim();
  }, g = (v) => {
    v.key === "Enter" && !v.shiftKey && (v.preventDefault(), p());
  };
  if (!t) return null;
  const b = r ? {
    top: r.top,
    left: Math.min(r.left, typeof window < "u" ? window.innerWidth - 340 : r.left)
  } : { top: "50%", left: "50%" };
  return /* @__PURE__ */ y(
    "div",
    {
      ref: h,
      className: "image-url-dialog fixed z-50",
      style: {
        top: (typeof b.top == "number", b.top),
        left: typeof b.left == "number" ? Math.max(8, b.left) : b.left,
        transform: r ? void 0 : "translate(-50%, -50%)"
      },
      children: [
        /* @__PURE__ */ y("div", { className: "image-url-dialog-header", children: [
          /* @__PURE__ */ y("div", { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ y(Al, { size: 16, className: "text-primary" }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageURLDialog.tsx",
              lineNumber: 143,
              columnNumber: 11
            }, this),
            /* @__PURE__ */ y("span", { className: "font-medium text-sm", children: "Insert Image from URL" }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageURLDialog.tsx",
              lineNumber: 144,
              columnNumber: 11
            }, this)
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageURLDialog.tsx",
            lineNumber: 142,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ y(
            "button",
            {
              onClick: e,
              className: "image-url-dialog-close",
              "aria-label": "Close",
              children: /* @__PURE__ */ y(lo, { size: 16 }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageURLDialog.tsx",
                lineNumber: 151,
                columnNumber: 11
              }, this)
            },
            void 0,
            !1,
            {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageURLDialog.tsx",
              lineNumber: 146,
              columnNumber: 9
            },
            this
          )
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageURLDialog.tsx",
          lineNumber: 141,
          columnNumber: 7
        }, this),
        /* @__PURE__ */ y("div", { className: "image-url-dialog-content", children: [
          /* @__PURE__ */ y("div", { className: "image-url-dialog-field", children: [
            /* @__PURE__ */ y("label", { className: "image-url-dialog-label", children: [
              /* @__PURE__ */ y(rh, { size: 12 }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageURLDialog.tsx",
                lineNumber: 160,
                columnNumber: 13
              }, this),
              "Image URL"
            ] }, void 0, !0, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageURLDialog.tsx",
              lineNumber: 159,
              columnNumber: 11
            }, this),
            /* @__PURE__ */ y(
              "input",
              {
                ref: f,
                type: "url",
                value: o,
                onChange: (v) => {
                  i(v.target.value), l && c("");
                },
                onKeyDown: g,
                placeholder: "https://example.com/image.jpg",
                className: `image-url-dialog-input ${l ? "error" : ""}`
              },
              void 0,
              !1,
              {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageURLDialog.tsx",
                lineNumber: 163,
                columnNumber: 11
              },
              this
            ),
            l && /* @__PURE__ */ y("span", { className: "image-url-dialog-error", children: l }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageURLDialog.tsx",
              lineNumber: 176,
              columnNumber: 13
            }, this)
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageURLDialog.tsx",
            lineNumber: 158,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ y("div", { className: "image-url-dialog-field", children: [
            /* @__PURE__ */ y("label", { className: "image-url-dialog-label", children: [
              /* @__PURE__ */ y(ws, { size: 12 }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageURLDialog.tsx",
                lineNumber: 183,
                columnNumber: 13
              }, this),
              "Alt Text (optional)"
            ] }, void 0, !0, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageURLDialog.tsx",
              lineNumber: 182,
              columnNumber: 11
            }, this),
            /* @__PURE__ */ y(
              "input",
              {
                type: "text",
                value: s,
                onChange: (v) => a(v.target.value),
                onKeyDown: g,
                placeholder: "Describe the image",
                className: "image-url-dialog-input"
              },
              void 0,
              !1,
              {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageURLDialog.tsx",
                lineNumber: 186,
                columnNumber: 11
              },
              this
            )
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageURLDialog.tsx",
            lineNumber: 181,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ y("div", { className: "image-url-dialog-actions", children: [
            /* @__PURE__ */ y(
              "button",
              {
                onClick: e,
                className: "image-url-dialog-btn image-url-dialog-btn-cancel",
                children: "Cancel"
              },
              void 0,
              !1,
              {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageURLDialog.tsx",
                lineNumber: 198,
                columnNumber: 11
              },
              this
            ),
            /* @__PURE__ */ y(
              "button",
              {
                onClick: p,
                disabled: u || !o.trim(),
                className: "image-url-dialog-btn image-url-dialog-btn-insert",
                children: u ? "Validating..." : "Insert Image"
              },
              void 0,
              !1,
              {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageURLDialog.tsx",
                lineNumber: 204,
                columnNumber: 11
              },
              this
            )
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageURLDialog.tsx",
            lineNumber: 197,
            columnNumber: 9
          }, this)
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageURLDialog.tsx",
          lineNumber: 156,
          columnNumber: 7
        }, this)
      ]
    },
    void 0,
    !0,
    {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageURLDialog.tsx",
      lineNumber: 131,
      columnNumber: 5
    },
    this
  );
}
const tD = [
  {
    title: "Paragraph",
    description: "Normal text",
    icon: /* @__PURE__ */ y(ws, { size: 18 }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SlashCommands.tsx",
      lineNumber: 62,
      columnNumber: 11
    }, void 0),
    command: (t) => t.chain().focus().setParagraph().run(),
    keywords: ["text", "normal", "p"]
  },
  {
    title: "Heading 1",
    description: "Large section heading",
    icon: /* @__PURE__ */ y(Ml, { size: 18 }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SlashCommands.tsx",
      lineNumber: 69,
      columnNumber: 11
    }, void 0),
    command: (t) => t.chain().focus().toggleHeading({ level: 1 }).run(),
    keywords: ["h1", "title", "large"]
  },
  {
    title: "Heading 2",
    description: "Medium section heading",
    icon: /* @__PURE__ */ y(th, { size: 18 }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SlashCommands.tsx",
      lineNumber: 76,
      columnNumber: 11
    }, void 0),
    command: (t) => t.chain().focus().toggleHeading({ level: 2 }).run(),
    keywords: ["h2", "subtitle"]
  },
  {
    title: "Heading 3",
    description: "Small section heading",
    icon: /* @__PURE__ */ y(nh, { size: 18 }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SlashCommands.tsx",
      lineNumber: 83,
      columnNumber: 11
    }, void 0),
    command: (t) => t.chain().focus().toggleHeading({ level: 3 }).run(),
    keywords: ["h3", "subheading"]
  },
  {
    title: "Bullet List",
    description: "Create a simple bullet list",
    icon: /* @__PURE__ */ y(Gi, { size: 18 }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SlashCommands.tsx",
      lineNumber: 90,
      columnNumber: 11
    }, void 0),
    command: (t) => t.chain().focus().toggleBulletList().run(),
    keywords: ["ul", "unordered", "bullets"]
  },
  {
    title: "Numbered List",
    description: "Create a numbered list",
    icon: /* @__PURE__ */ y(Ol, { size: 18 }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SlashCommands.tsx",
      lineNumber: 97,
      columnNumber: 11
    }, void 0),
    command: (t) => t.chain().focus().toggleOrderedList().run(),
    keywords: ["ol", "ordered", "numbers"]
  },
  {
    title: "Task List",
    description: "Create a todo list with checkboxes",
    icon: /* @__PURE__ */ y(Dl, { size: 18 }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SlashCommands.tsx",
      lineNumber: 104,
      columnNumber: 11
    }, void 0),
    command: (t) => t.chain().focus().toggleTaskList().run(),
    keywords: ["todo", "checkbox", "tasks"]
  },
  {
    title: "Quote",
    description: "Add a blockquote",
    icon: /* @__PURE__ */ y(Il, { size: 18 }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SlashCommands.tsx",
      lineNumber: 111,
      columnNumber: 11
    }, void 0),
    command: (t) => t.chain().focus().toggleBlockquote().run(),
    keywords: ["blockquote", "citation"]
  },
  {
    title: "Code Block",
    description: "Add a code block with syntax highlighting",
    icon: /* @__PURE__ */ y(xd, { size: 18 }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SlashCommands.tsx",
      lineNumber: 118,
      columnNumber: 11
    }, void 0),
    command: (t) => t.chain().focus().toggleCodeBlock().run(),
    keywords: ["code", "pre", "syntax"]
  },
  {
    title: "Table",
    description: "Insert a table",
    icon: /* @__PURE__ */ y(Sa, { size: 18 }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SlashCommands.tsx",
      lineNumber: 125,
      columnNumber: 11
    }, void 0),
    command: (t) => t.chain().focus().insertTable({ rows: 3, cols: 3, withHeaderRow: !0 }).run(),
    keywords: ["grid", "spreadsheet"]
  },
  // Image command is handled separately with a dialog
  {
    title: "Image",
    description: "Insert an image from URL",
    icon: /* @__PURE__ */ y(Al, { size: 18 }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SlashCommands.tsx",
      lineNumber: 133,
      columnNumber: 11
    }, void 0),
    command: () => {
    },
    keywords: ["picture", "photo", "img"],
    isImageCommand: !0
  },
  {
    title: "Divider",
    description: "Add a horizontal rule",
    icon: /* @__PURE__ */ y(Sd, { size: 18 }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SlashCommands.tsx",
      lineNumber: 144,
      columnNumber: 11
    }, void 0),
    command: (t) => t.chain().focus().setHorizontalRule().run(),
    keywords: ["hr", "separator", "line"]
  },
  {
    title: "Info Callout",
    description: "Add an info callout box",
    icon: /* @__PURE__ */ y(Ho, { size: 18, className: "text-blue-400" }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SlashCommands.tsx",
      lineNumber: 151,
      columnNumber: 11
    }, void 0),
    command: (t) => t.chain().focus().toggleCallout({ type: "info" }).run(),
    keywords: ["note", "tip", "information"]
  },
  {
    title: "Warning Callout",
    description: "Add a warning callout box",
    icon: /* @__PURE__ */ y(Pl, { size: 18, className: "text-yellow-400" }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SlashCommands.tsx",
      lineNumber: 158,
      columnNumber: 11
    }, void 0),
    command: (t) => t.chain().focus().toggleCallout({ type: "warning" }).run(),
    keywords: ["caution", "alert"]
  },
  {
    title: "Error Callout",
    description: "Add an error callout box",
    icon: /* @__PURE__ */ y(Tl, { size: 18, className: "text-red-400" }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SlashCommands.tsx",
      lineNumber: 165,
      columnNumber: 11
    }, void 0),
    command: (t) => t.chain().focus().toggleCallout({ type: "error" }).run(),
    keywords: ["danger", "critical"]
  },
  {
    title: "Success Callout",
    description: "Add a success callout box",
    icon: /* @__PURE__ */ y(Cl, { size: 18, className: "text-green-400" }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SlashCommands.tsx",
      lineNumber: 172,
      columnNumber: 11
    }, void 0),
    command: (t) => t.chain().focus().toggleCallout({ type: "success" }).run(),
    keywords: ["done", "complete"]
  },
  {
    title: "Note Callout",
    description: "Add a note callout box",
    icon: /* @__PURE__ */ y(Vo, { size: 18, className: "text-purple-400" }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SlashCommands.tsx",
      lineNumber: 179,
      columnNumber: 11
    }, void 0),
    command: (t) => t.chain().focus().toggleCallout({ type: "note" }).run(),
    keywords: ["memo", "remember"]
  },
  {
    title: "Date",
    description: "Insert a date pill (today)",
    icon: /* @__PURE__ */ y(Yv, { size: 18, className: "text-cyan-400" }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SlashCommands.tsx",
      lineNumber: 186,
      columnNumber: 11
    }, void 0),
    command: (t) => t.chain().focus().insertDatePill().run(),
    keywords: ["date", "today", "calendar", "time", "schedule"]
  },
  {
    title: "Wiki Link",
    description: "Insert a [[page name]] link",
    icon: /* @__PURE__ */ y(rh, { size: 18, className: "text-cyan-400" }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SlashCommands.tsx",
      lineNumber: 193,
      columnNumber: 11
    }, void 0),
    command: (t) => {
      const e = window.prompt("Enter page name:");
      e && t.chain().focus().insertContent(`[[${e}]]`).run();
    },
    keywords: ["wiki", "internal", "page", "link", "backlink"]
  }
];
function nD({ editor: t }) {
  const [e, n] = J(!1), [r, o] = J(""), [i, s] = J(0), [a, l] = J({ top: 0, left: 0 }), [c, u] = J(!1), [d, f] = J({ top: 0, left: 0 }), h = fe(null), m = tD.filter((v) => {
    const k = r.toLowerCase();
    return v.title.toLowerCase().includes(k) || v.description.toLowerCase().includes(k) || v.keywords?.some((x) => x.includes(k));
  }), p = ie((v) => {
    const k = m[v];
    if (k) {
      const { state: x } = t, { selection: w } = x, { $from: E } = w, S = E.nodeBefore?.textContent || "", C = S.lastIndexOf("/");
      if (C !== -1) {
        const M = E.pos - (S.length - C);
        t.chain().focus().deleteRange({ from: M, to: E.pos }).run();
      }
      if (k.isImageCommand) {
        const M = t.view.coordsAtPos(E.pos);
        f({
          top: M.bottom + 8,
          left: M.left
        }), u(!0);
      } else
        k.command(t);
      n(!1), o(""), s(0);
    }
  }, [t, m]), g = ie((v, k) => {
    t.chain().focus().setImage({ src: v, alt: k }).run();
  }, [t]);
  if (ge(() => {
    if (!t) return;
    const v = (x) => {
      if (!e) {
        if (x.key === "/") {
          const { state: w } = t, { selection: E } = w, { $from: S } = E, C = t.view.coordsAtPos(S.pos);
          l({
            top: C.bottom + 8,
            left: C.left
          }), setTimeout(() => {
            n(!0), o(""), s(0);
          }, 10);
        }
        return;
      }
      x.key === "ArrowDown" ? (x.preventDefault(), s((w) => (w + 1) % m.length)) : x.key === "ArrowUp" ? (x.preventDefault(), s((w) => (w - 1 + m.length) % m.length)) : x.key === "Enter" ? (x.preventDefault(), p(i)) : x.key === "Escape" ? (x.preventDefault(), n(!1), o("")) : x.key === "Backspace" ? r.length === 0 ? n(!1) : o((w) => w.slice(0, -1)) : x.key.length === 1 && !x.ctrlKey && !x.metaKey && (o((w) => w + x.key), s(0));
    }, k = (x) => {
      h.current && !h.current.contains(x.target) && (n(!1), o(""));
    };
    return document.addEventListener("keydown", v), document.addEventListener("click", k), () => {
      document.removeEventListener("keydown", v), document.removeEventListener("click", k);
    };
  }, [t, e, r, i, m, p]), ge(() => {
    i >= m.length && s(Math.max(0, m.length - 1));
  }, [m.length, i]), c)
    return /* @__PURE__ */ y(
      eD,
      {
        isOpen: c,
        onClose: () => u(!1),
        onInsert: g,
        position: d
      },
      void 0,
      !1,
      {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SlashCommands.tsx",
        lineNumber: 339,
        columnNumber: 7
      },
      this
    );
  if (!e || m.length === 0)
    return null;
  const b = {
    top: a.top,
    left: Math.min(a.left, typeof window < "u" ? window.innerWidth - 280 : a.left)
  };
  return /* @__PURE__ */ y(
    "div",
    {
      ref: h,
      className: "slash-command-menu fixed z-50 max-h-[60vh] overflow-y-auto",
      style: {
        top: b.top,
        left: Math.max(8, b.left)
      },
      children: [
        /* @__PURE__ */ y("div", { className: "text-xs text-muted-foreground px-3 py-2 border-b border-border", children: r ? `Searching: ${r}` : "Type to filter..." }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SlashCommands.tsx",
          lineNumber: 367,
          columnNumber: 7
        }, this),
        m.map((v, k) => /* @__PURE__ */ y(
          "div",
          {
            className: `slash-command-item ${k === i ? "is-selected" : ""}`,
            onClick: () => p(k),
            onMouseEnter: () => s(k),
            onTouchStart: () => s(k),
            children: [
              /* @__PURE__ */ y("div", { className: "icon flex-shrink-0", children: v.icon }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SlashCommands.tsx",
                lineNumber: 378,
                columnNumber: 11
              }, this),
              /* @__PURE__ */ y("div", { className: "flex flex-col min-w-0", children: [
                /* @__PURE__ */ y("span", { className: "label truncate", children: v.title }, void 0, !1, {
                  fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SlashCommands.tsx",
                  lineNumber: 380,
                  columnNumber: 13
                }, this),
                /* @__PURE__ */ y("span", { className: "text-xs text-muted-foreground truncate", children: v.description }, void 0, !1, {
                  fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SlashCommands.tsx",
                  lineNumber: 381,
                  columnNumber: 13
                }, this)
              ] }, void 0, !0, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SlashCommands.tsx",
                lineNumber: 379,
                columnNumber: 11
              }, this)
            ]
          },
          v.title,
          !0,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SlashCommands.tsx",
            lineNumber: 371,
            columnNumber: 9
          },
          this
        ))
      ]
    },
    void 0,
    !0,
    {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SlashCommands.tsx",
      lineNumber: 359,
      columnNumber: 5
    },
    this
  );
}
function Ne(t, e, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(o) {
    if (t?.(o), n === !1 || !o.defaultPrevented)
      return e?.(o);
  };
}
function fg(t, e) {
  if (typeof t == "function")
    return t(e);
  t != null && (t.current = e);
}
function wc(...t) {
  return (e) => {
    let n = !1;
    const r = t.map((o) => {
      const i = fg(o, e);
      return !n && typeof i == "function" && (n = !0), i;
    });
    if (n)
      return () => {
        for (let o = 0; o < r.length; o++) {
          const i = r[o];
          typeof i == "function" ? i() : fg(t[o], null);
        }
      };
  };
}
function At(...t) {
  return N.useCallback(wc(...t), t);
}
function ui(t, e = []) {
  let n = [];
  function r(i, s) {
    const a = N.createContext(s), l = n.length;
    n = [...n, s];
    const c = (d) => {
      const { scope: f, children: h, ...m } = d, p = f?.[t]?.[l] || a, g = N.useMemo(() => m, Object.values(m));
      return /* @__PURE__ */ R(p.Provider, { value: g, children: h });
    };
    c.displayName = i + "Provider";
    function u(d, f) {
      const h = f?.[t]?.[l] || a, m = N.useContext(h);
      if (m) return m;
      if (s !== void 0) return s;
      throw new Error(`\`${d}\` must be used within \`${i}\``);
    }
    return [c, u];
  }
  const o = () => {
    const i = n.map((s) => N.createContext(s));
    return function(a) {
      const l = a?.[t] || i;
      return N.useMemo(
        () => ({ [`__scope${t}`]: { ...a, [t]: l } }),
        [a, l]
      );
    };
  };
  return o.scopeName = t, [r, rD(o, ...e)];
}
function rD(...t) {
  const e = t[0];
  if (t.length === 1) return e;
  const n = () => {
    const r = t.map((o) => ({
      useScope: o(),
      scopeName: o.scopeName
    }));
    return function(i) {
      const s = r.reduce((a, { useScope: l, scopeName: c }) => {
        const d = l(i)[`__scope${c}`];
        return { ...a, ...d };
      }, {});
      return N.useMemo(() => ({ [`__scope${e.scopeName}`]: s }), [s]);
    };
  };
  return n.scopeName = e.scopeName, n;
}
var Rr = globalThis?.document ? N.useLayoutEffect : () => {
}, oD = N[" useInsertionEffect ".trim().toString()] || Rr;
function kc({
  prop: t,
  defaultProp: e,
  onChange: n = () => {
  },
  caller: r
}) {
  const [o, i, s] = iD({
    defaultProp: e,
    onChange: n
  }), a = t !== void 0, l = a ? t : o;
  {
    const u = N.useRef(t !== void 0);
    N.useEffect(() => {
      const d = u.current;
      d !== a && console.warn(
        `${r} is changing from ${d ? "controlled" : "uncontrolled"} to ${a ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
      ), u.current = a;
    }, [a, r]);
  }
  const c = N.useCallback(
    (u) => {
      if (a) {
        const d = sD(u) ? u(t) : u;
        d !== t && s.current?.(d);
      } else
        i(u);
    },
    [a, t, i, s]
  );
  return [l, c];
}
function iD({
  defaultProp: t,
  onChange: e
}) {
  const [n, r] = N.useState(t), o = N.useRef(n), i = N.useRef(e);
  return oD(() => {
    i.current = e;
  }, [e]), N.useEffect(() => {
    o.current !== n && (i.current?.(n), o.current = n);
  }, [n, o]), [n, r, i];
}
function sD(t) {
  return typeof t == "function";
}
// @__NO_SIDE_EFFECTS__
function ds(t) {
  const e = /* @__PURE__ */ lD(t), n = N.forwardRef((r, o) => {
    const { children: i, ...s } = r, a = N.Children.toArray(i), l = a.find(uD);
    if (l) {
      const c = l.props.children, u = a.map((d) => d === l ? N.Children.count(c) > 1 ? N.Children.only(null) : N.isValidElement(c) ? c.props.children : null : d);
      return /* @__PURE__ */ R(e, { ...s, ref: o, children: N.isValidElement(c) ? N.cloneElement(c, void 0, u) : null });
    }
    return /* @__PURE__ */ R(e, { ...s, ref: o, children: i });
  });
  return n.displayName = `${t}.Slot`, n;
}
var aD = /* @__PURE__ */ ds("Slot");
// @__NO_SIDE_EFFECTS__
function lD(t) {
  const e = N.forwardRef((n, r) => {
    const { children: o, ...i } = n;
    if (N.isValidElement(o)) {
      const s = fD(o), a = dD(i, o.props);
      return o.type !== N.Fragment && (a.ref = r ? wc(r, s) : s), N.cloneElement(o, a);
    }
    return N.Children.count(o) > 1 ? N.Children.only(null) : null;
  });
  return e.displayName = `${t}.SlotClone`, e;
}
var Xv = Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function cD(t) {
  const e = ({ children: n }) => /* @__PURE__ */ R(Hd, { children: n });
  return e.displayName = `${t}.Slottable`, e.__radixId = Xv, e;
}
function uD(t) {
  return N.isValidElement(t) && typeof t.type == "function" && "__radixId" in t.type && t.type.__radixId === Xv;
}
function dD(t, e) {
  const n = { ...e };
  for (const r in e) {
    const o = t[r], i = e[r];
    /^on[A-Z]/.test(r) ? o && i ? n[r] = (...a) => {
      const l = i(...a);
      return o(...a), l;
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...i } : r === "className" && (n[r] = [o, i].filter(Boolean).join(" "));
  }
  return { ...t, ...n };
}
function fD(t) {
  let e = Object.getOwnPropertyDescriptor(t.props, "ref")?.get, n = e && "isReactWarning" in e && e.isReactWarning;
  return n ? t.ref : (e = Object.getOwnPropertyDescriptor(t, "ref")?.get, n = e && "isReactWarning" in e && e.isReactWarning, n ? t.props.ref : t.props.ref || t.ref);
}
var hD = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
], Nt = hD.reduce((t, e) => {
  const n = /* @__PURE__ */ ds(`Primitive.${e}`), r = N.forwardRef((o, i) => {
    const { asChild: s, ...a } = o, l = s ? n : e;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ R(l, { ...a, ref: i });
  });
  return r.displayName = `Primitive.${e}`, { ...t, [e]: r };
}, {});
function Zv(t, e) {
  t && nb.flushSync(() => t.dispatchEvent(e));
}
function Jv(t) {
  const e = t + "CollectionProvider", [n, r] = ui(e), [o, i] = n(
    e,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), s = (p) => {
    const { scope: g, children: b } = p, v = ot.useRef(null), k = ot.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ R(o, { scope: g, itemMap: k, collectionRef: v, children: b });
  };
  s.displayName = e;
  const a = t + "CollectionSlot", l = /* @__PURE__ */ ds(a), c = ot.forwardRef(
    (p, g) => {
      const { scope: b, children: v } = p, k = i(a, b), x = At(g, k.collectionRef);
      return /* @__PURE__ */ R(l, { ref: x, children: v });
    }
  );
  c.displayName = a;
  const u = t + "CollectionItemSlot", d = "data-radix-collection-item", f = /* @__PURE__ */ ds(u), h = ot.forwardRef(
    (p, g) => {
      const { scope: b, children: v, ...k } = p, x = ot.useRef(null), w = At(g, x), E = i(u, b);
      return ot.useEffect(() => (E.itemMap.set(x, { ref: x, ...k }), () => void E.itemMap.delete(x))), /* @__PURE__ */ R(f, { [d]: "", ref: w, children: v });
    }
  );
  h.displayName = u;
  function m(p) {
    const g = i(t + "CollectionConsumer", p);
    return ot.useCallback(() => {
      const v = g.collectionRef.current;
      if (!v) return [];
      const k = Array.from(v.querySelectorAll(`[${d}]`));
      return Array.from(g.itemMap.values()).sort(
        (E, S) => k.indexOf(E.ref.current) - k.indexOf(S.ref.current)
      );
    }, [g.collectionRef, g.itemMap]);
  }
  return [
    { Provider: s, Slot: c, ItemSlot: h },
    m,
    r
  ];
}
var mD = N.createContext(void 0);
function Qv(t) {
  const e = N.useContext(mD);
  return t || e || "ltr";
}
function Pn(t) {
  const e = N.useRef(t);
  return N.useEffect(() => {
    e.current = t;
  }), N.useMemo(() => (...n) => e.current?.(...n), []);
}
function pD(t, e = globalThis?.document) {
  const n = Pn(t);
  N.useEffect(() => {
    const r = (o) => {
      o.key === "Escape" && n(o);
    };
    return e.addEventListener("keydown", r, { capture: !0 }), () => e.removeEventListener("keydown", r, { capture: !0 });
  }, [n, e]);
}
var gD = "DismissableLayer", Td = "dismissableLayer.update", bD = "dismissableLayer.pointerDownOutside", yD = "dismissableLayer.focusOutside", hg, ew = N.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), oh = N.forwardRef(
  (t, e) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: o,
      onFocusOutside: i,
      onInteractOutside: s,
      onDismiss: a,
      ...l
    } = t, c = N.useContext(ew), [u, d] = N.useState(null), f = u?.ownerDocument ?? globalThis?.document, [, h] = N.useState({}), m = At(e, (S) => d(S)), p = Array.from(c.layers), [g] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1), b = p.indexOf(g), v = u ? p.indexOf(u) : -1, k = c.layersWithOutsidePointerEventsDisabled.size > 0, x = v >= b, w = kD((S) => {
      const C = S.target, M = [...c.branches].some((O) => O.contains(C));
      !x || M || (o?.(S), s?.(S), S.defaultPrevented || a?.());
    }, f), E = xD((S) => {
      const C = S.target;
      [...c.branches].some((O) => O.contains(C)) || (i?.(S), s?.(S), S.defaultPrevented || a?.());
    }, f);
    return pD((S) => {
      v === c.layers.size - 1 && (r?.(S), !S.defaultPrevented && a && (S.preventDefault(), a()));
    }, f), N.useEffect(() => {
      if (u)
        return n && (c.layersWithOutsidePointerEventsDisabled.size === 0 && (hg = f.body.style.pointerEvents, f.body.style.pointerEvents = "none"), c.layersWithOutsidePointerEventsDisabled.add(u)), c.layers.add(u), mg(), () => {
          n && c.layersWithOutsidePointerEventsDisabled.size === 1 && (f.body.style.pointerEvents = hg);
        };
    }, [u, f, n, c]), N.useEffect(() => () => {
      u && (c.layers.delete(u), c.layersWithOutsidePointerEventsDisabled.delete(u), mg());
    }, [u, c]), N.useEffect(() => {
      const S = () => h({});
      return document.addEventListener(Td, S), () => document.removeEventListener(Td, S);
    }, []), /* @__PURE__ */ R(
      Nt.div,
      {
        ...l,
        ref: m,
        style: {
          pointerEvents: k ? x ? "auto" : "none" : void 0,
          ...t.style
        },
        onFocusCapture: Ne(t.onFocusCapture, E.onFocusCapture),
        onBlurCapture: Ne(t.onBlurCapture, E.onBlurCapture),
        onPointerDownCapture: Ne(
          t.onPointerDownCapture,
          w.onPointerDownCapture
        )
      }
    );
  }
);
oh.displayName = gD;
var vD = "DismissableLayerBranch", wD = N.forwardRef((t, e) => {
  const n = N.useContext(ew), r = N.useRef(null), o = At(e, r);
  return N.useEffect(() => {
    const i = r.current;
    if (i)
      return n.branches.add(i), () => {
        n.branches.delete(i);
      };
  }, [n.branches]), /* @__PURE__ */ R(Nt.div, { ...t, ref: o });
});
wD.displayName = vD;
function kD(t, e = globalThis?.document) {
  const n = Pn(t), r = N.useRef(!1), o = N.useRef(() => {
  });
  return N.useEffect(() => {
    const i = (a) => {
      if (a.target && !r.current) {
        let l = function() {
          tw(
            bD,
            n,
            c,
            { discrete: !0 }
          );
        };
        const c = { originalEvent: a };
        a.pointerType === "touch" ? (e.removeEventListener("click", o.current), o.current = l, e.addEventListener("click", o.current, { once: !0 })) : l();
      } else
        e.removeEventListener("click", o.current);
      r.current = !1;
    }, s = window.setTimeout(() => {
      e.addEventListener("pointerdown", i);
    }, 0);
    return () => {
      window.clearTimeout(s), e.removeEventListener("pointerdown", i), e.removeEventListener("click", o.current);
    };
  }, [e, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function xD(t, e = globalThis?.document) {
  const n = Pn(t), r = N.useRef(!1);
  return N.useEffect(() => {
    const o = (i) => {
      i.target && !r.current && tw(yD, n, { originalEvent: i }, {
        discrete: !1
      });
    };
    return e.addEventListener("focusin", o), () => e.removeEventListener("focusin", o);
  }, [e, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function mg() {
  const t = new CustomEvent(Td);
  document.dispatchEvent(t);
}
function tw(t, e, n, { discrete: r }) {
  const o = n.originalEvent.target, i = new CustomEvent(t, { bubbles: !1, cancelable: !0, detail: n });
  e && o.addEventListener(t, e, { once: !0 }), r ? Zv(o, i) : o.dispatchEvent(i);
}
var wu = 0;
function ND() {
  N.useEffect(() => {
    const t = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", t[0] ?? pg()), document.body.insertAdjacentElement("beforeend", t[1] ?? pg()), wu++, () => {
      wu === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((e) => e.remove()), wu--;
    };
  }, []);
}
function pg() {
  const t = document.createElement("span");
  return t.setAttribute("data-radix-focus-guard", ""), t.tabIndex = 0, t.style.outline = "none", t.style.opacity = "0", t.style.position = "fixed", t.style.pointerEvents = "none", t;
}
var ku = "focusScope.autoFocusOnMount", xu = "focusScope.autoFocusOnUnmount", gg = { bubbles: !1, cancelable: !0 }, ED = "FocusScope", nw = N.forwardRef((t, e) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: o,
    onUnmountAutoFocus: i,
    ...s
  } = t, [a, l] = N.useState(null), c = Pn(o), u = Pn(i), d = N.useRef(null), f = At(e, (p) => l(p)), h = N.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  N.useEffect(() => {
    if (r) {
      let p = function(k) {
        if (h.paused || !a) return;
        const x = k.target;
        a.contains(x) ? d.current = x : fr(d.current, { select: !0 });
      }, g = function(k) {
        if (h.paused || !a) return;
        const x = k.relatedTarget;
        x !== null && (a.contains(x) || fr(d.current, { select: !0 }));
      }, b = function(k) {
        if (document.activeElement === document.body)
          for (const w of k)
            w.removedNodes.length > 0 && fr(a);
      };
      document.addEventListener("focusin", p), document.addEventListener("focusout", g);
      const v = new MutationObserver(b);
      return a && v.observe(a, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", p), document.removeEventListener("focusout", g), v.disconnect();
      };
    }
  }, [r, a, h.paused]), N.useEffect(() => {
    if (a) {
      yg.add(h);
      const p = document.activeElement;
      if (!a.contains(p)) {
        const b = new CustomEvent(ku, gg);
        a.addEventListener(ku, c), a.dispatchEvent(b), b.defaultPrevented || (SD(_D(rw(a)), { select: !0 }), document.activeElement === p && fr(a));
      }
      return () => {
        a.removeEventListener(ku, c), setTimeout(() => {
          const b = new CustomEvent(xu, gg);
          a.addEventListener(xu, u), a.dispatchEvent(b), b.defaultPrevented || fr(p ?? document.body, { select: !0 }), a.removeEventListener(xu, u), yg.remove(h);
        }, 0);
      };
    }
  }, [a, c, u, h]);
  const m = N.useCallback(
    (p) => {
      if (!n && !r || h.paused) return;
      const g = p.key === "Tab" && !p.altKey && !p.ctrlKey && !p.metaKey, b = document.activeElement;
      if (g && b) {
        const v = p.currentTarget, [k, x] = TD(v);
        k && x ? !p.shiftKey && b === x ? (p.preventDefault(), n && fr(k, { select: !0 })) : p.shiftKey && b === k && (p.preventDefault(), n && fr(x, { select: !0 })) : b === v && p.preventDefault();
      }
    },
    [n, r, h.paused]
  );
  return /* @__PURE__ */ R(Nt.div, { tabIndex: -1, ...s, ref: f, onKeyDown: m });
});
nw.displayName = ED;
function SD(t, { select: e = !1 } = {}) {
  const n = document.activeElement;
  for (const r of t)
    if (fr(r, { select: e }), document.activeElement !== n) return;
}
function TD(t) {
  const e = rw(t), n = bg(e, t), r = bg(e.reverse(), t);
  return [n, r];
}
function rw(t) {
  const e = [], n = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const o = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || o ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) e.push(n.currentNode);
  return e;
}
function bg(t, e) {
  for (const n of t)
    if (!CD(n, { upTo: e })) return n;
}
function CD(t, { upTo: e }) {
  if (getComputedStyle(t).visibility === "hidden") return !0;
  for (; t; ) {
    if (e !== void 0 && t === e) return !1;
    if (getComputedStyle(t).display === "none") return !0;
    t = t.parentElement;
  }
  return !1;
}
function MD(t) {
  return t instanceof HTMLInputElement && "select" in t;
}
function fr(t, { select: e = !1 } = {}) {
  if (t && t.focus) {
    const n = document.activeElement;
    t.focus({ preventScroll: !0 }), t !== n && MD(t) && e && t.select();
  }
}
var yg = AD();
function AD() {
  let t = [];
  return {
    add(e) {
      const n = t[0];
      e !== n && n?.pause(), t = vg(t, e), t.unshift(e);
    },
    remove(e) {
      t = vg(t, e), t[0]?.resume();
    }
  };
}
function vg(t, e) {
  const n = [...t], r = n.indexOf(e);
  return r !== -1 && n.splice(r, 1), n;
}
function _D(t) {
  return t.filter((e) => e.tagName !== "A");
}
var RD = N[" useId ".trim().toString()] || (() => {
}), OD = 0;
function ri(t) {
  const [e, n] = N.useState(RD());
  return Rr(() => {
    n((r) => r ?? String(OD++));
  }, [t]), t || (e ? `radix-${e}` : "");
}
var ID = typeof document < "u", DD = function() {
}, Ta = ID ? eb : DD;
function $l(t, e) {
  if (t === e)
    return !0;
  if (typeof t != typeof e)
    return !1;
  if (typeof t == "function" && t.toString() === e.toString())
    return !0;
  let n, r, o;
  if (t && e && typeof t == "object") {
    if (Array.isArray(t)) {
      if (n = t.length, n !== e.length) return !1;
      for (r = n; r-- !== 0; )
        if (!$l(t[r], e[r]))
          return !1;
      return !0;
    }
    if (o = Object.keys(t), n = o.length, n !== Object.keys(e).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(e, o[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const i = o[r];
      if (!(i === "_owner" && t.$$typeof) && !$l(t[i], e[i]))
        return !1;
    }
    return !0;
  }
  return t !== t && e !== e;
}
function ow(t) {
  return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function wg(t, e) {
  const n = ow(t);
  return Math.round(e * n) / n;
}
function Nu(t) {
  const e = N.useRef(t);
  return Ta(() => {
    e.current = t;
  }), e;
}
function LD(t) {
  t === void 0 && (t = {});
  const {
    placement: e = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: o,
    elements: {
      reference: i,
      floating: s
    } = {},
    transform: a = !0,
    whileElementsMounted: l,
    open: c
  } = t, [u, d] = N.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: e,
    middlewareData: {},
    isPositioned: !1
  }), [f, h] = N.useState(r);
  $l(f, r) || h(r);
  const [m, p] = N.useState(null), [g, b] = N.useState(null), v = N.useCallback((A) => {
    A !== E.current && (E.current = A, p(A));
  }, []), k = N.useCallback((A) => {
    A !== S.current && (S.current = A, b(A));
  }, []), x = i || m, w = s || g, E = N.useRef(null), S = N.useRef(null), C = N.useRef(u), M = l != null, O = Nu(l), q = Nu(o), K = Nu(c), j = N.useCallback(() => {
    if (!E.current || !S.current)
      return;
    const A = {
      placement: e,
      strategy: n,
      middleware: f
    };
    q.current && (A.platform = q.current), If(E.current, S.current, A).then(($) => {
      const _ = {
        ...$,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: K.current !== !1
      };
      H.current && !$l(C.current, _) && (C.current = _, nb.flushSync(() => {
        d(_);
      }));
    });
  }, [f, e, n, q, K]);
  Ta(() => {
    c === !1 && C.current.isPositioned && (C.current.isPositioned = !1, d((A) => ({
      ...A,
      isPositioned: !1
    })));
  }, [c]);
  const H = N.useRef(!1);
  Ta(() => (H.current = !0, () => {
    H.current = !1;
  }), []), Ta(() => {
    if (x && (E.current = x), w && (S.current = w), x && w) {
      if (O.current)
        return O.current(x, w, j);
      j();
    }
  }, [x, w, j, O, M]);
  const G = N.useMemo(() => ({
    reference: E,
    floating: S,
    setReference: v,
    setFloating: k
  }), [v, k]), V = N.useMemo(() => ({
    reference: x,
    floating: w
  }), [x, w]), re = N.useMemo(() => {
    const A = {
      position: n,
      left: 0,
      top: 0
    };
    if (!V.floating)
      return A;
    const $ = wg(V.floating, u.x), _ = wg(V.floating, u.y);
    return a ? {
      ...A,
      transform: "translate(" + $ + "px, " + _ + "px)",
      ...ow(V.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: $,
      top: _
    };
  }, [n, a, V.floating, u.x, u.y]);
  return N.useMemo(() => ({
    ...u,
    update: j,
    refs: G,
    elements: V,
    floatingStyles: re
  }), [u, j, G, V, re]);
}
const PD = (t) => {
  function e(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: t,
    fn(n) {
      const {
        element: r,
        padding: o
      } = typeof t == "function" ? t(n) : t;
      return r && e(r) ? r.current != null ? Ga({
        element: r.current,
        padding: o
      }).fn(n) : {} : r ? Ga({
        element: r,
        padding: o
      }).fn(n) : {};
    }
  };
}, BD = (t, e) => ({
  ...Mf(t),
  options: [t, e]
}), zD = (t, e) => ({
  ...Af(t),
  options: [t, e]
}), $D = (t, e) => ({
  ...mM(t),
  options: [t, e]
}), HD = (t, e) => ({
  ..._f(t),
  options: [t, e]
}), FD = (t, e) => ({
  ...Rf(t),
  options: [t, e]
}), UD = (t, e) => ({
  ...Of(t),
  options: [t, e]
}), WD = (t, e) => ({
  ...PD(t),
  options: [t, e]
});
var VD = "Arrow", iw = N.forwardRef((t, e) => {
  const { children: n, width: r = 10, height: o = 5, ...i } = t;
  return /* @__PURE__ */ R(
    Nt.svg,
    {
      ...i,
      ref: e,
      width: r,
      height: o,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: t.asChild ? n : /* @__PURE__ */ R("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
iw.displayName = VD;
var KD = iw;
function qD(t) {
  const [e, n] = N.useState(void 0);
  return Rr(() => {
    if (t) {
      n({ width: t.offsetWidth, height: t.offsetHeight });
      const r = new ResizeObserver((o) => {
        if (!Array.isArray(o) || !o.length)
          return;
        const i = o[0];
        let s, a;
        if ("borderBoxSize" in i) {
          const l = i.borderBoxSize, c = Array.isArray(l) ? l[0] : l;
          s = c.inlineSize, a = c.blockSize;
        } else
          s = t.offsetWidth, a = t.offsetHeight;
        n({ width: s, height: a });
      });
      return r.observe(t, { box: "border-box" }), () => r.unobserve(t);
    } else
      n(void 0);
  }, [t]), e;
}
var ih = "Popper", [sw, xc] = ui(ih), [GD, aw] = sw(ih), lw = (t) => {
  const { __scopePopper: e, children: n } = t, [r, o] = N.useState(null);
  return /* @__PURE__ */ R(GD, { scope: e, anchor: r, onAnchorChange: o, children: n });
};
lw.displayName = ih;
var cw = "PopperAnchor", uw = N.forwardRef(
  (t, e) => {
    const { __scopePopper: n, virtualRef: r, ...o } = t, i = aw(cw, n), s = N.useRef(null), a = At(e, s), l = N.useRef(null);
    return N.useEffect(() => {
      const c = l.current;
      l.current = r?.current || s.current, c !== l.current && i.onAnchorChange(l.current);
    }), r ? null : /* @__PURE__ */ R(Nt.div, { ...o, ref: a });
  }
);
uw.displayName = cw;
var sh = "PopperContent", [jD, YD] = sw(sh), dw = N.forwardRef(
  (t, e) => {
    const {
      __scopePopper: n,
      side: r = "bottom",
      sideOffset: o = 0,
      align: i = "center",
      alignOffset: s = 0,
      arrowPadding: a = 0,
      avoidCollisions: l = !0,
      collisionBoundary: c = [],
      collisionPadding: u = 0,
      sticky: d = "partial",
      hideWhenDetached: f = !1,
      updatePositionStrategy: h = "optimized",
      onPlaced: m,
      ...p
    } = t, g = aw(sh, n), [b, v] = N.useState(null), k = At(e, (me) => v(me)), [x, w] = N.useState(null), E = qD(x), S = E?.width ?? 0, C = E?.height ?? 0, M = r + (i !== "center" ? "-" + i : ""), O = typeof u == "number" ? u : { top: 0, right: 0, bottom: 0, left: 0, ...u }, q = Array.isArray(c) ? c : [c], K = q.length > 0, j = {
      padding: O,
      boundary: q.filter(ZD),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: K
    }, { refs: H, floatingStyles: G, placement: V, isPositioned: re, middlewareData: A } = LD({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: M,
      whileElementsMounted: (...me) => hM(...me, {
        animationFrame: h === "always"
      }),
      elements: {
        reference: g.anchor
      },
      middleware: [
        BD({ mainAxis: o + C, alignmentAxis: s }),
        l && zD({
          mainAxis: !0,
          crossAxis: !1,
          limiter: d === "partial" ? $D() : void 0,
          ...j
        }),
        l && HD({ ...j }),
        FD({
          ...j,
          apply: ({ elements: me, rects: at, availableWidth: Ht, availableHeight: gt }) => {
            const { width: jt, height: Ft } = at.reference, an = me.floating.style;
            an.setProperty("--radix-popper-available-width", `${Ht}px`), an.setProperty("--radix-popper-available-height", `${gt}px`), an.setProperty("--radix-popper-anchor-width", `${jt}px`), an.setProperty("--radix-popper-anchor-height", `${Ft}px`);
          }
        }),
        x && WD({ element: x, padding: a }),
        JD({ arrowWidth: S, arrowHeight: C }),
        f && UD({ strategy: "referenceHidden", ...j })
      ]
    }), [$, _] = mw(V), z = Pn(m);
    Rr(() => {
      re && z?.();
    }, [re, z]);
    const Q = A.arrow?.x, ue = A.arrow?.y, Me = A.arrow?.centerOffset !== 0, [Oe, je] = N.useState();
    return Rr(() => {
      b && je(window.getComputedStyle(b).zIndex);
    }, [b]), /* @__PURE__ */ R(
      "div",
      {
        ref: H.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...G,
          transform: re ? G.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: Oe,
          "--radix-popper-transform-origin": [
            A.transformOrigin?.x,
            A.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...A.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: t.dir,
        children: /* @__PURE__ */ R(
          jD,
          {
            scope: n,
            placedSide: $,
            onArrowChange: w,
            arrowX: Q,
            arrowY: ue,
            shouldHideArrow: Me,
            children: /* @__PURE__ */ R(
              Nt.div,
              {
                "data-side": $,
                "data-align": _,
                ...p,
                ref: k,
                style: {
                  ...p.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: re ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
dw.displayName = sh;
var fw = "PopperArrow", XD = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, hw = N.forwardRef(function(e, n) {
  const { __scopePopper: r, ...o } = e, i = YD(fw, r), s = XD[i.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ R(
      "span",
      {
        ref: i.onArrowChange,
        style: {
          position: "absolute",
          left: i.arrowX,
          top: i.arrowY,
          [s]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[i.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[i.placedSide],
          visibility: i.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ R(
          KD,
          {
            ...o,
            ref: n,
            style: {
              ...o.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
hw.displayName = fw;
function ZD(t) {
  return t !== null;
}
var JD = (t) => ({
  name: "transformOrigin",
  options: t,
  fn(e) {
    const { placement: n, rects: r, middlewareData: o } = e, s = o.arrow?.centerOffset !== 0, a = s ? 0 : t.arrowWidth, l = s ? 0 : t.arrowHeight, [c, u] = mw(n), d = { start: "0%", center: "50%", end: "100%" }[u], f = (o.arrow?.x ?? 0) + a / 2, h = (o.arrow?.y ?? 0) + l / 2;
    let m = "", p = "";
    return c === "bottom" ? (m = s ? d : `${f}px`, p = `${-l}px`) : c === "top" ? (m = s ? d : `${f}px`, p = `${r.floating.height + l}px`) : c === "right" ? (m = `${-l}px`, p = s ? d : `${h}px`) : c === "left" && (m = `${r.floating.width + l}px`, p = s ? d : `${h}px`), { data: { x: m, y: p } };
  }
});
function mw(t) {
  const [e, n = "center"] = t.split("-");
  return [e, n];
}
var ah = lw, pw = uw, gw = dw, bw = hw, QD = "Portal", lh = N.forwardRef((t, e) => {
  const { container: n, ...r } = t, [o, i] = N.useState(!1);
  Rr(() => i(!0), []);
  const s = n || o && globalThis?.document?.body;
  return s ? rb.createPortal(/* @__PURE__ */ R(Nt.div, { ...r, ref: e }), s) : null;
});
lh.displayName = QD;
function eL(t, e) {
  return N.useReducer((n, r) => e[n][r] ?? n, t);
}
var co = (t) => {
  const { present: e, children: n } = t, r = tL(e), o = typeof n == "function" ? n({ present: r.isPresent }) : N.Children.only(n), i = At(r.ref, nL(o));
  return typeof n == "function" || r.isPresent ? N.cloneElement(o, { ref: i }) : null;
};
co.displayName = "Presence";
function tL(t) {
  const [e, n] = N.useState(), r = N.useRef(null), o = N.useRef(t), i = N.useRef("none"), s = t ? "mounted" : "unmounted", [a, l] = eL(s, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return N.useEffect(() => {
    const c = la(r.current);
    i.current = a === "mounted" ? c : "none";
  }, [a]), Rr(() => {
    const c = r.current, u = o.current;
    if (u !== t) {
      const f = i.current, h = la(c);
      t ? l("MOUNT") : h === "none" || c?.display === "none" ? l("UNMOUNT") : l(u && f !== h ? "ANIMATION_OUT" : "UNMOUNT"), o.current = t;
    }
  }, [t, l]), Rr(() => {
    if (e) {
      let c;
      const u = e.ownerDocument.defaultView ?? window, d = (h) => {
        const p = la(r.current).includes(CSS.escape(h.animationName));
        if (h.target === e && p && (l("ANIMATION_END"), !o.current)) {
          const g = e.style.animationFillMode;
          e.style.animationFillMode = "forwards", c = u.setTimeout(() => {
            e.style.animationFillMode === "forwards" && (e.style.animationFillMode = g);
          });
        }
      }, f = (h) => {
        h.target === e && (i.current = la(r.current));
      };
      return e.addEventListener("animationstart", f), e.addEventListener("animationcancel", d), e.addEventListener("animationend", d), () => {
        u.clearTimeout(c), e.removeEventListener("animationstart", f), e.removeEventListener("animationcancel", d), e.removeEventListener("animationend", d);
      };
    } else
      l("ANIMATION_END");
  }, [e, l]), {
    isPresent: ["mounted", "unmountSuspended"].includes(a),
    ref: N.useCallback((c) => {
      r.current = c ? getComputedStyle(c) : null, n(c);
    }, [])
  };
}
function la(t) {
  return t?.animationName || "none";
}
function nL(t) {
  let e = Object.getOwnPropertyDescriptor(t.props, "ref")?.get, n = e && "isReactWarning" in e && e.isReactWarning;
  return n ? t.ref : (e = Object.getOwnPropertyDescriptor(t, "ref")?.get, n = e && "isReactWarning" in e && e.isReactWarning, n ? t.props.ref : t.props.ref || t.ref);
}
var Eu = "rovingFocusGroup.onEntryFocus", rL = { bubbles: !1, cancelable: !0 }, ks = "RovingFocusGroup", [Cd, yw, oL] = Jv(ks), [iL, vw] = ui(
  ks,
  [oL]
), [sL, aL] = iL(ks), ww = N.forwardRef(
  (t, e) => /* @__PURE__ */ R(Cd.Provider, { scope: t.__scopeRovingFocusGroup, children: /* @__PURE__ */ R(Cd.Slot, { scope: t.__scopeRovingFocusGroup, children: /* @__PURE__ */ R(lL, { ...t, ref: e }) }) })
);
ww.displayName = ks;
var lL = N.forwardRef((t, e) => {
  const {
    __scopeRovingFocusGroup: n,
    orientation: r,
    loop: o = !1,
    dir: i,
    currentTabStopId: s,
    defaultCurrentTabStopId: a,
    onCurrentTabStopIdChange: l,
    onEntryFocus: c,
    preventScrollOnEntryFocus: u = !1,
    ...d
  } = t, f = N.useRef(null), h = At(e, f), m = Qv(i), [p, g] = kc({
    prop: s,
    defaultProp: a ?? null,
    onChange: l,
    caller: ks
  }), [b, v] = N.useState(!1), k = Pn(c), x = yw(n), w = N.useRef(!1), [E, S] = N.useState(0);
  return N.useEffect(() => {
    const C = f.current;
    if (C)
      return C.addEventListener(Eu, k), () => C.removeEventListener(Eu, k);
  }, [k]), /* @__PURE__ */ R(
    sL,
    {
      scope: n,
      orientation: r,
      dir: m,
      loop: o,
      currentTabStopId: p,
      onItemFocus: N.useCallback(
        (C) => g(C),
        [g]
      ),
      onItemShiftTab: N.useCallback(() => v(!0), []),
      onFocusableItemAdd: N.useCallback(
        () => S((C) => C + 1),
        []
      ),
      onFocusableItemRemove: N.useCallback(
        () => S((C) => C - 1),
        []
      ),
      children: /* @__PURE__ */ R(
        Nt.div,
        {
          tabIndex: b || E === 0 ? -1 : 0,
          "data-orientation": r,
          ...d,
          ref: h,
          style: { outline: "none", ...t.style },
          onMouseDown: Ne(t.onMouseDown, () => {
            w.current = !0;
          }),
          onFocus: Ne(t.onFocus, (C) => {
            const M = !w.current;
            if (C.target === C.currentTarget && M && !b) {
              const O = new CustomEvent(Eu, rL);
              if (C.currentTarget.dispatchEvent(O), !O.defaultPrevented) {
                const q = x().filter((V) => V.focusable), K = q.find((V) => V.active), j = q.find((V) => V.id === p), G = [K, j, ...q].filter(
                  Boolean
                ).map((V) => V.ref.current);
                Nw(G, u);
              }
            }
            w.current = !1;
          }),
          onBlur: Ne(t.onBlur, () => v(!1))
        }
      )
    }
  );
}), kw = "RovingFocusGroupItem", xw = N.forwardRef(
  (t, e) => {
    const {
      __scopeRovingFocusGroup: n,
      focusable: r = !0,
      active: o = !1,
      tabStopId: i,
      children: s,
      ...a
    } = t, l = ri(), c = i || l, u = aL(kw, n), d = u.currentTabStopId === c, f = yw(n), { onFocusableItemAdd: h, onFocusableItemRemove: m, currentTabStopId: p } = u;
    return N.useEffect(() => {
      if (r)
        return h(), () => m();
    }, [r, h, m]), /* @__PURE__ */ R(
      Cd.ItemSlot,
      {
        scope: n,
        id: c,
        focusable: r,
        active: o,
        children: /* @__PURE__ */ R(
          Nt.span,
          {
            tabIndex: d ? 0 : -1,
            "data-orientation": u.orientation,
            ...a,
            ref: e,
            onMouseDown: Ne(t.onMouseDown, (g) => {
              r ? u.onItemFocus(c) : g.preventDefault();
            }),
            onFocus: Ne(t.onFocus, () => u.onItemFocus(c)),
            onKeyDown: Ne(t.onKeyDown, (g) => {
              if (g.key === "Tab" && g.shiftKey) {
                u.onItemShiftTab();
                return;
              }
              if (g.target !== g.currentTarget) return;
              const b = dL(g, u.orientation, u.dir);
              if (b !== void 0) {
                if (g.metaKey || g.ctrlKey || g.altKey || g.shiftKey) return;
                g.preventDefault();
                let k = f().filter((x) => x.focusable).map((x) => x.ref.current);
                if (b === "last") k.reverse();
                else if (b === "prev" || b === "next") {
                  b === "prev" && k.reverse();
                  const x = k.indexOf(g.currentTarget);
                  k = u.loop ? fL(k, x + 1) : k.slice(x + 1);
                }
                setTimeout(() => Nw(k));
              }
            }),
            children: typeof s == "function" ? s({ isCurrentTabStop: d, hasTabStop: p != null }) : s
          }
        )
      }
    );
  }
);
xw.displayName = kw;
var cL = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function uL(t, e) {
  return e !== "rtl" ? t : t === "ArrowLeft" ? "ArrowRight" : t === "ArrowRight" ? "ArrowLeft" : t;
}
function dL(t, e, n) {
  const r = uL(t.key, n);
  if (!(e === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(e === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
    return cL[r];
}
function Nw(t, e = !1) {
  const n = document.activeElement;
  for (const r of t)
    if (r === n || (r.focus({ preventScroll: e }), document.activeElement !== n)) return;
}
function fL(t, e) {
  return t.map((n, r) => t[(e + r) % t.length]);
}
var hL = ww, mL = xw, pL = function(t) {
  if (typeof document > "u")
    return null;
  var e = Array.isArray(t) ? t[0] : t;
  return e.ownerDocument.body;
}, To = /* @__PURE__ */ new WeakMap(), ca = /* @__PURE__ */ new WeakMap(), ua = {}, Su = 0, Ew = function(t) {
  return t && (t.host || Ew(t.parentNode));
}, gL = function(t, e) {
  return e.map(function(n) {
    if (t.contains(n))
      return n;
    var r = Ew(n);
    return r && t.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", t, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, bL = function(t, e, n, r) {
  var o = gL(e, Array.isArray(t) ? t : [t]);
  ua[n] || (ua[n] = /* @__PURE__ */ new WeakMap());
  var i = ua[n], s = [], a = /* @__PURE__ */ new Set(), l = new Set(o), c = function(d) {
    !d || a.has(d) || (a.add(d), c(d.parentNode));
  };
  o.forEach(c);
  var u = function(d) {
    !d || l.has(d) || Array.prototype.forEach.call(d.children, function(f) {
      if (a.has(f))
        u(f);
      else
        try {
          var h = f.getAttribute(r), m = h !== null && h !== "false", p = (To.get(f) || 0) + 1, g = (i.get(f) || 0) + 1;
          To.set(f, p), i.set(f, g), s.push(f), p === 1 && m && ca.set(f, !0), g === 1 && f.setAttribute(n, "true"), m || f.setAttribute(r, "true");
        } catch (b) {
          console.error("aria-hidden: cannot operate on ", f, b);
        }
    });
  };
  return u(e), a.clear(), Su++, function() {
    s.forEach(function(d) {
      var f = To.get(d) - 1, h = i.get(d) - 1;
      To.set(d, f), i.set(d, h), f || (ca.has(d) || d.removeAttribute(r), ca.delete(d)), h || d.removeAttribute(n);
    }), Su--, Su || (To = /* @__PURE__ */ new WeakMap(), To = /* @__PURE__ */ new WeakMap(), ca = /* @__PURE__ */ new WeakMap(), ua = {});
  };
}, yL = function(t, e, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(t) ? t : [t]), o = pL(t);
  return o ? (r.push.apply(r, Array.from(o.querySelectorAll("[aria-live], script"))), bL(r, o, n, "aria-hidden")) : function() {
    return null;
  };
}, Rn = function() {
  return Rn = Object.assign || function(e) {
    for (var n, r = 1, o = arguments.length; r < o; r++) {
      n = arguments[r];
      for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
    }
    return e;
  }, Rn.apply(this, arguments);
};
function Sw(t, e) {
  var n = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(t); o < r.length; o++)
      e.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[o]) && (n[r[o]] = t[r[o]]);
  return n;
}
function vL(t, e, n) {
  if (n || arguments.length === 2) for (var r = 0, o = e.length, i; r < o; r++)
    (i || !(r in e)) && (i || (i = Array.prototype.slice.call(e, 0, r)), i[r] = e[r]);
  return t.concat(i || Array.prototype.slice.call(e));
}
var Ca = "right-scroll-bar-position", Ma = "width-before-scroll-bar", wL = "with-scroll-bars-hidden", kL = "--removed-body-scroll-bar-size";
function Tu(t, e) {
  return typeof t == "function" ? t(e) : t && (t.current = e), t;
}
function xL(t, e) {
  var n = J(function() {
    return {
      // value
      value: t,
      // last callback
      callback: e,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var o = n.value;
          o !== r && (n.value = r, n.callback(r, o));
        }
      }
    };
  })[0];
  return n.callback = e, n.facade;
}
var NL = typeof window < "u" ? N.useLayoutEffect : N.useEffect, kg = /* @__PURE__ */ new WeakMap();
function EL(t, e) {
  var n = xL(null, function(r) {
    return t.forEach(function(o) {
      return Tu(o, r);
    });
  });
  return NL(function() {
    var r = kg.get(n);
    if (r) {
      var o = new Set(r), i = new Set(t), s = n.current;
      o.forEach(function(a) {
        i.has(a) || Tu(a, null);
      }), i.forEach(function(a) {
        o.has(a) || Tu(a, s);
      });
    }
    kg.set(n, t);
  }, [t]), n;
}
function SL(t) {
  return t;
}
function TL(t, e) {
  e === void 0 && (e = SL);
  var n = [], r = !1, o = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : t;
    },
    useMedium: function(i) {
      var s = e(i, r);
      return n.push(s), function() {
        n = n.filter(function(a) {
          return a !== s;
        });
      };
    },
    assignSyncMedium: function(i) {
      for (r = !0; n.length; ) {
        var s = n;
        n = [], s.forEach(i);
      }
      n = {
        push: function(a) {
          return i(a);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(i) {
      r = !0;
      var s = [];
      if (n.length) {
        var a = n;
        n = [], a.forEach(i), s = n;
      }
      var l = function() {
        var u = s;
        s = [], u.forEach(i);
      }, c = function() {
        return Promise.resolve().then(l);
      };
      c(), n = {
        push: function(u) {
          s.push(u), c();
        },
        filter: function(u) {
          return s = s.filter(u), n;
        }
      };
    }
  };
  return o;
}
function CL(t) {
  t === void 0 && (t = {});
  var e = TL(null);
  return e.options = Rn({ async: !0, ssr: !1 }, t), e;
}
var Tw = function(t) {
  var e = t.sideCar, n = Sw(t, ["sideCar"]);
  if (!e)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = e.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return N.createElement(r, Rn({}, n));
};
Tw.isSideCarExport = !0;
function ML(t, e) {
  return t.useMedium(e), Tw;
}
var Cw = CL(), Cu = function() {
}, Nc = N.forwardRef(function(t, e) {
  var n = N.useRef(null), r = N.useState({
    onScrollCapture: Cu,
    onWheelCapture: Cu,
    onTouchMoveCapture: Cu
  }), o = r[0], i = r[1], s = t.forwardProps, a = t.children, l = t.className, c = t.removeScrollBar, u = t.enabled, d = t.shards, f = t.sideCar, h = t.noRelative, m = t.noIsolation, p = t.inert, g = t.allowPinchZoom, b = t.as, v = b === void 0 ? "div" : b, k = t.gapMode, x = Sw(t, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), w = f, E = EL([n, e]), S = Rn(Rn({}, x), o);
  return N.createElement(
    N.Fragment,
    null,
    u && N.createElement(w, { sideCar: Cw, removeScrollBar: c, shards: d, noRelative: h, noIsolation: m, inert: p, setCallbacks: i, allowPinchZoom: !!g, lockRef: n, gapMode: k }),
    s ? N.cloneElement(N.Children.only(a), Rn(Rn({}, S), { ref: E })) : N.createElement(v, Rn({}, S, { className: l, ref: E }), a)
  );
});
Nc.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
Nc.classNames = {
  fullWidth: Ma,
  zeroRight: Ca
};
var AL = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function _L() {
  if (!document)
    return null;
  var t = document.createElement("style");
  t.type = "text/css";
  var e = AL();
  return e && t.setAttribute("nonce", e), t;
}
function RL(t, e) {
  t.styleSheet ? t.styleSheet.cssText = e : t.appendChild(document.createTextNode(e));
}
function OL(t) {
  var e = document.head || document.getElementsByTagName("head")[0];
  e.appendChild(t);
}
var IL = function() {
  var t = 0, e = null;
  return {
    add: function(n) {
      t == 0 && (e = _L()) && (RL(e, n), OL(e)), t++;
    },
    remove: function() {
      t--, !t && e && (e.parentNode && e.parentNode.removeChild(e), e = null);
    }
  };
}, DL = function() {
  var t = IL();
  return function(e, n) {
    N.useEffect(function() {
      return t.add(e), function() {
        t.remove();
      };
    }, [e && n]);
  };
}, Mw = function() {
  var t = DL(), e = function(n) {
    var r = n.styles, o = n.dynamic;
    return t(r, o), null;
  };
  return e;
}, LL = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, Mu = function(t) {
  return parseInt(t || "", 10) || 0;
}, PL = function(t) {
  var e = window.getComputedStyle(document.body), n = e[t === "padding" ? "paddingLeft" : "marginLeft"], r = e[t === "padding" ? "paddingTop" : "marginTop"], o = e[t === "padding" ? "paddingRight" : "marginRight"];
  return [Mu(n), Mu(r), Mu(o)];
}, BL = function(t) {
  if (t === void 0 && (t = "margin"), typeof window > "u")
    return LL;
  var e = PL(t), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: e[0],
    top: e[1],
    right: e[2],
    gap: Math.max(0, r - n + e[2] - e[0])
  };
}, zL = Mw(), Ko = "data-scroll-locked", $L = function(t, e, n, r) {
  var o = t.left, i = t.top, s = t.right, a = t.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(wL, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(a, "px ").concat(r, `;
  }
  body[`).concat(Ko, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    e && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(o, `px;
    padding-top: `).concat(i, `px;
    padding-right: `).concat(s, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(a, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(a, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(Ca, ` {
    right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(Ma, ` {
    margin-right: `).concat(a, "px ").concat(r, `;
  }
  
  .`).concat(Ca, " .").concat(Ca, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(Ma, " .").concat(Ma, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(Ko, `] {
    `).concat(kL, ": ").concat(a, `px;
  }
`);
}, xg = function() {
  var t = parseInt(document.body.getAttribute(Ko) || "0", 10);
  return isFinite(t) ? t : 0;
}, HL = function() {
  N.useEffect(function() {
    return document.body.setAttribute(Ko, (xg() + 1).toString()), function() {
      var t = xg() - 1;
      t <= 0 ? document.body.removeAttribute(Ko) : document.body.setAttribute(Ko, t.toString());
    };
  }, []);
}, FL = function(t) {
  var e = t.noRelative, n = t.noImportant, r = t.gapMode, o = r === void 0 ? "margin" : r;
  HL();
  var i = N.useMemo(function() {
    return BL(o);
  }, [o]);
  return N.createElement(zL, { styles: $L(i, !e, o, n ? "" : "!important") });
}, Md = !1;
if (typeof window < "u")
  try {
    var da = Object.defineProperty({}, "passive", {
      get: function() {
        return Md = !0, !0;
      }
    });
    window.addEventListener("test", da, da), window.removeEventListener("test", da, da);
  } catch {
    Md = !1;
  }
var Co = Md ? { passive: !1 } : !1, UL = function(t) {
  return t.tagName === "TEXTAREA";
}, Aw = function(t, e) {
  if (!(t instanceof Element))
    return !1;
  var n = window.getComputedStyle(t);
  return (
    // not-not-scrollable
    n[e] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !UL(t) && n[e] === "visible")
  );
}, WL = function(t) {
  return Aw(t, "overflowY");
}, VL = function(t) {
  return Aw(t, "overflowX");
}, Ng = function(t, e) {
  var n = e.ownerDocument, r = e;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var o = _w(t, r);
    if (o) {
      var i = Rw(t, r), s = i[1], a = i[2];
      if (s > a)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, KL = function(t) {
  var e = t.scrollTop, n = t.scrollHeight, r = t.clientHeight;
  return [
    e,
    n,
    r
  ];
}, qL = function(t) {
  var e = t.scrollLeft, n = t.scrollWidth, r = t.clientWidth;
  return [
    e,
    n,
    r
  ];
}, _w = function(t, e) {
  return t === "v" ? WL(e) : VL(e);
}, Rw = function(t, e) {
  return t === "v" ? KL(e) : qL(e);
}, GL = function(t, e) {
  return t === "h" && e === "rtl" ? -1 : 1;
}, jL = function(t, e, n, r, o) {
  var i = GL(t, window.getComputedStyle(e).direction), s = i * r, a = n.target, l = e.contains(a), c = !1, u = s > 0, d = 0, f = 0;
  do {
    if (!a)
      break;
    var h = Rw(t, a), m = h[0], p = h[1], g = h[2], b = p - g - i * m;
    (m || b) && _w(t, a) && (d += b, f += m);
    var v = a.parentNode;
    a = v && v.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? v.host : v;
  } while (
    // portaled content
    !l && a !== document.body || // self content
    l && (e.contains(a) || e === a)
  );
  return (u && Math.abs(d) < 1 || !u && Math.abs(f) < 1) && (c = !0), c;
}, fa = function(t) {
  return "changedTouches" in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0];
}, Eg = function(t) {
  return [t.deltaX, t.deltaY];
}, Sg = function(t) {
  return t && "current" in t ? t.current : t;
}, YL = function(t, e) {
  return t[0] === e[0] && t[1] === e[1];
}, XL = function(t) {
  return `
  .block-interactivity-`.concat(t, ` {pointer-events: none;}
  .allow-interactivity-`).concat(t, ` {pointer-events: all;}
`);
}, ZL = 0, Mo = [];
function JL(t) {
  var e = N.useRef([]), n = N.useRef([0, 0]), r = N.useRef(), o = N.useState(ZL++)[0], i = N.useState(Mw)[0], s = N.useRef(t);
  N.useEffect(function() {
    s.current = t;
  }, [t]), N.useEffect(function() {
    if (t.inert) {
      document.body.classList.add("block-interactivity-".concat(o));
      var p = vL([t.lockRef.current], (t.shards || []).map(Sg), !0).filter(Boolean);
      return p.forEach(function(g) {
        return g.classList.add("allow-interactivity-".concat(o));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(o)), p.forEach(function(g) {
          return g.classList.remove("allow-interactivity-".concat(o));
        });
      };
    }
  }, [t.inert, t.lockRef.current, t.shards]);
  var a = N.useCallback(function(p, g) {
    if ("touches" in p && p.touches.length === 2 || p.type === "wheel" && p.ctrlKey)
      return !s.current.allowPinchZoom;
    var b = fa(p), v = n.current, k = "deltaX" in p ? p.deltaX : v[0] - b[0], x = "deltaY" in p ? p.deltaY : v[1] - b[1], w, E = p.target, S = Math.abs(k) > Math.abs(x) ? "h" : "v";
    if ("touches" in p && S === "h" && E.type === "range")
      return !1;
    var C = Ng(S, E);
    if (!C)
      return !0;
    if (C ? w = S : (w = S === "v" ? "h" : "v", C = Ng(S, E)), !C)
      return !1;
    if (!r.current && "changedTouches" in p && (k || x) && (r.current = w), !w)
      return !0;
    var M = r.current || w;
    return jL(M, g, p, M === "h" ? k : x);
  }, []), l = N.useCallback(function(p) {
    var g = p;
    if (!(!Mo.length || Mo[Mo.length - 1] !== i)) {
      var b = "deltaY" in g ? Eg(g) : fa(g), v = e.current.filter(function(w) {
        return w.name === g.type && (w.target === g.target || g.target === w.shadowParent) && YL(w.delta, b);
      })[0];
      if (v && v.should) {
        g.cancelable && g.preventDefault();
        return;
      }
      if (!v) {
        var k = (s.current.shards || []).map(Sg).filter(Boolean).filter(function(w) {
          return w.contains(g.target);
        }), x = k.length > 0 ? a(g, k[0]) : !s.current.noIsolation;
        x && g.cancelable && g.preventDefault();
      }
    }
  }, []), c = N.useCallback(function(p, g, b, v) {
    var k = { name: p, delta: g, target: b, should: v, shadowParent: QL(b) };
    e.current.push(k), setTimeout(function() {
      e.current = e.current.filter(function(x) {
        return x !== k;
      });
    }, 1);
  }, []), u = N.useCallback(function(p) {
    n.current = fa(p), r.current = void 0;
  }, []), d = N.useCallback(function(p) {
    c(p.type, Eg(p), p.target, a(p, t.lockRef.current));
  }, []), f = N.useCallback(function(p) {
    c(p.type, fa(p), p.target, a(p, t.lockRef.current));
  }, []);
  N.useEffect(function() {
    return Mo.push(i), t.setCallbacks({
      onScrollCapture: d,
      onWheelCapture: d,
      onTouchMoveCapture: f
    }), document.addEventListener("wheel", l, Co), document.addEventListener("touchmove", l, Co), document.addEventListener("touchstart", u, Co), function() {
      Mo = Mo.filter(function(p) {
        return p !== i;
      }), document.removeEventListener("wheel", l, Co), document.removeEventListener("touchmove", l, Co), document.removeEventListener("touchstart", u, Co);
    };
  }, []);
  var h = t.removeScrollBar, m = t.inert;
  return N.createElement(
    N.Fragment,
    null,
    m ? N.createElement(i, { styles: XL(o) }) : null,
    h ? N.createElement(FL, { noRelative: t.noRelative, gapMode: t.gapMode }) : null
  );
}
function QL(t) {
  for (var e = null; t !== null; )
    t instanceof ShadowRoot && (e = t.host, t = t.host), t = t.parentNode;
  return e;
}
const eP = ML(Cw, JL);
var Ow = N.forwardRef(function(t, e) {
  return N.createElement(Nc, Rn({}, t, { ref: e, sideCar: eP }));
});
Ow.classNames = Nc.classNames;
var Ad = ["Enter", " "], tP = ["ArrowDown", "PageUp", "Home"], Iw = ["ArrowUp", "PageDown", "End"], nP = [...tP, ...Iw], rP = {
  ltr: [...Ad, "ArrowRight"],
  rtl: [...Ad, "ArrowLeft"]
}, oP = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
}, xs = "Menu", [fs, iP, sP] = Jv(xs), [uo, Dw] = ui(xs, [
  sP,
  xc,
  vw
]), Ns = xc(), Lw = vw(), [Pw, Lr] = uo(xs), [aP, Es] = uo(xs), Bw = (t) => {
  const { __scopeMenu: e, open: n = !1, children: r, dir: o, onOpenChange: i, modal: s = !0 } = t, a = Ns(e), [l, c] = N.useState(null), u = N.useRef(!1), d = Pn(i), f = Qv(o);
  return N.useEffect(() => {
    const h = () => {
      u.current = !0, document.addEventListener("pointerdown", m, { capture: !0, once: !0 }), document.addEventListener("pointermove", m, { capture: !0, once: !0 });
    }, m = () => u.current = !1;
    return document.addEventListener("keydown", h, { capture: !0 }), () => {
      document.removeEventListener("keydown", h, { capture: !0 }), document.removeEventListener("pointerdown", m, { capture: !0 }), document.removeEventListener("pointermove", m, { capture: !0 });
    };
  }, []), /* @__PURE__ */ R(ah, { ...a, children: /* @__PURE__ */ R(
    Pw,
    {
      scope: e,
      open: n,
      onOpenChange: d,
      content: l,
      onContentChange: c,
      children: /* @__PURE__ */ R(
        aP,
        {
          scope: e,
          onClose: N.useCallback(() => d(!1), [d]),
          isUsingKeyboardRef: u,
          dir: f,
          modal: s,
          children: r
        }
      )
    }
  ) });
};
Bw.displayName = xs;
var lP = "MenuAnchor", ch = N.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, ...r } = t, o = Ns(n);
    return /* @__PURE__ */ R(pw, { ...o, ...r, ref: e });
  }
);
ch.displayName = lP;
var uh = "MenuPortal", [cP, zw] = uo(uh, {
  forceMount: void 0
}), $w = (t) => {
  const { __scopeMenu: e, forceMount: n, children: r, container: o } = t, i = Lr(uh, e);
  return /* @__PURE__ */ R(cP, { scope: e, forceMount: n, children: /* @__PURE__ */ R(co, { present: n || i.open, children: /* @__PURE__ */ R(lh, { asChild: !0, container: o, children: r }) }) });
};
$w.displayName = uh;
var sn = "MenuContent", [uP, dh] = uo(sn), Hw = N.forwardRef(
  (t, e) => {
    const n = zw(sn, t.__scopeMenu), { forceMount: r = n.forceMount, ...o } = t, i = Lr(sn, t.__scopeMenu), s = Es(sn, t.__scopeMenu);
    return /* @__PURE__ */ R(fs.Provider, { scope: t.__scopeMenu, children: /* @__PURE__ */ R(co, { present: r || i.open, children: /* @__PURE__ */ R(fs.Slot, { scope: t.__scopeMenu, children: s.modal ? /* @__PURE__ */ R(dP, { ...o, ref: e }) : /* @__PURE__ */ R(fP, { ...o, ref: e }) }) }) });
  }
), dP = N.forwardRef(
  (t, e) => {
    const n = Lr(sn, t.__scopeMenu), r = N.useRef(null), o = At(e, r);
    return N.useEffect(() => {
      const i = r.current;
      if (i) return yL(i);
    }, []), /* @__PURE__ */ R(
      fh,
      {
        ...t,
        ref: o,
        trapFocus: n.open,
        disableOutsidePointerEvents: n.open,
        disableOutsideScroll: !0,
        onFocusOutside: Ne(
          t.onFocusOutside,
          (i) => i.preventDefault(),
          { checkForDefaultPrevented: !1 }
        ),
        onDismiss: () => n.onOpenChange(!1)
      }
    );
  }
), fP = N.forwardRef((t, e) => {
  const n = Lr(sn, t.__scopeMenu);
  return /* @__PURE__ */ R(
    fh,
    {
      ...t,
      ref: e,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => n.onOpenChange(!1)
    }
  );
}), hP = /* @__PURE__ */ ds("MenuContent.ScrollLock"), fh = N.forwardRef(
  (t, e) => {
    const {
      __scopeMenu: n,
      loop: r = !1,
      trapFocus: o,
      onOpenAutoFocus: i,
      onCloseAutoFocus: s,
      disableOutsidePointerEvents: a,
      onEntryFocus: l,
      onEscapeKeyDown: c,
      onPointerDownOutside: u,
      onFocusOutside: d,
      onInteractOutside: f,
      onDismiss: h,
      disableOutsideScroll: m,
      ...p
    } = t, g = Lr(sn, n), b = Es(sn, n), v = Ns(n), k = Lw(n), x = iP(n), [w, E] = N.useState(null), S = N.useRef(null), C = At(e, S, g.onContentChange), M = N.useRef(0), O = N.useRef(""), q = N.useRef(0), K = N.useRef(null), j = N.useRef("right"), H = N.useRef(0), G = m ? Ow : N.Fragment, V = m ? { as: hP, allowPinchZoom: !0 } : void 0, re = ($) => {
      const _ = O.current + $, z = x().filter((me) => !me.disabled), Q = document.activeElement, ue = z.find((me) => me.ref.current === Q)?.textValue, Me = z.map((me) => me.textValue), Oe = SP(Me, _, ue), je = z.find((me) => me.textValue === Oe)?.ref.current;
      (function me(at) {
        O.current = at, window.clearTimeout(M.current), at !== "" && (M.current = window.setTimeout(() => me(""), 1e3));
      })(_), je && setTimeout(() => je.focus());
    };
    N.useEffect(() => () => window.clearTimeout(M.current), []), ND();
    const A = N.useCallback(($) => j.current === K.current?.side && CP($, K.current?.area), []);
    return /* @__PURE__ */ R(
      uP,
      {
        scope: n,
        searchRef: O,
        onItemEnter: N.useCallback(
          ($) => {
            A($) && $.preventDefault();
          },
          [A]
        ),
        onItemLeave: N.useCallback(
          ($) => {
            A($) || (S.current?.focus(), E(null));
          },
          [A]
        ),
        onTriggerLeave: N.useCallback(
          ($) => {
            A($) && $.preventDefault();
          },
          [A]
        ),
        pointerGraceTimerRef: q,
        onPointerGraceIntentChange: N.useCallback(($) => {
          K.current = $;
        }, []),
        children: /* @__PURE__ */ R(G, { ...V, children: /* @__PURE__ */ R(
          nw,
          {
            asChild: !0,
            trapped: o,
            onMountAutoFocus: Ne(i, ($) => {
              $.preventDefault(), S.current?.focus({ preventScroll: !0 });
            }),
            onUnmountAutoFocus: s,
            children: /* @__PURE__ */ R(
              oh,
              {
                asChild: !0,
                disableOutsidePointerEvents: a,
                onEscapeKeyDown: c,
                onPointerDownOutside: u,
                onFocusOutside: d,
                onInteractOutside: f,
                onDismiss: h,
                children: /* @__PURE__ */ R(
                  hL,
                  {
                    asChild: !0,
                    ...k,
                    dir: b.dir,
                    orientation: "vertical",
                    loop: r,
                    currentTabStopId: w,
                    onCurrentTabStopIdChange: E,
                    onEntryFocus: Ne(l, ($) => {
                      b.isUsingKeyboardRef.current || $.preventDefault();
                    }),
                    preventScrollOnEntryFocus: !0,
                    children: /* @__PURE__ */ R(
                      gw,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": rk(g.open),
                        "data-radix-menu-content": "",
                        dir: b.dir,
                        ...v,
                        ...p,
                        ref: C,
                        style: { outline: "none", ...p.style },
                        onKeyDown: Ne(p.onKeyDown, ($) => {
                          const z = $.target.closest("[data-radix-menu-content]") === $.currentTarget, Q = $.ctrlKey || $.altKey || $.metaKey, ue = $.key.length === 1;
                          z && ($.key === "Tab" && $.preventDefault(), !Q && ue && re($.key));
                          const Me = S.current;
                          if ($.target !== Me || !nP.includes($.key)) return;
                          $.preventDefault();
                          const je = x().filter((me) => !me.disabled).map((me) => me.ref.current);
                          Iw.includes($.key) && je.reverse(), NP(je);
                        }),
                        onBlur: Ne(t.onBlur, ($) => {
                          $.currentTarget.contains($.target) || (window.clearTimeout(M.current), O.current = "");
                        }),
                        onPointerMove: Ne(
                          t.onPointerMove,
                          hs(($) => {
                            const _ = $.target, z = H.current !== $.clientX;
                            if ($.currentTarget.contains(_) && z) {
                              const Q = $.clientX > H.current ? "right" : "left";
                              j.current = Q, H.current = $.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
Hw.displayName = sn;
var mP = "MenuGroup", hh = N.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, ...r } = t;
    return /* @__PURE__ */ R(Nt.div, { role: "group", ...r, ref: e });
  }
);
hh.displayName = mP;
var pP = "MenuLabel", Fw = N.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, ...r } = t;
    return /* @__PURE__ */ R(Nt.div, { ...r, ref: e });
  }
);
Fw.displayName = pP;
var Hl = "MenuItem", Tg = "menu.itemSelect", Ec = N.forwardRef(
  (t, e) => {
    const { disabled: n = !1, onSelect: r, ...o } = t, i = N.useRef(null), s = Es(Hl, t.__scopeMenu), a = dh(Hl, t.__scopeMenu), l = At(e, i), c = N.useRef(!1), u = () => {
      const d = i.current;
      if (!n && d) {
        const f = new CustomEvent(Tg, { bubbles: !0, cancelable: !0 });
        d.addEventListener(Tg, (h) => r?.(h), { once: !0 }), Zv(d, f), f.defaultPrevented ? c.current = !1 : s.onClose();
      }
    };
    return /* @__PURE__ */ R(
      Uw,
      {
        ...o,
        ref: l,
        disabled: n,
        onClick: Ne(t.onClick, u),
        onPointerDown: (d) => {
          t.onPointerDown?.(d), c.current = !0;
        },
        onPointerUp: Ne(t.onPointerUp, (d) => {
          c.current || d.currentTarget?.click();
        }),
        onKeyDown: Ne(t.onKeyDown, (d) => {
          const f = a.searchRef.current !== "";
          n || f && d.key === " " || Ad.includes(d.key) && (d.currentTarget.click(), d.preventDefault());
        })
      }
    );
  }
);
Ec.displayName = Hl;
var Uw = N.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, disabled: r = !1, textValue: o, ...i } = t, s = dh(Hl, n), a = Lw(n), l = N.useRef(null), c = At(e, l), [u, d] = N.useState(!1), [f, h] = N.useState("");
    return N.useEffect(() => {
      const m = l.current;
      m && h((m.textContent ?? "").trim());
    }, [i.children]), /* @__PURE__ */ R(
      fs.ItemSlot,
      {
        scope: n,
        disabled: r,
        textValue: o ?? f,
        children: /* @__PURE__ */ R(mL, { asChild: !0, ...a, focusable: !r, children: /* @__PURE__ */ R(
          Nt.div,
          {
            role: "menuitem",
            "data-highlighted": u ? "" : void 0,
            "aria-disabled": r || void 0,
            "data-disabled": r ? "" : void 0,
            ...i,
            ref: c,
            onPointerMove: Ne(
              t.onPointerMove,
              hs((m) => {
                r ? s.onItemLeave(m) : (s.onItemEnter(m), m.defaultPrevented || m.currentTarget.focus({ preventScroll: !0 }));
              })
            ),
            onPointerLeave: Ne(
              t.onPointerLeave,
              hs((m) => s.onItemLeave(m))
            ),
            onFocus: Ne(t.onFocus, () => d(!0)),
            onBlur: Ne(t.onBlur, () => d(!1))
          }
        ) })
      }
    );
  }
), gP = "MenuCheckboxItem", Ww = N.forwardRef(
  (t, e) => {
    const { checked: n = !1, onCheckedChange: r, ...o } = t;
    return /* @__PURE__ */ R(jw, { scope: t.__scopeMenu, checked: n, children: /* @__PURE__ */ R(
      Ec,
      {
        role: "menuitemcheckbox",
        "aria-checked": Fl(n) ? "mixed" : n,
        ...o,
        ref: e,
        "data-state": gh(n),
        onSelect: Ne(
          o.onSelect,
          () => r?.(Fl(n) ? !0 : !n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
Ww.displayName = gP;
var Vw = "MenuRadioGroup", [bP, yP] = uo(
  Vw,
  { value: void 0, onValueChange: () => {
  } }
), Kw = N.forwardRef(
  (t, e) => {
    const { value: n, onValueChange: r, ...o } = t, i = Pn(r);
    return /* @__PURE__ */ R(bP, { scope: t.__scopeMenu, value: n, onValueChange: i, children: /* @__PURE__ */ R(hh, { ...o, ref: e }) });
  }
);
Kw.displayName = Vw;
var qw = "MenuRadioItem", Gw = N.forwardRef(
  (t, e) => {
    const { value: n, ...r } = t, o = yP(qw, t.__scopeMenu), i = n === o.value;
    return /* @__PURE__ */ R(jw, { scope: t.__scopeMenu, checked: i, children: /* @__PURE__ */ R(
      Ec,
      {
        role: "menuitemradio",
        "aria-checked": i,
        ...r,
        ref: e,
        "data-state": gh(i),
        onSelect: Ne(
          r.onSelect,
          () => o.onValueChange?.(n),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
Gw.displayName = qw;
var mh = "MenuItemIndicator", [jw, vP] = uo(
  mh,
  { checked: !1 }
), Yw = N.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, forceMount: r, ...o } = t, i = vP(mh, n);
    return /* @__PURE__ */ R(
      co,
      {
        present: r || Fl(i.checked) || i.checked === !0,
        children: /* @__PURE__ */ R(
          Nt.span,
          {
            ...o,
            ref: e,
            "data-state": gh(i.checked)
          }
        )
      }
    );
  }
);
Yw.displayName = mh;
var wP = "MenuSeparator", Xw = N.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, ...r } = t;
    return /* @__PURE__ */ R(
      Nt.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...r,
        ref: e
      }
    );
  }
);
Xw.displayName = wP;
var kP = "MenuArrow", Zw = N.forwardRef(
  (t, e) => {
    const { __scopeMenu: n, ...r } = t, o = Ns(n);
    return /* @__PURE__ */ R(bw, { ...o, ...r, ref: e });
  }
);
Zw.displayName = kP;
var ph = "MenuSub", [xP, Jw] = uo(ph), Qw = (t) => {
  const { __scopeMenu: e, children: n, open: r = !1, onOpenChange: o } = t, i = Lr(ph, e), s = Ns(e), [a, l] = N.useState(null), [c, u] = N.useState(null), d = Pn(o);
  return N.useEffect(() => (i.open === !1 && d(!1), () => d(!1)), [i.open, d]), /* @__PURE__ */ R(ah, { ...s, children: /* @__PURE__ */ R(
    Pw,
    {
      scope: e,
      open: r,
      onOpenChange: d,
      content: c,
      onContentChange: u,
      children: /* @__PURE__ */ R(
        xP,
        {
          scope: e,
          contentId: ri(),
          triggerId: ri(),
          trigger: a,
          onTriggerChange: l,
          children: n
        }
      )
    }
  ) });
};
Qw.displayName = ph;
var Oi = "MenuSubTrigger", ek = N.forwardRef(
  (t, e) => {
    const n = Lr(Oi, t.__scopeMenu), r = Es(Oi, t.__scopeMenu), o = Jw(Oi, t.__scopeMenu), i = dh(Oi, t.__scopeMenu), s = N.useRef(null), { pointerGraceTimerRef: a, onPointerGraceIntentChange: l } = i, c = { __scopeMenu: t.__scopeMenu }, u = N.useCallback(() => {
      s.current && window.clearTimeout(s.current), s.current = null;
    }, []);
    return N.useEffect(() => u, [u]), N.useEffect(() => {
      const d = a.current;
      return () => {
        window.clearTimeout(d), l(null);
      };
    }, [a, l]), /* @__PURE__ */ R(ch, { asChild: !0, ...c, children: /* @__PURE__ */ R(
      Uw,
      {
        id: o.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": n.open,
        "aria-controls": o.contentId,
        "data-state": rk(n.open),
        ...t,
        ref: wc(e, o.onTriggerChange),
        onClick: (d) => {
          t.onClick?.(d), !(t.disabled || d.defaultPrevented) && (d.currentTarget.focus(), n.open || n.onOpenChange(!0));
        },
        onPointerMove: Ne(
          t.onPointerMove,
          hs((d) => {
            i.onItemEnter(d), !d.defaultPrevented && !t.disabled && !n.open && !s.current && (i.onPointerGraceIntentChange(null), s.current = window.setTimeout(() => {
              n.onOpenChange(!0), u();
            }, 100));
          })
        ),
        onPointerLeave: Ne(
          t.onPointerLeave,
          hs((d) => {
            u();
            const f = n.content?.getBoundingClientRect();
            if (f) {
              const h = n.content?.dataset.side, m = h === "right", p = m ? -5 : 5, g = f[m ? "left" : "right"], b = f[m ? "right" : "left"];
              i.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: d.clientX + p, y: d.clientY },
                  { x: g, y: f.top },
                  { x: b, y: f.top },
                  { x: b, y: f.bottom },
                  { x: g, y: f.bottom }
                ],
                side: h
              }), window.clearTimeout(a.current), a.current = window.setTimeout(
                () => i.onPointerGraceIntentChange(null),
                300
              );
            } else {
              if (i.onTriggerLeave(d), d.defaultPrevented) return;
              i.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: Ne(t.onKeyDown, (d) => {
          const f = i.searchRef.current !== "";
          t.disabled || f && d.key === " " || rP[r.dir].includes(d.key) && (n.onOpenChange(!0), n.content?.focus(), d.preventDefault());
        })
      }
    ) });
  }
);
ek.displayName = Oi;
var tk = "MenuSubContent", nk = N.forwardRef(
  (t, e) => {
    const n = zw(sn, t.__scopeMenu), { forceMount: r = n.forceMount, ...o } = t, i = Lr(sn, t.__scopeMenu), s = Es(sn, t.__scopeMenu), a = Jw(tk, t.__scopeMenu), l = N.useRef(null), c = At(e, l);
    return /* @__PURE__ */ R(fs.Provider, { scope: t.__scopeMenu, children: /* @__PURE__ */ R(co, { present: r || i.open, children: /* @__PURE__ */ R(fs.Slot, { scope: t.__scopeMenu, children: /* @__PURE__ */ R(
      fh,
      {
        id: a.contentId,
        "aria-labelledby": a.triggerId,
        ...o,
        ref: c,
        align: "start",
        side: s.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        trapFocus: !1,
        onOpenAutoFocus: (u) => {
          s.isUsingKeyboardRef.current && l.current?.focus(), u.preventDefault();
        },
        onCloseAutoFocus: (u) => u.preventDefault(),
        onFocusOutside: Ne(t.onFocusOutside, (u) => {
          u.target !== a.trigger && i.onOpenChange(!1);
        }),
        onEscapeKeyDown: Ne(t.onEscapeKeyDown, (u) => {
          s.onClose(), u.preventDefault();
        }),
        onKeyDown: Ne(t.onKeyDown, (u) => {
          const d = u.currentTarget.contains(u.target), f = oP[s.dir].includes(u.key);
          d && f && (i.onOpenChange(!1), a.trigger?.focus(), u.preventDefault());
        })
      }
    ) }) }) });
  }
);
nk.displayName = tk;
function rk(t) {
  return t ? "open" : "closed";
}
function Fl(t) {
  return t === "indeterminate";
}
function gh(t) {
  return Fl(t) ? "indeterminate" : t ? "checked" : "unchecked";
}
function NP(t) {
  const e = document.activeElement;
  for (const n of t)
    if (n === e || (n.focus(), document.activeElement !== e)) return;
}
function EP(t, e) {
  return t.map((n, r) => t[(e + r) % t.length]);
}
function SP(t, e, n) {
  const o = e.length > 1 && Array.from(e).every((c) => c === e[0]) ? e[0] : e, i = n ? t.indexOf(n) : -1;
  let s = EP(t, Math.max(i, 0));
  o.length === 1 && (s = s.filter((c) => c !== n));
  const l = s.find(
    (c) => c.toLowerCase().startsWith(o.toLowerCase())
  );
  return l !== n ? l : void 0;
}
function TP(t, e) {
  const { x: n, y: r } = t;
  let o = !1;
  for (let i = 0, s = e.length - 1; i < e.length; s = i++) {
    const a = e[i], l = e[s], c = a.x, u = a.y, d = l.x, f = l.y;
    u > r != f > r && n < (d - c) * (r - u) / (f - u) + c && (o = !o);
  }
  return o;
}
function CP(t, e) {
  if (!e) return !1;
  const n = { x: t.clientX, y: t.clientY };
  return TP(n, e);
}
function hs(t) {
  return (e) => e.pointerType === "mouse" ? t(e) : void 0;
}
var MP = Bw, AP = ch, _P = $w, RP = Hw, OP = hh, IP = Fw, DP = Ec, LP = Ww, PP = Kw, BP = Gw, zP = Yw, $P = Xw, HP = Zw, FP = Qw, UP = ek, WP = nk, Sc = "DropdownMenu", [VP] = ui(
  Sc,
  [Dw]
), Rt = Dw(), [KP, ok] = VP(Sc), ik = (t) => {
  const {
    __scopeDropdownMenu: e,
    children: n,
    dir: r,
    open: o,
    defaultOpen: i,
    onOpenChange: s,
    modal: a = !0
  } = t, l = Rt(e), c = N.useRef(null), [u, d] = kc({
    prop: o,
    defaultProp: i ?? !1,
    onChange: s,
    caller: Sc
  });
  return /* @__PURE__ */ R(
    KP,
    {
      scope: e,
      triggerId: ri(),
      triggerRef: c,
      contentId: ri(),
      open: u,
      onOpenChange: d,
      onOpenToggle: N.useCallback(() => d((f) => !f), [d]),
      modal: a,
      children: /* @__PURE__ */ R(MP, { ...l, open: u, onOpenChange: d, dir: r, modal: a, children: n })
    }
  );
};
ik.displayName = Sc;
var sk = "DropdownMenuTrigger", ak = N.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, disabled: r = !1, ...o } = t, i = ok(sk, n), s = Rt(n);
    return /* @__PURE__ */ R(AP, { asChild: !0, ...s, children: /* @__PURE__ */ R(
      Nt.button,
      {
        type: "button",
        id: i.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": i.open,
        "aria-controls": i.open ? i.contentId : void 0,
        "data-state": i.open ? "open" : "closed",
        "data-disabled": r ? "" : void 0,
        disabled: r,
        ...o,
        ref: wc(e, i.triggerRef),
        onPointerDown: Ne(t.onPointerDown, (a) => {
          !r && a.button === 0 && a.ctrlKey === !1 && (i.onOpenToggle(), i.open || a.preventDefault());
        }),
        onKeyDown: Ne(t.onKeyDown, (a) => {
          r || (["Enter", " "].includes(a.key) && i.onOpenToggle(), a.key === "ArrowDown" && i.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(a.key) && a.preventDefault());
        })
      }
    ) });
  }
);
ak.displayName = sk;
var qP = "DropdownMenuPortal", lk = (t) => {
  const { __scopeDropdownMenu: e, ...n } = t, r = Rt(e);
  return /* @__PURE__ */ R(_P, { ...r, ...n });
};
lk.displayName = qP;
var ck = "DropdownMenuContent", uk = N.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t, o = ok(ck, n), i = Rt(n), s = N.useRef(!1);
    return /* @__PURE__ */ R(
      RP,
      {
        id: o.contentId,
        "aria-labelledby": o.triggerId,
        ...i,
        ...r,
        ref: e,
        onCloseAutoFocus: Ne(t.onCloseAutoFocus, (a) => {
          s.current || o.triggerRef.current?.focus(), s.current = !1, a.preventDefault();
        }),
        onInteractOutside: Ne(t.onInteractOutside, (a) => {
          const l = a.detail.originalEvent, c = l.button === 0 && l.ctrlKey === !0, u = l.button === 2 || c;
          (!o.modal || u) && (s.current = !0);
        }),
        style: {
          ...t.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
uk.displayName = ck;
var GP = "DropdownMenuGroup", jP = N.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t, o = Rt(n);
    return /* @__PURE__ */ R(OP, { ...o, ...r, ref: e });
  }
);
jP.displayName = GP;
var YP = "DropdownMenuLabel", XP = N.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t, o = Rt(n);
    return /* @__PURE__ */ R(IP, { ...o, ...r, ref: e });
  }
);
XP.displayName = YP;
var ZP = "DropdownMenuItem", dk = N.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t, o = Rt(n);
    return /* @__PURE__ */ R(DP, { ...o, ...r, ref: e });
  }
);
dk.displayName = ZP;
var JP = "DropdownMenuCheckboxItem", QP = N.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, o = Rt(n);
  return /* @__PURE__ */ R(LP, { ...o, ...r, ref: e });
});
QP.displayName = JP;
var eB = "DropdownMenuRadioGroup", tB = N.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, o = Rt(n);
  return /* @__PURE__ */ R(PP, { ...o, ...r, ref: e });
});
tB.displayName = eB;
var nB = "DropdownMenuRadioItem", rB = N.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, o = Rt(n);
  return /* @__PURE__ */ R(BP, { ...o, ...r, ref: e });
});
rB.displayName = nB;
var oB = "DropdownMenuItemIndicator", iB = N.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, o = Rt(n);
  return /* @__PURE__ */ R(zP, { ...o, ...r, ref: e });
});
iB.displayName = oB;
var sB = "DropdownMenuSeparator", fk = N.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, o = Rt(n);
  return /* @__PURE__ */ R($P, { ...o, ...r, ref: e });
});
fk.displayName = sB;
var aB = "DropdownMenuArrow", lB = N.forwardRef(
  (t, e) => {
    const { __scopeDropdownMenu: n, ...r } = t, o = Rt(n);
    return /* @__PURE__ */ R(HP, { ...o, ...r, ref: e });
  }
);
lB.displayName = aB;
var cB = (t) => {
  const { __scopeDropdownMenu: e, children: n, open: r, onOpenChange: o, defaultOpen: i } = t, s = Rt(e), [a, l] = kc({
    prop: r,
    defaultProp: i ?? !1,
    onChange: o,
    caller: "DropdownMenuSub"
  });
  return /* @__PURE__ */ R(FP, { ...s, open: a, onOpenChange: l, children: n });
}, uB = "DropdownMenuSubTrigger", hk = N.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, o = Rt(n);
  return /* @__PURE__ */ R(UP, { ...o, ...r, ref: e });
});
hk.displayName = uB;
var dB = "DropdownMenuSubContent", mk = N.forwardRef((t, e) => {
  const { __scopeDropdownMenu: n, ...r } = t, o = Rt(n);
  return /* @__PURE__ */ R(
    WP,
    {
      ...o,
      ...r,
      ref: e,
      style: {
        ...t.style,
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
mk.displayName = dB;
var fB = ik, hB = ak, mB = lk, pB = uk, gB = dk, bB = fk, yB = cB, vB = hk, wB = mk;
function pk(t) {
  var e, n, r = "";
  if (typeof t == "string" || typeof t == "number") r += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var o = t.length;
    for (e = 0; e < o; e++) t[e] && (n = pk(t[e])) && (r && (r += " "), r += n);
  } else for (n in t) t[n] && (r && (r += " "), r += n);
  return r;
}
function gk() {
  for (var t, e, n = 0, r = "", o = arguments.length; n < o; n++) (t = arguments[n]) && (e = pk(t)) && (r && (r += " "), r += e);
  return r;
}
const bh = "-", kB = (t) => {
  const e = NB(t), {
    conflictingClassGroups: n,
    conflictingClassGroupModifiers: r
  } = t;
  return {
    getClassGroupId: (s) => {
      const a = s.split(bh);
      return a[0] === "" && a.length !== 1 && a.shift(), bk(a, e) || xB(s);
    },
    getConflictingClassGroupIds: (s, a) => {
      const l = n[s] || [];
      return a && r[s] ? [...l, ...r[s]] : l;
    }
  };
}, bk = (t, e) => {
  if (t.length === 0)
    return e.classGroupId;
  const n = t[0], r = e.nextPart.get(n), o = r ? bk(t.slice(1), r) : void 0;
  if (o)
    return o;
  if (e.validators.length === 0)
    return;
  const i = t.join(bh);
  return e.validators.find(({
    validator: s
  }) => s(i))?.classGroupId;
}, Cg = /^\[(.+)\]$/, xB = (t) => {
  if (Cg.test(t)) {
    const e = Cg.exec(t)[1], n = e?.substring(0, e.indexOf(":"));
    if (n)
      return "arbitrary.." + n;
  }
}, NB = (t) => {
  const {
    theme: e,
    classGroups: n
  } = t, r = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  for (const o in n)
    _d(n[o], r, o, e);
  return r;
}, _d = (t, e, n, r) => {
  t.forEach((o) => {
    if (typeof o == "string") {
      const i = o === "" ? e : Mg(e, o);
      i.classGroupId = n;
      return;
    }
    if (typeof o == "function") {
      if (EB(o)) {
        _d(o(r), e, n, r);
        return;
      }
      e.validators.push({
        validator: o,
        classGroupId: n
      });
      return;
    }
    Object.entries(o).forEach(([i, s]) => {
      _d(s, Mg(e, i), n, r);
    });
  });
}, Mg = (t, e) => {
  let n = t;
  return e.split(bh).forEach((r) => {
    n.nextPart.has(r) || n.nextPart.set(r, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), n = n.nextPart.get(r);
  }), n;
}, EB = (t) => t.isThemeGetter, SB = (t) => {
  if (t < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let e = 0, n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
  const o = (i, s) => {
    n.set(i, s), e++, e > t && (e = 0, r = n, n = /* @__PURE__ */ new Map());
  };
  return {
    get(i) {
      let s = n.get(i);
      if (s !== void 0)
        return s;
      if ((s = r.get(i)) !== void 0)
        return o(i, s), s;
    },
    set(i, s) {
      n.has(i) ? n.set(i, s) : o(i, s);
    }
  };
}, Rd = "!", Od = ":", TB = Od.length, CB = (t) => {
  const {
    prefix: e,
    experimentalParseClassName: n
  } = t;
  let r = (o) => {
    const i = [];
    let s = 0, a = 0, l = 0, c;
    for (let m = 0; m < o.length; m++) {
      let p = o[m];
      if (s === 0 && a === 0) {
        if (p === Od) {
          i.push(o.slice(l, m)), l = m + TB;
          continue;
        }
        if (p === "/") {
          c = m;
          continue;
        }
      }
      p === "[" ? s++ : p === "]" ? s-- : p === "(" ? a++ : p === ")" && a--;
    }
    const u = i.length === 0 ? o : o.substring(l), d = MB(u), f = d !== u, h = c && c > l ? c - l : void 0;
    return {
      modifiers: i,
      hasImportantModifier: f,
      baseClassName: d,
      maybePostfixModifierPosition: h
    };
  };
  if (e) {
    const o = e + Od, i = r;
    r = (s) => s.startsWith(o) ? i(s.substring(o.length)) : {
      isExternal: !0,
      modifiers: [],
      hasImportantModifier: !1,
      baseClassName: s,
      maybePostfixModifierPosition: void 0
    };
  }
  if (n) {
    const o = r;
    r = (i) => n({
      className: i,
      parseClassName: o
    });
  }
  return r;
}, MB = (t) => t.endsWith(Rd) ? t.substring(0, t.length - 1) : t.startsWith(Rd) ? t.substring(1) : t, AB = (t) => {
  const e = Object.fromEntries(t.orderSensitiveModifiers.map((r) => [r, !0]));
  return (r) => {
    if (r.length <= 1)
      return r;
    const o = [];
    let i = [];
    return r.forEach((s) => {
      s[0] === "[" || e[s] ? (o.push(...i.sort(), s), i = []) : i.push(s);
    }), o.push(...i.sort()), o;
  };
}, _B = (t) => ({
  cache: SB(t.cacheSize),
  parseClassName: CB(t),
  sortModifiers: AB(t),
  ...kB(t)
}), RB = /\s+/, OB = (t, e) => {
  const {
    parseClassName: n,
    getClassGroupId: r,
    getConflictingClassGroupIds: o,
    sortModifiers: i
  } = e, s = [], a = t.trim().split(RB);
  let l = "";
  for (let c = a.length - 1; c >= 0; c -= 1) {
    const u = a[c], {
      isExternal: d,
      modifiers: f,
      hasImportantModifier: h,
      baseClassName: m,
      maybePostfixModifierPosition: p
    } = n(u);
    if (d) {
      l = u + (l.length > 0 ? " " + l : l);
      continue;
    }
    let g = !!p, b = r(g ? m.substring(0, p) : m);
    if (!b) {
      if (!g) {
        l = u + (l.length > 0 ? " " + l : l);
        continue;
      }
      if (b = r(m), !b) {
        l = u + (l.length > 0 ? " " + l : l);
        continue;
      }
      g = !1;
    }
    const v = i(f).join(":"), k = h ? v + Rd : v, x = k + b;
    if (s.includes(x))
      continue;
    s.push(x);
    const w = o(b, g);
    for (let E = 0; E < w.length; ++E) {
      const S = w[E];
      s.push(k + S);
    }
    l = u + (l.length > 0 ? " " + l : l);
  }
  return l;
};
function IB() {
  let t = 0, e, n, r = "";
  for (; t < arguments.length; )
    (e = arguments[t++]) && (n = yk(e)) && (r && (r += " "), r += n);
  return r;
}
const yk = (t) => {
  if (typeof t == "string")
    return t;
  let e, n = "";
  for (let r = 0; r < t.length; r++)
    t[r] && (e = yk(t[r])) && (n && (n += " "), n += e);
  return n;
};
function DB(t, ...e) {
  let n, r, o, i = s;
  function s(l) {
    const c = e.reduce((u, d) => d(u), t());
    return n = _B(c), r = n.cache.get, o = n.cache.set, i = a, a(l);
  }
  function a(l) {
    const c = r(l);
    if (c)
      return c;
    const u = OB(l, n);
    return o(l, u), u;
  }
  return function() {
    return i(IB.apply(null, arguments));
  };
}
const ct = (t) => {
  const e = (n) => n[t] || [];
  return e.isThemeGetter = !0, e;
}, vk = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, wk = /^\((?:(\w[\w-]*):)?(.+)\)$/i, LB = /^\d+\/\d+$/, PB = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, BB = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, zB = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/, $B = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, HB = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, Ao = (t) => LB.test(t), Se = (t) => !!t && !Number.isNaN(Number(t)), ar = (t) => !!t && Number.isInteger(Number(t)), Au = (t) => t.endsWith("%") && Se(t.slice(0, -1)), Vn = (t) => PB.test(t), FB = () => !0, UB = (t) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  BB.test(t) && !zB.test(t)
), kk = () => !1, WB = (t) => $B.test(t), VB = (t) => HB.test(t), KB = (t) => !te(t) && !ne(t), qB = (t) => di(t, Ek, kk), te = (t) => vk.test(t), Hr = (t) => di(t, Sk, UB), _u = (t) => di(t, ZB, Se), Ag = (t) => di(t, xk, kk), GB = (t) => di(t, Nk, VB), ha = (t) => di(t, Tk, WB), ne = (t) => wk.test(t), xi = (t) => fi(t, Sk), jB = (t) => fi(t, JB), _g = (t) => fi(t, xk), YB = (t) => fi(t, Ek), XB = (t) => fi(t, Nk), ma = (t) => fi(t, Tk, !0), di = (t, e, n) => {
  const r = vk.exec(t);
  return r ? r[1] ? e(r[1]) : n(r[2]) : !1;
}, fi = (t, e, n = !1) => {
  const r = wk.exec(t);
  return r ? r[1] ? e(r[1]) : n : !1;
}, xk = (t) => t === "position" || t === "percentage", Nk = (t) => t === "image" || t === "url", Ek = (t) => t === "length" || t === "size" || t === "bg-size", Sk = (t) => t === "length", ZB = (t) => t === "number", JB = (t) => t === "family-name", Tk = (t) => t === "shadow", QB = () => {
  const t = ct("color"), e = ct("font"), n = ct("text"), r = ct("font-weight"), o = ct("tracking"), i = ct("leading"), s = ct("breakpoint"), a = ct("container"), l = ct("spacing"), c = ct("radius"), u = ct("shadow"), d = ct("inset-shadow"), f = ct("text-shadow"), h = ct("drop-shadow"), m = ct("blur"), p = ct("perspective"), g = ct("aspect"), b = ct("ease"), v = ct("animate"), k = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], x = () => [
    "center",
    "top",
    "bottom",
    "left",
    "right",
    "top-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-top",
    "top-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-top",
    "bottom-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-bottom",
    "bottom-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-bottom"
  ], w = () => [...x(), ne, te], E = () => ["auto", "hidden", "clip", "visible", "scroll"], S = () => ["auto", "contain", "none"], C = () => [ne, te, l], M = () => [Ao, "full", "auto", ...C()], O = () => [ar, "none", "subgrid", ne, te], q = () => ["auto", {
    span: ["full", ar, ne, te]
  }, ar, ne, te], K = () => [ar, "auto", ne, te], j = () => ["auto", "min", "max", "fr", ne, te], H = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"], G = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"], V = () => ["auto", ...C()], re = () => [Ao, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...C()], A = () => [t, ne, te], $ = () => [...x(), _g, Ag, {
    position: [ne, te]
  }], _ = () => ["no-repeat", {
    repeat: ["", "x", "y", "space", "round"]
  }], z = () => ["auto", "cover", "contain", YB, qB, {
    size: [ne, te]
  }], Q = () => [Au, xi, Hr], ue = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    "full",
    c,
    ne,
    te
  ], Me = () => ["", Se, xi, Hr], Oe = () => ["solid", "dashed", "dotted", "double"], je = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], me = () => [Se, Au, _g, Ag], at = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    m,
    ne,
    te
  ], Ht = () => ["none", Se, ne, te], gt = () => ["none", Se, ne, te], jt = () => [Se, ne, te], Ft = () => [Ao, "full", ...C()];
  return {
    cacheSize: 500,
    theme: {
      animate: ["spin", "ping", "pulse", "bounce"],
      aspect: ["video"],
      blur: [Vn],
      breakpoint: [Vn],
      color: [FB],
      container: [Vn],
      "drop-shadow": [Vn],
      ease: ["in", "out", "in-out"],
      font: [KB],
      "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
      "inset-shadow": [Vn],
      leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
      perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
      radius: [Vn],
      shadow: [Vn],
      spacing: ["px", Se],
      text: [Vn],
      "text-shadow": [Vn],
      tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
    },
    classGroups: {
      // --------------
      // --- Layout ---
      // --------------
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", Ao, te, ne, g]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [Se, te, ne, a]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": k()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": k()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: w()
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: E()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": E()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": E()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: S()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": S()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": S()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: M()
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": M()
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": M()
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: M()
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: M()
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: M()
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: M()
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: M()
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: M()
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: [ar, "auto", ne, te]
      }],
      // ------------------------
      // --- Flexbox and Grid ---
      // ------------------------
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: [Ao, "full", "auto", a, ...C()]
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["nowrap", "wrap", "wrap-reverse"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: [Se, Ao, "auto", "initial", "none", te]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ["", Se, ne, te]
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ["", Se, ne, te]
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: [ar, "first", "last", "none", ne, te]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": O()
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: q()
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": K()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": K()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": O()
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: q()
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": K()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": K()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": j()
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": j()
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: C()
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": C()
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": C()
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: [...H(), "normal"]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": [...G(), "normal"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", ...G()]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...H()]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: [...G(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", ...G(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": H()
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": [...G(), "baseline"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", ...G()]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: C()
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: C()
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: C()
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: C()
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: C()
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: C()
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: C()
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: C()
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: C()
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: V()
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: V()
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: V()
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: V()
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: V()
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: V()
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: V()
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: V()
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: V()
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x": [{
        "space-x": C()
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y": [{
        "space-y": C()
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y-reverse": ["space-y-reverse"],
      // --------------
      // --- Sizing ---
      // --------------
      /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */
      size: [{
        size: re()
      }],
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: [a, "screen", ...re()]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [
          a,
          "screen",
          /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "none",
          ...re()
        ]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [
          a,
          "screen",
          "none",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "prose",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          {
            screen: [s]
          },
          ...re()
        ]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: ["screen", "lh", ...re()]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["screen", "lh", "none", ...re()]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": ["screen", "lh", ...re()]
      }],
      // ------------------
      // --- Typography ---
      // ------------------
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", n, xi, Hr]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: [r, ne, _u]
      }],
      /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */
      "font-stretch": [{
        "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", Au, te]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [jB, te, e]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: [o, ne, te]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": [Se, "none", ne, _u]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: [
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          i,
          ...C()
        ]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", ne, te]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["disc", "decimal", "none", ne, te]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: A()
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: A()
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...Oe(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: [Se, "from-font", "auto", ne, Hr]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: A()
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": [Se, "auto", ne, te]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: C()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", ne, te]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Overflow Wrap
       * @see https://tailwindcss.com/docs/overflow-wrap
       */
      wrap: [{
        wrap: ["break-word", "anywhere", "normal"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", ne, te]
      }],
      // -------------------
      // --- Backgrounds ---
      // -------------------
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: $()
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: _()
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: z()
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          linear: [{
            to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, ar, ne, te],
          radial: ["", ne, te],
          conic: [ar, ne, te]
        }, XB, GB]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: A()
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: Q()
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: Q()
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: Q()
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: A()
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: A()
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: A()
      }],
      // ---------------
      // --- Borders ---
      // ---------------
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: ue()
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": ue()
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": ue()
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": ue()
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": ue()
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": ue()
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": ue()
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": ue()
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": ue()
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": ue()
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": ue()
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": ue()
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": ue()
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": ue()
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": ue()
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: Me()
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": Me()
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": Me()
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": Me()
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": Me()
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": Me()
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": Me()
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": Me()
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": Me()
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x": [{
        "divide-x": Me()
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y": [{
        "divide-y": Me()
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...Oe(), "hidden", "none"]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */
      "divide-style": [{
        divide: [...Oe(), "hidden", "none"]
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: A()
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": A()
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": A()
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": A()
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": A()
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": A()
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": A()
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": A()
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": A()
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: A()
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [...Oe(), "none", "hidden"]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [Se, ne, te]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: ["", Se, xi, Hr]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: A()
      }],
      // ---------------
      // --- Effects ---
      // ---------------
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          u,
          ma,
          ha
        ]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */
      "shadow-color": [{
        shadow: A()
      }],
      /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */
      "inset-shadow": [{
        "inset-shadow": ["none", d, ma, ha]
      }],
      /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */
      "inset-shadow-color": [{
        "inset-shadow": A()
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */
      "ring-w": [{
        ring: Me()
      }],
      /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */
      "ring-color": [{
        ring: A()
      }],
      /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-w": [{
        "ring-offset": [Se, Hr]
      }],
      /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-color": [{
        "ring-offset": A()
      }],
      /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */
      "inset-ring-w": [{
        "inset-ring": Me()
      }],
      /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */
      "inset-ring-color": [{
        "inset-ring": A()
      }],
      /**
       * Text Shadow
       * @see https://tailwindcss.com/docs/text-shadow
       */
      "text-shadow": [{
        "text-shadow": ["none", f, ma, ha]
      }],
      /**
       * Text Shadow Color
       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color
       */
      "text-shadow-color": [{
        "text-shadow": A()
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [Se, ne, te]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...je(), "plus-darker", "plus-lighter"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": je()
      }],
      /**
       * Mask Clip
       * @see https://tailwindcss.com/docs/mask-clip
       */
      "mask-clip": [{
        "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
      }, "mask-no-clip"],
      /**
       * Mask Composite
       * @see https://tailwindcss.com/docs/mask-composite
       */
      "mask-composite": [{
        mask: ["add", "subtract", "intersect", "exclude"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image-linear-pos": [{
        "mask-linear": [Se]
      }],
      "mask-image-linear-from-pos": [{
        "mask-linear-from": me()
      }],
      "mask-image-linear-to-pos": [{
        "mask-linear-to": me()
      }],
      "mask-image-linear-from-color": [{
        "mask-linear-from": A()
      }],
      "mask-image-linear-to-color": [{
        "mask-linear-to": A()
      }],
      "mask-image-t-from-pos": [{
        "mask-t-from": me()
      }],
      "mask-image-t-to-pos": [{
        "mask-t-to": me()
      }],
      "mask-image-t-from-color": [{
        "mask-t-from": A()
      }],
      "mask-image-t-to-color": [{
        "mask-t-to": A()
      }],
      "mask-image-r-from-pos": [{
        "mask-r-from": me()
      }],
      "mask-image-r-to-pos": [{
        "mask-r-to": me()
      }],
      "mask-image-r-from-color": [{
        "mask-r-from": A()
      }],
      "mask-image-r-to-color": [{
        "mask-r-to": A()
      }],
      "mask-image-b-from-pos": [{
        "mask-b-from": me()
      }],
      "mask-image-b-to-pos": [{
        "mask-b-to": me()
      }],
      "mask-image-b-from-color": [{
        "mask-b-from": A()
      }],
      "mask-image-b-to-color": [{
        "mask-b-to": A()
      }],
      "mask-image-l-from-pos": [{
        "mask-l-from": me()
      }],
      "mask-image-l-to-pos": [{
        "mask-l-to": me()
      }],
      "mask-image-l-from-color": [{
        "mask-l-from": A()
      }],
      "mask-image-l-to-color": [{
        "mask-l-to": A()
      }],
      "mask-image-x-from-pos": [{
        "mask-x-from": me()
      }],
      "mask-image-x-to-pos": [{
        "mask-x-to": me()
      }],
      "mask-image-x-from-color": [{
        "mask-x-from": A()
      }],
      "mask-image-x-to-color": [{
        "mask-x-to": A()
      }],
      "mask-image-y-from-pos": [{
        "mask-y-from": me()
      }],
      "mask-image-y-to-pos": [{
        "mask-y-to": me()
      }],
      "mask-image-y-from-color": [{
        "mask-y-from": A()
      }],
      "mask-image-y-to-color": [{
        "mask-y-to": A()
      }],
      "mask-image-radial": [{
        "mask-radial": [ne, te]
      }],
      "mask-image-radial-from-pos": [{
        "mask-radial-from": me()
      }],
      "mask-image-radial-to-pos": [{
        "mask-radial-to": me()
      }],
      "mask-image-radial-from-color": [{
        "mask-radial-from": A()
      }],
      "mask-image-radial-to-color": [{
        "mask-radial-to": A()
      }],
      "mask-image-radial-shape": [{
        "mask-radial": ["circle", "ellipse"]
      }],
      "mask-image-radial-size": [{
        "mask-radial": [{
          closest: ["side", "corner"],
          farthest: ["side", "corner"]
        }]
      }],
      "mask-image-radial-pos": [{
        "mask-radial-at": x()
      }],
      "mask-image-conic-pos": [{
        "mask-conic": [Se]
      }],
      "mask-image-conic-from-pos": [{
        "mask-conic-from": me()
      }],
      "mask-image-conic-to-pos": [{
        "mask-conic-to": me()
      }],
      "mask-image-conic-from-color": [{
        "mask-conic-from": A()
      }],
      "mask-image-conic-to-color": [{
        "mask-conic-to": A()
      }],
      /**
       * Mask Mode
       * @see https://tailwindcss.com/docs/mask-mode
       */
      "mask-mode": [{
        mask: ["alpha", "luminance", "match"]
      }],
      /**
       * Mask Origin
       * @see https://tailwindcss.com/docs/mask-origin
       */
      "mask-origin": [{
        "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
      }],
      /**
       * Mask Position
       * @see https://tailwindcss.com/docs/mask-position
       */
      "mask-position": [{
        mask: $()
      }],
      /**
       * Mask Repeat
       * @see https://tailwindcss.com/docs/mask-repeat
       */
      "mask-repeat": [{
        mask: _()
      }],
      /**
       * Mask Size
       * @see https://tailwindcss.com/docs/mask-size
       */
      "mask-size": [{
        mask: z()
      }],
      /**
       * Mask Type
       * @see https://tailwindcss.com/docs/mask-type
       */
      "mask-type": [{
        "mask-type": ["alpha", "luminance"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image": [{
        mask: ["none", ne, te]
      }],
      // ---------------
      // --- Filters ---
      // ---------------
      /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          ne,
          te
        ]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: at()
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [Se, ne, te]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [Se, ne, te]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          h,
          ma,
          ha
        ]
      }],
      /**
       * Drop Shadow Color
       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color
       */
      "drop-shadow-color": [{
        "drop-shadow": A()
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: ["", Se, ne, te]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [Se, ne, te]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: ["", Se, ne, te]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [Se, ne, te]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: ["", Se, ne, te]
      }],
      /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          ne,
          te
        ]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": at()
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [Se, ne, te]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [Se, ne, te]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": ["", Se, ne, te]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [Se, ne, te]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": ["", Se, ne, te]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [Se, ne, te]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [Se, ne, te]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": ["", Se, ne, te]
      }],
      // --------------
      // --- Tables ---
      // --------------
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": C()
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": C()
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": C()
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // ---------------------------------
      // --- Transitions and Animation ---
      // ---------------------------------
      /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", ne, te]
      }],
      /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */
      "transition-behavior": [{
        transition: ["normal", "discrete"]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: [Se, "initial", ne, te]
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "initial", b, ne, te]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: [Se, ne, te]
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", v, ne, te]
      }],
      // ------------------
      // --- Transforms ---
      // ------------------
      /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */
      backface: [{
        backface: ["hidden", "visible"]
      }],
      /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */
      perspective: [{
        perspective: [p, ne, te]
      }],
      /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */
      "perspective-origin": [{
        "perspective-origin": w()
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: Ht()
      }],
      /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-x": [{
        "rotate-x": Ht()
      }],
      /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-y": [{
        "rotate-y": Ht()
      }],
      /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-z": [{
        "rotate-z": Ht()
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: gt()
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": gt()
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": gt()
      }],
      /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-z": [{
        "scale-z": gt()
      }],
      /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-3d": ["scale-3d"],
      /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */
      skew: [{
        skew: jt()
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": jt()
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": jt()
      }],
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: [ne, te, "", "none", "gpu", "cpu"]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: w()
      }],
      /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */
      "transform-style": [{
        transform: ["3d", "flat"]
      }],
      /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */
      translate: [{
        translate: Ft()
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": Ft()
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": Ft()
      }],
      /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-z": [{
        "translate-z": Ft()
      }],
      /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-none": ["translate-none"],
      // ---------------------
      // --- Interactivity ---
      // ---------------------
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: A()
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: A()
      }],
      /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */
      "color-scheme": [{
        scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", ne, te]
      }],
      /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */
      "field-sizing": [{
        "field-sizing": ["fixed", "content"]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["auto", "none"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "", "y", "x"]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": C()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": C()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": C()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": C()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": C()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": C()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": C()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": C()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": C()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": C()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": C()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": C()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": C()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": C()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": C()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": C()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": C()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": C()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", ne, te]
      }],
      // -----------
      // --- SVG ---
      // -----------
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: ["none", ...A()]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [Se, xi, Hr, _u]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: ["none", ...A()]
      }],
      // ---------------------
      // --- Accessibility ---
      // ---------------------
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      translate: ["translate-x", "translate-y", "translate-none"],
      "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    },
    orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
  };
}, ez = /* @__PURE__ */ DB(QB);
function fo(...t) {
  return ez(gk(t));
}
function _o({
  ...t
}) {
  return /* @__PURE__ */ y(fB, { "data-slot": "dropdown-menu", ...t }, void 0, !1, {
    fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/ui/dropdown-menu.tsx",
    lineNumber: 10,
    columnNumber: 10
  }, this);
}
function Ro({
  ...t
}) {
  return /* @__PURE__ */ y(
    hB,
    {
      "data-slot": "dropdown-menu-trigger",
      ...t
    },
    void 0,
    !1,
    {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/ui/dropdown-menu.tsx",
      lineNumber: 25,
      columnNumber: 5
    },
    this
  );
}
function Oo({
  className: t,
  sideOffset: e = 4,
  ...n
}) {
  return /* @__PURE__ */ y(mB, { children: /* @__PURE__ */ y(
    pB,
    {
      "data-slot": "dropdown-menu-content",
      sideOffset: e,
      className: fo(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
        t
      ),
      ...n
    },
    void 0,
    !1,
    {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/ui/dropdown-menu.tsx",
      lineNumber: 39,
      columnNumber: 7
    },
    this
  ) }, void 0, !1, {
    fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/ui/dropdown-menu.tsx",
    lineNumber: 38,
    columnNumber: 5
  }, this);
}
function ke({
  className: t,
  inset: e,
  variant: n = "default",
  ...r
}) {
  return /* @__PURE__ */ y(
    gB,
    {
      "data-slot": "dropdown-menu-item",
      "data-inset": e,
      "data-variant": n,
      className: fo(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        t
      ),
      ...r
    },
    void 0,
    !1,
    {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/ui/dropdown-menu.tsx",
      lineNumber: 70,
      columnNumber: 5
    },
    this
  );
}
function lr({
  className: t,
  ...e
}) {
  return /* @__PURE__ */ y(
    bB,
    {
      "data-slot": "dropdown-menu-separator",
      className: fo("bg-border -mx-1 my-1 h-px", t),
      ...e
    },
    void 0,
    !1,
    {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/ui/dropdown-menu.tsx",
      lineNumber: 169,
      columnNumber: 5
    },
    this
  );
}
function Rg({
  ...t
}) {
  return /* @__PURE__ */ y(yB, { "data-slot": "dropdown-menu-sub", ...t }, void 0, !1, {
    fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/ui/dropdown-menu.tsx",
    lineNumber: 196,
    columnNumber: 10
  }, this);
}
function Og({
  className: t,
  inset: e,
  children: n,
  ...r
}) {
  return /* @__PURE__ */ y(
    vB,
    {
      "data-slot": "dropdown-menu-sub-trigger",
      "data-inset": e,
      className: fo(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        t
      ),
      ...r,
      children: [
        n,
        /* @__PURE__ */ y(l2, { className: "ml-auto size-4" }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/ui/dropdown-menu.tsx",
          lineNumber: 218,
          columnNumber: 7
        }, this)
      ]
    },
    void 0,
    !0,
    {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/ui/dropdown-menu.tsx",
      lineNumber: 208,
      columnNumber: 5
    },
    this
  );
}
function Ig({
  className: t,
  ...e
}) {
  return /* @__PURE__ */ y(
    wB,
    {
      "data-slot": "dropdown-menu-sub-content",
      className: fo(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        t
      ),
      ...e
    },
    void 0,
    !1,
    {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/ui/dropdown-menu.tsx",
      lineNumber: 228,
      columnNumber: 5
    },
    this
  );
}
const Dg = (t) => typeof t == "boolean" ? `${t}` : t === 0 ? "0" : t, Lg = gk, tz = (t, e) => (n) => {
  var r;
  if (e?.variants == null) return Lg(t, n?.class, n?.className);
  const { variants: o, defaultVariants: i } = e, s = Object.keys(o).map((c) => {
    const u = n?.[c], d = i?.[c];
    if (u === null) return null;
    const f = Dg(u) || Dg(d);
    return o[c][f];
  }), a = n && Object.entries(n).reduce((c, u) => {
    let [d, f] = u;
    return f === void 0 || (c[d] = f), c;
  }, {}), l = e == null || (r = e.compoundVariants) === null || r === void 0 ? void 0 : r.reduce((c, u) => {
    let { class: d, className: f, ...h } = u;
    return Object.entries(h).every((m) => {
      let [p, g] = m;
      return Array.isArray(g) ? g.includes({
        ...i,
        ...a
      }[p]) : {
        ...i,
        ...a
      }[p] === g;
    }) ? [
      ...c,
      d,
      f
    ] : c;
  }, []);
  return Lg(t, s, l, n?.class, n?.className);
}, nz = tz(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline: "border bg-transparent shadow-xs hover:bg-accent dark:bg-transparent dark:border-input dark:hover:bg-input/50",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
        "icon-sm": "size-8",
        "icon-lg": "size-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
function Io({
  className: t,
  variant: e,
  size: n,
  asChild: r = !1,
  ...o
}) {
  return /* @__PURE__ */ y(
    r ? aD : "button",
    {
      "data-slot": "button",
      className: fo(nz({ variant: e, size: n, className: t })),
      ...o
    },
    void 0,
    !1,
    {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/ui/button.tsx",
      lineNumber: 52,
      columnNumber: 5
    },
    this
  );
}
var rz = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
}), oz = "VisuallyHidden", Ck = N.forwardRef(
  (t, e) => /* @__PURE__ */ R(
    Nt.span,
    {
      ...t,
      ref: e,
      style: { ...rz, ...t.style }
    }
  )
);
Ck.displayName = oz;
var iz = Ck, [Tc] = ui("Tooltip", [
  xc
]), Cc = xc(), Mk = "TooltipProvider", sz = 700, Id = "tooltip.open", [az, yh] = Tc(Mk), Ak = (t) => {
  const {
    __scopeTooltip: e,
    delayDuration: n = sz,
    skipDelayDuration: r = 300,
    disableHoverableContent: o = !1,
    children: i
  } = t, s = N.useRef(!0), a = N.useRef(!1), l = N.useRef(0);
  return N.useEffect(() => {
    const c = l.current;
    return () => window.clearTimeout(c);
  }, []), /* @__PURE__ */ R(
    az,
    {
      scope: e,
      isOpenDelayedRef: s,
      delayDuration: n,
      onOpen: N.useCallback(() => {
        window.clearTimeout(l.current), s.current = !1;
      }, []),
      onClose: N.useCallback(() => {
        window.clearTimeout(l.current), l.current = window.setTimeout(
          () => s.current = !0,
          r
        );
      }, [r]),
      isPointerInTransitRef: a,
      onPointerInTransitChange: N.useCallback((c) => {
        a.current = c;
      }, []),
      disableHoverableContent: o,
      children: i
    }
  );
};
Ak.displayName = Mk;
var ms = "Tooltip", [lz, Ss] = Tc(ms), _k = (t) => {
  const {
    __scopeTooltip: e,
    children: n,
    open: r,
    defaultOpen: o,
    onOpenChange: i,
    disableHoverableContent: s,
    delayDuration: a
  } = t, l = yh(ms, t.__scopeTooltip), c = Cc(e), [u, d] = N.useState(null), f = ri(), h = N.useRef(0), m = s ?? l.disableHoverableContent, p = a ?? l.delayDuration, g = N.useRef(!1), [b, v] = kc({
    prop: r,
    defaultProp: o ?? !1,
    onChange: (S) => {
      S ? (l.onOpen(), document.dispatchEvent(new CustomEvent(Id))) : l.onClose(), i?.(S);
    },
    caller: ms
  }), k = N.useMemo(() => b ? g.current ? "delayed-open" : "instant-open" : "closed", [b]), x = N.useCallback(() => {
    window.clearTimeout(h.current), h.current = 0, g.current = !1, v(!0);
  }, [v]), w = N.useCallback(() => {
    window.clearTimeout(h.current), h.current = 0, v(!1);
  }, [v]), E = N.useCallback(() => {
    window.clearTimeout(h.current), h.current = window.setTimeout(() => {
      g.current = !0, v(!0), h.current = 0;
    }, p);
  }, [p, v]);
  return N.useEffect(() => () => {
    h.current && (window.clearTimeout(h.current), h.current = 0);
  }, []), /* @__PURE__ */ R(ah, { ...c, children: /* @__PURE__ */ R(
    lz,
    {
      scope: e,
      contentId: f,
      open: b,
      stateAttribute: k,
      trigger: u,
      onTriggerChange: d,
      onTriggerEnter: N.useCallback(() => {
        l.isOpenDelayedRef.current ? E() : x();
      }, [l.isOpenDelayedRef, E, x]),
      onTriggerLeave: N.useCallback(() => {
        m ? w() : (window.clearTimeout(h.current), h.current = 0);
      }, [w, m]),
      onOpen: x,
      onClose: w,
      disableHoverableContent: m,
      children: n
    }
  ) });
};
_k.displayName = ms;
var Dd = "TooltipTrigger", Rk = N.forwardRef(
  (t, e) => {
    const { __scopeTooltip: n, ...r } = t, o = Ss(Dd, n), i = yh(Dd, n), s = Cc(n), a = N.useRef(null), l = At(e, a, o.onTriggerChange), c = N.useRef(!1), u = N.useRef(!1), d = N.useCallback(() => c.current = !1, []);
    return N.useEffect(() => () => document.removeEventListener("pointerup", d), [d]), /* @__PURE__ */ R(pw, { asChild: !0, ...s, children: /* @__PURE__ */ R(
      Nt.button,
      {
        "aria-describedby": o.open ? o.contentId : void 0,
        "data-state": o.stateAttribute,
        ...r,
        ref: l,
        onPointerMove: Ne(t.onPointerMove, (f) => {
          f.pointerType !== "touch" && !u.current && !i.isPointerInTransitRef.current && (o.onTriggerEnter(), u.current = !0);
        }),
        onPointerLeave: Ne(t.onPointerLeave, () => {
          o.onTriggerLeave(), u.current = !1;
        }),
        onPointerDown: Ne(t.onPointerDown, () => {
          o.open && o.onClose(), c.current = !0, document.addEventListener("pointerup", d, { once: !0 });
        }),
        onFocus: Ne(t.onFocus, () => {
          c.current || o.onOpen();
        }),
        onBlur: Ne(t.onBlur, o.onClose),
        onClick: Ne(t.onClick, o.onClose)
      }
    ) });
  }
);
Rk.displayName = Dd;
var vh = "TooltipPortal", [cz, uz] = Tc(vh, {
  forceMount: void 0
}), Ok = (t) => {
  const { __scopeTooltip: e, forceMount: n, children: r, container: o } = t, i = Ss(vh, e);
  return /* @__PURE__ */ R(cz, { scope: e, forceMount: n, children: /* @__PURE__ */ R(co, { present: n || i.open, children: /* @__PURE__ */ R(lh, { asChild: !0, container: o, children: r }) }) });
};
Ok.displayName = vh;
var oi = "TooltipContent", Ik = N.forwardRef(
  (t, e) => {
    const n = uz(oi, t.__scopeTooltip), { forceMount: r = n.forceMount, side: o = "top", ...i } = t, s = Ss(oi, t.__scopeTooltip);
    return /* @__PURE__ */ R(co, { present: r || s.open, children: s.disableHoverableContent ? /* @__PURE__ */ R(Dk, { side: o, ...i, ref: e }) : /* @__PURE__ */ R(dz, { side: o, ...i, ref: e }) });
  }
), dz = N.forwardRef((t, e) => {
  const n = Ss(oi, t.__scopeTooltip), r = yh(oi, t.__scopeTooltip), o = N.useRef(null), i = At(e, o), [s, a] = N.useState(null), { trigger: l, onClose: c } = n, u = o.current, { onPointerInTransitChange: d } = r, f = N.useCallback(() => {
    a(null), d(!1);
  }, [d]), h = N.useCallback(
    (m, p) => {
      const g = m.currentTarget, b = { x: m.clientX, y: m.clientY }, v = pz(b, g.getBoundingClientRect()), k = gz(b, v), x = bz(p.getBoundingClientRect()), w = vz([...k, ...x]);
      a(w), d(!0);
    },
    [d]
  );
  return N.useEffect(() => () => f(), [f]), N.useEffect(() => {
    if (l && u) {
      const m = (g) => h(g, u), p = (g) => h(g, l);
      return l.addEventListener("pointerleave", m), u.addEventListener("pointerleave", p), () => {
        l.removeEventListener("pointerleave", m), u.removeEventListener("pointerleave", p);
      };
    }
  }, [l, u, h, f]), N.useEffect(() => {
    if (s) {
      const m = (p) => {
        const g = p.target, b = { x: p.clientX, y: p.clientY }, v = l?.contains(g) || u?.contains(g), k = !yz(b, s);
        v ? f() : k && (f(), c());
      };
      return document.addEventListener("pointermove", m), () => document.removeEventListener("pointermove", m);
    }
  }, [l, u, s, c, f]), /* @__PURE__ */ R(Dk, { ...t, ref: i });
}), [fz, hz] = Tc(ms, { isInside: !1 }), mz = /* @__PURE__ */ cD("TooltipContent"), Dk = N.forwardRef(
  (t, e) => {
    const {
      __scopeTooltip: n,
      children: r,
      "aria-label": o,
      onEscapeKeyDown: i,
      onPointerDownOutside: s,
      ...a
    } = t, l = Ss(oi, n), c = Cc(n), { onClose: u } = l;
    return N.useEffect(() => (document.addEventListener(Id, u), () => document.removeEventListener(Id, u)), [u]), N.useEffect(() => {
      if (l.trigger) {
        const d = (f) => {
          f.target?.contains(l.trigger) && u();
        };
        return window.addEventListener("scroll", d, { capture: !0 }), () => window.removeEventListener("scroll", d, { capture: !0 });
      }
    }, [l.trigger, u]), /* @__PURE__ */ R(
      oh,
      {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: i,
        onPointerDownOutside: s,
        onFocusOutside: (d) => d.preventDefault(),
        onDismiss: u,
        children: /* @__PURE__ */ ob(
          gw,
          {
            "data-state": l.stateAttribute,
            ...c,
            ...a,
            ref: e,
            style: {
              ...a.style,
              "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
              "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
              "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
              "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
              "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [
              /* @__PURE__ */ R(mz, { children: r }),
              /* @__PURE__ */ R(fz, { scope: n, isInside: !0, children: /* @__PURE__ */ R(iz, { id: l.contentId, role: "tooltip", children: o || r }) })
            ]
          }
        )
      }
    );
  }
);
Ik.displayName = oi;
var Lk = "TooltipArrow", Pk = N.forwardRef(
  (t, e) => {
    const { __scopeTooltip: n, ...r } = t, o = Cc(n);
    return hz(
      Lk,
      n
    ).isInside ? null : /* @__PURE__ */ R(bw, { ...o, ...r, ref: e });
  }
);
Pk.displayName = Lk;
function pz(t, e) {
  const n = Math.abs(e.top - t.y), r = Math.abs(e.bottom - t.y), o = Math.abs(e.right - t.x), i = Math.abs(e.left - t.x);
  switch (Math.min(n, r, o, i)) {
    case i:
      return "left";
    case o:
      return "right";
    case n:
      return "top";
    case r:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function gz(t, e, n = 5) {
  const r = [];
  switch (e) {
    case "top":
      r.push(
        { x: t.x - n, y: t.y + n },
        { x: t.x + n, y: t.y + n }
      );
      break;
    case "bottom":
      r.push(
        { x: t.x - n, y: t.y - n },
        { x: t.x + n, y: t.y - n }
      );
      break;
    case "left":
      r.push(
        { x: t.x + n, y: t.y - n },
        { x: t.x + n, y: t.y + n }
      );
      break;
    case "right":
      r.push(
        { x: t.x - n, y: t.y - n },
        { x: t.x - n, y: t.y + n }
      );
      break;
  }
  return r;
}
function bz(t) {
  const { top: e, right: n, bottom: r, left: o } = t;
  return [
    { x: o, y: e },
    { x: n, y: e },
    { x: n, y: r },
    { x: o, y: r }
  ];
}
function yz(t, e) {
  const { x: n, y: r } = t;
  let o = !1;
  for (let i = 0, s = e.length - 1; i < e.length; s = i++) {
    const a = e[i], l = e[s], c = a.x, u = a.y, d = l.x, f = l.y;
    u > r != f > r && n < (d - c) * (r - u) / (f - u) + c && (o = !o);
  }
  return o;
}
function vz(t) {
  const e = t.slice();
  return e.sort((n, r) => n.x < r.x ? -1 : n.x > r.x ? 1 : n.y < r.y ? -1 : n.y > r.y ? 1 : 0), wz(e);
}
function wz(t) {
  if (t.length <= 1) return t.slice();
  const e = [];
  for (let r = 0; r < t.length; r++) {
    const o = t[r];
    for (; e.length >= 2; ) {
      const i = e[e.length - 1], s = e[e.length - 2];
      if ((i.x - s.x) * (o.y - s.y) >= (i.y - s.y) * (o.x - s.x)) e.pop();
      else break;
    }
    e.push(o);
  }
  e.pop();
  const n = [];
  for (let r = t.length - 1; r >= 0; r--) {
    const o = t[r];
    for (; n.length >= 2; ) {
      const i = n[n.length - 1], s = n[n.length - 2];
      if ((i.x - s.x) * (o.y - s.y) >= (i.y - s.y) * (o.x - s.x)) n.pop();
      else break;
    }
    n.push(o);
  }
  return n.pop(), e.length === 1 && n.length === 1 && e[0].x === n[0].x && e[0].y === n[0].y ? e : e.concat(n);
}
var kz = Ak, xz = _k, Nz = Rk, Ez = Ok, Sz = Ik, Tz = Pk;
function Cz({
  delayDuration: t = 0,
  ...e
}) {
  return /* @__PURE__ */ y(
    kz,
    {
      "data-slot": "tooltip-provider",
      delayDuration: t,
      ...e
    },
    void 0,
    !1,
    {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/ui/tooltip.tsx",
      lineNumber: 11,
      columnNumber: 5
    },
    this
  );
}
function Bk({
  ...t
}) {
  return /* @__PURE__ */ y(Cz, { children: /* @__PURE__ */ y(xz, { "data-slot": "tooltip", ...t }, void 0, !1, {
    fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/ui/tooltip.tsx",
    lineNumber: 24,
    columnNumber: 7
  }, this) }, void 0, !1, {
    fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/ui/tooltip.tsx",
    lineNumber: 23,
    columnNumber: 5
  }, this);
}
function zk({
  ...t
}) {
  return /* @__PURE__ */ y(Nz, { "data-slot": "tooltip-trigger", ...t }, void 0, !1, {
    fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/ui/tooltip.tsx",
    lineNumber: 32,
    columnNumber: 10
  }, this);
}
function $k({
  className: t,
  sideOffset: e = 0,
  children: n,
  ...r
}) {
  return /* @__PURE__ */ y(Ez, { children: /* @__PURE__ */ y(
    Sz,
    {
      "data-slot": "tooltip-content",
      sideOffset: e,
      className: fo(
        "bg-foreground text-background animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
        t
      ),
      ...r,
      children: [
        n,
        /* @__PURE__ */ y(Tz, { className: "bg-foreground fill-foreground z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/ui/tooltip.tsx",
          lineNumber: 53,
          columnNumber: 9
        }, this)
      ]
    },
    void 0,
    !0,
    {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/ui/tooltip.tsx",
      lineNumber: 43,
      columnNumber: 7
    },
    this
  ) }, void 0, !1, {
    fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/ui/tooltip.tsx",
    lineNumber: 42,
    columnNumber: 5
  }, this);
}
const ut = ({ onClick: t, isActive: e, disabled: n, children: r, tooltip: o }) => {
  const i = /* @__PURE__ */ y(
    "button",
    {
      onClick: t,
      disabled: n,
      className: `
        flex items-center justify-center w-9 h-9 sm:w-8 sm:h-8 rounded-md
        transition-all duration-100 ease-out touch-manipulation
        ${e ? "bg-primary text-primary-foreground" : "bg-transparent text-foreground hover:bg-secondary active:bg-secondary/80"}
        ${n ? "opacity-50 cursor-not-allowed" : ""}
      `,
      children: r
    },
    void 0,
    !1,
    {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
      lineNumber: 95,
      columnNumber: 5
    },
    void 0
  );
  return o ? /* @__PURE__ */ y(Bk, { children: [
    /* @__PURE__ */ y(zk, { asChild: !0, children: i }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
      lineNumber: 115,
      columnNumber: 9
    }, void 0),
    /* @__PURE__ */ y($k, { side: "bottom", className: "text-xs hidden sm:block", children: o }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
      lineNumber: 116,
      columnNumber: 9
    }, void 0)
  ] }, void 0, !0, {
    fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
    lineNumber: 114,
    columnNumber: 7
  }, void 0) : i;
}, Ni = () => /* @__PURE__ */ y("div", { className: "w-px h-6 bg-border mx-0.5 hidden sm:block" }, void 0, !1, {
  fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
  lineNumber: 127,
  columnNumber: 3
}, void 0), Mz = si(function({ editor: e, onCopyMarkdown: n, onOpenLinkPopover: r, className: o = "" }) {
  const [i, s] = J(""), [a, l] = J(!1), c = Lf({
    editor: e,
    selector: ({ editor: h }) => ({
      canUndo: h.can().undo(),
      canRedo: h.can().redo(),
      isBold: h.isActive("bold"),
      isItalic: h.isActive("italic"),
      isUnderline: h.isActive("underline"),
      isStrike: h.isActive("strike"),
      isCode: h.isActive("code"),
      isHighlight: h.isActive("highlight"),
      isH1: h.isActive("heading", { level: 1 }),
      isH2: h.isActive("heading", { level: 2 }),
      isH3: h.isActive("heading", { level: 3 }),
      isBlockquote: h.isActive("blockquote"),
      isBulletList: h.isActive("bulletList"),
      isOrderedList: h.isActive("orderedList"),
      isTaskList: h.isActive("taskList"),
      isCodeBlock: h.isActive("codeBlock"),
      isLink: h.isActive("link")
    })
  }), u = ie(() => {
    i && (e.chain().focus().setImage({ src: i }).run(), s(""), l(!1));
  }, [e, i]), d = ie(() => {
    e.chain().focus().insertTable({ rows: 3, cols: 3, withHeaderRow: !0 }).run();
  }, [e]), f = ie((h) => {
    e.chain().focus().insertCallout({ type: h }).run();
  }, [e]);
  return /* @__PURE__ */ y("div", { className: `flex items-center gap-0.5 sm:gap-1 px-2 sm:px-3 py-1.5 sm:py-2 border-b border-border bg-card/50 overflow-x-auto scrollbar-hide ${o}`, children: [
    /* @__PURE__ */ y(
      ut,
      {
        onClick: () => e.chain().focus().undo().run(),
        disabled: !c?.canUndo,
        tooltip: "Undo (Ctrl+Z)",
        children: /* @__PURE__ */ y(O2, { size: 18, className: "sm:w-4 sm:h-4" }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 183,
          columnNumber: 9
        }, this)
      },
      void 0,
      !1,
      {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
        lineNumber: 178,
        columnNumber: 7
      },
      this
    ),
    /* @__PURE__ */ y(
      ut,
      {
        onClick: () => e.chain().focus().redo().run(),
        disabled: !c?.canRedo,
        tooltip: "Redo (Ctrl+Shift+Z)",
        children: /* @__PURE__ */ y(C2, { size: 18, className: "sm:w-4 sm:h-4" }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 190,
          columnNumber: 9
        }, this)
      },
      void 0,
      !1,
      {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
        lineNumber: 185,
        columnNumber: 7
      },
      this
    ),
    /* @__PURE__ */ y(Ni, {}, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
      lineNumber: 193,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ y("div", { className: "hidden sm:flex items-center gap-0.5", children: [
      /* @__PURE__ */ y(
        ut,
        {
          onClick: () => e.chain().focus().toggleBold().run(),
          isActive: c?.isBold,
          tooltip: "Bold (Ctrl+B)",
          children: /* @__PURE__ */ y(Sl, { size: 16 }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 202,
            columnNumber: 11
          }, this)
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 197,
          columnNumber: 9
        },
        this
      ),
      /* @__PURE__ */ y(
        ut,
        {
          onClick: () => e.chain().focus().toggleItalic().run(),
          isActive: c?.isItalic,
          tooltip: "Italic (Ctrl+I)",
          children: /* @__PURE__ */ y(_l, { size: 16 }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 209,
            columnNumber: 11
          }, this)
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 204,
          columnNumber: 9
        },
        this
      ),
      /* @__PURE__ */ y(
        ut,
        {
          onClick: () => e.chain().focus().toggleUnderline().run(),
          isActive: c?.isUnderline,
          tooltip: "Underline (Ctrl+U)",
          children: /* @__PURE__ */ y(Bl, { size: 16 }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 216,
            columnNumber: 11
          }, this)
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 211,
          columnNumber: 9
        },
        this
      ),
      /* @__PURE__ */ y(
        ut,
        {
          onClick: () => e.chain().focus().toggleStrike().run(),
          isActive: c?.isStrike,
          tooltip: "Strikethrough",
          children: /* @__PURE__ */ y(Ll, { size: 16 }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 223,
            columnNumber: 11
          }, this)
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 218,
          columnNumber: 9
        },
        this
      ),
      /* @__PURE__ */ y(
        ut,
        {
          onClick: () => e.chain().focus().toggleCode().run(),
          isActive: c?.isCode,
          tooltip: "Inline Code (Ctrl+E)",
          children: /* @__PURE__ */ y(Nd, { size: 16 }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 230,
            columnNumber: 11
          }, this)
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 225,
          columnNumber: 9
        },
        this
      ),
      /* @__PURE__ */ y(
        ut,
        {
          onClick: () => e.chain().focus().toggleHighlight().run(),
          isActive: c?.isHighlight,
          tooltip: "Highlight",
          children: /* @__PURE__ */ y(Ed, { size: 16 }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 237,
            columnNumber: 11
          }, this)
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 232,
          columnNumber: 9
        },
        this
      ),
      /* @__PURE__ */ y(
        ut,
        {
          onClick: () => r?.(),
          isActive: c?.isLink,
          tooltip: "Link (Ctrl+K)",
          children: /* @__PURE__ */ y(Rl, { size: 16 }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 244,
            columnNumber: 11
          }, this)
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 239,
          columnNumber: 9
        },
        this
      )
    ] }, void 0, !0, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
      lineNumber: 196,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ y(_o, { children: [
      /* @__PURE__ */ y(Ro, { asChild: !0, children: /* @__PURE__ */ y(Io, { variant: "ghost", size: "sm", className: "h-9 w-9 p-0 sm:hidden", children: /* @__PURE__ */ y(ws, { size: 18 }, void 0, !1, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
        lineNumber: 252,
        columnNumber: 13
      }, this) }, void 0, !1, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
        lineNumber: 251,
        columnNumber: 11
      }, this) }, void 0, !1, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
        lineNumber: 250,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ y(Oo, { align: "start", className: "w-48", children: [
        /* @__PURE__ */ y(ke, { onClick: () => e.chain().focus().toggleBold().run(), children: [
          /* @__PURE__ */ y(Sl, { size: 16, className: "mr-2" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 257,
            columnNumber: 13
          }, this),
          " Bold"
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 256,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ y(ke, { onClick: () => e.chain().focus().toggleItalic().run(), children: [
          /* @__PURE__ */ y(_l, { size: 16, className: "mr-2" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 260,
            columnNumber: 13
          }, this),
          " Italic"
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 259,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ y(ke, { onClick: () => e.chain().focus().toggleUnderline().run(), children: [
          /* @__PURE__ */ y(Bl, { size: 16, className: "mr-2" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 263,
            columnNumber: 13
          }, this),
          " Underline"
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 262,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ y(ke, { onClick: () => e.chain().focus().toggleStrike().run(), children: [
          /* @__PURE__ */ y(Ll, { size: 16, className: "mr-2" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 266,
            columnNumber: 13
          }, this),
          " Strikethrough"
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 265,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ y(ke, { onClick: () => e.chain().focus().toggleCode().run(), children: [
          /* @__PURE__ */ y(Nd, { size: 16, className: "mr-2" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 269,
            columnNumber: 13
          }, this),
          " Inline Code"
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 268,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ y(ke, { onClick: () => e.chain().focus().toggleHighlight().run(), children: [
          /* @__PURE__ */ y(Ed, { size: 16, className: "mr-2" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 272,
            columnNumber: 13
          }, this),
          " Highlight"
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 271,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ y(ke, { onClick: () => r?.(), children: [
          /* @__PURE__ */ y(Rl, { size: 16, className: "mr-2" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 275,
            columnNumber: 13
          }, this),
          " Link"
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 274,
          columnNumber: 11
        }, this)
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
        lineNumber: 255,
        columnNumber: 9
      }, this)
    ] }, void 0, !0, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
      lineNumber: 249,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ y(Ni, {}, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
      lineNumber: 280,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ y(_o, { children: [
      /* @__PURE__ */ y(Ro, { asChild: !0, children: /* @__PURE__ */ y(Io, { variant: "ghost", size: "sm", className: "h-9 sm:h-8 px-1.5 sm:px-2 gap-1", children: [
        /* @__PURE__ */ y(Ml, { size: 18, className: "sm:w-4 sm:h-4" }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 286,
          columnNumber: 13
        }, this),
        /* @__PURE__ */ y("span", { className: "text-xs hidden sm:inline", children: "Heading" }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 287,
          columnNumber: 13
        }, this)
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
        lineNumber: 285,
        columnNumber: 11
      }, this) }, void 0, !1, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
        lineNumber: 284,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ y(Oo, { align: "start", children: [
        /* @__PURE__ */ y(ke, { onClick: () => e.chain().focus().toggleHeading({ level: 1 }).run(), children: [
          /* @__PURE__ */ y(Ml, { size: 16, className: "mr-2" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 292,
            columnNumber: 13
          }, this),
          " Heading 1"
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 291,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ y(ke, { onClick: () => e.chain().focus().toggleHeading({ level: 2 }).run(), children: [
          /* @__PURE__ */ y(th, { size: 16, className: "mr-2" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 295,
            columnNumber: 13
          }, this),
          " Heading 2"
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 294,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ y(ke, { onClick: () => e.chain().focus().toggleHeading({ level: 3 }).run(), children: [
          /* @__PURE__ */ y(nh, { size: 16, className: "mr-2" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 298,
            columnNumber: 13
          }, this),
          " Heading 3"
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 297,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ y(lr, {}, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 300,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ y(ke, { onClick: () => e.chain().focus().setParagraph().run(), children: [
          /* @__PURE__ */ y(Vo, { size: 16, className: "mr-2" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 302,
            columnNumber: 13
          }, this),
          " Paragraph"
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 301,
          columnNumber: 11
        }, this)
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
        lineNumber: 290,
        columnNumber: 9
      }, this)
    ] }, void 0, !0, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
      lineNumber: 283,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ y(Ni, {}, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
      lineNumber: 307,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ y("div", { className: "hidden md:flex items-center gap-0.5", children: [
      /* @__PURE__ */ y(
        ut,
        {
          onClick: () => e.chain().focus().toggleBulletList().run(),
          isActive: c?.isBulletList,
          tooltip: "Bullet List",
          children: /* @__PURE__ */ y(Gi, { size: 16 }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 316,
            columnNumber: 11
          }, this)
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 311,
          columnNumber: 9
        },
        this
      ),
      /* @__PURE__ */ y(
        ut,
        {
          onClick: () => e.chain().focus().toggleOrderedList().run(),
          isActive: c?.isOrderedList,
          tooltip: "Numbered List",
          children: /* @__PURE__ */ y(Ol, { size: 16 }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 323,
            columnNumber: 11
          }, this)
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 318,
          columnNumber: 9
        },
        this
      ),
      /* @__PURE__ */ y(
        ut,
        {
          onClick: () => e.chain().focus().toggleTaskList().run(),
          isActive: c?.isTaskList,
          tooltip: "Task List",
          children: /* @__PURE__ */ y(Dl, { size: 16 }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 330,
            columnNumber: 11
          }, this)
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 325,
          columnNumber: 9
        },
        this
      ),
      /* @__PURE__ */ y(
        ut,
        {
          onClick: () => e.chain().focus().toggleBlockquote().run(),
          isActive: c?.isBlockquote,
          tooltip: "Quote",
          children: /* @__PURE__ */ y(Il, { size: 16 }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 337,
            columnNumber: 11
          }, this)
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 332,
          columnNumber: 9
        },
        this
      ),
      /* @__PURE__ */ y(
        ut,
        {
          onClick: () => e.chain().focus().toggleCodeBlock().run(),
          isActive: c?.isCodeBlock,
          tooltip: "Code Block",
          children: /* @__PURE__ */ y(xd, { size: 16 }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 344,
            columnNumber: 11
          }, this)
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 339,
          columnNumber: 9
        },
        this
      ),
      /* @__PURE__ */ y(Ni, {}, void 0, !1, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
        lineNumber: 346,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ y(
        ut,
        {
          onClick: () => {
            c?.isTaskList ? e.chain().focus().sinkListItem("taskItem").run() : (c?.isBulletList || c?.isOrderedList) && e.chain().focus().sinkListItem("listItem").run();
          },
          disabled: !c?.isBulletList && !c?.isOrderedList && !c?.isTaskList,
          tooltip: "Indent (Tab)",
          children: /* @__PURE__ */ y(ag, { size: 16 }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 359,
            columnNumber: 11
          }, this)
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 347,
          columnNumber: 9
        },
        this
      ),
      /* @__PURE__ */ y(
        ut,
        {
          onClick: () => {
            c?.isTaskList ? e.chain().focus().liftListItem("taskItem").run() : (c?.isBulletList || c?.isOrderedList) && e.chain().focus().liftListItem("listItem").run();
          },
          disabled: !c?.isBulletList && !c?.isOrderedList && !c?.isTaskList,
          tooltip: "Outdent (Shift+Tab)",
          children: /* @__PURE__ */ y(sg, { size: 16 }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 373,
            columnNumber: 11
          }, this)
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 361,
          columnNumber: 9
        },
        this
      )
    ] }, void 0, !0, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
      lineNumber: 310,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ y(_o, { children: [
      /* @__PURE__ */ y(Ro, { asChild: !0, children: /* @__PURE__ */ y(Io, { variant: "ghost", size: "sm", className: "h-9 w-9 p-0 md:hidden", children: /* @__PURE__ */ y(Gi, { size: 18 }, void 0, !1, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
        lineNumber: 381,
        columnNumber: 13
      }, this) }, void 0, !1, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
        lineNumber: 380,
        columnNumber: 11
      }, this) }, void 0, !1, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
        lineNumber: 379,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ y(Oo, { align: "start", className: "w-48", children: [
        /* @__PURE__ */ y(ke, { onClick: () => e.chain().focus().toggleBulletList().run(), children: [
          /* @__PURE__ */ y(Gi, { size: 16, className: "mr-2" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 386,
            columnNumber: 13
          }, this),
          " Bullet List"
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 385,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ y(ke, { onClick: () => e.chain().focus().toggleOrderedList().run(), children: [
          /* @__PURE__ */ y(Ol, { size: 16, className: "mr-2" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 389,
            columnNumber: 13
          }, this),
          " Numbered List"
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 388,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ y(ke, { onClick: () => e.chain().focus().toggleTaskList().run(), children: [
          /* @__PURE__ */ y(Dl, { size: 16, className: "mr-2" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 392,
            columnNumber: 13
          }, this),
          " Task List"
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 391,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ y(ke, { onClick: () => e.chain().focus().toggleBlockquote().run(), children: [
          /* @__PURE__ */ y(Il, { size: 16, className: "mr-2" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 395,
            columnNumber: 13
          }, this),
          " Quote"
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 394,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ y(ke, { onClick: () => e.chain().focus().toggleCodeBlock().run(), children: [
          /* @__PURE__ */ y(xd, { size: 16, className: "mr-2" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 398,
            columnNumber: 13
          }, this),
          " Code Block"
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 397,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ y(lr, {}, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 400,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ y(
          ke,
          {
            onClick: () => {
              c?.isTaskList ? e.chain().focus().sinkListItem("taskItem").run() : (c?.isBulletList || c?.isOrderedList) && e.chain().focus().sinkListItem("listItem").run();
            },
            disabled: !c?.isBulletList && !c?.isOrderedList && !c?.isTaskList,
            children: [
              /* @__PURE__ */ y(ag, { size: 16, className: "mr-2" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
                lineNumber: 411,
                columnNumber: 13
              }, this),
              " Indent"
            ]
          },
          void 0,
          !0,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 401,
            columnNumber: 11
          },
          this
        ),
        /* @__PURE__ */ y(
          ke,
          {
            onClick: () => {
              c?.isTaskList ? e.chain().focus().liftListItem("taskItem").run() : (c?.isBulletList || c?.isOrderedList) && e.chain().focus().liftListItem("listItem").run();
            },
            disabled: !c?.isBulletList && !c?.isOrderedList && !c?.isTaskList,
            children: [
              /* @__PURE__ */ y(sg, { size: 16, className: "mr-2" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
                lineNumber: 423,
                columnNumber: 13
              }, this),
              " Outdent"
            ]
          },
          void 0,
          !0,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 413,
            columnNumber: 11
          },
          this
        )
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
        lineNumber: 384,
        columnNumber: 9
      }, this)
    ] }, void 0, !0, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
      lineNumber: 378,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ y(Ni, {}, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
      lineNumber: 428,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ y("div", { className: "hidden lg:flex items-center gap-0.5", children: [
      /* @__PURE__ */ y(
        ut,
        {
          onClick: d,
          tooltip: "Insert Table (3×3)",
          children: /* @__PURE__ */ y(Sa, { size: 16 }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 437,
            columnNumber: 11
          }, this)
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 433,
          columnNumber: 9
        },
        this
      ),
      /* @__PURE__ */ y(
        ut,
        {
          onClick: () => l(!0),
          tooltip: "Insert Image",
          children: /* @__PURE__ */ y(Al, { size: 16 }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 443,
            columnNumber: 11
          }, this)
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 439,
          columnNumber: 9
        },
        this
      ),
      /* @__PURE__ */ y(
        ut,
        {
          onClick: () => e.chain().focus().setHorizontalRule().run(),
          tooltip: "Horizontal Rule",
          children: /* @__PURE__ */ y(Sd, { size: 16 }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 449,
            columnNumber: 11
          }, this)
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 445,
          columnNumber: 9
        },
        this
      ),
      /* @__PURE__ */ y(_o, { children: [
        /* @__PURE__ */ y(Ro, { asChild: !0, children: /* @__PURE__ */ y(
          "button",
          {
            className: "flex items-center justify-center w-8 h-8 rounded-md transition-all duration-100 ease-out touch-manipulation bg-transparent text-foreground hover:bg-secondary active:bg-secondary/80",
            title: "Insert Callout",
            children: /* @__PURE__ */ y(Ho, { size: 16 }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
              lineNumber: 458,
              columnNumber: 15
            }, this)
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 454,
            columnNumber: 13
          },
          this
        ) }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 453,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ y(Oo, { align: "start", children: [
          /* @__PURE__ */ y(ke, { onClick: () => f("info"), children: [
            /* @__PURE__ */ y(Ho, { size: 16, className: "mr-2 text-blue-400" }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
              lineNumber: 463,
              columnNumber: 15
            }, this),
            " Info"
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 462,
            columnNumber: 13
          }, this),
          /* @__PURE__ */ y(ke, { onClick: () => f("warning"), children: [
            /* @__PURE__ */ y(Pl, { size: 16, className: "mr-2 text-yellow-400" }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
              lineNumber: 466,
              columnNumber: 15
            }, this),
            " Warning"
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 465,
            columnNumber: 13
          }, this),
          /* @__PURE__ */ y(ke, { onClick: () => f("error"), children: [
            /* @__PURE__ */ y(Tl, { size: 16, className: "mr-2 text-red-400" }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
              lineNumber: 469,
              columnNumber: 15
            }, this),
            " Error"
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 468,
            columnNumber: 13
          }, this),
          /* @__PURE__ */ y(ke, { onClick: () => f("success"), children: [
            /* @__PURE__ */ y(Cl, { size: 16, className: "mr-2 text-green-400" }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
              lineNumber: 472,
              columnNumber: 15
            }, this),
            " Success"
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 471,
            columnNumber: 13
          }, this),
          /* @__PURE__ */ y(ke, { onClick: () => f("note"), children: [
            /* @__PURE__ */ y(Vo, { size: 16, className: "mr-2 text-purple-400" }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
              lineNumber: 475,
              columnNumber: 15
            }, this),
            " Note"
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 474,
            columnNumber: 13
          }, this)
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 461,
          columnNumber: 11
        }, this)
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
        lineNumber: 452,
        columnNumber: 9
      }, this)
    ] }, void 0, !0, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
      lineNumber: 432,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ y(_o, { children: [
      /* @__PURE__ */ y(Ro, { asChild: !0, children: /* @__PURE__ */ y(Io, { variant: "ghost", size: "sm", className: "h-9 sm:h-8 px-1.5 sm:px-2 gap-1 lg:hidden", children: [
        /* @__PURE__ */ y(u2, { size: 18, className: "sm:w-4 sm:h-4" }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 485,
          columnNumber: 13
        }, this),
        /* @__PURE__ */ y("span", { className: "text-xs hidden sm:inline", children: "Insert" }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 486,
          columnNumber: 13
        }, this)
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
        lineNumber: 484,
        columnNumber: 11
      }, this) }, void 0, !1, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
        lineNumber: 483,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ y(Oo, { align: "start", className: "w-56", children: [
        /* @__PURE__ */ y(ke, { onClick: d, children: [
          /* @__PURE__ */ y(Sa, { size: 16, className: "mr-2" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 491,
            columnNumber: 13
          }, this),
          " Table (3×3)"
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 490,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ y(ke, { onClick: () => l(!0), children: [
          /* @__PURE__ */ y(Al, { size: 16, className: "mr-2" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 494,
            columnNumber: 13
          }, this),
          " Image"
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 493,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ y(ke, { onClick: () => e.chain().focus().setHorizontalRule().run(), children: [
          /* @__PURE__ */ y(Sd, { size: 16, className: "mr-2" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 497,
            columnNumber: 13
          }, this),
          " Horizontal Rule"
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 496,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ y(lr, {}, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 499,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ y(Rg, { children: [
          /* @__PURE__ */ y(Og, { children: [
            /* @__PURE__ */ y(Ho, { size: 16, className: "mr-2" }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
              lineNumber: 502,
              columnNumber: 15
            }, this),
            " Callout"
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 501,
            columnNumber: 13
          }, this),
          /* @__PURE__ */ y(Ig, { children: [
            /* @__PURE__ */ y(ke, { onClick: () => f("info"), children: [
              /* @__PURE__ */ y(Ho, { size: 16, className: "mr-2 text-blue-400" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
                lineNumber: 506,
                columnNumber: 17
              }, this),
              " Info"
            ] }, void 0, !0, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
              lineNumber: 505,
              columnNumber: 15
            }, this),
            /* @__PURE__ */ y(ke, { onClick: () => f("warning"), children: [
              /* @__PURE__ */ y(Pl, { size: 16, className: "mr-2 text-yellow-400" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
                lineNumber: 509,
                columnNumber: 17
              }, this),
              " Warning"
            ] }, void 0, !0, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
              lineNumber: 508,
              columnNumber: 15
            }, this),
            /* @__PURE__ */ y(ke, { onClick: () => f("error"), children: [
              /* @__PURE__ */ y(Tl, { size: 16, className: "mr-2 text-red-400" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
                lineNumber: 512,
                columnNumber: 17
              }, this),
              " Error"
            ] }, void 0, !0, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
              lineNumber: 511,
              columnNumber: 15
            }, this),
            /* @__PURE__ */ y(ke, { onClick: () => f("success"), children: [
              /* @__PURE__ */ y(Cl, { size: 16, className: "mr-2 text-green-400" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
                lineNumber: 515,
                columnNumber: 17
              }, this),
              " Success"
            ] }, void 0, !0, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
              lineNumber: 514,
              columnNumber: 15
            }, this),
            /* @__PURE__ */ y(ke, { onClick: () => f("note"), children: [
              /* @__PURE__ */ y(Vo, { size: 16, className: "mr-2 text-purple-400" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
                lineNumber: 518,
                columnNumber: 17
              }, this),
              " Note"
            ] }, void 0, !0, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
              lineNumber: 517,
              columnNumber: 15
            }, this)
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 504,
            columnNumber: 13
          }, this)
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 500,
          columnNumber: 11
        }, this)
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
        lineNumber: 489,
        columnNumber: 9
      }, this)
    ] }, void 0, !0, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
      lineNumber: 482,
      columnNumber: 7
    }, this),
    e.isActive("table") && /* @__PURE__ */ y(_o, { children: [
      /* @__PURE__ */ y(Ro, { asChild: !0, children: /* @__PURE__ */ y(
        Io,
        {
          variant: "ghost",
          size: "sm",
          className: "h-9 sm:h-8 px-1.5 sm:px-2 gap-1 bg-primary/10",
          children: [
            /* @__PURE__ */ y(Sa, { size: 18, className: "sm:w-4 sm:h-4" }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
              lineNumber: 534,
              columnNumber: 15
            }, this),
            /* @__PURE__ */ y("span", { className: "text-xs hidden sm:inline", children: "Table" }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
              lineNumber: 535,
              columnNumber: 15
            }, this)
          ]
        },
        void 0,
        !0,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 529,
          columnNumber: 13
        },
        this
      ) }, void 0, !1, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
        lineNumber: 528,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ y(Oo, { align: "start", className: "w-56", children: [
        /* @__PURE__ */ y(
          ke,
          {
            onClick: () => e.chain().focus().addColumnBefore().run(),
            disabled: !e.can().addColumnBefore(),
            children: [
              /* @__PURE__ */ y(ig, { size: 16, className: "mr-2" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
                lineNumber: 543,
                columnNumber: 15
              }, this),
              " Add Column Before"
            ]
          },
          void 0,
          !0,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 539,
            columnNumber: 13
          },
          this
        ),
        /* @__PURE__ */ y(
          ke,
          {
            onClick: () => e.chain().focus().addColumnAfter().run(),
            disabled: !e.can().addColumnAfter(),
            children: [
              /* @__PURE__ */ y(ig, { size: 16, className: "mr-2" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
                lineNumber: 549,
                columnNumber: 15
              }, this),
              " Add Column After"
            ]
          },
          void 0,
          !0,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 545,
            columnNumber: 13
          },
          this
        ),
        /* @__PURE__ */ y(
          ke,
          {
            onClick: () => e.chain().focus().deleteColumn().run(),
            disabled: !e.can().deleteColumn(),
            children: [
              /* @__PURE__ */ y(ji, { size: 16, className: "mr-2 text-destructive" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
                lineNumber: 555,
                columnNumber: 15
              }, this),
              " Delete Column"
            ]
          },
          void 0,
          !0,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 551,
            columnNumber: 13
          },
          this
        ),
        /* @__PURE__ */ y(lr, {}, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 557,
          columnNumber: 13
        }, this),
        /* @__PURE__ */ y(
          ke,
          {
            onClick: () => e.chain().focus().addRowBefore().run(),
            disabled: !e.can().addRowBefore(),
            children: [
              /* @__PURE__ */ y(cg, { size: 16, className: "mr-2" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
                lineNumber: 562,
                columnNumber: 15
              }, this),
              " Add Row Before"
            ]
          },
          void 0,
          !0,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 558,
            columnNumber: 13
          },
          this
        ),
        /* @__PURE__ */ y(
          ke,
          {
            onClick: () => e.chain().focus().addRowAfter().run(),
            disabled: !e.can().addRowAfter(),
            children: [
              /* @__PURE__ */ y(cg, { size: 16, className: "mr-2" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
                lineNumber: 568,
                columnNumber: 15
              }, this),
              " Add Row After"
            ]
          },
          void 0,
          !0,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 564,
            columnNumber: 13
          },
          this
        ),
        /* @__PURE__ */ y(
          ke,
          {
            onClick: () => e.chain().focus().deleteRow().run(),
            disabled: !e.can().deleteRow(),
            children: [
              /* @__PURE__ */ y(ji, { size: 16, className: "mr-2 text-destructive" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
                lineNumber: 574,
                columnNumber: 15
              }, this),
              " Delete Row"
            ]
          },
          void 0,
          !0,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 570,
            columnNumber: 13
          },
          this
        ),
        /* @__PURE__ */ y(lr, {}, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 576,
          columnNumber: 13
        }, this),
        /* @__PURE__ */ y(
          ke,
          {
            onClick: () => e.chain().focus().toggleHeaderRow().run(),
            disabled: !e.can().toggleHeaderRow(),
            children: [
              /* @__PURE__ */ y(ug, { size: 16, className: "mr-2" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
                lineNumber: 581,
                columnNumber: 15
              }, this),
              " Toggle Header Row"
            ]
          },
          void 0,
          !0,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 577,
            columnNumber: 13
          },
          this
        ),
        /* @__PURE__ */ y(
          ke,
          {
            onClick: () => e.chain().focus().toggleHeaderColumn().run(),
            disabled: !e.can().toggleHeaderColumn(),
            children: [
              /* @__PURE__ */ y(ug, { size: 16, className: "mr-2" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
                lineNumber: 587,
                columnNumber: 15
              }, this),
              " Toggle Header Column"
            ]
          },
          void 0,
          !0,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 583,
            columnNumber: 13
          },
          this
        ),
        /* @__PURE__ */ y(lr, {}, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 589,
          columnNumber: 13
        }, this),
        /* @__PURE__ */ y(Rg, { children: [
          /* @__PURE__ */ y(Og, { children: [
            /* @__PURE__ */ y(x2, { size: 16, className: "mr-2" }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
              lineNumber: 592,
              columnNumber: 17
            }, this),
            " Cell Background"
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 591,
            columnNumber: 15
          }, this),
          /* @__PURE__ */ y(Ig, { className: "w-48", children: [
            /* @__PURE__ */ y("div", { className: "p-2", children: [
              /* @__PURE__ */ y("div", { className: "text-xs text-muted-foreground mb-2", children: "Quick Colors" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
                lineNumber: 596,
                columnNumber: 19
              }, this),
              /* @__PURE__ */ y("div", { className: "grid grid-cols-6 gap-1 mb-2", children: [
                { color: "#ef4444", name: "Red" },
                { color: "#f97316", name: "Orange" },
                { color: "#eab308", name: "Yellow" },
                { color: "#22c55e", name: "Green" },
                { color: "#3b82f6", name: "Blue" },
                { color: "#8b5cf6", name: "Purple" },
                { color: "#ec4899", name: "Pink" },
                { color: "#14b8a6", name: "Teal" },
                { color: "#6366f1", name: "Indigo" },
                { color: "#64748b", name: "Slate" },
                { color: "#1e293b", name: "Dark" },
                { color: "#f1f5f9", name: "Light" }
              ].map(({ color: h, name: m }) => /* @__PURE__ */ y(
                "button",
                {
                  onClick: () => e.chain().focus().setCellBackground(h).run(),
                  className: "w-6 h-6 rounded border border-border hover:scale-110 transition-transform touch-manipulation",
                  style: { backgroundColor: h },
                  title: m
                },
                h,
                !1,
                {
                  fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
                  lineNumber: 612,
                  columnNumber: 23
                },
                this
              )) }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
                lineNumber: 597,
                columnNumber: 19
              }, this),
              /* @__PURE__ */ y("div", { className: "text-xs text-muted-foreground mb-1", children: "Custom Color" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
                lineNumber: 621,
                columnNumber: 19
              }, this),
              /* @__PURE__ */ y(
                "input",
                {
                  type: "color",
                  defaultValue: "#3b82f6",
                  onChange: (h) => e.chain().focus().setCellBackground(h.target.value).run(),
                  className: "w-full h-8 rounded cursor-pointer border border-border",
                  style: { backgroundColor: "transparent" }
                },
                void 0,
                !1,
                {
                  fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
                  lineNumber: 622,
                  columnNumber: 19
                },
                this
              )
            ] }, void 0, !0, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
              lineNumber: 595,
              columnNumber: 17
            }, this),
            /* @__PURE__ */ y(lr, {}, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
              lineNumber: 630,
              columnNumber: 17
            }, this),
            /* @__PURE__ */ y(ke, { onClick: () => e.chain().focus().unsetCellBackground().run(), children: [
              /* @__PURE__ */ y(lo, { size: 16, className: "mr-2" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
                lineNumber: 632,
                columnNumber: 19
              }, this),
              " Remove Background"
            ] }, void 0, !0, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
              lineNumber: 631,
              columnNumber: 17
            }, this)
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 594,
            columnNumber: 15
          }, this)
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 590,
          columnNumber: 13
        }, this),
        /* @__PURE__ */ y(lr, {}, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 636,
          columnNumber: 13
        }, this),
        /* @__PURE__ */ y(
          ke,
          {
            onClick: () => e.chain().focus().deleteTable().run(),
            disabled: !e.can().deleteTable(),
            className: "text-destructive",
            children: [
              /* @__PURE__ */ y(ji, { size: 16, className: "mr-2" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
                lineNumber: 642,
                columnNumber: 15
              }, this),
              " Delete Table"
            ]
          },
          void 0,
          !0,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 637,
            columnNumber: 13
          },
          this
        )
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
        lineNumber: 538,
        columnNumber: 11
      }, this)
    ] }, void 0, !0, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
      lineNumber: 527,
      columnNumber: 9
    }, this),
    a && /* @__PURE__ */ y("div", { className: "fixed inset-0 z-50 flex items-center justify-center bg-black/50 p-4 sm:relative sm:inset-auto sm:bg-transparent sm:p-0", children: /* @__PURE__ */ y("div", { className: "flex flex-col sm:flex-row items-stretch sm:items-center gap-2 p-4 sm:p-0 bg-card sm:bg-secondary rounded-lg sm:rounded-md w-full max-w-sm sm:max-w-none sm:w-auto", children: [
      /* @__PURE__ */ y(
        "input",
        {
          type: "url",
          placeholder: "Image URL...",
          value: i,
          onChange: (h) => s(h.target.value),
          onKeyDown: (h) => {
            h.key === "Enter" && (h.preventDefault(), u()), h.key === "Escape" && (l(!1), s(""));
          },
          className: "bg-secondary sm:bg-transparent border sm:border-none rounded px-3 py-2 sm:py-0 outline-none text-sm w-full sm:w-40",
          autoFocus: !0
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 652,
          columnNumber: 13
        },
        this
      ),
      /* @__PURE__ */ y("div", { className: "flex gap-2 sm:gap-1", children: [
        /* @__PURE__ */ y(
          "button",
          {
            onClick: u,
            className: "flex-1 sm:flex-none px-4 sm:px-2 py-2 sm:py-0.5 text-sm sm:text-xs bg-primary text-primary-foreground rounded",
            children: "Add"
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 671,
            columnNumber: 15
          },
          this
        ),
        /* @__PURE__ */ y(
          "button",
          {
            onClick: () => {
              l(!1), s("");
            },
            className: "flex-1 sm:flex-none px-4 sm:px-2 py-2 sm:py-0.5 text-sm sm:text-xs text-muted-foreground bg-secondary sm:bg-transparent rounded",
            children: "Cancel"
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
            lineNumber: 677,
            columnNumber: 15
          },
          this
        )
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
        lineNumber: 670,
        columnNumber: 13
      }, this)
    ] }, void 0, !0, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
      lineNumber: 651,
      columnNumber: 11
    }, this) }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
      lineNumber: 650,
      columnNumber: 9
    }, this),
    /* @__PURE__ */ y("div", { className: "flex-1 min-w-2" }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
      lineNumber: 692,
      columnNumber: 7
    }, this),
    n && /* @__PURE__ */ y(Bk, { children: [
      /* @__PURE__ */ y(zk, { asChild: !0, children: /* @__PURE__ */ y(
        Io,
        {
          variant: "ghost",
          size: "sm",
          className: "h-9 sm:h-8 px-2 gap-1 shrink-0",
          onClick: n,
          children: [
            /* @__PURE__ */ y(eh, { size: 18, className: "sm:w-4 sm:h-4" }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
              lineNumber: 704,
              columnNumber: 15
            }, this),
            /* @__PURE__ */ y("span", { className: "text-xs hidden md:inline", children: "Copy MD" }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
              lineNumber: 705,
              columnNumber: 15
            }, this)
          ]
        },
        void 0,
        !0,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
          lineNumber: 698,
          columnNumber: 13
        },
        this
      ) }, void 0, !1, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
        lineNumber: 697,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ y($k, { side: "bottom", className: "text-xs", children: "Copy content as Markdown" }, void 0, !1, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
        lineNumber: 708,
        columnNumber: 11
      }, this)
    ] }, void 0, !0, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
      lineNumber: 696,
      columnNumber: 9
    }, this)
  ] }, void 0, !0, {
    fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/EditorToolbar.tsx",
    lineNumber: 176,
    columnNumber: 5
  }, this);
});
function Az({ editor: t, isOpen: e, onClose: n, focusTrigger: r = 0, initialSearchQuery: o }) {
  const [i, s] = J(""), [a, l] = J(""), [c, u] = J(!1), [d, f] = J(!1), [h, m] = J(!1), [p, g] = J(!1), [b, v] = J([]), [k, x] = J(0), [w, E] = J(null), [S, C] = J(!1), M = fe(!1), O = fe(null), q = fe(null), K = fe(!1);
  ge(() => {
    e && o && o.trim() && s(o);
  }, [e, o, r]);
  const j = ie(() => {
    if (!i || !t) {
      v([]), x(0), E(null);
      return;
    }
    const { doc: _ } = t.state, z = [];
    let Q;
    try {
      if (d)
        Q = new RegExp(i, c ? "g" : "gi");
      else {
        let ue = i.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        h && (ue = `\\b${ue}\\b`), Q = new RegExp(ue, c ? "g" : "gi");
      }
      E(null);
    } catch (ue) {
      E(ue.message), v([]);
      return;
    }
    _.descendants((ue, Me) => {
      if (ue.isText && ue.text) {
        let Oe;
        for (; (Oe = Q.exec(ue.text)) !== null; )
          z.push({
            from: Me + Oe.index,
            to: Me + Oe.index + Oe[0].length,
            text: Oe[0]
          });
      }
      return !0;
    }), v(z), z.length > 0 && k >= z.length && x(0);
  }, [i, c, d, h, t, k]);
  ge(() => {
    j();
  }, [j]), ge(() => {
    if (!t) return;
    const _ = typeof t.commands.setSearchHighlight == "function";
    e && i && _ ? t.commands.setSearchHighlight({
      searchTerm: i,
      caseSensitive: c,
      useRegex: d,
      currentMatchIndex: k
    }) : _ && t.commands.clearSearchHighlight();
  }, [t, e, i, c, d, k]), ge(() => {
    !e && t && (typeof t.commands.clearSearchHighlight == "function" && t.commands.clearSearchHighlight(), M.current || typeof t.commands.clearAllOccurrences == "function" && (t.commands.clearAllOccurrences(), C(!1)), M.current = !1);
  }, [e, t]), ge(() => {
    if (b.length > 0 && k < b.length) {
      const _ = b[k], z = t.view.domAtPos(_.from);
      z.node && z.node.parentElement?.scrollIntoView({ behavior: "smooth", block: "center" }), K.current && (K.current = !1);
    }
  }, [k, b, t]), ge(() => {
    e && O.current && (O.current.focus(), O.current.select());
  }, [e, r]);
  const H = ie(() => {
    b.length !== 0 && (K.current = !0, x((_) => (_ + 1) % b.length));
  }, [b.length]), G = ie(() => {
    b.length !== 0 && (K.current = !0, x((_) => (_ - 1 + b.length) % b.length));
  }, [b.length]), V = ie(() => {
    if (b.length === 0 || k >= b.length) return;
    const _ = b[k];
    t.chain().focus().setTextSelection({ from: _.from, to: _.to }).deleteSelection().insertContent(a).run(), setTimeout(j, 10);
  }, [b, k, a, t, j]), re = ie(() => {
    if (b.length === 0) return;
    const _ = [...b].sort((z, Q) => Q.from - z.from);
    t.chain().focus(), _.forEach((z) => {
      t.chain().setTextSelection({ from: z.from, to: z.to }).deleteSelection().insertContent(a).run();
    }), setTimeout(j, 10);
  }, [b, a, t, j]), A = ie(() => {
    if (b.length === 0 || !i || !(typeof t.commands.selectAllOccurrences == "function")) return;
    t.commands.selectAllOccurrences({
      searchTerm: i,
      caseSensitive: c,
      useRegex: d,
      wholeWord: h
    }) && (C(!0), M.current = !0, typeof t.commands.clearSearchHighlight == "function" && t.commands.clearSearchHighlight(), n(), t.commands.focus());
  }, [b, i, c, d, h, t, n]), $ = ie((_) => {
    _.key === "Enter" ? (_.preventDefault(), _.shiftKey ? G() : H(), O.current?.focus()) : _.key === "Escape" ? (_.preventDefault(), n()) : _.key === "h" && (_.ctrlKey || _.metaKey) ? (_.preventDefault(), g((z) => !z)) : _.key === "l" && (_.ctrlKey || _.metaKey) && _.shiftKey && (_.preventDefault(), A());
  }, [H, G, n, A]);
  return e ? /* @__PURE__ */ y(
    "div",
    {
      className: "find-replace-panel",
      onKeyDown: $,
      children: [
        /* @__PURE__ */ y("div", { className: "find-replace-row", children: [
          /* @__PURE__ */ y("div", { className: "find-replace-input-wrapper", children: [
            /* @__PURE__ */ y(R2, { size: 14, className: "find-replace-icon" }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
              lineNumber: 300,
              columnNumber: 11
            }, this),
            /* @__PURE__ */ y(
              "input",
              {
                ref: O,
                type: "text",
                placeholder: "Find...",
                value: i,
                onChange: (_) => s(_.target.value),
                className: `find-replace-input ${w ? "has-error" : ""}`
              },
              void 0,
              !1,
              {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
                lineNumber: 301,
                columnNumber: 11
              },
              this
            ),
            w && /* @__PURE__ */ y("span", { className: "find-replace-error", title: w, children: "!" }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
              lineNumber: 310,
              columnNumber: 13
            }, this)
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
            lineNumber: 299,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ y("span", { className: "find-replace-count", children: b.length > 0 ? `${k + 1} of ${b.length}` : i ? "No results" : "" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
            lineNumber: 315,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ y(
            "button",
            {
              onClick: G,
              disabled: b.length === 0,
              className: "find-replace-btn",
              title: "Previous match (Shift+Enter)",
              children: /* @__PURE__ */ y(c2, { size: 16 }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
                lineNumber: 329,
                columnNumber: 11
              }, this)
            },
            void 0,
            !1,
            {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
              lineNumber: 323,
              columnNumber: 9
            },
            this
          ),
          /* @__PURE__ */ y(
            "button",
            {
              onClick: H,
              disabled: b.length === 0,
              className: "find-replace-btn",
              title: "Next match (Enter)",
              children: /* @__PURE__ */ y(vc, { size: 16 }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
                lineNumber: 337,
                columnNumber: 11
              }, this)
            },
            void 0,
            !1,
            {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
              lineNumber: 331,
              columnNumber: 9
            },
            this
          ),
          /* @__PURE__ */ y(
            "button",
            {
              onClick: A,
              disabled: b.length === 0,
              className: `find-replace-btn ${S ? "active" : ""}`,
              title: `Select all occurrences (${navigator.platform?.includes("Mac") ? "⌘" : "Ctrl"}+Shift+L) — Apply formatting to all ${b.length} matches`,
              children: /* @__PURE__ */ y(k2, { size: 16 }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
                lineNumber: 347,
                columnNumber: 11
              }, this)
            },
            void 0,
            !1,
            {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
              lineNumber: 341,
              columnNumber: 9
            },
            this
          ),
          /* @__PURE__ */ y("div", { className: "find-replace-separator" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
            lineNumber: 351,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ y(
            "button",
            {
              onClick: () => u((_) => !_),
              className: `find-replace-btn ${c ? "active" : ""}`,
              title: "Match case",
              children: /* @__PURE__ */ y(a2, { size: 16 }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
                lineNumber: 359,
                columnNumber: 11
              }, this)
            },
            void 0,
            !1,
            {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
              lineNumber: 354,
              columnNumber: 9
            },
            this
          ),
          /* @__PURE__ */ y(
            "button",
            {
              onClick: () => m((_) => !_),
              className: `find-replace-btn ${h ? "active" : ""}`,
              title: "Match whole word",
              children: /* @__PURE__ */ y(D2, { size: 16 }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
                lineNumber: 366,
                columnNumber: 11
              }, this)
            },
            void 0,
            !1,
            {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
              lineNumber: 361,
              columnNumber: 9
            },
            this
          ),
          /* @__PURE__ */ y(
            "button",
            {
              onClick: () => f((_) => !_),
              className: `find-replace-btn ${d ? "active" : ""}`,
              title: "Use regex",
              children: /* @__PURE__ */ y(M2, { size: 16 }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
                lineNumber: 373,
                columnNumber: 11
              }, this)
            },
            void 0,
            !1,
            {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
              lineNumber: 368,
              columnNumber: 9
            },
            this
          ),
          /* @__PURE__ */ y(
            "button",
            {
              onClick: () => g((_) => !_),
              className: `find-replace-btn ${p ? "active" : ""}`,
              title: "Toggle replace (Ctrl+H)",
              children: /* @__PURE__ */ y(lg, { size: 16 }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
                lineNumber: 382,
                columnNumber: 11
              }, this)
            },
            void 0,
            !1,
            {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
              lineNumber: 377,
              columnNumber: 9
            },
            this
          ),
          /* @__PURE__ */ y(
            "button",
            {
              onClick: n,
              className: "find-replace-btn",
              title: "Close (Escape)",
              children: /* @__PURE__ */ y(lo, { size: 16 }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
                lineNumber: 391,
                columnNumber: 11
              }, this)
            },
            void 0,
            !1,
            {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
              lineNumber: 386,
              columnNumber: 9
            },
            this
          )
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
          lineNumber: 298,
          columnNumber: 7
        }, this),
        p && /* @__PURE__ */ y("div", { className: "find-replace-row", children: [
          /* @__PURE__ */ y("div", { className: "find-replace-input-wrapper", children: [
            /* @__PURE__ */ y(lg, { size: 14, className: "find-replace-icon" }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
              lineNumber: 399,
              columnNumber: 13
            }, this),
            /* @__PURE__ */ y(
              "input",
              {
                ref: q,
                type: "text",
                placeholder: "Replace with...",
                value: a,
                onChange: (_) => l(_.target.value),
                className: "find-replace-input"
              },
              void 0,
              !1,
              {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
                lineNumber: 400,
                columnNumber: 13
              },
              this
            )
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
            lineNumber: 398,
            columnNumber: 11
          }, this),
          /* @__PURE__ */ y(
            "button",
            {
              onClick: V,
              disabled: b.length === 0,
              className: "find-replace-btn replace-btn",
              title: "Replace current",
              children: "Replace"
            },
            void 0,
            !1,
            {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
              lineNumber: 410,
              columnNumber: 11
            },
            this
          ),
          /* @__PURE__ */ y(
            "button",
            {
              onClick: re,
              disabled: b.length === 0,
              className: "find-replace-btn replace-btn",
              title: "Replace all",
              children: [
                /* @__PURE__ */ y(A2, { size: 14 }, void 0, !1, {
                  fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
                  lineNumber: 424,
                  columnNumber: 13
                }, this),
                "All"
              ]
            },
            void 0,
            !0,
            {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
              lineNumber: 418,
              columnNumber: 11
            },
            this
          )
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
          lineNumber: 397,
          columnNumber: 9
        }, this)
      ]
    },
    void 0,
    !0,
    {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/FindReplace.tsx",
      lineNumber: 293,
      columnNumber: 5
    },
    this
  ) : null;
}
const _z = typeof navigator < "u" && /Mac|iPod|iPhone|iPad/.test(navigator.platform), Kn = _z ? "⌘" : "Ctrl", Rz = ({ editor: t }) => {
  const [e, n] = J(!1), [r, o] = J(0), [i, s] = J(0), [a, l] = J(""), [c, u] = J(""), [d, f] = J(!1), [h, m] = J(!1);
  ge(() => {
    if (!t) return;
    const S = () => {
      const M = t.storage.selectAllOccurrences;
      M ? (n(M.isActive), o(M.ranges.length), s(M.allMatches.length), l(M.searchTerm), u(M.typedBuffer), f(M.isTypingReplace), m(M.isIncremental)) : (n(!1), o(0), s(0));
    }, C = () => {
      S();
    };
    return t.on("transaction", C), S(), () => {
      t.off("transaction", C);
    };
  }, [t]);
  const p = ie(() => {
    t.commands.toggleMarkOnAllOccurrences("bold"), t.commands.focus();
  }, [t]), g = ie(() => {
    t.commands.toggleMarkOnAllOccurrences("italic"), t.commands.focus();
  }, [t]), b = ie(() => {
    t.commands.toggleMarkOnAllOccurrences("underline"), t.commands.focus();
  }, [t]), v = ie(() => {
    t.commands.toggleMarkOnAllOccurrences("strike"), t.commands.focus();
  }, [t]), k = ie(() => {
    t.commands.deleteAllOccurrences(), t.commands.focus();
  }, [t]), x = ie(() => {
    t.commands.clearAllOccurrences(), t.commands.focus();
  }, [t]), w = ie(() => {
    t.commands.selectNextOccurrence(), t.commands.focus();
  }, [t]), E = ie(() => {
    a && (t.commands.selectAllOccurrences({
      searchTerm: a,
      caseSensitive: !1,
      useRegex: !1,
      wholeWord: !1
    }), t.commands.focus());
  }, [t, a]);
  return !e || r === 0 ? null : /* @__PURE__ */ y("div", { className: "select-all-action-bar", children: [
    /* @__PURE__ */ y("div", { className: "select-all-action-bar-inner", children: [
      /* @__PURE__ */ y("div", { className: "select-all-action-bar-count", children: [
        /* @__PURE__ */ y("span", { className: "select-all-action-bar-count-number", children: h && i > 0 ? `${r}/${i}` : r }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
          lineNumber: 131,
          columnNumber: 11
        }, void 0),
        /* @__PURE__ */ y("span", { className: "select-all-action-bar-count-label", children: "selected" }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
          lineNumber: 134,
          columnNumber: 11
        }, void 0)
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
        lineNumber: 130,
        columnNumber: 9
      }, void 0),
      /* @__PURE__ */ y("div", { className: "select-all-action-bar-preview", children: d ? /* @__PURE__ */ y(fn, { children: [
        /* @__PURE__ */ y(ws, { size: 12, className: "select-all-action-bar-preview-icon" }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
          lineNumber: 141,
          columnNumber: 15
        }, void 0),
        /* @__PURE__ */ y("span", { className: "select-all-action-bar-preview-old", children: a }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
          lineNumber: 142,
          columnNumber: 15
        }, void 0),
        /* @__PURE__ */ y("span", { className: "select-all-action-bar-preview-arrow", children: "→" }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
          lineNumber: 143,
          columnNumber: 15
        }, void 0),
        /* @__PURE__ */ y("span", { className: "select-all-action-bar-preview-new", children: c || "∅" }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
          lineNumber: 144,
          columnNumber: 15
        }, void 0)
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
        lineNumber: 140,
        columnNumber: 13
      }, void 0) : /* @__PURE__ */ y(fn, { children: /* @__PURE__ */ y("span", { className: "select-all-action-bar-preview-term", children: [
        '"',
        a,
        '"'
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
        lineNumber: 148,
        columnNumber: 15
      }, void 0) }, void 0, !1, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
        lineNumber: 147,
        columnNumber: 13
      }, void 0) }, void 0, !1, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
        lineNumber: 138,
        columnNumber: 9
      }, void 0),
      /* @__PURE__ */ y("div", { className: "select-all-action-bar-separator" }, void 0, !1, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
        lineNumber: 154,
        columnNumber: 9
      }, void 0),
      h && r < i && /* @__PURE__ */ y(fn, { children: [
        /* @__PURE__ */ y(
          "button",
          {
            onClick: w,
            className: "select-all-action-bar-btn select-all-action-bar-btn-primary",
            title: `Select next occurrence (${Kn}+D)`,
            children: /* @__PURE__ */ y(T2, { size: 14 }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
              lineNumber: 164,
              columnNumber: 15
            }, void 0)
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
            lineNumber: 159,
            columnNumber: 13
          },
          void 0
        ),
        /* @__PURE__ */ y(
          "button",
          {
            onClick: E,
            className: "select-all-action-bar-btn select-all-action-bar-btn-secondary",
            title: `Select all remaining (${Kn}+Shift+L)`,
            children: "All"
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
            lineNumber: 166,
            columnNumber: 13
          },
          void 0
        ),
        /* @__PURE__ */ y("div", { className: "select-all-action-bar-separator" }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
          lineNumber: 173,
          columnNumber: 13
        }, void 0)
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
        lineNumber: 158,
        columnNumber: 11
      }, void 0),
      /* @__PURE__ */ y(
        "button",
        {
          onClick: p,
          className: "select-all-action-bar-btn",
          title: `Bold all occurrences (${Kn}+B)`,
          children: /* @__PURE__ */ y(Sl, { size: 14 }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
            lineNumber: 183,
            columnNumber: 11
          }, void 0)
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
          lineNumber: 178,
          columnNumber: 9
        },
        void 0
      ),
      /* @__PURE__ */ y(
        "button",
        {
          onClick: g,
          className: "select-all-action-bar-btn",
          title: `Italic all occurrences (${Kn}+I)`,
          children: /* @__PURE__ */ y(_l, { size: 14 }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
            lineNumber: 190,
            columnNumber: 11
          }, void 0)
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
          lineNumber: 185,
          columnNumber: 9
        },
        void 0
      ),
      /* @__PURE__ */ y(
        "button",
        {
          onClick: b,
          className: "select-all-action-bar-btn",
          title: `Underline all occurrences (${Kn}+U)`,
          children: /* @__PURE__ */ y(Bl, { size: 14 }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
            lineNumber: 197,
            columnNumber: 11
          }, void 0)
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
          lineNumber: 192,
          columnNumber: 9
        },
        void 0
      ),
      /* @__PURE__ */ y(
        "button",
        {
          onClick: v,
          className: "select-all-action-bar-btn",
          title: "Strikethrough all occurrences",
          children: /* @__PURE__ */ y(Ll, { size: 14 }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
            lineNumber: 204,
            columnNumber: 11
          }, void 0)
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
          lineNumber: 199,
          columnNumber: 9
        },
        void 0
      ),
      /* @__PURE__ */ y("div", { className: "select-all-action-bar-separator" }, void 0, !1, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
        lineNumber: 208,
        columnNumber: 9
      }, void 0),
      /* @__PURE__ */ y(
        "button",
        {
          onClick: k,
          className: "select-all-action-bar-btn select-all-action-bar-btn-danger",
          title: "Delete all occurrences",
          children: /* @__PURE__ */ y(ji, { size: 14 }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
            lineNumber: 216,
            columnNumber: 11
          }, void 0)
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
          lineNumber: 211,
          columnNumber: 9
        },
        void 0
      ),
      /* @__PURE__ */ y(
        "button",
        {
          onClick: x,
          className: "select-all-action-bar-btn",
          title: "Exit select all mode (Escape)",
          children: /* @__PURE__ */ y(lo, { size: 14 }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
            lineNumber: 225,
            columnNumber: 11
          }, void 0)
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
          lineNumber: 220,
          columnNumber: 9
        },
        void 0
      )
    ] }, void 0, !0, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
      lineNumber: 128,
      columnNumber: 7
    }, void 0),
    /* @__PURE__ */ y("div", { className: "select-all-action-bar-hint", children: h && r < i ? /* @__PURE__ */ y(fn, { children: [
      /* @__PURE__ */ y("kbd", { children: [
        Kn,
        "+D"
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
        lineNumber: 233,
        columnNumber: 13
      }, void 0),
      " next · ",
      /* @__PURE__ */ y("kbd", { children: [
        Kn,
        "+Shift+L"
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
        lineNumber: 233,
        columnNumber: 42
      }, void 0),
      " all · Type to replace · ",
      /* @__PURE__ */ y("kbd", { children: "Esc" }, void 0, !1, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
        lineNumber: 233,
        columnNumber: 94
      }, void 0),
      " to exit · ",
      /* @__PURE__ */ y("kbd", { children: [
        Kn,
        "+Z"
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
        lineNumber: 233,
        columnNumber: 119
      }, void 0),
      " undo"
    ] }, void 0, !0, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
      lineNumber: 232,
      columnNumber: 11
    }, void 0) : /* @__PURE__ */ y(fn, { children: [
      "Type to replace all · ",
      /* @__PURE__ */ y("kbd", { children: "Esc" }, void 0, !1, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
        lineNumber: 237,
        columnNumber: 35
      }, void 0),
      " to exit · ",
      /* @__PURE__ */ y("kbd", { children: "Backspace" }, void 0, !1, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
        lineNumber: 237,
        columnNumber: 60
      }, void 0),
      " to delete · ",
      /* @__PURE__ */ y("kbd", { children: [
        Kn,
        "+Z"
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
        lineNumber: 237,
        columnNumber: 93
      }, void 0),
      " undo"
    ] }, void 0, !0, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
      lineNumber: 236,
      columnNumber: 11
    }, void 0) }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
      lineNumber: 230,
      columnNumber: 7
    }, void 0)
  ] }, void 0, !0, {
    fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SelectAllActionBar.tsx",
    lineNumber: 127,
    columnNumber: 5
  }, void 0);
}, Oz = si(Rz), pa = "-dismissed";
function Iz(t) {
  let e = 0;
  for (let n = 0; n < t.length; n++) {
    const r = t.charCodeAt(n);
    e = (e << 5) - e + r, e = e & e;
  }
  return e;
}
function Dz(t, e = {}) {
  const {
    storageKey: n = "manus-editor-content",
    debounceMs: r = 1e3,
    enabled: o = !0,
    onSave: i,
    onRecover: s
  } = e, [a, l] = J({
    status: "idle",
    lastSaved: null,
    hasRecoverableContent: !1,
    error: null
  }), c = fe(null), u = fe(""), d = fe(0);
  ge(() => {
    if (o && !(!t || t.isDestroyed))
      try {
        const b = localStorage.getItem(n), v = localStorage.getItem(n + pa);
        if (b && !v) {
          let k = "";
          try {
            k = t.getHTML() || "";
          } catch {
            return;
          }
          b !== k && b.length > 50 && l((x) => ({ ...x, hasRecoverableContent: !0 }));
        }
      } catch (b) {
        console.warn("useAutoSave: Error checking for recoverable content", b);
      }
  }, [t, n, o]);
  const f = ie(() => {
    if (!(!t || !o || t.isDestroyed))
      try {
        const b = t.getHTML(), v = Iz(b);
        if (v === d.current && b.length === u.current.length) {
          l((k) => ({ ...k, status: "saved" }));
          return;
        }
        if (b.length < 20)
          return;
        l((k) => ({ ...k, status: "saving" })), localStorage.setItem(n, b), localStorage.setItem(n + "-timestamp", (/* @__PURE__ */ new Date()).toISOString()), u.current = b, d.current = v, l((k) => ({
          ...k,
          status: "saved",
          lastSaved: /* @__PURE__ */ new Date(),
          error: null
        })), i?.(b), setTimeout(() => {
          l((k) => k.status === "saved" ? { ...k, status: "idle" } : k);
        }, 2e3);
      } catch (b) {
        console.error("useAutoSave: Error saving content", b), l((v) => ({
          ...v,
          status: "error",
          error: b instanceof Error ? b.message : "Failed to save"
        }));
      }
  }, [t, n, o, i]);
  ge(() => {
    if (!t || !o || t.isDestroyed) return;
    const b = () => {
      t.isDestroyed || (c.current && clearTimeout(c.current), c.current = setTimeout(() => {
        f();
      }, r));
    };
    return t.on("update", b), () => {
      t.off("update", b), c.current && clearTimeout(c.current);
    };
  }, [t, r, o, f]), ge(() => {
    if (!t || !o || t.isDestroyed) return;
    const b = () => {
      if (!t.isDestroyed)
        try {
          const v = t.getHTML();
          v.length >= 20 && (localStorage.setItem(n, v), localStorage.setItem(n + "-timestamp", (/* @__PURE__ */ new Date()).toISOString()));
        } catch (v) {
          console.warn("useAutoSave: Error saving on unload", v);
        }
    };
    return window.addEventListener("beforeunload", b), () => {
      window.removeEventListener("beforeunload", b);
    };
  }, [t, n, o]);
  const h = ie(() => {
    c.current && clearTimeout(c.current), f();
  }, [f]), m = ie(() => {
    try {
      localStorage.removeItem(n), localStorage.removeItem(n + "-timestamp"), localStorage.removeItem(n + pa), u.current = "", l({
        status: "idle",
        lastSaved: null,
        hasRecoverableContent: !1,
        error: null
      });
    } catch (b) {
      console.warn("useAutoSave: Error clearing content", b);
    }
  }, [n]), p = ie(() => {
    if (!t || t.isDestroyed) return null;
    try {
      const b = localStorage.getItem(n);
      return b && t && !t.isDestroyed ? (l((v) => ({ ...v, hasRecoverableContent: !1 })), queueMicrotask(() => {
        if (t && !t.isDestroyed)
          try {
            t.commands.setContent(b), u.current = b, localStorage.removeItem(n + pa), s?.(b);
          } catch (v) {
            console.warn("useAutoSave: Error setting content during recovery", v);
          }
      }), b) : null;
    } catch (b) {
      return console.warn("useAutoSave: Error recovering content", b), null;
    }
  }, [t, n, s]), g = ie(() => {
    try {
      localStorage.setItem(n + pa, "true"), l((b) => ({ ...b, hasRecoverableContent: !1 }));
    } catch (b) {
      console.warn("useAutoSave: Error dismissing recovery", b);
    }
  }, [n]);
  return {
    ...a,
    save: h,
    clear: m,
    recover: p,
    dismissRecovery: g
  };
}
const Lz = 200;
function Pz(t, e = {}) {
  const {
    debounceMs: n = 500,
    extendedStats: r = !1,
    enabled: o = !0
  } = e, [i, s] = J({
    words: 0,
    characters: 0,
    charactersWithSpaces: 0,
    paragraphs: 0,
    sentences: 0,
    readingTime: 0,
    isCalculating: !1
  }), a = fe(null), l = fe(""), c = ie((u) => {
    const d = u.trim(), f = d.length > 0 ? d.split(/\s+/).filter((v) => v.length > 0).length : 0, h = d.replace(/\s/g, "").length, m = u.length;
    let p = 0, g = 0;
    r && (p = d.length > 0 ? d.split(/\n\s*\n/).filter((v) => v.trim().length > 0).length : 0, g = d.length > 0 ? (d.match(/[.!?]+/g) || []).length : 0);
    const b = Math.max(1, Math.ceil(f / Lz));
    return {
      words: f,
      characters: h,
      charactersWithSpaces: m,
      paragraphs: p,
      sentences: g,
      readingTime: b,
      isCalculating: !1
    };
  }, [r]);
  return ge(() => {
    if (!t || !o) return;
    const u = () => {
      a.current && clearTimeout(a.current), s((d) => ({ ...d, isCalculating: !0 })), a.current = setTimeout(() => {
        try {
          const d = t.getText();
          if (d === l.current) {
            s((h) => ({ ...h, isCalculating: !1 }));
            return;
          }
          l.current = d;
          const f = c(d);
          s(f);
        } catch (d) {
          console.warn("useWordCount: Error calculating word count", d), s((f) => ({ ...f, isCalculating: !1 }));
        }
      }, n);
    };
    return u(), t.on("update", u), () => {
      t.off("update", u), a.current && clearTimeout(a.current);
    };
  }, [t, n, o, c]), i;
}
function Bz({ status: t, lastSaved: e, className: n = "" }) {
  const r = (o) => {
    if (!o) return "";
    const s = (/* @__PURE__ */ new Date()).getTime() - o.getTime(), a = Math.floor(s / 1e3), l = Math.floor(a / 60), c = Math.floor(l / 60);
    return a < 10 ? "Just now" : a < 60 ? `${a}s ago` : l < 60 ? `${l}m ago` : c < 24 ? `${c}h ago` : o.toLocaleDateString();
  };
  return /* @__PURE__ */ y(
    "div",
    {
      className: `auto-save-indicator flex items-center gap-1.5 text-xs ${n}`,
      title: e ? `Last saved: ${e.toLocaleString()}` : "Not saved yet",
      children: [
        t === "idle" && e && /* @__PURE__ */ y(fn, { children: [
          /* @__PURE__ */ y(h2, { className: "w-3.5 h-3.5 text-muted-foreground" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/AutoSaveIndicator.tsx",
            lineNumber: 40,
            columnNumber: 11
          }, this),
          /* @__PURE__ */ y("span", { className: "text-muted-foreground", children: [
            "Saved ",
            r(e)
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/AutoSaveIndicator.tsx",
            lineNumber: 41,
            columnNumber: 11
          }, this)
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/AutoSaveIndicator.tsx",
          lineNumber: 39,
          columnNumber: 9
        }, this),
        t === "saving" && /* @__PURE__ */ y(fn, { children: [
          /* @__PURE__ */ y(y2, { className: "w-3.5 h-3.5 text-cyan-500 animate-spin" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/AutoSaveIndicator.tsx",
            lineNumber: 47,
            columnNumber: 11
          }, this),
          /* @__PURE__ */ y("span", { className: "text-cyan-500", children: "Saving..." }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/AutoSaveIndicator.tsx",
            lineNumber: 48,
            columnNumber: 11
          }, this)
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/AutoSaveIndicator.tsx",
          lineNumber: 46,
          columnNumber: 9
        }, this),
        t === "saved" && /* @__PURE__ */ y(fn, { children: [
          /* @__PURE__ */ y(yc, { className: "w-3.5 h-3.5 text-emerald-500" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/AutoSaveIndicator.tsx",
            lineNumber: 54,
            columnNumber: 11
          }, this),
          /* @__PURE__ */ y("span", { className: "text-emerald-500", children: "Saved" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/AutoSaveIndicator.tsx",
            lineNumber: 55,
            columnNumber: 11
          }, this)
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/AutoSaveIndicator.tsx",
          lineNumber: 53,
          columnNumber: 9
        }, this),
        t === "error" && /* @__PURE__ */ y(fn, { children: [
          /* @__PURE__ */ y(f2, { className: "w-3.5 h-3.5 text-red-500" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/AutoSaveIndicator.tsx",
            lineNumber: 61,
            columnNumber: 11
          }, this),
          /* @__PURE__ */ y("span", { className: "text-red-500", children: "Save failed" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/AutoSaveIndicator.tsx",
            lineNumber: 62,
            columnNumber: 11
          }, this)
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/AutoSaveIndicator.tsx",
          lineNumber: 60,
          columnNumber: 9
        }, this)
      ]
    },
    void 0,
    !0,
    {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/AutoSaveIndicator.tsx",
      lineNumber: 34,
      columnNumber: 5
    },
    this
  );
}
function zz({ onRecover: t, onDismiss: e, className: n = "" }) {
  return /* @__PURE__ */ y(
    "div",
    {
      className: `recovery-banner flex items-center justify-between gap-4 px-4 py-3 rounded-lg ${n}`,
      children: [
        /* @__PURE__ */ y("div", { className: "flex items-center gap-3 min-w-0", children: [
          /* @__PURE__ */ y(Tl, { className: "w-5 h-5 recovery-banner-icon flex-shrink-0" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/RecoveryBanner.tsx",
            lineNumber: 22,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ y("span", { className: "text-sm recovery-banner-text", children: "We found unsaved content from your last session." }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/RecoveryBanner.tsx",
            lineNumber: 23,
            columnNumber: 9
          }, this)
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/RecoveryBanner.tsx",
          lineNumber: 21,
          columnNumber: 7
        }, this),
        /* @__PURE__ */ y("div", { className: "flex items-center gap-3 flex-shrink-0", children: [
          /* @__PURE__ */ y(
            "button",
            {
              onClick: t,
              className: "recovery-banner-btn flex items-center gap-1.5 px-4 py-2 text-sm font-medium rounded-md transition-colors duration-150",
              children: [
                /* @__PURE__ */ y(_2, { className: "w-4 h-4" }, void 0, !1, {
                  fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/RecoveryBanner.tsx",
                  lineNumber: 33,
                  columnNumber: 11
                }, this),
                "Recover"
              ]
            },
            void 0,
            !0,
            {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/RecoveryBanner.tsx",
              lineNumber: 29,
              columnNumber: 9
            },
            this
          ),
          /* @__PURE__ */ y(
            "button",
            {
              onClick: e,
              className: "recovery-banner-dismiss p-2 rounded-md transition-colors duration-150",
              title: "Dismiss",
              "aria-label": "Dismiss recovery banner",
              children: /* @__PURE__ */ y(lo, { className: "w-5 h-5" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/RecoveryBanner.tsx",
                lineNumber: 43,
                columnNumber: 11
              }, this)
            },
            void 0,
            !1,
            {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/RecoveryBanner.tsx",
              lineNumber: 37,
              columnNumber: 9
            },
            this
          )
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/RecoveryBanner.tsx",
          lineNumber: 28,
          columnNumber: 7
        }, this)
      ]
    },
    void 0,
    !0,
    {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/RecoveryBanner.tsx",
      lineNumber: 18,
      columnNumber: 5
    },
    this
  );
}
const $z = /\[\[([^\[\]]+)\]\]$/, Hz = kn.create({
  name: "wikiLink",
  addOptions() {
    return {
      HTMLAttributes: {},
      onWikiLinkClick: void 0,
      validateLink: void 0,
      linkClass: "wiki-link",
      invalidLinkClass: "wiki-link-invalid"
    };
  },
  addAttributes() {
    return {
      pageName: {
        default: null,
        parseHTML: (t) => t.getAttribute("data-page-name"),
        renderHTML: (t) => t.pageName ? {
          "data-page-name": t.pageName
        } : {}
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "span[data-wiki-link]"
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    const e = t["data-page-name"] || "", n = this.options.validateLink ? this.options.validateLink(e) : !0;
    return [
      "span",
      De(
        this.options.HTMLAttributes,
        t,
        {
          "data-wiki-link": "",
          class: n ? this.options.linkClass : `${this.options.linkClass} ${this.options.invalidLinkClass}`
        }
      ),
      0
    ];
  },
  addCommands() {
    return {
      setWikiLink: (t) => ({ commands: e }) => e.setMark(this.name, t),
      unsetWikiLink: () => ({ commands: t }) => t.unsetMark(this.name)
    };
  },
  addInputRules() {
    const t = this.type;
    return [
      new nn({
        find: $z,
        handler: ({ state: e, range: n, match: r }) => {
          try {
            const o = r[1];
            if (!o) return;
            const { tr: i } = e, s = n.from, a = n.to;
            i.delete(s, a);
            const l = t.create({ pageName: o }), c = e.schema.text(o, [l]);
            i.insert(s, c), this.editor.view.dispatch(i);
          } catch (o) {
            console.warn("WikiLinkSafe: Error in input rule", o);
          }
        }
      })
    ];
  },
  // Handle clicks on wiki links using native event delegation
  onCreate() {
    const { onWikiLinkClick: t } = this.options;
    if (!t) return;
    const e = (n) => {
      const r = n.target;
      if (r.hasAttribute("data-wiki-link")) {
        const o = r.getAttribute("data-page-name");
        o && (n.preventDefault(), t(o));
      }
    };
    this.editor.view.dom.addEventListener("click", e), this._clickHandler = e;
  },
  onDestroy() {
    const t = this._clickHandler;
    t && this.editor.view.dom.removeEventListener("click", t);
  }
}), cr = {
  header: /^#{1,6}\s+/m,
  bold: /\*\*[^*]+\*\*/,
  codeBlock: /```[\s\S]*?```/,
  list: /^\s*[-*]\s+/m,
  taskList: /^\s*[-*]\s*\[[ x]\]/im,
  link: /\[.+\]\(.+\)/,
  // Table pattern: header row with pipes, separator row with dashes, optional data rows
  // Allow headers and separators with or without trailing pipes
  table: /^\|[^\n]+\n\|[-:\s|]+/m,
  // Callout pattern: ```info, ```warning, ```error, ```success, ```note
  callout: /```(?:info|warning|error|success|note)\s*\n[\s\S]*?```/
}, Pg = ["info", "warning", "error", "success", "note"];
function Fz(t) {
  return t.length < 3 ? !1 : !!(cr.header.test(t) || cr.bold.test(t) || cr.list.test(t) || cr.taskList.test(t) || cr.codeBlock.test(t) || cr.callout.test(t) || cr.link.test(t) || cr.table.test(t));
}
function Uz(t) {
  const e = t.trim().split(`
`);
  if (e.length < 2) return "";
  const r = e[0].split("|").map((a) => a.trim()).filter((a) => a.length > 0);
  if (r.length === 0 || !e[1].includes("-")) return "";
  const i = e.slice(2);
  let s = "<table><thead><tr>";
  for (const a of r)
    s += "<th><p>" + a + "</p></th>";
  s += "</tr></thead><tbody>";
  for (const a of i) {
    if (!a.trim()) continue;
    const l = a.split("|"), c = [];
    for (let u = 0; u < l.length; u++) {
      const d = l[u].trim();
      u === 0 && d === "" && a.trim().startsWith("|") || u === l.length - 1 && d === "" && a.trim().endsWith("|") || c.push(d);
    }
    if (c.length !== 0) {
      s += "<tr>";
      for (let u = 0; u < r.length; u++) {
        const d = c[u] || "";
        s += "<td><p>" + d + "</p></td>";
      }
      s += "</tr>";
    }
  }
  return s += "</tbody></table>", s;
}
function Wz(t) {
  let e = t;
  const n = /^(\|[^\n]*(?:\n\|[^\n]*)*)/gm, r = [];
  e = e.replace(n, (s) => {
    const a = s.split(`
`);
    if (a.length >= 2) {
      const l = a[1];
      if (/^\|?[\s\-:|]+\|?$/.test(l) && l.includes("-")) {
        const c = Uz(s);
        if (c) {
          const u = `MANUSTABLEPLACEHOLDER${r.length}END`;
          return r.push(c), u;
        }
      }
    }
    return s;
  }), Pg.forEach((s) => {
    const a = new RegExp(`\`\`\`${s}\\s*\\n([\\s\\S]*?)\`\`\``, "g");
    e = e.replace(a, (l, c) => {
      let u = c.trim();
      return u = u.replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>"), u = u.replace(/__([^_]+)__/g, "<strong>$1</strong>"), u = u.replace(new RegExp("(?<!\\*)\\*([^*]+)\\*(?!\\*)", "g"), "<em>$1</em>"), u = u.replace(new RegExp("(?<!_)_([^_]+)_(?!_)", "g"), "<em>$1</em>"), u = u.replace(/`([^`]+)`/g, "<code>$1</code>"), u.startsWith("<") || (u = `<p>${u}</p>`), `<div data-callout="" data-type="${s}" class="callout callout-${s}">${u}</div>`;
    });
  }), e = e.replace(/```(\w*)\n([\s\S]*?)```/g, (s, a, l) => {
    if (Pg.includes(a))
      return `<div data-callout="" data-type="${a}" class="callout callout-${a}"><p>${l.trim()}</p></div>`;
    const c = a || "plaintext", u = l.trim().replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    return `<pre><code class="language-${c}">${u}</code></pre>`;
  }), e = e.replace(/`([^`]+)`/g, "<code>$1</code>"), e = e.replace(/^(#{1,6})\s+(.+)$/gm, (s, a, l) => {
    const c = a.length;
    return `<h${c}>${l}</h${c}>`;
  }), e = e.replace(/^(\s*)[-*]\s*\[x\]\s+(.+)$/gim, '$1<li data-type="taskItem" data-checked="true"><p>$2</p></li>'), e = e.replace(/^(\s*)[-*]\s*\[\s*\]\s+(.+)$/gim, '$1<li data-type="taskItem" data-checked="false"><p>$2</p></li>'), e = e.replace(/^(\s*)[-*]\s+(?!\[)(.+)$/gm, "$1<li><p>$2</p></li>"), e = e.replace(/^(\s*)\d+\.\s+(.+)$/gm, "$1<li><p>$2</p></li>"), e = e.replace(/(<li data-type="taskItem"[^>]*>[\s\S]*?<\/li>\n?)+/g, '<ul data-type="taskList">$&</ul>'), e = e.replace(/(<li><p>[\s\S]*?<\/p><\/li>\n?)+/g, "<ul>$&</ul>"), e = e.replace(/^>\s+(.+)$/gm, "<blockquote><p>$1</p></blockquote>"), e = e.replace(/^[-*_]{3,}$/gm, "<hr>"), e = e.replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>"), e = e.replace(/__([^_]+)__/g, "<strong>$1</strong>"), e = e.replace(new RegExp("(?<!\\*)\\*([^*]+)\\*(?!\\*)", "g"), "<em>$1</em>"), e = e.replace(new RegExp("(?<!_)_([^_]+)_(?!_)", "g"), "<em>$1</em>"), e = e.replace(/~~([^~]+)~~/g, "<s>$1</s>"), e = e.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1">'), e = e.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>'), e = e.split(`
`).map((s) => {
    const a = s.trim();
    return a ? /^<[a-z]/.test(a) || /^<\//.test(a) || a.startsWith("MANUSTABLEPLACEHOLDER") ? s : `<p>${a}</p>` : "";
  }).join(`
`), e = e.replace(/<p>\s*<\/p>/g, "");
  for (let s = 0; s < r.length; s++)
    e = e.replace(`MANUSTABLEPLACEHOLDER${s}END`, r[s]);
  return e;
}
const Vz = Re.create({
  name: "markdownPasteSafe",
  addOptions() {
    return {
      enableMarkdownPaste: !0
    };
  },
  addProseMirrorPlugins() {
    if (!this.options.enableMarkdownPaste)
      return [];
    const t = this.editor;
    return [
      new Ce({
        key: new Ie("markdownPaste"),
        props: {
          handlePaste(e, n, r) {
            const o = n.clipboardData;
            if (!o) return !1;
            const i = o.getData("text/html");
            if (i && i.trim())
              return !1;
            const s = o.getData("text/plain");
            if (!s || !Fz(s))
              return !1;
            n.preventDefault();
            const a = Wz(s);
            return t.commands.insertContent(a, {
              parseOptions: {
                preserveWhitespace: !1
              }
            }), !0;
          }
        }
      })
    ];
  }
}), Bg = new Ie("collapsibleHeading");
function Ul(t, e, n) {
  return `h${e}-${n}-${t.textContent.slice(0, 50)}`;
}
let qo = null;
function Ru(t, e, n) {
  const r = [], o = [];
  t.descendants((l, c) => {
    if (l.type.name === "heading" && n.levels.includes(l.attrs.level)) {
      const u = Ul(l, l.attrs.level, c);
      o.push({
        pos: c,
        level: l.attrs.level,
        id: u,
        isCollapsed: e.collapsedHeadings.has(u),
        nodeSize: l.nodeSize
      });
    }
  });
  const i = [];
  for (let l = 0; l < o.length; l++) {
    const c = o[l];
    if (c.isCollapsed) {
      const u = c.pos + c.nodeSize;
      let d = t.content.size;
      for (let f = l + 1; f < o.length; f++)
        if (o[f].level <= c.level) {
          d = o[f].pos;
          break;
        }
      u < d && i.push({ start: u, end: d });
    }
  }
  const s = [];
  for (const l of i)
    if (s.length === 0)
      s.push(l);
    else {
      const c = s[s.length - 1];
      l.start <= c.end ? c.end = Math.max(c.end, l.end) : s.push(l);
    }
  function a(l) {
    for (const c of s)
      if (l >= c.start && l < c.end) return !0;
    return !1;
  }
  return t.descendants((l, c) => {
    if (l.type.name === "heading" && n.levels.includes(l.attrs.level)) {
      const u = Ul(l, l.attrs.level, c), d = e.collapsedHeadings.has(u), f = a(c);
      r.push(
        Ve.node(c, c + l.nodeSize, {
          class: `collapsible-heading collapsible-heading-level-${l.attrs.level} ${d ? "is-collapsed" : "is-expanded"}${f ? " collapsible-heading-hidden" : ""}`,
          "data-heading-id": u,
          "data-heading-level": String(l.attrs.level)
        })
      );
      const h = Ve.widget(c + l.nodeSize - 1, () => {
        const m = document.querySelector(`button.collapsible-heading-chevron[data-heading-id="${u}"]`);
        if (m) {
          m.classList.contains("collapsed") !== d && (m.classList.remove("collapsed", "expanded"), m.classList.add(d ? "collapsed" : "expanded"), m.title = d ? "Click to expand" : "Click to collapse");
          const v = m.parentElement;
          if (v) return v;
        }
        const p = document.createElement("span");
        p.className = "collapsible-heading-chevron-wrapper", p.setAttribute("contenteditable", "false");
        const g = document.createElement("button");
        return g.className = `collapsible-heading-chevron ${d ? "collapsed" : "expanded"}`, g.setAttribute("data-heading-id", u), g.setAttribute("data-heading-level", String(l.attrs.level)), g.setAttribute("contenteditable", "false"), g.setAttribute("tabindex", "-1"), g.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="9 18 15 12 9 6"></polyline></svg>', g.title = d ? "Click to expand" : "Click to collapse", g.addEventListener("click", (b) => {
          b.preventDefault(), b.stopPropagation();
          const v = g.classList.contains("collapsed");
          g.classList.remove("collapsed", "expanded"), g.classList.add(v ? "expanded" : "collapsed"), g.title = v ? "Click to collapse" : "Click to expand", e.collapsedHeadings.has(u) ? e.collapsedHeadings.delete(u) : e.collapsedHeadings.add(u), qo && qo.dispatch(qo.state.tr.setMeta("collapsibleHeading", { toggled: u }));
        }), p.appendChild(g), p;
      }, { side: 1, key: `chevron-${u}` });
      r.push(h);
    } else l.isBlock && a(c) && r.push(
      Ve.node(c, c + l.nodeSize, {
        class: "collapsible-heading-hidden"
      })
    );
  }), Te.create(t, r);
}
const Kz = Re.create({
  name: "collapsibleHeading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6]
    };
  },
  addStorage() {
    return {
      collapsedHeadings: /* @__PURE__ */ new Set()
    };
  },
  addCommands() {
    return {
      toggleHeadingCollapse: (t) => ({ editor: e, tr: n }) => {
        const r = this.storage, o = n.doc.nodeAt(t);
        if (!o || o.type.name !== "heading")
          return !1;
        const i = Ul(o, o.attrs.level, t);
        return r.collapsedHeadings.has(i) ? r.collapsedHeadings.delete(i) : r.collapsedHeadings.add(i), e.view.dispatch(n.setMeta("collapsibleHeading", { toggled: i })), !0;
      },
      expandAllHeadings: () => ({ editor: t, tr: e }) => (this.storage.collapsedHeadings.clear(), t.view.dispatch(e.setMeta("collapsibleHeading", { expandAll: !0 })), !0),
      collapseAllHeadings: () => ({ editor: t, tr: e }) => {
        const n = this.storage;
        return e.doc.descendants((o, i) => {
          o.type.name === "heading" && n.collapsedHeadings.add(Ul(o, o.attrs.level, i));
        }), t.view.dispatch(e.setMeta("collapsibleHeading", { collapseAll: !0 })), !0;
      }
    };
  },
  addProseMirrorPlugins() {
    const t = this.storage, e = this.options;
    return [
      new Ce({
        key: Bg,
        view(n) {
          return qo = n, {
            update(r) {
              qo = r;
            },
            destroy() {
              qo = null;
            }
          };
        },
        state: {
          init(n, r) {
            return {
              collapsedHeadings: /* @__PURE__ */ new Set(),
              decorations: Ru(r.doc, t, e),
              docVersion: 0
            };
          },
          apply(n, r, o, i) {
            return n.getMeta("collapsibleHeading") || n.docChanged ? {
              collapsedHeadings: new Set(t.collapsedHeadings),
              decorations: Ru(i.doc, t, e),
              docVersion: r.docVersion + 1
            } : {
              ...r,
              decorations: r.decorations.map(n.mapping, n.doc)
            };
          }
        },
        props: {
          decorations(n) {
            const r = Bg.getState(n);
            return r?.decorations ? r.decorations : Ru(n.doc, t, e);
          }
        }
      })
    ];
  }
}), qz = /\[([^\]]+)\]\(([^)]+)\)$/, Gz = /^(https?:\/\/|www\.)[^\s]+$/i, jz = Re.create({
  name: "markdownLinkInputRule",
  addInputRules() {
    return [
      new nn({
        find: qz,
        handler: ({ state: t, range: e, match: n, chain: r }) => {
          const o = n[1];
          let i = n[2];
          i && !i.startsWith("http://") && !i.startsWith("https://") && (i.startsWith("www."), i = "https://" + i), r().deleteRange(e).insertContent({
            type: "text",
            text: o,
            marks: [
              {
                type: "link",
                attrs: {
                  href: i,
                  target: "_blank",
                  rel: "noopener noreferrer"
                }
              }
            ]
          }).run();
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const t = this.editor;
    return [
      new Ce({
        key: new Ie("pasteUrlAsLink"),
        props: {
          handlePaste(e, n) {
            const r = n.clipboardData;
            if (!r) return !1;
            const o = r.getData("text/plain");
            if (!o) return !1;
            const i = o.trim();
            if (!Gz.test(i)) return !1;
            const { state: s } = e, { selection: a } = s, { from: l, to: c, empty: u } = a;
            let d = i;
            if (!d.startsWith("http://") && !d.startsWith("https://") && (d.startsWith("www."), d = "https://" + d), !u && s.doc.textBetween(l, c))
              return t.chain().focus().extendMarkRange("link").setLink({ href: d }).run(), !0;
            const f = s.schema.marks.link.create({ href: d }), h = s.tr;
            return h.insertText(d, l, c), h.addMark(l, l + d.length, f), e.dispatch(h), !0;
          }
        }
      })
    ];
  }
}), Yz = ["info", "warning", "error", "success", "note"], Xz = Re.create({
  name: "calloutInputRule",
  addProseMirrorPlugins() {
    const t = this.editor;
    return [
      new Ce({
        key: new Ie("calloutInputRule"),
        props: {
          handleKeyDown(e, n) {
            if (n.key !== "Enter") return !1;
            const { state: r } = e, { selection: o, doc: i } = r, { $from: s } = o, a = s.start();
            s.end();
            const l = i.textBetween(a, s.pos, ""), c = l.trim();
            for (const u of Yz)
              if (c === `\`\`\`${u}`) {
                n.preventDefault();
                const d = r.tr, f = a + l.indexOf("```");
                d.delete(f, s.pos);
                const h = t.schema.nodes.callout, m = t.schema.nodes.paragraph;
                if (h && m) {
                  const p = m.create(), g = h.create({ type: u }, D.from(p));
                  d.insert(f, g);
                  const b = d.doc.resolve(f + 2);
                  d.setSelection(ce.near(b)), e.dispatch(d);
                }
                return !0;
              }
            return !1;
          }
        }
      })
    ];
  }
}), ga = new Ie("searchHighlight"), Zz = Re.create({
  name: "searchHighlight",
  addOptions() {
    return {
      searchTerm: "",
      caseSensitive: !1,
      useRegex: !1,
      currentMatchIndex: 0
    };
  },
  addStorage() {
    return {
      searchTerm: "",
      caseSensitive: !1,
      useRegex: !1,
      currentMatchIndex: 0
    };
  },
  addCommands() {
    return {
      setSearchHighlight: (t) => ({ editor: e, tr: n, dispatch: r }) => (this.storage.searchTerm = t.searchTerm ?? this.storage.searchTerm, this.storage.caseSensitive = t.caseSensitive ?? this.storage.caseSensitive, this.storage.useRegex = t.useRegex ?? this.storage.useRegex, this.storage.currentMatchIndex = t.currentMatchIndex ?? this.storage.currentMatchIndex, r && r(n.setMeta(ga, { update: !0 })), !0),
      clearSearchHighlight: () => ({ editor: t, tr: e, dispatch: n }) => (this.storage.searchTerm = "", this.storage.caseSensitive = !1, this.storage.useRegex = !1, this.storage.currentMatchIndex = 0, n && n(e.setMeta(ga, { update: !0 })), !0)
    };
  },
  addProseMirrorPlugins() {
    const t = this.storage;
    return [
      new Ce({
        key: ga,
        state: {
          init() {
            return Te.empty;
          },
          apply(e, n, r, o) {
            const { searchTerm: i, caseSensitive: s, useRegex: a, currentMatchIndex: l } = t, c = e.getMeta(ga), u = e.docChanged;
            if (!i)
              return Te.empty;
            if (!u && !c)
              return n.map(e.mapping, o.doc);
            const d = [];
            let f = 0;
            try {
              let h;
              if (a)
                h = new RegExp(i, s ? "g" : "gi");
              else {
                const m = i.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
                h = new RegExp(m, s ? "g" : "gi");
              }
              o.doc.descendants((m, p) => {
                if (m.isText && m.text) {
                  let g;
                  for (; (g = h.exec(m.text)) !== null; ) {
                    const b = p + g.index, v = p + g.index + g[0].length, k = f === l;
                    d.push(
                      Ve.inline(b, v, {
                        class: k ? "search-highlight-current" : "search-highlight"
                      })
                    ), f++;
                  }
                }
                return !0;
              });
            } catch {
              return Te.empty;
            }
            return Te.create(o.doc, d);
          }
        },
        props: {
          decorations(e) {
            return this.getState(e);
          }
        }
      })
    ];
  }
}), Jz = Re.create({
  name: "tabIndent",
  // Set higher priority to ensure this extension handles Tab before other extensions
  priority: 1e3,
  addProseMirrorPlugins() {
    const t = this.editor;
    return [
      Iy({
        Tab: (e, n) => {
          const { $from: r } = e.selection;
          let o = !1, i = !1;
          for (let s = r.depth; s >= 0; s--) {
            const a = r.node(s);
            if (a.type.name === "taskList") {
              o = !0, i = !0;
              break;
            }
            if (a.type.name === "bulletList" || a.type.name === "orderedList") {
              o = !0;
              break;
            }
          }
          return o && (i ? t.chain().focus().sinkListItem("taskItem").run() : t.chain().focus().sinkListItem("listItem").run()), !0;
        },
        "Shift-Tab": (e, n) => {
          const { $from: r } = e.selection;
          let o = !1, i = !1;
          for (let s = r.depth; s >= 0; s--) {
            const a = r.node(s);
            if (a.type.name === "taskList") {
              o = !0, i = !0;
              break;
            }
            if (a.type.name === "bulletList" || a.type.name === "orderedList") {
              o = !0;
              break;
            }
          }
          return o && (i ? t.chain().focus().liftListItem("taskItem").run() : t.chain().focus().liftListItem("listItem").run()), !0;
        }
      })
    ];
  }
}), yt = new Ie("selectAllOccurrences");
function zg(t, e, n, r, o) {
  const i = [];
  if (!e) return i;
  let s;
  try {
    if (r)
      s = new RegExp(e, n ? "g" : "gi");
    else {
      let a = e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      o && (a = `\\b${a}\\b`), s = new RegExp(a, n ? "g" : "gi");
    }
  } catch {
    return i;
  }
  return t.descendants((a, l) => {
    if (a.isText && a.text) {
      let c;
      for (; (c = s.exec(a.text)) !== null; )
        i.push({
          from: l + c.index,
          to: l + c.index + c[0].length,
          text: c[0]
        });
    }
    return !0;
  }), i;
}
function ur(t, e) {
  const n = yt.getState(t.state);
  if (!n) return [];
  const r = [];
  return n.find().forEach((o) => {
    if (o.from === o.to) return;
    const i = t.state.doc.textBetween(o.from, o.to, "");
    r.push({ from: o.from, to: o.to, text: i });
  }), r;
}
function Qz(t, e) {
  for (let n = 0; n < t.length; n++)
    if (t[n].from >= e) return n;
  return 0;
}
function dt(t) {
  t.isActive = !1, t.ranges = [], t.searchTerm = "", t.typedBuffer = "", t.isTypingReplace = !1, t.allMatches = [], t.nextMatchIndex = 0, t.isIncremental = !1, t.undoStack = [], t.redoStack = [];
}
const e3 = Re.create({
  name: "selectAllOccurrences",
  addStorage() {
    return {
      isActive: !1,
      ranges: [],
      searchTerm: "",
      caseSensitive: !1,
      useRegex: !1,
      wholeWord: !1,
      typedBuffer: "",
      isTypingReplace: !1,
      originalTermLength: 0,
      allMatches: [],
      nextMatchIndex: 0,
      isIncremental: !1,
      undoStack: [],
      redoStack: []
    };
  },
  addCommands() {
    return {
      /**
       * Activate "Select All Occurrences" mode — highlights ALL matches at once.
       */
      selectAllOccurrences: (t) => ({ editor: e, tr: n, dispatch: r }) => {
        const {
          searchTerm: o,
          caseSensitive: i = !1,
          useRegex: s = !1,
          wholeWord: a = !1
        } = t;
        if (!o) return !1;
        const l = zg(e.state.doc, o, i, s, a);
        return l.length === 0 ? !1 : (this.storage.isActive = !0, this.storage.ranges = l, this.storage.searchTerm = o, this.storage.caseSensitive = i, this.storage.useRegex = s, this.storage.wholeWord = a, this.storage.typedBuffer = "", this.storage.isTypingReplace = !1, this.storage.originalTermLength = o.length, this.storage.allMatches = l, this.storage.nextMatchIndex = l.length, this.storage.isIncremental = !1, this.storage.undoStack = [], this.storage.redoStack = [], r && r(n.setMeta(yt, { activate: !0 })), !0);
      },
      /**
       * Select the next occurrence incrementally (Cmd+D behavior).
       * First call: selects the word under cursor or current selection.
       * Subsequent calls: add the next match to the selection.
       */
      selectNextOccurrence: () => ({ editor: t, tr: e, dispatch: n }) => {
        const r = this.storage;
        if (!r.isActive) {
          const { state: o } = t, { from: i, to: s } = o.selection;
          let a = "";
          if (i !== s)
            a = o.doc.textBetween(i, s, "");
          else {
            const d = o.doc.resolve(i), f = d.parent;
            if (f.isTextblock) {
              const h = f.textContent, m = d.parentOffset;
              let p = m, g = m;
              for (; p > 0 && /\w/.test(h[p - 1]); ) p--;
              for (; g < h.length && /\w/.test(h[g]); ) g++;
              p < g && (a = h.slice(p, g));
            }
          }
          if (!a) return !1;
          const l = zg(o.doc, a, !1, !1, !1);
          if (l.length === 0) return !1;
          const c = Qz(l, i), u = l[c];
          return r.isActive = !0, r.ranges = [u], r.searchTerm = a, r.caseSensitive = !1, r.useRegex = !1, r.wholeWord = !1, r.typedBuffer = "", r.isTypingReplace = !1, r.originalTermLength = a.length, r.allMatches = l, r.nextMatchIndex = (c + 1) % l.length, r.isIncremental = !0, r.undoStack = [], r.redoStack = [], n && n(e.setMeta(yt, { activate: !0 })), setTimeout(() => {
            try {
              const d = t.view.domAtPos(u.from);
              d.node && d.node.parentElement?.scrollIntoView({ behavior: "smooth", block: "center" });
            } catch {
            }
          }, 20), !0;
        }
        if (r.isIncremental && r.allMatches.length > 0) {
          const o = r.nextMatchIndex, i = r.allMatches[o];
          return r.ranges.some(
            (a) => a.from === i.from && a.to === i.to
          ) ? !1 : (r.ranges = [...r.ranges, i], r.nextMatchIndex = (o + 1) % r.allMatches.length, r.ranges.length >= r.allMatches.length && (r.isIncremental = !1), n && n(e.setMeta(yt, { activate: !0 })), setTimeout(() => {
            try {
              const a = t.view.domAtPos(i.from);
              a.node && a.node.parentElement?.scrollIntoView({ behavior: "smooth", block: "center" });
            } catch {
            }
          }, 20), !0);
        }
        return !1;
      },
      /**
       * Deactivate "Select All Occurrences" mode and clear highlights.
       */
      clearAllOccurrences: () => ({ tr: t, dispatch: e }) => (dt(this.storage), e && e(t.setMeta(yt, { deactivate: !0 })), !0),
      /**
       * Apply a mark (bold, italic, etc.) to all selected occurrences in one transaction.
       * All changes are in a single transaction for proper undo/redo.
       */
      toggleMarkOnAllOccurrences: (t) => ({ editor: e, tr: n, dispatch: r }) => {
        if (!this.storage.isActive || this.storage.ranges.length === 0) return !1;
        const o = e.schema.marks[t];
        if (!o) return !1;
        const { ranges: i } = this.storage, s = i.every((a) => {
          let l = !0;
          return e.state.doc.nodesBetween(a.from, a.to, (c) => {
            c.isText && !o.isInSet(c.marks) && (l = !1);
          }), l;
        });
        if (r) {
          for (const a of i)
            s ? n.removeMark(a.from, a.to, o) : n.addMark(a.from, a.to, o.create());
          r(n);
        }
        return setTimeout(() => {
          try {
            const a = e.view;
            if (a) {
              const l = ur(a, this.storage);
              this.storage.ranges = l, l.length === 0 && dt(this.storage);
            }
          } catch {
          }
        }, 10), !0;
      },
      /**
       * Delete all selected occurrences in a single transaction.
       */
      deleteAllOccurrences: () => ({ editor: t, tr: e, dispatch: n }) => {
        if (!this.storage.isActive || this.storage.ranges.length === 0) return !1;
        if (n) {
          const r = [...this.storage.ranges].sort((o, i) => i.from - o.from);
          for (const o of r)
            e.delete(o.from, o.to);
          n(e);
        }
        return dt(this.storage), !0;
      },
      /**
       * Replace all selected occurrences with new text in a single transaction.
       */
      replaceAllOccurrences: (t) => ({ editor: e, tr: n, dispatch: r }) => {
        if (!this.storage.isActive || this.storage.ranges.length === 0) return !1;
        if (r) {
          const o = [...this.storage.ranges].sort((i, s) => s.from - i.from);
          for (const i of o)
            n.replaceWith(i.from, i.to, e.schema.text(t));
          r(n);
        }
        return t ? setTimeout(() => {
          try {
            const o = e.view;
            if (o) {
              const i = ur(o, this.storage);
              this.storage.ranges = i, this.storage.searchTerm = t, i.length === 0 && dt(this.storage);
            }
          } catch {
          }
        }, 10) : dt(this.storage), !0;
      },
      /**
       * Get the current state of Select All Occurrences mode.
       */
      getOccurrencesState: () => () => !0
    };
  },
  addKeyboardShortcuts() {
    return {
      // Cmd+D / Ctrl+D: select next occurrence incrementally
      "Mod-d": () => this.editor.commands.selectNextOccurrence()
    };
  },
  addProseMirrorPlugins() {
    const t = this.storage;
    return [
      new Ce({
        key: yt,
        state: {
          init() {
            return Te.empty;
          },
          apply(e, n, r, o) {
            const i = e.getMeta(yt);
            if (i?.deactivate || !t.isActive)
              return Te.empty;
            if (i?.activate || i?.refresh) {
              const s = [];
              for (const a of t.ranges) {
                s.push(
                  Ve.inline(a.from, a.to, {
                    class: "select-all-occurrence-highlight",
                    "data-occurrence": "true"
                  })
                );
                const l = document.createElement("span");
                l.className = "select-all-multi-cursor", l.setAttribute("aria-hidden", "true"), s.push(
                  Ve.widget(a.to, l, {
                    side: 1,
                    key: `cursor-${a.from}-${a.to}`
                  })
                );
              }
              return Te.create(o.doc, s);
            }
            return e.docChanged ? n.map(e.mapping, o.doc) : n;
          }
        },
        props: {
          decorations(e) {
            return this.getState(e);
          },
          // Clicking outside the highlighted ranges exits the mode
          handleClick(e, n) {
            if (!t.isActive) return !1;
            if (!t.ranges.some(
              (o) => n >= o.from && n <= o.to
            )) {
              dt(t);
              const { tr: o } = e.state;
              e.dispatch(o.setMeta(yt, { deactivate: !0 }));
            }
            return !1;
          },
          /**
           * Intercept keystrokes when Select All mode is active.
           * - Escape: exit mode
           * - Backspace: delete one char from typed buffer, or delete all occurrences if buffer empty
           * - Cmd+Z / Ctrl+Z: undo the last batch replacement step
           * - Formatting shortcuts (Cmd+B, Cmd+I, etc.): let them through for batch formatting
           */
          handleKeyDown(e, n) {
            if (!t.isActive) return !1;
            if (n.key === "Escape") {
              dt(t);
              const { tr: r } = e.state;
              return e.dispatch(r.setMeta(yt, { deactivate: !0 })), !0;
            }
            if ((n.metaKey || n.ctrlKey) && n.key === "z" && !n.shiftKey) {
              if (n.preventDefault(), t.isTypingReplace && t.undoStack.length > 0) {
                t.redoStack.push(t.typedBuffer);
                const o = t.undoStack.pop();
                return t.typedBuffer = o, o === "" && (t.isTypingReplace = !1), Zf(e.state, e.dispatch), setTimeout(() => {
                  const i = ur(e);
                  t.ranges = i, i.length === 0 && dt(t);
                }, 10), !0;
              }
              dt(t);
              const { tr: r } = e.state;
              return e.dispatch(r.setMeta(yt, { deactivate: !0 })), !1;
            }
            if ((n.metaKey || n.ctrlKey) && (n.key === "z" && n.shiftKey || n.key === "y")) {
              if (n.preventDefault(), t.redoStack.length > 0) {
                t.undoStack.push(t.isTypingReplace ? t.typedBuffer : "");
                const o = t.redoStack.pop();
                return t.typedBuffer = o, t.isTypingReplace = !0, Jf(e.state, e.dispatch), setTimeout(() => {
                  const i = ur(e);
                  t.ranges = i, i.length === 0 && dt(t);
                }, 10), !0;
              }
              dt(t);
              const { tr: r } = e.state;
              return e.dispatch(r.setMeta(yt, { deactivate: !0 })), !1;
            }
            if (n.metaKey || n.ctrlKey)
              return !1;
            if (n.key === "Backspace") {
              if (n.preventDefault(), t.isTypingReplace && t.typedBuffer.length > 0) {
                t.undoStack.push(t.typedBuffer), t.typedBuffer = t.typedBuffer.slice(0, -1);
                const r = ur(e);
                if (r.length === 0) {
                  dt(t);
                  const { tr: a } = e.state;
                  return e.dispatch(a.setMeta(yt, { deactivate: !0 })), !0;
                }
                const o = t.typedBuffer.length > 0 ? t.typedBuffer : t.searchTerm, i = [...r].sort((a, l) => l.from - a.from), { tr: s } = e.state;
                for (const a of i)
                  s.replaceWith(a.from, a.to, e.state.schema.text(o));
                e.dispatch(s), t.typedBuffer.length === 0 && (t.isTypingReplace = !1), setTimeout(() => {
                  const a = ur(e);
                  t.ranges = a, a.length === 0 && dt(t);
                }, 10);
              } else if (!t.isTypingReplace) {
                const r = [...t.ranges].sort((s, a) => a.from - s.from), { tr: o } = e.state;
                for (const s of r)
                  o.delete(s.from, s.to);
                e.dispatch(o), dt(t);
                const { tr: i } = e.state;
                e.dispatch(i.setMeta(yt, { deactivate: !0 }));
              }
              return !0;
            }
            if (n.key === "Delete") {
              n.preventDefault();
              const r = [...t.ranges].sort((s, a) => a.from - s.from), { tr: o } = e.state;
              for (const s of r)
                o.delete(s.from, s.to);
              e.dispatch(o), dt(t);
              const { tr: i } = e.state;
              return e.dispatch(i.setMeta(yt, { deactivate: !0 })), !0;
            }
            if (["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Tab", "Home", "End"].includes(n.key)) {
              dt(t);
              const { tr: r } = e.state;
              return e.dispatch(r.setMeta(yt, { deactivate: !0 })), !1;
            }
            if (n.key === "Enter") {
              dt(t);
              const { tr: r } = e.state;
              return e.dispatch(r.setMeta(yt, { deactivate: !0 })), !1;
            }
            return !1;
          },
          /**
           * Intercept text input (typed characters) for batch replacement.
           * 
           * Each keystroke creates a single transaction that replaces all occurrences,
           * making each step individually undoable via Cmd+Z.
           * 
           * KEY FIX: Instead of re-searching the document after replacement (which
           * would find false matches), we rely on ProseMirror's decoration mapping
           * to track where the replaced text lives.
           */
          handleTextInput(e, n, r, o) {
            if (!t.isActive || !o) return !1;
            const i = ur(e);
            if (i.length === 0) {
              dt(t);
              const { tr: l } = e.state;
              return e.dispatch(l.setMeta(yt, { deactivate: !0 })), !0;
            }
            t.undoStack.push(t.isTypingReplace ? t.typedBuffer : ""), t.redoStack = [], t.isTypingReplace ? t.typedBuffer += o : (t.isTypingReplace = !0, t.typedBuffer = o);
            const s = [...i].sort((l, c) => c.from - l.from), { tr: a } = e.state;
            for (const l of s)
              a.replaceWith(l.from, l.to, e.state.schema.text(t.typedBuffer));
            return e.dispatch(a), setTimeout(() => {
              const l = ur(e);
              t.ranges = l, l.length === 0 && dt(t);
            }, 10), !0;
          }
        }
      })
    ];
  }
});
function t3(t) {
  return new Promise((e, n) => {
    const r = new FileReader();
    r.onload = () => {
      typeof r.result == "string" ? e(r.result) : n(new Error("Failed to read file"));
    }, r.onerror = () => n(new Error("Failed to read file")), r.readAsDataURL(t);
  });
}
function n3(t, e) {
  return e.includes(t.type);
}
function r3(t) {
  return new Promise((e) => {
    const n = new Image();
    n.onload = () => {
      e({ width: n.width, height: n.height });
    }, n.onerror = () => {
      e({ width: 400, height: 300 });
    }, n.src = t;
  });
}
async function o3(t, e, n) {
  return new Promise((r, o) => {
    const i = new Image(), s = new FileReader();
    s.onload = (a) => {
      i.src = a.target?.result;
    }, s.onerror = () => o(new Error("Failed to read file")), i.onload = () => {
      let a = i.width, l = i.height;
      if (a > e) {
        const p = e / a;
        a = e, l = Math.round(l * p);
      }
      const c = document.createElement("canvas");
      c.width = a, c.height = l;
      const u = c.getContext("2d");
      if (!u) {
        o(new Error("Failed to get canvas context"));
        return;
      }
      u.imageSmoothingEnabled = !0, u.imageSmoothingQuality = "high", u.drawImage(i, 0, 0, a, l);
      const d = t.type === "image/png" || t.type === "image/gif", f = d ? "image/png" : "image/jpeg", h = d ? void 0 : n, m = c.toDataURL(f, h);
      r({ dataUrl: m, width: a, height: l });
    }, i.onerror = () => o(new Error("Failed to load image")), s.readAsDataURL(t);
  });
}
async function $g(t, e, n) {
  if (!n3(t, n.allowedMimeTypes))
    return n.onUploadError?.(`Invalid file type: ${t.type}. Allowed types: ${n.allowedMimeTypes.join(", ")}`), !1;
  if (t.size > n.maxFileSize) {
    const r = (n.maxFileSize / 1048576).toFixed(1), o = (t.size / (1024 * 1024)).toFixed(1);
    return n.onUploadError?.(`File too large: ${o}MB. Maximum size: ${r}MB`), !1;
  }
  try {
    n.onUploadStart?.();
    let r, o;
    const i = ["image/jpeg", "image/png", "image/webp"].includes(t.type);
    if (n.enableCompression && i) {
      const s = await o3(
        t,
        n.maxCompressedWidth,
        n.compressionQuality
      );
      r = s.dataUrl, o = Math.min(s.width, 600);
    } else {
      r = await t3(t);
      const s = await r3(r);
      o = Math.min(s.width, 600);
    }
    return e.chain().focus().setImage({
      src: r,
      alt: t.name,
      width: o
    }).run(), n.onUploadComplete?.(), !0;
  } catch (r) {
    return n.onUploadError?.(`Failed to process image: ${r instanceof Error ? r.message : "Unknown error"}`), !1;
  }
}
function Hg(t) {
  const e = [];
  if (t.items)
    for (let n = 0; n < t.items.length; n++) {
      const r = t.items[n];
      if (r.kind === "file" && r.type.startsWith("image/")) {
        const o = r.getAsFile();
        o && e.push(o);
      }
    }
  if (e.length === 0 && t.files)
    for (let n = 0; n < t.files.length; n++) {
      const r = t.files[n];
      r.type.startsWith("image/") && e.push(r);
    }
  return e;
}
const i3 = Re.create({
  name: "imageUpload",
  addOptions() {
    return {
      maxFileSize: 5 * 1024 * 1024,
      // 5MB default
      allowedMimeTypes: [
        "image/jpeg",
        "image/png",
        "image/gif",
        "image/webp",
        "image/svg+xml"
      ],
      enableCompression: !0,
      // Enable compression by default
      maxCompressedWidth: 1200,
      // Max width for compressed images
      compressionQuality: 0.8,
      // JPEG quality (0-1)
      onUploadStart: void 0,
      onUploadComplete: void 0,
      onUploadError: void 0
    };
  },
  addProseMirrorPlugins() {
    const t = this.options, e = this.editor;
    return [
      new Ce({
        key: new Ie("imageUpload"),
        props: {
          // Handle paste events with images
          handlePaste(n, r) {
            const o = r.clipboardData;
            if (!o) return !1;
            const i = Hg(o);
            return i.length === 0 ? !1 : (r.preventDefault(), i.forEach((s) => {
              $g(s, e, t);
            }), !0);
          },
          // Handle drop events with images
          handleDrop(n, r, o, i) {
            if (i) return !1;
            const s = r.dataTransfer;
            if (!s) return !1;
            const a = Hg(s);
            if (a.length === 0)
              return !1;
            r.preventDefault();
            const l = n.posAtCoords({
              left: r.clientX,
              top: r.clientY
            });
            if (l) {
              const c = n.state.tr.setSelection(
                ce.near(n.state.doc.resolve(l.pos))
              );
              n.dispatch(c);
            }
            return a.forEach((c) => {
              $g(c, e, t);
            }), !0;
          }
        }
      })
    ];
  }
});
function s3({ containerRef: t, enabled: e = !0 }) {
  const [n, r] = J(!1), [o, i] = J(0), s = ie((u) => {
    u.preventDefault(), u.stopPropagation(), u.dataTransfer?.types.includes("Files") && (i((d) => d + 1), r(!0));
  }, []), a = ie((u) => {
    u.preventDefault(), u.stopPropagation(), i((d) => {
      const f = d - 1;
      return f === 0 && r(!1), f;
    });
  }, []), l = ie((u) => {
    u.preventDefault(), u.stopPropagation();
  }, []), c = ie((u) => {
    u.preventDefault(), u.stopPropagation(), r(!1), i(0);
  }, []);
  return ge(() => {
    if (!e || !t.current) return;
    const u = t.current;
    return u.addEventListener("dragenter", s), u.addEventListener("dragleave", a), u.addEventListener("dragover", l), u.addEventListener("drop", c), () => {
      u.removeEventListener("dragenter", s), u.removeEventListener("dragleave", a), u.removeEventListener("dragover", l), u.removeEventListener("drop", c);
    };
  }, [e, t, s, a, l, c]), n ? /* @__PURE__ */ y("div", { className: "image-drop-zone", children: /* @__PURE__ */ y("div", { className: "image-drop-zone-content", children: [
    /* @__PURE__ */ y("div", { className: "image-drop-zone-icon", children: /* @__PURE__ */ y(b2, { className: "w-12 h-12" }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageDropZone.tsx",
      lineNumber: 84,
      columnNumber: 11
    }, this) }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageDropZone.tsx",
      lineNumber: 83,
      columnNumber: 9
    }, this),
    /* @__PURE__ */ y("div", { className: "image-drop-zone-text", children: [
      /* @__PURE__ */ y("span", { className: "image-drop-zone-title", children: "Drop image here" }, void 0, !1, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageDropZone.tsx",
        lineNumber: 87,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ y("span", { className: "image-drop-zone-subtitle", children: "Release to insert image into the editor" }, void 0, !1, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageDropZone.tsx",
        lineNumber: 88,
        columnNumber: 11
      }, this)
    ] }, void 0, !0, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageDropZone.tsx",
      lineNumber: 86,
      columnNumber: 9
    }, this)
  ] }, void 0, !0, {
    fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageDropZone.tsx",
    lineNumber: 82,
    columnNumber: 7
  }, this) }, void 0, !1, {
    fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageDropZone.tsx",
    lineNumber: 81,
    columnNumber: 5
  }, this) : null;
}
function a3({
  src: t,
  alt: e,
  position: n,
  onSave: r,
  onDelete: o,
  onClose: i
}) {
  const [s, a] = J(t), [l, c] = J(e), u = fe(null), d = fe(null);
  ge(() => {
    d.current?.focus(), d.current?.select();
  }, []), ge(() => {
    const p = (b) => {
      u.current && !u.current.contains(b.target) && i();
    }, g = setTimeout(() => {
      document.addEventListener("mousedown", p);
    }, 100);
    return () => {
      clearTimeout(g), document.removeEventListener("mousedown", p);
    };
  }, [i]), ge(() => {
    const p = (g) => {
      g.key === "Escape" ? i() : g.key === "Enter" && (g.metaKey || g.ctrlKey) && f();
    };
    return document.addEventListener("keydown", p), () => document.removeEventListener("keydown", p);
  }, [s, l, i]);
  const f = () => {
    s.trim() && r(s.trim(), l.trim());
  }, m = (() => {
    let v = n.x, k = n.y + 10;
    return v + 320 > window.innerWidth - 16 && (v = window.innerWidth - 320 - 16), v < 16 && (v = 16), k + 200 > window.innerHeight - 16 && (k = n.y - 200 - 10), { left: v, top: k };
  })();
  return /* @__PURE__ */ y(
    "div",
    {
      ref: u,
      className: "image-edit-popover",
      style: {
        position: "fixed",
        left: m.left,
        top: m.top,
        zIndex: 1e3
      },
      children: [
        /* @__PURE__ */ y("div", { className: "image-edit-popover-header", children: [
          /* @__PURE__ */ y("span", { className: "image-edit-popover-title", children: "Edit Image" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageEditPopover.tsx",
            lineNumber: 135,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ y(
            "button",
            {
              onClick: i,
              className: "image-edit-popover-close",
              "aria-label": "Close",
              children: /* @__PURE__ */ y(lo, { className: "w-4 h-4" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageEditPopover.tsx",
                lineNumber: 141,
                columnNumber: 11
              }, this)
            },
            void 0,
            !1,
            {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageEditPopover.tsx",
              lineNumber: 136,
              columnNumber: 9
            },
            this
          )
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageEditPopover.tsx",
          lineNumber: 134,
          columnNumber: 7
        }, this),
        /* @__PURE__ */ y("div", { className: "image-edit-popover-content", children: [
          /* @__PURE__ */ y("div", { className: "image-edit-popover-field", children: [
            /* @__PURE__ */ y("label", { className: "image-edit-popover-label", children: [
              /* @__PURE__ */ y(Rl, { className: "w-3.5 h-3.5" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageEditPopover.tsx",
                lineNumber: 150,
                columnNumber: 13
              }, this),
              /* @__PURE__ */ y("span", { children: "Image URL" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageEditPopover.tsx",
                lineNumber: 151,
                columnNumber: 13
              }, this)
            ] }, void 0, !0, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageEditPopover.tsx",
              lineNumber: 149,
              columnNumber: 11
            }, this),
            /* @__PURE__ */ y(
              "input",
              {
                ref: d,
                type: "text",
                value: s,
                onChange: (p) => a(p.target.value),
                placeholder: "https://example.com/image.jpg",
                className: "image-edit-popover-input"
              },
              void 0,
              !1,
              {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageEditPopover.tsx",
                lineNumber: 153,
                columnNumber: 11
              },
              this
            )
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageEditPopover.tsx",
            lineNumber: 148,
            columnNumber: 9
          }, this),
          /* @__PURE__ */ y("div", { className: "image-edit-popover-field", children: [
            /* @__PURE__ */ y("label", { className: "image-edit-popover-label", children: [
              /* @__PURE__ */ y(ws, { className: "w-3.5 h-3.5" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageEditPopover.tsx",
                lineNumber: 166,
                columnNumber: 13
              }, this),
              /* @__PURE__ */ y("span", { children: "Alt Text" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageEditPopover.tsx",
                lineNumber: 167,
                columnNumber: 13
              }, this)
            ] }, void 0, !0, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageEditPopover.tsx",
              lineNumber: 165,
              columnNumber: 11
            }, this),
            /* @__PURE__ */ y(
              "input",
              {
                type: "text",
                value: l,
                onChange: (p) => c(p.target.value),
                placeholder: "Describe the image...",
                className: "image-edit-popover-input"
              },
              void 0,
              !1,
              {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageEditPopover.tsx",
                lineNumber: 169,
                columnNumber: 11
              },
              this
            )
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageEditPopover.tsx",
            lineNumber: 164,
            columnNumber: 9
          }, this)
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageEditPopover.tsx",
          lineNumber: 146,
          columnNumber: 7
        }, this),
        /* @__PURE__ */ y("div", { className: "image-edit-popover-footer", children: [
          /* @__PURE__ */ y(
            "button",
            {
              onClick: o,
              className: "image-edit-popover-btn image-edit-popover-btn-delete",
              title: "Delete image",
              children: /* @__PURE__ */ y(ji, { className: "w-4 h-4" }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageEditPopover.tsx",
                lineNumber: 186,
                columnNumber: 11
              }, this)
            },
            void 0,
            !1,
            {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageEditPopover.tsx",
              lineNumber: 181,
              columnNumber: 9
            },
            this
          ),
          /* @__PURE__ */ y("div", { className: "image-edit-popover-actions", children: [
            /* @__PURE__ */ y(
              "button",
              {
                onClick: i,
                className: "image-edit-popover-btn image-edit-popover-btn-cancel",
                children: "Cancel"
              },
              void 0,
              !1,
              {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageEditPopover.tsx",
                lineNumber: 189,
                columnNumber: 11
              },
              this
            ),
            /* @__PURE__ */ y(
              "button",
              {
                onClick: f,
                className: "image-edit-popover-btn image-edit-popover-btn-save",
                disabled: !s.trim(),
                children: [
                  /* @__PURE__ */ y(yc, { className: "w-4 h-4" }, void 0, !1, {
                    fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageEditPopover.tsx",
                    lineNumber: 200,
                    columnNumber: 13
                  }, this),
                  "Save"
                ]
              },
              void 0,
              !0,
              {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageEditPopover.tsx",
                lineNumber: 195,
                columnNumber: 11
              },
              this
            )
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageEditPopover.tsx",
            lineNumber: 188,
            columnNumber: 9
          }, this)
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageEditPopover.tsx",
          lineNumber: 180,
          columnNumber: 7
        }, this)
      ]
    },
    void 0,
    !0,
    {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ImageEditPopover.tsx",
      lineNumber: 123,
      columnNumber: 5
    },
    this
  );
}
function l3(t) {
  const e = [], n = t.split(`
`);
  let r = 0, o = !1, i = "";
  for (let s = 0; s < n.length; s++) {
    const a = n[s], l = r;
    if (a.startsWith("```")) {
      o ? (o = !1, e.push({
        type: "code-block",
        content: a,
        start: l,
        end: l + a.length
      })) : (o = !0, i = a.slice(3).trim(), e.push({
        type: "code-block",
        content: "```",
        start: l,
        end: l + 3
      }), i && e.push({
        type: "code-block-lang",
        content: i,
        start: l + 3,
        end: l + 3 + i.length
      })), r += a.length + 1;
      continue;
    }
    if (o) {
      e.push({
        type: "code-block",
        content: a,
        start: l,
        end: l + a.length
      }), r += a.length + 1;
      continue;
    }
    const c = a.match(/^(#{1,6})\s+(.*)$/);
    if (c) {
      const v = c[1].length;
      e.push({
        type: `heading${v}`,
        content: a,
        start: l,
        end: l + a.length
      }), r += a.length + 1;
      continue;
    }
    if (/^(-{3,}|\*{3,}|_{3,})$/.test(a.trim())) {
      e.push({
        type: "horizontal-rule",
        content: a,
        start: l,
        end: l + a.length
      }), r += a.length + 1;
      continue;
    }
    if (a.startsWith(">")) {
      e.push({
        type: "blockquote",
        content: a,
        start: l,
        end: l + a.length
      }), r += a.length + 1;
      continue;
    }
    if (/^\|?[\s-:|]+\|?$/.test(a) && a.includes("-")) {
      e.push({
        type: "table-separator",
        content: a,
        start: l,
        end: l + a.length
      }), r += a.length + 1;
      continue;
    }
    if (a.includes("|") && (a.startsWith("|") || a.trim().includes(" | "))) {
      e.push({
        type: "table-cell",
        content: a,
        start: l,
        end: l + a.length
      }), r += a.length + 1;
      continue;
    }
    const u = a.match(/^(\s*[-*+]\s+)\[([xX ])\]\s+(.*)$/);
    if (u) {
      const v = u[2].toLowerCase() === "x";
      e.push({
        type: v ? "task-checked" : "task-list",
        content: a,
        start: l,
        end: l + a.length
      }), r += a.length + 1;
      continue;
    }
    if (a.match(/^(\s*[-*+])\s+(.*)$/)) {
      e.push({
        type: "list-bullet",
        content: a,
        start: l,
        end: l + a.length
      }), r += a.length + 1;
      continue;
    }
    if (a.match(/^(\s*\d+\.)\s+(.*)$/)) {
      e.push({
        type: "list-number",
        content: a,
        start: l,
        end: l + a.length
      }), r += a.length + 1;
      continue;
    }
    let h = 0;
    const m = [
      // Bold italic (must come before bold and italic)
      { regex: /\*\*\*(.+?)\*\*\*|___(.+?)___/g, type: "bold-italic" },
      // Bold
      { regex: /\*\*(.+?)\*\*|__(.+?)__/g, type: "bold" },
      // Italic
      { regex: /\*(.+?)\*|_(.+?)_/g, type: "italic" },
      // Strikethrough
      { regex: /~~(.+?)~~/g, type: "strikethrough" },
      // Inline code
      { regex: /`([^`]+)`/g, type: "code-inline" },
      // Images (must come before links)
      { regex: /!\[([^\]]*)\]\(([^)]+)\)/g, type: "image" },
      // Links
      { regex: /\[([^\]]+)\]\(([^)]+)\)/g, type: "link" }
    ], p = [];
    for (const v of m) {
      let k;
      for (v.regex.lastIndex = 0; (k = v.regex.exec(a)) !== null; )
        p.push({
          start: l + k.index,
          end: l + k.index + k[0].length,
          type: v.type,
          content: k[0]
        });
    }
    p.sort((v, k) => v.start - k.start);
    const g = [];
    let b = l;
    for (const v of p)
      v.start >= b && (g.push(v), b = v.end);
    for (const v of g)
      v.start > l + h && e.push({
        type: "text",
        content: a.substring(h, v.start - l),
        start: l + h,
        end: v.start
      }), e.push({
        type: v.type,
        content: v.content,
        start: v.start,
        end: v.end
      }), h = v.end - l;
    h < a.length && e.push({
      type: "text",
      content: a.substring(h),
      start: l + h,
      end: l + a.length
    }), g.length === 0 && a.length > 0 && e.push({
      type: "text",
      content: a,
      start: l,
      end: l + a.length
    }), r += a.length + 1;
  }
  return e;
}
function c3(t) {
  return {
    heading1: "md-heading md-h1",
    heading2: "md-heading md-h2",
    heading3: "md-heading md-h3",
    heading4: "md-heading md-h4",
    heading5: "md-heading md-h5",
    heading6: "md-heading md-h6",
    bold: "md-bold",
    italic: "md-italic",
    "bold-italic": "md-bold-italic",
    strikethrough: "md-strikethrough",
    "code-inline": "md-code-inline",
    "code-block": "md-code-block",
    "code-block-lang": "md-code-lang",
    link: "md-link",
    "link-text": "md-link-text",
    "link-url": "md-link-url",
    image: "md-image",
    "list-bullet": "md-list-bullet",
    "list-number": "md-list-number",
    "task-list": "md-task",
    "task-checked": "md-task-checked",
    blockquote: "md-blockquote",
    "horizontal-rule": "md-hr",
    "table-header": "md-table-header",
    "table-separator": "md-table-separator",
    "table-cell": "md-table-cell",
    text: "md-text"
  }[t] || "md-text";
}
function Ii(t) {
  return t.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
function u3(t, e) {
  if (e.length === 0)
    return Ii(t);
  let n = "";
  const r = t.split(`
`);
  let o = 0;
  for (let i = 0; i < r.length; i++) {
    const s = r[i], a = o + s.length, l = e.filter((u) => u.start >= o && u.start < a);
    let c = o;
    for (const u of l)
      u.start > c && (n += Ii(t.substring(c, u.start))), n += `<span class="${c3(u.type)}">${Ii(u.content)}</span>`, c = u.end;
    c < a && (n += Ii(t.substring(c, a))), i < r.length - 1 && (n += `
`), o = a + 1;
  }
  return n;
}
function d3({
  content: t,
  onChange: e,
  placeholder: n = "Write your markdown here...",
  editable: r = !0,
  autofocus: o = !1,
  className: i = ""
}) {
  const s = fe(null), a = fe(null), l = fe(null), c = Xi(() => {
    const h = l3(t);
    return u3(t, h);
  }, [t]), u = ie(() => {
    const h = s.current, m = a.current;
    if (h) {
      h.style.height = "auto";
      const p = Math.max(h.scrollHeight, 200);
      h.style.height = `${p}px`, m && (m.style.height = `${p}px`);
    }
  }, []), d = ie(() => {
    const h = s.current, m = a.current;
    h && m && (m.scrollTop = h.scrollTop, m.scrollLeft = h.scrollLeft);
  }, []);
  ge(() => {
    u();
  }, [t, u]), ge(() => {
    o && s.current && s.current.focus();
  }, [o]);
  const f = ie((h) => {
    if (h.key === "Tab") {
      h.preventDefault();
      const m = h.currentTarget, p = m.selectionStart, g = m.selectionEnd, b = m.value;
      if (h.shiftKey) {
        const v = b.substring(0, p), k = b.substring(p, g), x = b.substring(g), E = v.lastIndexOf(`
`) + 1, S = v.substring(0, E), C = v.substring(E), M = (C + k).split(`
`), O = M.map((K) => K.startsWith("  ") ? K.substring(2) : K.startsWith("	") ? K.substring(1) : K), q = S + O.join(`
`) + x;
        e(q), setTimeout(() => {
          const K = (C + k).length - O.join(`
`).length;
          m.selectionStart = Math.max(E, p - (M[0].length - O[0].length)), m.selectionEnd = g - K;
        }, 0);
      } else if (p === g) {
        const v = b.substring(0, p) + "  " + b.substring(g);
        e(v), setTimeout(() => {
          m.selectionStart = m.selectionEnd = p + 2;
        }, 0);
      } else {
        const v = b.substring(0, p), k = b.substring(p, g), x = b.substring(g), E = v.lastIndexOf(`
`) + 1, S = v.substring(0, E), M = (v.substring(E) + k).split(`
`), O = M.map((K) => "  " + K), q = S + O.join(`
`) + x;
        e(q), setTimeout(() => {
          m.selectionStart = p + 2, m.selectionEnd = g + M.length * 2;
        }, 0);
      }
    }
  }, [e]);
  return /* @__PURE__ */ y("div", { ref: l, className: `syntax-highlighted-editor ${i}`, children: [
    /* @__PURE__ */ y(
      "div",
      {
        ref: a,
        className: "syntax-highlight-overlay",
        dangerouslySetInnerHTML: { __html: c || `<span class="md-placeholder">${Ii(n)}</span>` },
        "aria-hidden": "true"
      },
      void 0,
      !1,
      {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SyntaxHighlightedMarkdown.tsx",
        lineNumber: 502,
        columnNumber: 7
      },
      this
    ),
    /* @__PURE__ */ y(
      "textarea",
      {
        ref: s,
        value: t,
        onChange: (h) => e(h.target.value),
        onKeyDown: f,
        onScroll: d,
        placeholder: "",
        disabled: !r,
        className: "syntax-textarea",
        spellCheck: !1
      },
      void 0,
      !1,
      {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SyntaxHighlightedMarkdown.tsx",
        lineNumber: 508,
        columnNumber: 7
      },
      this
    )
  ] }, void 0, !0, {
    fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/SyntaxHighlightedMarkdown.tsx",
    lineNumber: 501,
    columnNumber: 5
  }, this);
}
let Fg = 0, Ld = 0, Hk = 0;
function f3(t) {
  Ld++, Hk = t;
}
const h3 = si(function({
  visible: e,
  onClose: n,
  editor: r
}) {
  const [o, i] = J(!1), [s, a] = J({
    fps: 0,
    frameTime: 0,
    frameTimeMax: 0,
    memoryUsed: 0,
    memoryTotal: 0,
    renderCount: 0,
    transactionCount: 0,
    lastTransactionTime: 0,
    domNodes: 0,
    longFrames: 0
  }), l = fe([]), c = fe(performance.now()), u = fe(0), d = fe(0), f = fe(0), h = fe(0), [m, p] = J(new Array(60).fill(0)), [g, b] = J(new Array(60).fill(0));
  ge(() => {
    if (!e || !r) return;
    const S = () => {
      const C = performance.now();
      queueMicrotask(() => {
        const M = performance.now() - C;
        f3(M);
      });
    };
    return r.on("transaction", S), () => {
      r.off("transaction", S);
    };
  }, [e, r]), ge(() => {
    if (!e) return;
    let S = 0, C = performance.now(), M = 0;
    const O = (q) => {
      const K = q - c.current;
      if (c.current = q, l.current.push({ time: q, duration: K }), l.current.length > 120 && (l.current = l.current.slice(-120)), K > 16.67 && d.current++, S++, q - C >= 1e3) {
        M = S, S = 0, C = q;
        const j = l.current.slice(-60), H = j.length > 0 ? j.reduce((Q, ue) => Q + ue.duration, 0) / j.length : 0, G = j.length > 0 ? Math.max(...j.map((Q) => Q.duration)) : 0, V = performance.memory, re = V ? V.usedJSHeapSize / (1024 * 1024) : 0, A = V ? V.jsHeapSizeLimit / (1024 * 1024) : 0, $ = document.querySelectorAll("*").length, _ = Fg - f.current, z = Ld - h.current;
        f.current = Fg, h.current = Ld, a({
          fps: M,
          frameTime: Math.round(H * 100) / 100,
          frameTimeMax: Math.round(G * 100) / 100,
          memoryUsed: Math.round(re * 10) / 10,
          memoryTotal: Math.round(A),
          renderCount: _,
          transactionCount: z,
          lastTransactionTime: Math.round(Hk * 100) / 100,
          domNodes: $,
          longFrames: d.current
        }), p((Q) => [...Q.slice(1), M]), b((Q) => [...Q.slice(1), H]), d.current = 0;
      }
      u.current = requestAnimationFrame(O);
    };
    return u.current = requestAnimationFrame(O), () => {
      cancelAnimationFrame(u.current);
    };
  }, [e]);
  const v = ie(() => {
    n?.();
  }, [n]), k = ie(() => {
    i((S) => !S);
  }, []);
  if (!e) return null;
  const x = (S) => S >= 55 ? "#4ade80" : S >= 30 ? "#fbbf24" : "#f87171", w = (S) => S <= 16.67 ? "#4ade80" : S <= 33.33 ? "#fbbf24" : "#f87171", E = (S, C, M) => {
    const K = S.map((j, H) => {
      const G = H / (S.length - 1) * 120, V = 24 - Math.min(j, C) / C * 24;
      return `${G},${V}`;
    }).join(" ");
    return /* @__PURE__ */ y("svg", { width: 120, height: 24, className: "perf-sparkline", children: /* @__PURE__ */ y(
      "polyline",
      {
        points: K,
        fill: "none",
        stroke: M,
        strokeWidth: "1.5",
        strokeLinejoin: "round"
      },
      void 0,
      !1,
      {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
        lineNumber: 225,
        columnNumber: 9
      },
      this
    ) }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
      lineNumber: 224,
      columnNumber: 7
    }, this);
  };
  return /* @__PURE__ */ y("div", { className: "perf-profiler-overlay", children: [
    /* @__PURE__ */ y("div", { className: "perf-profiler-header", children: [
      /* @__PURE__ */ y("div", { className: "perf-profiler-title", children: [
        /* @__PURE__ */ y(s2, { size: 14 }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
          lineNumber: 241,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ y("span", { children: "Performance" }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
          lineNumber: 242,
          columnNumber: 11
        }, this)
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
        lineNumber: 240,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ y("div", { className: "perf-profiler-actions", children: [
        /* @__PURE__ */ y("button", { onClick: k, title: o ? "Expand" : "Minimize", children: o ? /* @__PURE__ */ y(v2, { size: 12 }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
          lineNumber: 246,
          columnNumber: 28
        }, this) : /* @__PURE__ */ y(w2, { size: 12 }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
          lineNumber: 246,
          columnNumber: 54
        }, this) }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
          lineNumber: 245,
          columnNumber: 11
        }, this),
        /* @__PURE__ */ y("button", { onClick: v, title: "Close profiler", children: /* @__PURE__ */ y(lo, { size: 12 }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
          lineNumber: 249,
          columnNumber: 13
        }, this) }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
          lineNumber: 248,
          columnNumber: 11
        }, this)
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
        lineNumber: 244,
        columnNumber: 9
      }, this)
    ] }, void 0, !0, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
      lineNumber: 239,
      columnNumber: 7
    }, this),
    !o && /* @__PURE__ */ y("div", { className: "perf-profiler-body", children: [
      /* @__PURE__ */ y("div", { className: "perf-section", children: [
        /* @__PURE__ */ y("div", { className: "perf-row", children: [
          /* @__PURE__ */ y("span", { className: "perf-label", children: "FPS" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
            lineNumber: 259,
            columnNumber: 15
          }, this),
          /* @__PURE__ */ y("span", { className: "perf-value", style: { color: x(s.fps) }, children: s.fps }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
            lineNumber: 260,
            columnNumber: 15
          }, this)
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
          lineNumber: 258,
          columnNumber: 13
        }, this),
        E(m, 70, x(s.fps))
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
        lineNumber: 257,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ y("div", { className: "perf-section", children: [
        /* @__PURE__ */ y("div", { className: "perf-row", children: [
          /* @__PURE__ */ y("span", { className: "perf-label", children: "Frame Time" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
            lineNumber: 270,
            columnNumber: 15
          }, this),
          /* @__PURE__ */ y("span", { className: "perf-value", style: { color: w(s.frameTime) }, children: [
            s.frameTime,
            "ms"
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
            lineNumber: 271,
            columnNumber: 15
          }, this)
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
          lineNumber: 269,
          columnNumber: 13
        }, this),
        /* @__PURE__ */ y("div", { className: "perf-row perf-row-sub", children: [
          /* @__PURE__ */ y("span", { className: "perf-label-sub", children: "Max" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
            lineNumber: 276,
            columnNumber: 15
          }, this),
          /* @__PURE__ */ y("span", { className: "perf-value-sub", style: { color: w(s.frameTimeMax) }, children: [
            s.frameTimeMax,
            "ms"
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
            lineNumber: 277,
            columnNumber: 15
          }, this)
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
          lineNumber: 275,
          columnNumber: 13
        }, this),
        /* @__PURE__ */ y("div", { className: "perf-row perf-row-sub", children: [
          /* @__PURE__ */ y("span", { className: "perf-label-sub", children: [
            "Jank (",
            ">",
            " 16.7ms)"
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
            lineNumber: 282,
            columnNumber: 15
          }, this),
          /* @__PURE__ */ y("span", { className: "perf-value-sub", style: { color: s.longFrames > 3 ? "#f87171" : "#4ade80" }, children: [
            s.longFrames,
            "/s"
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
            lineNumber: 283,
            columnNumber: 15
          }, this)
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
          lineNumber: 281,
          columnNumber: 13
        }, this),
        E(g, 50, w(s.frameTime))
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
        lineNumber: 268,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ y("div", { className: "perf-section", children: [
        /* @__PURE__ */ y("div", { className: "perf-row", children: [
          /* @__PURE__ */ y("span", { className: "perf-label", children: "Renders/s" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
            lineNumber: 293,
            columnNumber: 15
          }, this),
          /* @__PURE__ */ y("span", { className: "perf-value", children: s.renderCount }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
            lineNumber: 294,
            columnNumber: 15
          }, this)
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
          lineNumber: 292,
          columnNumber: 13
        }, this),
        /* @__PURE__ */ y("div", { className: "perf-row", children: [
          /* @__PURE__ */ y("span", { className: "perf-label", children: "Transactions/s" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
            lineNumber: 297,
            columnNumber: 15
          }, this),
          /* @__PURE__ */ y("span", { className: "perf-value", children: s.transactionCount }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
            lineNumber: 298,
            columnNumber: 15
          }, this)
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
          lineNumber: 296,
          columnNumber: 13
        }, this),
        /* @__PURE__ */ y("div", { className: "perf-row perf-row-sub", children: [
          /* @__PURE__ */ y("span", { className: "perf-label-sub", children: "Last TX time" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
            lineNumber: 301,
            columnNumber: 15
          }, this),
          /* @__PURE__ */ y("span", { className: "perf-value-sub", children: [
            s.lastTransactionTime,
            "ms"
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
            lineNumber: 302,
            columnNumber: 15
          }, this)
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
          lineNumber: 300,
          columnNumber: 13
        }, this)
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
        lineNumber: 291,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ y("div", { className: "perf-section", children: [
        /* @__PURE__ */ y("div", { className: "perf-row", children: [
          /* @__PURE__ */ y("span", { className: "perf-label", children: "DOM Nodes" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
            lineNumber: 309,
            columnNumber: 15
          }, this),
          /* @__PURE__ */ y("span", { className: "perf-value", children: s.domNodes.toLocaleString() }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
            lineNumber: 310,
            columnNumber: 15
          }, this)
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
          lineNumber: 308,
          columnNumber: 13
        }, this),
        s.memoryTotal > 0 && /* @__PURE__ */ y("div", { className: "perf-row", children: [
          /* @__PURE__ */ y("span", { className: "perf-label", children: "Memory" }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
            lineNumber: 314,
            columnNumber: 17
          }, this),
          /* @__PURE__ */ y("span", { className: "perf-value", children: [
            s.memoryUsed,
            "MB / ",
            s.memoryTotal,
            "MB"
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
            lineNumber: 315,
            columnNumber: 17
          }, this)
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
          lineNumber: 313,
          columnNumber: 15
        }, this)
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
        lineNumber: 307,
        columnNumber: 11
      }, this)
    ] }, void 0, !0, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
      lineNumber: 255,
      columnNumber: 9
    }, this)
  ] }, void 0, !0, {
    fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/PerformanceProfiler.tsx",
    lineNumber: 237,
    columnNumber: 5
  }, this);
});
function m3(t, e, n) {
  const r = [];
  return t.state.doc.descendants((i, s) => {
    if (i.type.name === "heading") {
      const a = i.attrs.level;
      if (a >= e && a <= n) {
        const l = i.textContent;
        l.trim() && r.push({ id: `toc-heading-${s}`, text: l.trim(), level: a, pos: s });
      }
    }
  }), r;
}
function p3(t) {
  if (t.length === 0) return [];
  const e = [], n = [];
  for (const r of t) {
    const o = { ...r, children: [] };
    for (; n.length > 0 && n[n.length - 1].level >= r.level; )
      n.pop();
    if (n.length === 0)
      e.push(o);
    else {
      const i = n[n.length - 1].item;
      i.children || (i.children = []), i.children.push(o);
    }
    n.push({ item: o, level: r.level });
  }
  return e;
}
function Ug(t, e) {
  try {
    const n = t.state.doc.resolve(e), r = t.view.nodeDOM(n.before(n.depth + 1));
    if (r instanceof HTMLElement) return r;
    const o = t.view.nodeDOM(e);
    if (o instanceof HTMLElement) return o;
  } catch {
  }
  return null;
}
const Wg = si(function({
  editor: e,
  visible: n = !0,
  onVisibilityChange: r,
  title: o = "",
  minLevel: i = 1,
  maxLevel: s = 4,
  showLevelIndicators: a = !1,
  highlightActive: l = !0,
  treeView: c = !1,
  className: u = "",
  width: d = "220px",
  position: f = "right",
  scrollOffset: h = 20,
  onItemClick: m,
  renderItem: p,
  showToggleButton: g = !0,
  scrollContainerRef: b
}) {
  const [v, k] = J([]), [x, w] = J(null), [E, S] = J(n), [C, M] = J(/* @__PURE__ */ new Set()), O = fe(null), q = fe(null);
  ge(() => {
    S(n);
  }, [n]);
  const K = ie(() => {
    if (!e || e.isDestroyed) return;
    const _ = m3(e, i, s);
    k(_), x && !_.find((z) => z.id === x) && w(null);
  }, [e, i, s, x]);
  ge(() => {
    if (!e) return;
    const _ = () => {
      q.current && clearTimeout(q.current), q.current = setTimeout(() => K(), 300);
    };
    return K(), e.on("update", _), e.on("create", _), () => {
      e.off("update", _), e.off("create", _), q.current && clearTimeout(q.current);
    };
  }, [e, K]), ge(() => {
    if (!e || !l || !E || v.length === 0) return;
    const _ = b?.current || e.view.dom.closest(".editor-content-wrapper");
    if (!_) return;
    const z = () => {
      const Me = _.getBoundingClientRect();
      let Oe = null;
      for (let je = v.length - 1; je >= 0; je--) {
        const me = v[je], at = Ug(e, me.pos);
        if (at && at.getBoundingClientRect().top - Me.top <= h + 10) {
          Oe = me.id;
          break;
        }
      }
      !Oe && v.length > 0 && (Oe = v[0].id), w(Oe);
    };
    let Q;
    const ue = () => {
      cancelAnimationFrame(Q), Q = requestAnimationFrame(z);
    };
    return _.addEventListener("scroll", ue, { passive: !0 }), z(), () => {
      _.removeEventListener("scroll", ue), cancelAnimationFrame(Q);
    };
  }, [e, v, l, E, h, b]);
  const j = ie((_) => {
    if (!e || e.isDestroyed) return;
    const z = Ug(e, _.pos);
    if (z) {
      const Q = b?.current || e.view.dom.closest(".editor-content-wrapper");
      if (Q) {
        const ue = Q.getBoundingClientRect(), Oe = z.getBoundingClientRect().top - ue.top + Q.scrollTop;
        Q.scrollTo({ top: Oe - h, behavior: "smooth" });
      } else
        z.scrollIntoView({ behavior: "smooth", block: "start" });
    }
    try {
      e.commands.setTextSelection(_.pos + 1);
    } catch {
    }
    w(_.id), m?.(_);
  }, [e, h, m, b]), H = ie(() => {
    const _ = !E;
    S(_), r?.(_);
  }, [E, r]), G = ie((_) => {
    M((z) => {
      const Q = new Set(z);
      return Q.has(_) ? Q.delete(_) : Q.add(_), Q;
    });
  }, []), V = ie((_, z, Q = 0) => {
    if (p)
      return p(_, z, () => j(_));
    const ue = (_.level - i) * 14, Me = c && _.children && _.children.length > 0, Oe = C.has(_.id);
    return /* @__PURE__ */ y(
      "div",
      {
        className: `toc-item ${z ? "toc-item-active" : ""} toc-level-${_.level}`,
        style: { paddingLeft: `${ue + 10}px` },
        children: /* @__PURE__ */ y(
          "button",
          {
            className: "toc-item-button",
            onClick: () => j(_),
            title: _.text,
            children: [
              Me && /* @__PURE__ */ y(
                "span",
                {
                  className: "toc-collapse-toggle",
                  onClick: (je) => {
                    je.stopPropagation(), G(_.id);
                  },
                  children: /* @__PURE__ */ y("svg", { width: "10", height: "10", viewBox: "0 0 10 10", fill: "none", children: Oe ? /* @__PURE__ */ y("path", { d: "M3.5 2L7 5L3.5 8", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }, void 0, !1, {
                    fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/TableOfContents.tsx",
                    lineNumber: 257,
                    columnNumber: 21
                  }, this) : /* @__PURE__ */ y("path", { d: "M2 3.5L5 7L8 3.5", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }, void 0, !1, {
                    fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/TableOfContents.tsx",
                    lineNumber: 258,
                    columnNumber: 21
                  }, this) }, void 0, !1, {
                    fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/TableOfContents.tsx",
                    lineNumber: 255,
                    columnNumber: 15
                  }, this)
                },
                void 0,
                !1,
                {
                  fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/TableOfContents.tsx",
                  lineNumber: 248,
                  columnNumber: 13
                },
                this
              ),
              a && /* @__PURE__ */ y("span", { className: "toc-level-indicator", children: [
                "H",
                _.level
              ] }, void 0, !0, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/TableOfContents.tsx",
                lineNumber: 264,
                columnNumber: 13
              }, this),
              /* @__PURE__ */ y("span", { className: "toc-item-text", children: _.text }, void 0, !1, {
                fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/TableOfContents.tsx",
                lineNumber: 266,
                columnNumber: 11
              }, this)
            ]
          },
          void 0,
          !0,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/TableOfContents.tsx",
            lineNumber: 242,
            columnNumber: 9
          },
          this
        )
      },
      _.id,
      !1,
      {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/TableOfContents.tsx",
        lineNumber: 237,
        columnNumber: 7
      },
      this
    );
  }, [p, j, c, i, a, C, G]), re = ie((_, z = 0) => _.map((Q) => {
    const ue = x === Q.id, Me = C.has(Q.id), Oe = Q.children && Q.children.length > 0;
    return /* @__PURE__ */ y("div", { children: [
      V(Q, ue, z),
      Oe && !Me && /* @__PURE__ */ y("div", { className: "toc-children", children: re(Q.children, z + 1) }, void 0, !1, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/TableOfContents.tsx",
        lineNumber: 281,
        columnNumber: 13
      }, this)
    ] }, Q.id, !0, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/TableOfContents.tsx",
      lineNumber: 278,
      columnNumber: 9
    }, this);
  }), [x, C, V]), A = ie(() => v.map((_) => {
    const z = x === _.id;
    return V(_, z);
  }), [v, x, V]);
  if (!e) return null;
  const $ = c ? p3(v) : [];
  return /* @__PURE__ */ y(fn, { children: [
    g && /* @__PURE__ */ y(
      "button",
      {
        className: `toc-toggle-button toc-toggle-${f}`,
        onClick: H,
        title: E ? "Hide Table of Contents" : "Show Table of Contents",
        children: E ? /* @__PURE__ */ y(N2, { size: 16 }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/TableOfContents.tsx",
          lineNumber: 310,
          columnNumber: 24
        }, this) : /* @__PURE__ */ y(E2, { size: 16 }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/TableOfContents.tsx",
          lineNumber: 310,
          columnNumber: 56
        }, this)
      },
      void 0,
      !1,
      {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/TableOfContents.tsx",
        lineNumber: 305,
        columnNumber: 9
      },
      this
    ),
    /* @__PURE__ */ y(
      "div",
      {
        ref: O,
        className: `toc-sidebar ${E ? "toc-visible" : "toc-hidden"} toc-${f} ${u}`,
        style: { width: E ? d : "0px" },
        children: /* @__PURE__ */ y("div", { className: "toc-inner", children: [
          o && /* @__PURE__ */ y("div", { className: "toc-header", children: /* @__PURE__ */ y("span", { className: "toc-title", children: o }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/TableOfContents.tsx",
            lineNumber: 324,
            columnNumber: 15
          }, this) }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/TableOfContents.tsx",
            lineNumber: 323,
            columnNumber: 13
          }, this),
          /* @__PURE__ */ y("div", { className: "toc-content", children: v.length === 0 ? /* @__PURE__ */ y("div", { className: "toc-empty", children: [
            /* @__PURE__ */ y("p", { children: "No headings yet" }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/TableOfContents.tsx",
              lineNumber: 332,
              columnNumber: 17
            }, this),
            /* @__PURE__ */ y("p", { className: "toc-empty-hint", children: "Add headings to see the outline." }, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/TableOfContents.tsx",
              lineNumber: 333,
              columnNumber: 17
            }, this)
          ] }, void 0, !0, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/TableOfContents.tsx",
            lineNumber: 331,
            columnNumber: 15
          }, this) : /* @__PURE__ */ y("div", { className: "toc-list", children: c ? re($) : A() }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/TableOfContents.tsx",
            lineNumber: 336,
            columnNumber: 15
          }, this) }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/TableOfContents.tsx",
            lineNumber: 329,
            columnNumber: 11
          }, this)
        ] }, void 0, !0, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/TableOfContents.tsx",
          lineNumber: 320,
          columnNumber: 9
        }, this)
      },
      void 0,
      !1,
      {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/TableOfContents.tsx",
        lineNumber: 315,
        columnNumber: 7
      },
      this
    )
  ] }, void 0, !0, {
    fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/TableOfContents.tsx",
    lineNumber: 302,
    columnNumber: 5
  }, this);
});
function g3(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e];
    for (var r in n)
      n.hasOwnProperty(r) && (t[r] = n[r]);
  }
  return t;
}
function Pd(t, e) {
  return Array(e + 1).join(t);
}
function Fk(t) {
  return t.replace(/^\n*/, "");
}
function Uk(t) {
  for (var e = t.length; e > 0 && t[e - 1] === `
`; ) e--;
  return t.substring(0, e);
}
function Wk(t) {
  return Uk(Fk(t));
}
var b3 = [
  "ADDRESS",
  "ARTICLE",
  "ASIDE",
  "AUDIO",
  "BLOCKQUOTE",
  "BODY",
  "CANVAS",
  "CENTER",
  "DD",
  "DIR",
  "DIV",
  "DL",
  "DT",
  "FIELDSET",
  "FIGCAPTION",
  "FIGURE",
  "FOOTER",
  "FORM",
  "FRAMESET",
  "H1",
  "H2",
  "H3",
  "H4",
  "H5",
  "H6",
  "HEADER",
  "HGROUP",
  "HR",
  "HTML",
  "ISINDEX",
  "LI",
  "MAIN",
  "MENU",
  "NAV",
  "NOFRAMES",
  "NOSCRIPT",
  "OL",
  "OUTPUT",
  "P",
  "PRE",
  "SECTION",
  "TABLE",
  "TBODY",
  "TD",
  "TFOOT",
  "TH",
  "THEAD",
  "TR",
  "UL"
];
function wh(t) {
  return kh(t, b3);
}
var Vk = [
  "AREA",
  "BASE",
  "BR",
  "COL",
  "COMMAND",
  "EMBED",
  "HR",
  "IMG",
  "INPUT",
  "KEYGEN",
  "LINK",
  "META",
  "PARAM",
  "SOURCE",
  "TRACK",
  "WBR"
];
function Kk(t) {
  return kh(t, Vk);
}
function y3(t) {
  return Gk(t, Vk);
}
var qk = [
  "A",
  "TABLE",
  "THEAD",
  "TBODY",
  "TFOOT",
  "TH",
  "TD",
  "IFRAME",
  "SCRIPT",
  "AUDIO",
  "VIDEO"
];
function v3(t) {
  return kh(t, qk);
}
function w3(t) {
  return Gk(t, qk);
}
function kh(t, e) {
  return e.indexOf(t.nodeName) >= 0;
}
function Gk(t, e) {
  return t.getElementsByTagName && e.some(function(n) {
    return t.getElementsByTagName(n).length;
  });
}
var Ot = {};
Ot.paragraph = {
  filter: "p",
  replacement: function(t) {
    return `

` + t + `

`;
  }
};
Ot.lineBreak = {
  filter: "br",
  replacement: function(t, e, n) {
    return n.br + `
`;
  }
};
Ot.heading = {
  filter: ["h1", "h2", "h3", "h4", "h5", "h6"],
  replacement: function(t, e, n) {
    var r = Number(e.nodeName.charAt(1));
    if (n.headingStyle === "setext" && r < 3) {
      var o = Pd(r === 1 ? "=" : "-", t.length);
      return `

` + t + `
` + o + `

`;
    } else
      return `

` + Pd("#", r) + " " + t + `

`;
  }
};
Ot.blockquote = {
  filter: "blockquote",
  replacement: function(t) {
    return t = Wk(t).replace(/^/gm, "> "), `

` + t + `

`;
  }
};
Ot.list = {
  filter: ["ul", "ol"],
  replacement: function(t, e) {
    var n = e.parentNode;
    return n.nodeName === "LI" && n.lastElementChild === e ? `
` + t : `

` + t + `

`;
  }
};
Ot.listItem = {
  filter: "li",
  replacement: function(t, e, n) {
    var r = n.bulletListMarker + "   ", o = e.parentNode;
    if (o.nodeName === "OL") {
      var i = o.getAttribute("start"), s = Array.prototype.indexOf.call(o.children, e);
      r = (i ? Number(i) + s : s + 1) + ".  ";
    }
    var a = /\n$/.test(t);
    return t = Wk(t) + (a ? `
` : ""), t = t.replace(/\n/gm, `
` + " ".repeat(r.length)), r + t + (e.nextSibling ? `
` : "");
  }
};
Ot.indentedCodeBlock = {
  filter: function(t, e) {
    return e.codeBlockStyle === "indented" && t.nodeName === "PRE" && t.firstChild && t.firstChild.nodeName === "CODE";
  },
  replacement: function(t, e, n) {
    return `

    ` + e.firstChild.textContent.replace(/\n/g, `
    `) + `

`;
  }
};
Ot.fencedCodeBlock = {
  filter: function(t, e) {
    return e.codeBlockStyle === "fenced" && t.nodeName === "PRE" && t.firstChild && t.firstChild.nodeName === "CODE";
  },
  replacement: function(t, e, n) {
    for (var r = e.firstChild.getAttribute("class") || "", o = (r.match(/language-(\S+)/) || [null, ""])[1], i = e.firstChild.textContent, s = n.fence.charAt(0), a = 3, l = new RegExp("^" + s + "{3,}", "gm"), c; c = l.exec(i); )
      c[0].length >= a && (a = c[0].length + 1);
    var u = Pd(s, a);
    return `

` + u + o + `
` + i.replace(/\n$/, "") + `
` + u + `

`;
  }
};
Ot.horizontalRule = {
  filter: "hr",
  replacement: function(t, e, n) {
    return `

` + n.hr + `

`;
  }
};
Ot.inlineLink = {
  filter: function(t, e) {
    return e.linkStyle === "inlined" && t.nodeName === "A" && t.getAttribute("href");
  },
  replacement: function(t, e) {
    var n = e.getAttribute("href");
    n && (n = n.replace(/([()])/g, "\\$1"));
    var r = Wl(e.getAttribute("title"));
    return r && (r = ' "' + r.replace(/"/g, '\\"') + '"'), "[" + t + "](" + n + r + ")";
  }
};
Ot.referenceLink = {
  filter: function(t, e) {
    return e.linkStyle === "referenced" && t.nodeName === "A" && t.getAttribute("href");
  },
  replacement: function(t, e, n) {
    var r = e.getAttribute("href"), o = Wl(e.getAttribute("title"));
    o && (o = ' "' + o + '"');
    var i, s;
    switch (n.linkReferenceStyle) {
      case "collapsed":
        i = "[" + t + "][]", s = "[" + t + "]: " + r + o;
        break;
      case "shortcut":
        i = "[" + t + "]", s = "[" + t + "]: " + r + o;
        break;
      default:
        var a = this.references.length + 1;
        i = "[" + t + "][" + a + "]", s = "[" + a + "]: " + r + o;
    }
    return this.references.push(s), i;
  },
  references: [],
  append: function(t) {
    var e = "";
    return this.references.length && (e = `

` + this.references.join(`
`) + `

`, this.references = []), e;
  }
};
Ot.emphasis = {
  filter: ["em", "i"],
  replacement: function(t, e, n) {
    return t.trim() ? n.emDelimiter + t + n.emDelimiter : "";
  }
};
Ot.strong = {
  filter: ["strong", "b"],
  replacement: function(t, e, n) {
    return t.trim() ? n.strongDelimiter + t + n.strongDelimiter : "";
  }
};
Ot.code = {
  filter: function(t) {
    var e = t.previousSibling || t.nextSibling, n = t.parentNode.nodeName === "PRE" && !e;
    return t.nodeName === "CODE" && !n;
  },
  replacement: function(t) {
    if (!t) return "";
    t = t.replace(/\r?\n|\r/g, " ");
    for (var e = /^`|^ .*?[^ ].* $|`$/.test(t) ? " " : "", n = "`", r = t.match(/`+/gm) || []; r.indexOf(n) !== -1; ) n = n + "`";
    return n + e + t + e + n;
  }
};
Ot.image = {
  filter: "img",
  replacement: function(t, e) {
    var n = Wl(e.getAttribute("alt")), r = e.getAttribute("src") || "", o = Wl(e.getAttribute("title")), i = o ? ' "' + o + '"' : "";
    return r ? "![" + n + "](" + r + i + ")" : "";
  }
};
function Wl(t) {
  return t ? t.replace(/(\n+\s*)+/g, `
`) : "";
}
function jk(t) {
  this.options = t, this._keep = [], this._remove = [], this.blankRule = {
    replacement: t.blankReplacement
  }, this.keepReplacement = t.keepReplacement, this.defaultRule = {
    replacement: t.defaultReplacement
  }, this.array = [];
  for (var e in t.rules) this.array.push(t.rules[e]);
}
jk.prototype = {
  add: function(t, e) {
    this.array.unshift(e);
  },
  keep: function(t) {
    this._keep.unshift({
      filter: t,
      replacement: this.keepReplacement
    });
  },
  remove: function(t) {
    this._remove.unshift({
      filter: t,
      replacement: function() {
        return "";
      }
    });
  },
  forNode: function(t) {
    if (t.isBlank) return this.blankRule;
    var e;
    return (e = Ou(this.array, t, this.options)) || (e = Ou(this._keep, t, this.options)) || (e = Ou(this._remove, t, this.options)) ? e : this.defaultRule;
  },
  forEach: function(t) {
    for (var e = 0; e < this.array.length; e++) t(this.array[e], e);
  }
};
function Ou(t, e, n) {
  for (var r = 0; r < t.length; r++) {
    var o = t[r];
    if (k3(o, e, n)) return o;
  }
}
function k3(t, e, n) {
  var r = t.filter;
  if (typeof r == "string") {
    if (r === e.nodeName.toLowerCase()) return !0;
  } else if (Array.isArray(r)) {
    if (r.indexOf(e.nodeName.toLowerCase()) > -1) return !0;
  } else if (typeof r == "function") {
    if (r.call(t, e, n)) return !0;
  } else
    throw new TypeError("`filter` needs to be a string, array, or function");
}
function x3(t) {
  var e = t.element, n = t.isBlock, r = t.isVoid, o = t.isPre || function(d) {
    return d.nodeName === "PRE";
  };
  if (!(!e.firstChild || o(e))) {
    for (var i = null, s = !1, a = null, l = Vg(a, e, o); l !== e; ) {
      if (l.nodeType === 3 || l.nodeType === 4) {
        var c = l.data.replace(/[ \r\n\t]+/g, " ");
        if ((!i || / $/.test(i.data)) && !s && c[0] === " " && (c = c.substr(1)), !c) {
          l = Iu(l);
          continue;
        }
        l.data = c, i = l;
      } else if (l.nodeType === 1)
        n(l) || l.nodeName === "BR" ? (i && (i.data = i.data.replace(/ $/, "")), i = null, s = !1) : r(l) || o(l) ? (i = null, s = !0) : i && (s = !1);
      else {
        l = Iu(l);
        continue;
      }
      var u = Vg(a, l, o);
      a = l, l = u;
    }
    i && (i.data = i.data.replace(/ $/, ""), i.data || Iu(i));
  }
}
function Iu(t) {
  var e = t.nextSibling || t.parentNode;
  return t.parentNode.removeChild(t), e;
}
function Vg(t, e, n) {
  return t && t.parentNode === e || n(e) ? e.nextSibling || e.parentNode : e.firstChild || e.nextSibling || e.parentNode;
}
var xh = typeof window < "u" ? window : {};
function N3() {
  var t = xh.DOMParser, e = !1;
  try {
    new t().parseFromString("", "text/html") && (e = !0);
  } catch {
  }
  return e;
}
function E3() {
  var t = function() {
  };
  return S3() ? t.prototype.parseFromString = function(e) {
    var n = new window.ActiveXObject("htmlfile");
    return n.designMode = "on", n.open(), n.write(e), n.close(), n;
  } : t.prototype.parseFromString = function(e) {
    var n = document.implementation.createHTMLDocument("");
    return n.open(), n.write(e), n.close(), n;
  }, t;
}
function S3() {
  var t = !1;
  try {
    document.implementation.createHTMLDocument("").open();
  } catch {
    xh.ActiveXObject && (t = !0);
  }
  return t;
}
var T3 = N3() ? xh.DOMParser : E3();
function C3(t, e) {
  var n;
  if (typeof t == "string") {
    var r = M3().parseFromString(
      // DOM parsers arrange elements in the <head> and <body>.
      // Wrapping in a custom element ensures elements are reliably arranged in
      // a single element.
      '<x-turndown id="turndown-root">' + t + "</x-turndown>",
      "text/html"
    );
    n = r.getElementById("turndown-root");
  } else
    n = t.cloneNode(!0);
  return x3({
    element: n,
    isBlock: wh,
    isVoid: Kk,
    isPre: e.preformattedCode ? A3 : null
  }), n;
}
var Du;
function M3() {
  return Du = Du || new T3(), Du;
}
function A3(t) {
  return t.nodeName === "PRE" || t.nodeName === "CODE";
}
function _3(t, e) {
  return t.isBlock = wh(t), t.isCode = t.nodeName === "CODE" || t.parentNode.isCode, t.isBlank = R3(t), t.flankingWhitespace = O3(t, e), t;
}
function R3(t) {
  return !Kk(t) && !v3(t) && /^\s*$/i.test(t.textContent) && !y3(t) && !w3(t);
}
function O3(t, e) {
  if (t.isBlock || e.preformattedCode && t.isCode)
    return { leading: "", trailing: "" };
  var n = I3(t.textContent);
  return n.leadingAscii && Kg("left", t, e) && (n.leading = n.leadingNonAscii), n.trailingAscii && Kg("right", t, e) && (n.trailing = n.trailingNonAscii), { leading: n.leading, trailing: n.trailing };
}
function I3(t) {
  var e = t.match(/^(([ \t\r\n]*)(\s*))(?:(?=\S)[\s\S]*\S)?((\s*?)([ \t\r\n]*))$/);
  return {
    leading: e[1],
    // whole string for whitespace-only strings
    leadingAscii: e[2],
    leadingNonAscii: e[3],
    trailing: e[4],
    // empty for whitespace-only strings
    trailingNonAscii: e[5],
    trailingAscii: e[6]
  };
}
function Kg(t, e, n) {
  var r, o, i;
  return t === "left" ? (r = e.previousSibling, o = / $/) : (r = e.nextSibling, o = /^ /), r && (r.nodeType === 3 ? i = o.test(r.nodeValue) : n.preformattedCode && r.nodeName === "CODE" ? i = !1 : r.nodeType === 1 && !wh(r) && (i = o.test(r.textContent))), i;
}
var D3 = Array.prototype.reduce, L3 = [
  [/\\/g, "\\\\"],
  [/\*/g, "\\*"],
  [/^-/g, "\\-"],
  [/^\+ /g, "\\+ "],
  [/^(=+)/g, "\\$1"],
  [/^(#{1,6}) /g, "\\$1 "],
  [/`/g, "\\`"],
  [/^~~~/g, "\\~~~"],
  [/\[/g, "\\["],
  [/\]/g, "\\]"],
  [/^>/g, "\\>"],
  [/_/g, "\\_"],
  [/^(\d+)\. /g, "$1\\. "]
];
function Vl(t) {
  if (!(this instanceof Vl)) return new Vl(t);
  var e = {
    rules: Ot,
    headingStyle: "setext",
    hr: "* * *",
    bulletListMarker: "*",
    codeBlockStyle: "indented",
    fence: "```",
    emDelimiter: "_",
    strongDelimiter: "**",
    linkStyle: "inlined",
    linkReferenceStyle: "full",
    br: "  ",
    preformattedCode: !1,
    blankReplacement: function(n, r) {
      return r.isBlock ? `

` : "";
    },
    keepReplacement: function(n, r) {
      return r.isBlock ? `

` + r.outerHTML + `

` : r.outerHTML;
    },
    defaultReplacement: function(n, r) {
      return r.isBlock ? `

` + n + `

` : n;
    }
  };
  this.options = g3({}, e, t), this.rules = new jk(this.options);
}
Vl.prototype = {
  /**
   * The entry point for converting a string or DOM node to Markdown
   * @public
   * @param {String|HTMLElement} input The string or DOM node to convert
   * @returns A Markdown representation of the input
   * @type String
   */
  turndown: function(t) {
    if (!z3(t))
      throw new TypeError(
        t + " is not a string, or an element/document/fragment node."
      );
    if (t === "") return "";
    var e = Yk.call(this, new C3(t, this.options));
    return P3.call(this, e);
  },
  /**
   * Add one or more plugins
   * @public
   * @param {Function|Array} plugin The plugin or array of plugins to add
   * @returns The Turndown instance for chaining
   * @type Object
   */
  use: function(t) {
    if (Array.isArray(t))
      for (var e = 0; e < t.length; e++) this.use(t[e]);
    else if (typeof t == "function")
      t(this);
    else
      throw new TypeError("plugin must be a Function or an Array of Functions");
    return this;
  },
  /**
   * Adds a rule
   * @public
   * @param {String} key The unique key of the rule
   * @param {Object} rule The rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  addRule: function(t, e) {
    return this.rules.add(t, e), this;
  },
  /**
   * Keep a node (as HTML) that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  keep: function(t) {
    return this.rules.keep(t), this;
  },
  /**
   * Remove a node that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */
  remove: function(t) {
    return this.rules.remove(t), this;
  },
  /**
   * Escapes Markdown syntax
   * @public
   * @param {String} string The string to escape
   * @returns A string with Markdown syntax escaped
   * @type String
   */
  escape: function(t) {
    return L3.reduce(function(e, n) {
      return e.replace(n[0], n[1]);
    }, t);
  }
};
function Yk(t) {
  var e = this;
  return D3.call(t.childNodes, function(n, r) {
    r = new _3(r, e.options);
    var o = "";
    return r.nodeType === 3 ? o = r.isCode ? r.nodeValue : e.escape(r.nodeValue) : r.nodeType === 1 && (o = B3.call(e, r)), Xk(n, o);
  }, "");
}
function P3(t) {
  var e = this;
  return this.rules.forEach(function(n) {
    typeof n.append == "function" && (t = Xk(t, n.append(e.options)));
  }), t.replace(/^[\t\r\n]+/, "").replace(/[\t\r\n\s]+$/, "");
}
function B3(t) {
  var e = this.rules.forNode(t), n = Yk.call(this, t), r = t.flankingWhitespace;
  return (r.leading || r.trailing) && (n = n.trim()), r.leading + e.replacement(n, t, this.options) + r.trailing;
}
function Xk(t, e) {
  var n = Uk(t), r = Fk(e), o = Math.max(t.length - n.length, e.length - r.length), i = `

`.substring(0, o);
  return n + i + r;
}
function z3(t) {
  return t != null && (typeof t == "string" || t.nodeType && (t.nodeType === 1 || t.nodeType === 9 || t.nodeType === 11));
}
var qg = /highlight-(?:text|source)-([a-z0-9]+)/;
function $3(t) {
  t.addRule("highlightedCodeBlock", {
    filter: function(e) {
      var n = e.firstChild;
      return e.nodeName === "DIV" && qg.test(e.className) && n && n.nodeName === "PRE";
    },
    replacement: function(e, n, r) {
      var o = n.className || "", i = (o.match(qg) || [null, ""])[1];
      return `

` + r.fence + i + `
` + n.firstChild.textContent + `
` + r.fence + `

`;
    }
  });
}
function H3(t) {
  t.addRule("strikethrough", {
    filter: ["del", "s", "strike"],
    replacement: function(e) {
      return "~" + e + "~";
    }
  });
}
var F3 = Array.prototype.indexOf, U3 = Array.prototype.every, ii = {};
ii.tableCell = {
  filter: ["th", "td"],
  replacement: function(t, e) {
    return Zk(t, e);
  }
};
ii.tableRow = {
  filter: "tr",
  replacement: function(t, e) {
    var n = "", r = { left: ":--", right: "--:", center: ":-:" };
    if (Nh(e))
      for (var o = 0; o < e.childNodes.length; o++) {
        var i = "---", s = (e.childNodes[o].getAttribute("align") || "").toLowerCase();
        s && (i = r[s] || i), n += Zk(i, e.childNodes[o]);
      }
    return `
` + t + (n ? `
` + n : "");
  }
};
ii.table = {
  // Only convert tables with a heading row.
  // Tables with no heading row are kept using `keep` (see below).
  filter: function(t) {
    return t.nodeName === "TABLE" && Nh(t.rows[0]);
  },
  replacement: function(t) {
    return t = t.replace(`

`, `
`), `

` + t + `

`;
  }
};
ii.tableSection = {
  filter: ["thead", "tbody", "tfoot"],
  replacement: function(t) {
    return t;
  }
};
function Nh(t) {
  var e = t.parentNode;
  return e.nodeName === "THEAD" || e.firstChild === t && (e.nodeName === "TABLE" || W3(e)) && U3.call(t.childNodes, function(n) {
    return n.nodeName === "TH";
  });
}
function W3(t) {
  var e = t.previousSibling;
  return t.nodeName === "TBODY" && (!e || e.nodeName === "THEAD" && /^\s*$/i.test(e.textContent));
}
function Zk(t, e) {
  var n = F3.call(e.parentNode.childNodes, e), r = " ";
  return n === 0 && (r = "| "), r + t + " |";
}
function V3(t) {
  t.keep(function(n) {
    return n.nodeName === "TABLE" && !Nh(n.rows[0]);
  });
  for (var e in ii) t.addRule(e, ii[e]);
}
function K3(t) {
  t.addRule("taskListItems", {
    filter: function(e) {
      return e.type === "checkbox" && e.parentNode.nodeName === "LI";
    },
    replacement: function(e, n) {
      return (n.checked ? "[x]" : "[ ]") + " ";
    }
  });
}
function q3(t) {
  t.use([
    $3,
    H3,
    V3,
    K3
  ]);
}
function Eh() {
  return { async: !1, breaks: !1, extensions: null, gfm: !0, hooks: null, pedantic: !1, renderer: null, silent: !1, tokenizer: null, walkTokens: null };
}
var ho = Eh();
function Jk(t) {
  ho = t;
}
var Yi = { exec: () => null };
function Pe(t, e = "") {
  let n = typeof t == "string" ? t : t.source, r = { replace: (o, i) => {
    let s = typeof i == "string" ? i : i.source;
    return s = s.replace(Dt.caret, "$1"), n = n.replace(o, s), r;
  }, getRegex: () => new RegExp(n, e) };
  return r;
}
var G3 = (() => {
  try {
    return !!new RegExp("(?<=1)(?<!1)");
  } catch {
    return !1;
  }
})(), Dt = { codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm, outputLinkReplace: /\\([\[\]])/g, indentCodeCompensation: /^(\s+)(?:```)/, beginningSpace: /^\s+/, endingHash: /#$/, startingSpaceChar: /^ /, endingSpaceChar: / $/, nonSpaceChar: /[^ ]/, newLineCharGlobal: /\n/g, tabCharGlobal: /\t/g, multipleSpaceGlobal: /\s+/g, blankLine: /^[ \t]*$/, doubleBlankLine: /\n[ \t]*\n[ \t]*$/, blockquoteStart: /^ {0,3}>/, blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g, blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm, listReplaceTabs: /^\t+/, listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g, listIsTask: /^\[[ xX]\] +\S/, listReplaceTask: /^\[[ xX]\] +/, listTaskCheckbox: /\[[ xX]\]/, anyLine: /\n.*\n/, hrefBrackets: /^<(.*)>$/, tableDelimiter: /[:|]/, tableAlignChars: /^\||\| *$/g, tableRowBlankLine: /\n[ \t]*$/, tableAlignRight: /^ *-+: *$/, tableAlignCenter: /^ *:-+: *$/, tableAlignLeft: /^ *:-+ *$/, startATag: /^<a /i, endATag: /^<\/a>/i, startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i, endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i, startAngleBracket: /^</, endAngleBracket: />$/, pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/, unicodeAlphaNumeric: /[\p{L}\p{N}]/u, escapeTest: /[&<>"']/, escapeReplace: /[&<>"']/g, escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g, unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, caret: /(^|[^\[])\^/g, percentDecode: /%25/g, findPipe: /\|/g, splitPipe: / \|/, slashPipe: /\\\|/g, carriageReturn: /\r\n|\r/g, spaceLine: /^ +$/gm, notSpaceStart: /^\S*/, endingNewline: /\n$/, listItemRegex: (t) => new RegExp(`^( {0,3}${t})((?:[	 ][^\\n]*)?(?:\\n|$))`), nextBulletRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), hrRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), fencesBeginRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}(?:\`\`\`|~~~)`), headingBeginRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}#`), htmlBeginRegex: (t) => new RegExp(`^ {0,${Math.min(3, t - 1)}}<(?:[a-z].*>|!--)`, "i") }, j3 = /^(?:[ \t]*(?:\n|$))+/, Y3 = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/, X3 = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, Ts = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, Z3 = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, Sh = /(?:[*+-]|\d{1,9}[.)])/, Qk = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/, ex = Pe(Qk).replace(/bull/g, Sh).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex(), J3 = Pe(Qk).replace(/bull/g, Sh).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(), Th = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, Q3 = /^[^\n]+/, Ch = /(?!\s*\])(?:\\[\s\S]|[^\[\]\\])+/, e$ = Pe(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", Ch).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), t$ = Pe(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, Sh).getRegex(), Mc = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", Mh = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, n$ = Pe("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", Mh).replace("tag", Mc).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), tx = Pe(Th).replace("hr", Ts).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Mc).getRegex(), r$ = Pe(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", tx).getRegex(), Ah = { blockquote: r$, code: Y3, def: e$, fences: X3, heading: Z3, hr: Ts, html: n$, lheading: ex, list: t$, newline: j3, paragraph: tx, table: Yi, text: Q3 }, Gg = Pe("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", Ts).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Mc).getRegex(), o$ = { ...Ah, lheading: J3, table: Gg, paragraph: Pe(Th).replace("hr", Ts).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", Gg).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Mc).getRegex() }, i$ = { ...Ah, html: Pe(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", Mh).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: Yi, lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: Pe(Th).replace("hr", Ts).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", ex).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex() }, s$ = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, a$ = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, nx = /^( {2,}|\\)\n(?!\s*$)/, l$ = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, Ac = /[\p{P}\p{S}]/u, _h = /[\s\p{P}\p{S}]/u, rx = /[^\s\p{P}\p{S}]/u, c$ = Pe(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, _h).getRegex(), ox = /(?!~)[\p{P}\p{S}]/u, u$ = /(?!~)[\s\p{P}\p{S}]/u, d$ = /(?:[^\s\p{P}\p{S}]|~)/u, f$ = Pe(/link|precode-code|html/, "g").replace("link", /\[(?:[^\[\]`]|(?<a>`+)[^`]+\k<a>(?!`))*?\]\((?:\\[\s\S]|[^\\\(\)]|\((?:\\[\s\S]|[^\\\(\)])*\))*\)/).replace("precode-", G3 ? "(?<!`)()" : "(^^|[^`])").replace("code", /(?<b>`+)[^`]+\k<b>(?!`)/).replace("html", /<(?! )[^<>]*?>/).getRegex(), ix = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/, h$ = Pe(ix, "u").replace(/punct/g, Ac).getRegex(), m$ = Pe(ix, "u").replace(/punct/g, ox).getRegex(), sx = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)", p$ = Pe(sx, "gu").replace(/notPunctSpace/g, rx).replace(/punctSpace/g, _h).replace(/punct/g, Ac).getRegex(), g$ = Pe(sx, "gu").replace(/notPunctSpace/g, d$).replace(/punctSpace/g, u$).replace(/punct/g, ox).getRegex(), b$ = Pe("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, rx).replace(/punctSpace/g, _h).replace(/punct/g, Ac).getRegex(), y$ = Pe(/\\(punct)/, "gu").replace(/punct/g, Ac).getRegex(), v$ = Pe(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), w$ = Pe(Mh).replace("(?:-->|$)", "-->").getRegex(), k$ = Pe("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", w$).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), Kl = /(?:\[(?:\\[\s\S]|[^\[\]\\])*\]|\\[\s\S]|`+[^`]*?`+(?!`)|[^\[\]\\`])*?/, x$ = Pe(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", Kl).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), ax = Pe(/^!?\[(label)\]\[(ref)\]/).replace("label", Kl).replace("ref", Ch).getRegex(), lx = Pe(/^!?\[(ref)\](?:\[\])?/).replace("ref", Ch).getRegex(), N$ = Pe("reflink|nolink(?!\\()", "g").replace("reflink", ax).replace("nolink", lx).getRegex(), jg = /[hH][tT][tT][pP][sS]?|[fF][tT][pP]/, Rh = { _backpedal: Yi, anyPunctuation: y$, autolink: v$, blockSkip: f$, br: nx, code: a$, del: Yi, emStrongLDelim: h$, emStrongRDelimAst: p$, emStrongRDelimUnd: b$, escape: s$, link: x$, nolink: lx, punctuation: c$, reflink: ax, reflinkSearch: N$, tag: k$, text: l$, url: Yi }, E$ = { ...Rh, link: Pe(/^!?\[(label)\]\((.*?)\)/).replace("label", Kl).getRegex(), reflink: Pe(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", Kl).getRegex() }, Bd = { ...Rh, emStrongRDelimAst: g$, emStrongLDelim: m$, url: Pe(/^((?:protocol):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/).replace("protocol", jg).replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(), _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])((?:\\[\s\S]|[^\\])*?(?:\\[\s\S]|[^\s~\\]))\1(?=[^~]|$)/, text: Pe(/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|protocol:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/).replace("protocol", jg).getRegex() }, S$ = { ...Bd, br: Pe(nx).replace("{2,}", "*").getRegex(), text: Pe(Bd.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() }, ba = { normal: Ah, gfm: o$, pedantic: i$ }, Ei = { normal: Rh, gfm: Bd, breaks: S$, pedantic: E$ }, T$ = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, Yg = (t) => T$[t];
function jn(t, e) {
  if (e) {
    if (Dt.escapeTest.test(t)) return t.replace(Dt.escapeReplace, Yg);
  } else if (Dt.escapeTestNoEncode.test(t)) return t.replace(Dt.escapeReplaceNoEncode, Yg);
  return t;
}
function Xg(t) {
  try {
    t = encodeURI(t).replace(Dt.percentDecode, "%");
  } catch {
    return null;
  }
  return t;
}
function Zg(t, e) {
  let n = t.replace(Dt.findPipe, (i, s, a) => {
    let l = !1, c = s;
    for (; --c >= 0 && a[c] === "\\"; ) l = !l;
    return l ? "|" : " |";
  }), r = n.split(Dt.splitPipe), o = 0;
  if (r[0].trim() || r.shift(), r.length > 0 && !r.at(-1)?.trim() && r.pop(), e) if (r.length > e) r.splice(e);
  else for (; r.length < e; ) r.push("");
  for (; o < r.length; o++) r[o] = r[o].trim().replace(Dt.slashPipe, "|");
  return r;
}
function Si(t, e, n) {
  let r = t.length;
  if (r === 0) return "";
  let o = 0;
  for (; o < r && t.charAt(r - o - 1) === e; )
    o++;
  return t.slice(0, r - o);
}
function C$(t, e) {
  if (t.indexOf(e[1]) === -1) return -1;
  let n = 0;
  for (let r = 0; r < t.length; r++) if (t[r] === "\\") r++;
  else if (t[r] === e[0]) n++;
  else if (t[r] === e[1] && (n--, n < 0)) return r;
  return n > 0 ? -2 : -1;
}
function Jg(t, e, n, r, o) {
  let i = e.href, s = e.title || null, a = t[1].replace(o.other.outputLinkReplace, "$1");
  r.state.inLink = !0;
  let l = { type: t[0].charAt(0) === "!" ? "image" : "link", raw: n, href: i, title: s, text: a, tokens: r.inlineTokens(a) };
  return r.state.inLink = !1, l;
}
function M$(t, e, n) {
  let r = t.match(n.other.indentCodeCompensation);
  if (r === null) return e;
  let o = r[1];
  return e.split(`
`).map((i) => {
    let s = i.match(n.other.beginningSpace);
    if (s === null) return i;
    let [a] = s;
    return a.length >= o.length ? i.slice(o.length) : i;
  }).join(`
`);
}
var ql = class {
  options;
  rules;
  lexer;
  constructor(t) {
    this.options = t || ho;
  }
  space(t) {
    let e = this.rules.block.newline.exec(t);
    if (e && e[0].length > 0) return { type: "space", raw: e[0] };
  }
  code(t) {
    let e = this.rules.block.code.exec(t);
    if (e) {
      let n = e[0].replace(this.rules.other.codeRemoveIndent, "");
      return { type: "code", raw: e[0], codeBlockStyle: "indented", text: this.options.pedantic ? n : Si(n, `
`) };
    }
  }
  fences(t) {
    let e = this.rules.block.fences.exec(t);
    if (e) {
      let n = e[0], r = M$(n, e[3] || "", this.rules);
      return { type: "code", raw: n, lang: e[2] ? e[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : e[2], text: r };
    }
  }
  heading(t) {
    let e = this.rules.block.heading.exec(t);
    if (e) {
      let n = e[2].trim();
      if (this.rules.other.endingHash.test(n)) {
        let r = Si(n, "#");
        (this.options.pedantic || !r || this.rules.other.endingSpaceChar.test(r)) && (n = r.trim());
      }
      return { type: "heading", raw: e[0], depth: e[1].length, text: n, tokens: this.lexer.inline(n) };
    }
  }
  hr(t) {
    let e = this.rules.block.hr.exec(t);
    if (e) return { type: "hr", raw: Si(e[0], `
`) };
  }
  blockquote(t) {
    let e = this.rules.block.blockquote.exec(t);
    if (e) {
      let n = Si(e[0], `
`).split(`
`), r = "", o = "", i = [];
      for (; n.length > 0; ) {
        let s = !1, a = [], l;
        for (l = 0; l < n.length; l++) if (this.rules.other.blockquoteStart.test(n[l])) a.push(n[l]), s = !0;
        else if (!s) a.push(n[l]);
        else break;
        n = n.slice(l);
        let c = a.join(`
`), u = c.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
        r = r ? `${r}
${c}` : c, o = o ? `${o}
${u}` : u;
        let d = this.lexer.state.top;
        if (this.lexer.state.top = !0, this.lexer.blockTokens(u, i, !0), this.lexer.state.top = d, n.length === 0) break;
        let f = i.at(-1);
        if (f?.type === "code") break;
        if (f?.type === "blockquote") {
          let h = f, m = h.raw + `
` + n.join(`
`), p = this.blockquote(m);
          i[i.length - 1] = p, r = r.substring(0, r.length - h.raw.length) + p.raw, o = o.substring(0, o.length - h.text.length) + p.text;
          break;
        } else if (f?.type === "list") {
          let h = f, m = h.raw + `
` + n.join(`
`), p = this.list(m);
          i[i.length - 1] = p, r = r.substring(0, r.length - f.raw.length) + p.raw, o = o.substring(0, o.length - h.raw.length) + p.raw, n = m.substring(i.at(-1).raw.length).split(`
`);
          continue;
        }
      }
      return { type: "blockquote", raw: r, tokens: i, text: o };
    }
  }
  list(t) {
    let e = this.rules.block.list.exec(t);
    if (e) {
      let n = e[1].trim(), r = n.length > 1, o = { type: "list", raw: "", ordered: r, start: r ? +n.slice(0, -1) : "", loose: !1, items: [] };
      n = r ? `\\d{1,9}\\${n.slice(-1)}` : `\\${n}`, this.options.pedantic && (n = r ? n : "[*+-]");
      let i = this.rules.other.listItemRegex(n), s = !1;
      for (; t; ) {
        let l = !1, c = "", u = "";
        if (!(e = i.exec(t)) || this.rules.block.hr.test(t)) break;
        c = e[0], t = t.substring(c.length);
        let d = e[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, (p) => " ".repeat(3 * p.length)), f = t.split(`
`, 1)[0], h = !d.trim(), m = 0;
        if (this.options.pedantic ? (m = 2, u = d.trimStart()) : h ? m = e[1].length + 1 : (m = e[2].search(this.rules.other.nonSpaceChar), m = m > 4 ? 1 : m, u = d.slice(m), m += e[1].length), h && this.rules.other.blankLine.test(f) && (c += f + `
`, t = t.substring(f.length + 1), l = !0), !l) {
          let p = this.rules.other.nextBulletRegex(m), g = this.rules.other.hrRegex(m), b = this.rules.other.fencesBeginRegex(m), v = this.rules.other.headingBeginRegex(m), k = this.rules.other.htmlBeginRegex(m);
          for (; t; ) {
            let x = t.split(`
`, 1)[0], w;
            if (f = x, this.options.pedantic ? (f = f.replace(this.rules.other.listReplaceNesting, "  "), w = f) : w = f.replace(this.rules.other.tabCharGlobal, "    "), b.test(f) || v.test(f) || k.test(f) || p.test(f) || g.test(f)) break;
            if (w.search(this.rules.other.nonSpaceChar) >= m || !f.trim()) u += `
` + w.slice(m);
            else {
              if (h || d.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || b.test(d) || v.test(d) || g.test(d)) break;
              u += `
` + f;
            }
            !h && !f.trim() && (h = !0), c += x + `
`, t = t.substring(x.length + 1), d = w.slice(m);
          }
        }
        o.loose || (s ? o.loose = !0 : this.rules.other.doubleBlankLine.test(c) && (s = !0)), o.items.push({ type: "list_item", raw: c, task: !!this.options.gfm && this.rules.other.listIsTask.test(u), loose: !1, text: u, tokens: [] }), o.raw += c;
      }
      let a = o.items.at(-1);
      if (a) a.raw = a.raw.trimEnd(), a.text = a.text.trimEnd();
      else return;
      o.raw = o.raw.trimEnd();
      for (let l of o.items) {
        if (this.lexer.state.top = !1, l.tokens = this.lexer.blockTokens(l.text, []), l.task) {
          if (l.text = l.text.replace(this.rules.other.listReplaceTask, ""), l.tokens[0]?.type === "text" || l.tokens[0]?.type === "paragraph") {
            l.tokens[0].raw = l.tokens[0].raw.replace(this.rules.other.listReplaceTask, ""), l.tokens[0].text = l.tokens[0].text.replace(this.rules.other.listReplaceTask, "");
            for (let u = this.lexer.inlineQueue.length - 1; u >= 0; u--) if (this.rules.other.listIsTask.test(this.lexer.inlineQueue[u].src)) {
              this.lexer.inlineQueue[u].src = this.lexer.inlineQueue[u].src.replace(this.rules.other.listReplaceTask, "");
              break;
            }
          }
          let c = this.rules.other.listTaskCheckbox.exec(l.raw);
          if (c) {
            let u = { type: "checkbox", raw: c[0] + " ", checked: c[0] !== "[ ]" };
            l.checked = u.checked, o.loose ? l.tokens[0] && ["paragraph", "text"].includes(l.tokens[0].type) && "tokens" in l.tokens[0] && l.tokens[0].tokens ? (l.tokens[0].raw = u.raw + l.tokens[0].raw, l.tokens[0].text = u.raw + l.tokens[0].text, l.tokens[0].tokens.unshift(u)) : l.tokens.unshift({ type: "paragraph", raw: u.raw, text: u.raw, tokens: [u] }) : l.tokens.unshift(u);
          }
        }
        if (!o.loose) {
          let c = l.tokens.filter((d) => d.type === "space"), u = c.length > 0 && c.some((d) => this.rules.other.anyLine.test(d.raw));
          o.loose = u;
        }
      }
      if (o.loose) for (let l of o.items) {
        l.loose = !0;
        for (let c of l.tokens) c.type === "text" && (c.type = "paragraph");
      }
      return o;
    }
  }
  html(t) {
    let e = this.rules.block.html.exec(t);
    if (e) return { type: "html", block: !0, raw: e[0], pre: e[1] === "pre" || e[1] === "script" || e[1] === "style", text: e[0] };
  }
  def(t) {
    let e = this.rules.block.def.exec(t);
    if (e) {
      let n = e[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), r = e[2] ? e[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", o = e[3] ? e[3].substring(1, e[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : e[3];
      return { type: "def", tag: n, raw: e[0], href: r, title: o };
    }
  }
  table(t) {
    let e = this.rules.block.table.exec(t);
    if (!e || !this.rules.other.tableDelimiter.test(e[2])) return;
    let n = Zg(e[1]), r = e[2].replace(this.rules.other.tableAlignChars, "").split("|"), o = e[3]?.trim() ? e[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], i = { type: "table", raw: e[0], header: [], align: [], rows: [] };
    if (n.length === r.length) {
      for (let s of r) this.rules.other.tableAlignRight.test(s) ? i.align.push("right") : this.rules.other.tableAlignCenter.test(s) ? i.align.push("center") : this.rules.other.tableAlignLeft.test(s) ? i.align.push("left") : i.align.push(null);
      for (let s = 0; s < n.length; s++) i.header.push({ text: n[s], tokens: this.lexer.inline(n[s]), header: !0, align: i.align[s] });
      for (let s of o) i.rows.push(Zg(s, i.header.length).map((a, l) => ({ text: a, tokens: this.lexer.inline(a), header: !1, align: i.align[l] })));
      return i;
    }
  }
  lheading(t) {
    let e = this.rules.block.lheading.exec(t);
    if (e) return { type: "heading", raw: e[0], depth: e[2].charAt(0) === "=" ? 1 : 2, text: e[1], tokens: this.lexer.inline(e[1]) };
  }
  paragraph(t) {
    let e = this.rules.block.paragraph.exec(t);
    if (e) {
      let n = e[1].charAt(e[1].length - 1) === `
` ? e[1].slice(0, -1) : e[1];
      return { type: "paragraph", raw: e[0], text: n, tokens: this.lexer.inline(n) };
    }
  }
  text(t) {
    let e = this.rules.block.text.exec(t);
    if (e) return { type: "text", raw: e[0], text: e[0], tokens: this.lexer.inline(e[0]) };
  }
  escape(t) {
    let e = this.rules.inline.escape.exec(t);
    if (e) return { type: "escape", raw: e[0], text: e[1] };
  }
  tag(t) {
    let e = this.rules.inline.tag.exec(t);
    if (e) return !this.lexer.state.inLink && this.rules.other.startATag.test(e[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && this.rules.other.endATag.test(e[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(e[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(e[0]) && (this.lexer.state.inRawBlock = !1), { type: "html", raw: e[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, block: !1, text: e[0] };
  }
  link(t) {
    let e = this.rules.inline.link.exec(t);
    if (e) {
      let n = e[2].trim();
      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(n)) {
        if (!this.rules.other.endAngleBracket.test(n)) return;
        let i = Si(n.slice(0, -1), "\\");
        if ((n.length - i.length) % 2 === 0) return;
      } else {
        let i = C$(e[2], "()");
        if (i === -2) return;
        if (i > -1) {
          let s = (e[0].indexOf("!") === 0 ? 5 : 4) + e[1].length + i;
          e[2] = e[2].substring(0, i), e[0] = e[0].substring(0, s).trim(), e[3] = "";
        }
      }
      let r = e[2], o = "";
      if (this.options.pedantic) {
        let i = this.rules.other.pedanticHrefTitle.exec(r);
        i && (r = i[1], o = i[3]);
      } else o = e[3] ? e[3].slice(1, -1) : "";
      return r = r.trim(), this.rules.other.startAngleBracket.test(r) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(n) ? r = r.slice(1) : r = r.slice(1, -1)), Jg(e, { href: r && r.replace(this.rules.inline.anyPunctuation, "$1"), title: o && o.replace(this.rules.inline.anyPunctuation, "$1") }, e[0], this.lexer, this.rules);
    }
  }
  reflink(t, e) {
    let n;
    if ((n = this.rules.inline.reflink.exec(t)) || (n = this.rules.inline.nolink.exec(t))) {
      let r = (n[2] || n[1]).replace(this.rules.other.multipleSpaceGlobal, " "), o = e[r.toLowerCase()];
      if (!o) {
        let i = n[0].charAt(0);
        return { type: "text", raw: i, text: i };
      }
      return Jg(n, o, n[0], this.lexer, this.rules);
    }
  }
  emStrong(t, e, n = "") {
    let r = this.rules.inline.emStrongLDelim.exec(t);
    if (!(!r || r[3] && n.match(this.rules.other.unicodeAlphaNumeric)) && (!(r[1] || r[2]) || !n || this.rules.inline.punctuation.exec(n))) {
      let o = [...r[0]].length - 1, i, s, a = o, l = 0, c = r[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      for (c.lastIndex = 0, e = e.slice(-1 * t.length + o); (r = c.exec(e)) != null; ) {
        if (i = r[1] || r[2] || r[3] || r[4] || r[5] || r[6], !i) continue;
        if (s = [...i].length, r[3] || r[4]) {
          a += s;
          continue;
        } else if ((r[5] || r[6]) && o % 3 && !((o + s) % 3)) {
          l += s;
          continue;
        }
        if (a -= s, a > 0) continue;
        s = Math.min(s, s + a + l);
        let u = [...r[0]][0].length, d = t.slice(0, o + r.index + u + s);
        if (Math.min(o, s) % 2) {
          let h = d.slice(1, -1);
          return { type: "em", raw: d, text: h, tokens: this.lexer.inlineTokens(h) };
        }
        let f = d.slice(2, -2);
        return { type: "strong", raw: d, text: f, tokens: this.lexer.inlineTokens(f) };
      }
    }
  }
  codespan(t) {
    let e = this.rules.inline.code.exec(t);
    if (e) {
      let n = e[2].replace(this.rules.other.newLineCharGlobal, " "), r = this.rules.other.nonSpaceChar.test(n), o = this.rules.other.startingSpaceChar.test(n) && this.rules.other.endingSpaceChar.test(n);
      return r && o && (n = n.substring(1, n.length - 1)), { type: "codespan", raw: e[0], text: n };
    }
  }
  br(t) {
    let e = this.rules.inline.br.exec(t);
    if (e) return { type: "br", raw: e[0] };
  }
  del(t) {
    let e = this.rules.inline.del.exec(t);
    if (e) return { type: "del", raw: e[0], text: e[2], tokens: this.lexer.inlineTokens(e[2]) };
  }
  autolink(t) {
    let e = this.rules.inline.autolink.exec(t);
    if (e) {
      let n, r;
      return e[2] === "@" ? (n = e[1], r = "mailto:" + n) : (n = e[1], r = n), { type: "link", raw: e[0], text: n, href: r, tokens: [{ type: "text", raw: n, text: n }] };
    }
  }
  url(t) {
    let e;
    if (e = this.rules.inline.url.exec(t)) {
      let n, r;
      if (e[2] === "@") n = e[0], r = "mailto:" + n;
      else {
        let o;
        do
          o = e[0], e[0] = this.rules.inline._backpedal.exec(e[0])?.[0] ?? "";
        while (o !== e[0]);
        n = e[0], e[1] === "www." ? r = "http://" + e[0] : r = e[0];
      }
      return { type: "link", raw: e[0], text: n, href: r, tokens: [{ type: "text", raw: n, text: n }] };
    }
  }
  inlineText(t) {
    let e = this.rules.inline.text.exec(t);
    if (e) {
      let n = this.lexer.state.inRawBlock;
      return { type: "text", raw: e[0], text: e[0], escaped: n };
    }
  }
}, un = class zd {
  tokens;
  options;
  state;
  inlineQueue;
  tokenizer;
  constructor(e) {
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = e || ho, this.options.tokenizer = this.options.tokenizer || new ql(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: !1, inRawBlock: !1, top: !0 };
    let n = { other: Dt, block: ba.normal, inline: Ei.normal };
    this.options.pedantic ? (n.block = ba.pedantic, n.inline = Ei.pedantic) : this.options.gfm && (n.block = ba.gfm, this.options.breaks ? n.inline = Ei.breaks : n.inline = Ei.gfm), this.tokenizer.rules = n;
  }
  static get rules() {
    return { block: ba, inline: Ei };
  }
  static lex(e, n) {
    return new zd(n).lex(e);
  }
  static lexInline(e, n) {
    return new zd(n).inlineTokens(e);
  }
  lex(e) {
    e = e.replace(Dt.carriageReturn, `
`), this.blockTokens(e, this.tokens);
    for (let n = 0; n < this.inlineQueue.length; n++) {
      let r = this.inlineQueue[n];
      this.inlineTokens(r.src, r.tokens);
    }
    return this.inlineQueue = [], this.tokens;
  }
  blockTokens(e, n = [], r = !1) {
    for (this.options.pedantic && (e = e.replace(Dt.tabCharGlobal, "    ").replace(Dt.spaceLine, "")); e; ) {
      let o;
      if (this.options.extensions?.block?.some((s) => (o = s.call({ lexer: this }, e, n)) ? (e = e.substring(o.raw.length), n.push(o), !0) : !1)) continue;
      if (o = this.tokenizer.space(e)) {
        e = e.substring(o.raw.length);
        let s = n.at(-1);
        o.raw.length === 1 && s !== void 0 ? s.raw += `
` : n.push(o);
        continue;
      }
      if (o = this.tokenizer.code(e)) {
        e = e.substring(o.raw.length);
        let s = n.at(-1);
        s?.type === "paragraph" || s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + o.raw, s.text += `
` + o.text, this.inlineQueue.at(-1).src = s.text) : n.push(o);
        continue;
      }
      if (o = this.tokenizer.fences(e)) {
        e = e.substring(o.raw.length), n.push(o);
        continue;
      }
      if (o = this.tokenizer.heading(e)) {
        e = e.substring(o.raw.length), n.push(o);
        continue;
      }
      if (o = this.tokenizer.hr(e)) {
        e = e.substring(o.raw.length), n.push(o);
        continue;
      }
      if (o = this.tokenizer.blockquote(e)) {
        e = e.substring(o.raw.length), n.push(o);
        continue;
      }
      if (o = this.tokenizer.list(e)) {
        e = e.substring(o.raw.length), n.push(o);
        continue;
      }
      if (o = this.tokenizer.html(e)) {
        e = e.substring(o.raw.length), n.push(o);
        continue;
      }
      if (o = this.tokenizer.def(e)) {
        e = e.substring(o.raw.length);
        let s = n.at(-1);
        s?.type === "paragraph" || s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + o.raw, s.text += `
` + o.raw, this.inlineQueue.at(-1).src = s.text) : this.tokens.links[o.tag] || (this.tokens.links[o.tag] = { href: o.href, title: o.title }, n.push(o));
        continue;
      }
      if (o = this.tokenizer.table(e)) {
        e = e.substring(o.raw.length), n.push(o);
        continue;
      }
      if (o = this.tokenizer.lheading(e)) {
        e = e.substring(o.raw.length), n.push(o);
        continue;
      }
      let i = e;
      if (this.options.extensions?.startBlock) {
        let s = 1 / 0, a = e.slice(1), l;
        this.options.extensions.startBlock.forEach((c) => {
          l = c.call({ lexer: this }, a), typeof l == "number" && l >= 0 && (s = Math.min(s, l));
        }), s < 1 / 0 && s >= 0 && (i = e.substring(0, s + 1));
      }
      if (this.state.top && (o = this.tokenizer.paragraph(i))) {
        let s = n.at(-1);
        r && s?.type === "paragraph" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + o.raw, s.text += `
` + o.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : n.push(o), r = i.length !== e.length, e = e.substring(o.raw.length);
        continue;
      }
      if (o = this.tokenizer.text(e)) {
        e = e.substring(o.raw.length);
        let s = n.at(-1);
        s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + o.raw, s.text += `
` + o.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : n.push(o);
        continue;
      }
      if (e) {
        let s = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(s);
          break;
        } else throw new Error(s);
      }
    }
    return this.state.top = !0, n;
  }
  inline(e, n = []) {
    return this.inlineQueue.push({ src: e, tokens: n }), n;
  }
  inlineTokens(e, n = []) {
    let r = e, o = null;
    if (this.tokens.links) {
      let l = Object.keys(this.tokens.links);
      if (l.length > 0) for (; (o = this.tokenizer.rules.inline.reflinkSearch.exec(r)) != null; ) l.includes(o[0].slice(o[0].lastIndexOf("[") + 1, -1)) && (r = r.slice(0, o.index) + "[" + "a".repeat(o[0].length - 2) + "]" + r.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (o = this.tokenizer.rules.inline.anyPunctuation.exec(r)) != null; ) r = r.slice(0, o.index) + "++" + r.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    let i;
    for (; (o = this.tokenizer.rules.inline.blockSkip.exec(r)) != null; ) i = o[2] ? o[2].length : 0, r = r.slice(0, o.index + i) + "[" + "a".repeat(o[0].length - i - 2) + "]" + r.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    r = this.options.hooks?.emStrongMask?.call({ lexer: this }, r) ?? r;
    let s = !1, a = "";
    for (; e; ) {
      s || (a = ""), s = !1;
      let l;
      if (this.options.extensions?.inline?.some((u) => (l = u.call({ lexer: this }, e, n)) ? (e = e.substring(l.raw.length), n.push(l), !0) : !1)) continue;
      if (l = this.tokenizer.escape(e)) {
        e = e.substring(l.raw.length), n.push(l);
        continue;
      }
      if (l = this.tokenizer.tag(e)) {
        e = e.substring(l.raw.length), n.push(l);
        continue;
      }
      if (l = this.tokenizer.link(e)) {
        e = e.substring(l.raw.length), n.push(l);
        continue;
      }
      if (l = this.tokenizer.reflink(e, this.tokens.links)) {
        e = e.substring(l.raw.length);
        let u = n.at(-1);
        l.type === "text" && u?.type === "text" ? (u.raw += l.raw, u.text += l.text) : n.push(l);
        continue;
      }
      if (l = this.tokenizer.emStrong(e, r, a)) {
        e = e.substring(l.raw.length), n.push(l);
        continue;
      }
      if (l = this.tokenizer.codespan(e)) {
        e = e.substring(l.raw.length), n.push(l);
        continue;
      }
      if (l = this.tokenizer.br(e)) {
        e = e.substring(l.raw.length), n.push(l);
        continue;
      }
      if (l = this.tokenizer.del(e)) {
        e = e.substring(l.raw.length), n.push(l);
        continue;
      }
      if (l = this.tokenizer.autolink(e)) {
        e = e.substring(l.raw.length), n.push(l);
        continue;
      }
      if (!this.state.inLink && (l = this.tokenizer.url(e))) {
        e = e.substring(l.raw.length), n.push(l);
        continue;
      }
      let c = e;
      if (this.options.extensions?.startInline) {
        let u = 1 / 0, d = e.slice(1), f;
        this.options.extensions.startInline.forEach((h) => {
          f = h.call({ lexer: this }, d), typeof f == "number" && f >= 0 && (u = Math.min(u, f));
        }), u < 1 / 0 && u >= 0 && (c = e.substring(0, u + 1));
      }
      if (l = this.tokenizer.inlineText(c)) {
        e = e.substring(l.raw.length), l.raw.slice(-1) !== "_" && (a = l.raw.slice(-1)), s = !0;
        let u = n.at(-1);
        u?.type === "text" ? (u.raw += l.raw, u.text += l.text) : n.push(l);
        continue;
      }
      if (e) {
        let u = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(u);
          break;
        } else throw new Error(u);
      }
    }
    return n;
  }
}, Gl = class {
  options;
  parser;
  constructor(t) {
    this.options = t || ho;
  }
  space(t) {
    return "";
  }
  code({ text: t, lang: e, escaped: n }) {
    let r = (e || "").match(Dt.notSpaceStart)?.[0], o = t.replace(Dt.endingNewline, "") + `
`;
    return r ? '<pre><code class="language-' + jn(r) + '">' + (n ? o : jn(o, !0)) + `</code></pre>
` : "<pre><code>" + (n ? o : jn(o, !0)) + `</code></pre>
`;
  }
  blockquote({ tokens: t }) {
    return `<blockquote>
${this.parser.parse(t)}</blockquote>
`;
  }
  html({ text: t }) {
    return t;
  }
  def(t) {
    return "";
  }
  heading({ tokens: t, depth: e }) {
    return `<h${e}>${this.parser.parseInline(t)}</h${e}>
`;
  }
  hr(t) {
    return `<hr>
`;
  }
  list(t) {
    let e = t.ordered, n = t.start, r = "";
    for (let s = 0; s < t.items.length; s++) {
      let a = t.items[s];
      r += this.listitem(a);
    }
    let o = e ? "ol" : "ul", i = e && n !== 1 ? ' start="' + n + '"' : "";
    return "<" + o + i + `>
` + r + "</" + o + `>
`;
  }
  listitem(t) {
    return `<li>${this.parser.parse(t.tokens)}</li>
`;
  }
  checkbox({ checked: t }) {
    return "<input " + (t ? 'checked="" ' : "") + 'disabled="" type="checkbox"> ';
  }
  paragraph({ tokens: t }) {
    return `<p>${this.parser.parseInline(t)}</p>
`;
  }
  table(t) {
    let e = "", n = "";
    for (let o = 0; o < t.header.length; o++) n += this.tablecell(t.header[o]);
    e += this.tablerow({ text: n });
    let r = "";
    for (let o = 0; o < t.rows.length; o++) {
      let i = t.rows[o];
      n = "";
      for (let s = 0; s < i.length; s++) n += this.tablecell(i[s]);
      r += this.tablerow({ text: n });
    }
    return r && (r = `<tbody>${r}</tbody>`), `<table>
<thead>
` + e + `</thead>
` + r + `</table>
`;
  }
  tablerow({ text: t }) {
    return `<tr>
${t}</tr>
`;
  }
  tablecell(t) {
    let e = this.parser.parseInline(t.tokens), n = t.header ? "th" : "td";
    return (t.align ? `<${n} align="${t.align}">` : `<${n}>`) + e + `</${n}>
`;
  }
  strong({ tokens: t }) {
    return `<strong>${this.parser.parseInline(t)}</strong>`;
  }
  em({ tokens: t }) {
    return `<em>${this.parser.parseInline(t)}</em>`;
  }
  codespan({ text: t }) {
    return `<code>${jn(t, !0)}</code>`;
  }
  br(t) {
    return "<br>";
  }
  del({ tokens: t }) {
    return `<del>${this.parser.parseInline(t)}</del>`;
  }
  link({ href: t, title: e, tokens: n }) {
    let r = this.parser.parseInline(n), o = Xg(t);
    if (o === null) return r;
    t = o;
    let i = '<a href="' + t + '"';
    return e && (i += ' title="' + jn(e) + '"'), i += ">" + r + "</a>", i;
  }
  image({ href: t, title: e, text: n, tokens: r }) {
    r && (n = this.parser.parseInline(r, this.parser.textRenderer));
    let o = Xg(t);
    if (o === null) return jn(n);
    t = o;
    let i = `<img src="${t}" alt="${n}"`;
    return e && (i += ` title="${jn(e)}"`), i += ">", i;
  }
  text(t) {
    return "tokens" in t && t.tokens ? this.parser.parseInline(t.tokens) : "escaped" in t && t.escaped ? t.text : jn(t.text);
  }
}, Oh = class {
  strong({ text: t }) {
    return t;
  }
  em({ text: t }) {
    return t;
  }
  codespan({ text: t }) {
    return t;
  }
  del({ text: t }) {
    return t;
  }
  html({ text: t }) {
    return t;
  }
  text({ text: t }) {
    return t;
  }
  link({ text: t }) {
    return "" + t;
  }
  image({ text: t }) {
    return "" + t;
  }
  br() {
    return "";
  }
  checkbox({ raw: t }) {
    return t;
  }
}, dn = class $d {
  options;
  renderer;
  textRenderer;
  constructor(e) {
    this.options = e || ho, this.options.renderer = this.options.renderer || new Gl(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new Oh();
  }
  static parse(e, n) {
    return new $d(n).parse(e);
  }
  static parseInline(e, n) {
    return new $d(n).parseInline(e);
  }
  parse(e) {
    let n = "";
    for (let r = 0; r < e.length; r++) {
      let o = e[r];
      if (this.options.extensions?.renderers?.[o.type]) {
        let s = o, a = this.options.extensions.renderers[s.type].call({ parser: this }, s);
        if (a !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "def", "paragraph", "text"].includes(s.type)) {
          n += a || "";
          continue;
        }
      }
      let i = o;
      switch (i.type) {
        case "space": {
          n += this.renderer.space(i);
          break;
        }
        case "hr": {
          n += this.renderer.hr(i);
          break;
        }
        case "heading": {
          n += this.renderer.heading(i);
          break;
        }
        case "code": {
          n += this.renderer.code(i);
          break;
        }
        case "table": {
          n += this.renderer.table(i);
          break;
        }
        case "blockquote": {
          n += this.renderer.blockquote(i);
          break;
        }
        case "list": {
          n += this.renderer.list(i);
          break;
        }
        case "checkbox": {
          n += this.renderer.checkbox(i);
          break;
        }
        case "html": {
          n += this.renderer.html(i);
          break;
        }
        case "def": {
          n += this.renderer.def(i);
          break;
        }
        case "paragraph": {
          n += this.renderer.paragraph(i);
          break;
        }
        case "text": {
          n += this.renderer.text(i);
          break;
        }
        default: {
          let s = 'Token with "' + i.type + '" type was not found.';
          if (this.options.silent) return console.error(s), "";
          throw new Error(s);
        }
      }
    }
    return n;
  }
  parseInline(e, n = this.renderer) {
    let r = "";
    for (let o = 0; o < e.length; o++) {
      let i = e[o];
      if (this.options.extensions?.renderers?.[i.type]) {
        let a = this.options.extensions.renderers[i.type].call({ parser: this }, i);
        if (a !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(i.type)) {
          r += a || "";
          continue;
        }
      }
      let s = i;
      switch (s.type) {
        case "escape": {
          r += n.text(s);
          break;
        }
        case "html": {
          r += n.html(s);
          break;
        }
        case "link": {
          r += n.link(s);
          break;
        }
        case "image": {
          r += n.image(s);
          break;
        }
        case "checkbox": {
          r += n.checkbox(s);
          break;
        }
        case "strong": {
          r += n.strong(s);
          break;
        }
        case "em": {
          r += n.em(s);
          break;
        }
        case "codespan": {
          r += n.codespan(s);
          break;
        }
        case "br": {
          r += n.br(s);
          break;
        }
        case "del": {
          r += n.del(s);
          break;
        }
        case "text": {
          r += n.text(s);
          break;
        }
        default: {
          let a = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent) return console.error(a), "";
          throw new Error(a);
        }
      }
    }
    return r;
  }
}, Di = class {
  options;
  block;
  constructor(t) {
    this.options = t || ho;
  }
  static passThroughHooks = /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens", "emStrongMask"]);
  static passThroughHooksRespectAsync = /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens"]);
  preprocess(t) {
    return t;
  }
  postprocess(t) {
    return t;
  }
  processAllTokens(t) {
    return t;
  }
  emStrongMask(t) {
    return t;
  }
  provideLexer() {
    return this.block ? un.lex : un.lexInline;
  }
  provideParser() {
    return this.block ? dn.parse : dn.parseInline;
  }
}, A$ = class {
  defaults = Eh();
  options = this.setOptions;
  parse = this.parseMarkdown(!0);
  parseInline = this.parseMarkdown(!1);
  Parser = dn;
  Renderer = Gl;
  TextRenderer = Oh;
  Lexer = un;
  Tokenizer = ql;
  Hooks = Di;
  constructor(...t) {
    this.use(...t);
  }
  walkTokens(t, e) {
    let n = [];
    for (let r of t) switch (n = n.concat(e.call(this, r)), r.type) {
      case "table": {
        let o = r;
        for (let i of o.header) n = n.concat(this.walkTokens(i.tokens, e));
        for (let i of o.rows) for (let s of i) n = n.concat(this.walkTokens(s.tokens, e));
        break;
      }
      case "list": {
        let o = r;
        n = n.concat(this.walkTokens(o.items, e));
        break;
      }
      default: {
        let o = r;
        this.defaults.extensions?.childTokens?.[o.type] ? this.defaults.extensions.childTokens[o.type].forEach((i) => {
          let s = o[i].flat(1 / 0);
          n = n.concat(this.walkTokens(s, e));
        }) : o.tokens && (n = n.concat(this.walkTokens(o.tokens, e)));
      }
    }
    return n;
  }
  use(...t) {
    let e = this.defaults.extensions || { renderers: {}, childTokens: {} };
    return t.forEach((n) => {
      let r = { ...n };
      if (r.async = this.defaults.async || r.async || !1, n.extensions && (n.extensions.forEach((o) => {
        if (!o.name) throw new Error("extension name required");
        if ("renderer" in o) {
          let i = e.renderers[o.name];
          i ? e.renderers[o.name] = function(...s) {
            let a = o.renderer.apply(this, s);
            return a === !1 && (a = i.apply(this, s)), a;
          } : e.renderers[o.name] = o.renderer;
        }
        if ("tokenizer" in o) {
          if (!o.level || o.level !== "block" && o.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
          let i = e[o.level];
          i ? i.unshift(o.tokenizer) : e[o.level] = [o.tokenizer], o.start && (o.level === "block" ? e.startBlock ? e.startBlock.push(o.start) : e.startBlock = [o.start] : o.level === "inline" && (e.startInline ? e.startInline.push(o.start) : e.startInline = [o.start]));
        }
        "childTokens" in o && o.childTokens && (e.childTokens[o.name] = o.childTokens);
      }), r.extensions = e), n.renderer) {
        let o = this.defaults.renderer || new Gl(this.defaults);
        for (let i in n.renderer) {
          if (!(i in o)) throw new Error(`renderer '${i}' does not exist`);
          if (["options", "parser"].includes(i)) continue;
          let s = i, a = n.renderer[s], l = o[s];
          o[s] = (...c) => {
            let u = a.apply(o, c);
            return u === !1 && (u = l.apply(o, c)), u || "";
          };
        }
        r.renderer = o;
      }
      if (n.tokenizer) {
        let o = this.defaults.tokenizer || new ql(this.defaults);
        for (let i in n.tokenizer) {
          if (!(i in o)) throw new Error(`tokenizer '${i}' does not exist`);
          if (["options", "rules", "lexer"].includes(i)) continue;
          let s = i, a = n.tokenizer[s], l = o[s];
          o[s] = (...c) => {
            let u = a.apply(o, c);
            return u === !1 && (u = l.apply(o, c)), u;
          };
        }
        r.tokenizer = o;
      }
      if (n.hooks) {
        let o = this.defaults.hooks || new Di();
        for (let i in n.hooks) {
          if (!(i in o)) throw new Error(`hook '${i}' does not exist`);
          if (["options", "block"].includes(i)) continue;
          let s = i, a = n.hooks[s], l = o[s];
          Di.passThroughHooks.has(i) ? o[s] = (c) => {
            if (this.defaults.async && Di.passThroughHooksRespectAsync.has(i)) return (async () => {
              let d = await a.call(o, c);
              return l.call(o, d);
            })();
            let u = a.call(o, c);
            return l.call(o, u);
          } : o[s] = (...c) => {
            if (this.defaults.async) return (async () => {
              let d = await a.apply(o, c);
              return d === !1 && (d = await l.apply(o, c)), d;
            })();
            let u = a.apply(o, c);
            return u === !1 && (u = l.apply(o, c)), u;
          };
        }
        r.hooks = o;
      }
      if (n.walkTokens) {
        let o = this.defaults.walkTokens, i = n.walkTokens;
        r.walkTokens = function(s) {
          let a = [];
          return a.push(i.call(this, s)), o && (a = a.concat(o.call(this, s))), a;
        };
      }
      this.defaults = { ...this.defaults, ...r };
    }), this;
  }
  setOptions(t) {
    return this.defaults = { ...this.defaults, ...t }, this;
  }
  lexer(t, e) {
    return un.lex(t, e ?? this.defaults);
  }
  parser(t, e) {
    return dn.parse(t, e ?? this.defaults);
  }
  parseMarkdown(t) {
    return (e, n) => {
      let r = { ...n }, o = { ...this.defaults, ...r }, i = this.onError(!!o.silent, !!o.async);
      if (this.defaults.async === !0 && r.async === !1) return i(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      if (typeof e > "u" || e === null) return i(new Error("marked(): input parameter is undefined or null"));
      if (typeof e != "string") return i(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(e) + ", string expected"));
      if (o.hooks && (o.hooks.options = o, o.hooks.block = t), o.async) return (async () => {
        let s = o.hooks ? await o.hooks.preprocess(e) : e, a = await (o.hooks ? await o.hooks.provideLexer() : t ? un.lex : un.lexInline)(s, o), l = o.hooks ? await o.hooks.processAllTokens(a) : a;
        o.walkTokens && await Promise.all(this.walkTokens(l, o.walkTokens));
        let c = await (o.hooks ? await o.hooks.provideParser() : t ? dn.parse : dn.parseInline)(l, o);
        return o.hooks ? await o.hooks.postprocess(c) : c;
      })().catch(i);
      try {
        o.hooks && (e = o.hooks.preprocess(e));
        let s = (o.hooks ? o.hooks.provideLexer() : t ? un.lex : un.lexInline)(e, o);
        o.hooks && (s = o.hooks.processAllTokens(s)), o.walkTokens && this.walkTokens(s, o.walkTokens);
        let a = (o.hooks ? o.hooks.provideParser() : t ? dn.parse : dn.parseInline)(s, o);
        return o.hooks && (a = o.hooks.postprocess(a)), a;
      } catch (s) {
        return i(s);
      }
    };
  }
  onError(t, e) {
    return (n) => {
      if (n.message += `
Please report this to https://github.com/markedjs/marked.`, t) {
        let r = "<p>An error occurred:</p><pre>" + jn(n.message + "", !0) + "</pre>";
        return e ? Promise.resolve(r) : r;
      }
      if (e) return Promise.reject(n);
      throw n;
    };
  }
}, io = new A$();
function $e(t, e) {
  return io.parse(t, e);
}
$e.options = $e.setOptions = function(t) {
  return io.setOptions(t), $e.defaults = io.defaults, Jk($e.defaults), $e;
};
$e.getDefaults = Eh;
$e.defaults = ho;
$e.use = function(...t) {
  return io.use(...t), $e.defaults = io.defaults, Jk($e.defaults), $e;
};
$e.walkTokens = function(t, e) {
  return io.walkTokens(t, e);
};
$e.parseInline = io.parseInline;
$e.Parser = dn;
$e.parser = dn.parse;
$e.Renderer = Gl;
$e.TextRenderer = Oh;
$e.Lexer = un;
$e.lexer = un.lex;
$e.Tokenizer = ql;
$e.Hooks = Di;
$e.parse = $e;
$e.options;
$e.setOptions;
$e.use;
$e.walkTokens;
$e.parseInline;
dn.parse;
un.lex;
const _$ = () => {
  if (typeof window > "u") return !1;
  const t = "ontouchstart" in window, e = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent), n = window.innerWidth < 768;
  return t && (e || n) || e && n;
}, H$ = Xl(function({
  content: e = "",
  onChange: n,
  onHTMLChange: r,
  onMarkdownChange: o,
  placeholder: i = 'Start writing... Use "/" for commands',
  editable: s = !0,
  autofocus: a = !1,
  className: l = "",
  showToolbar: c = !0,
  showWordCount: u = !0,
  theme: d,
  autoSave: f = !0,
  autoSaveKey: h = "manus-editor-content",
  autoSaveDelay: m = 1e3,
  showRecoveryBanner: p = !0,
  showFloatingToolbar: g = !0,
  maxImageSize: b = 5 * 1024 * 1024,
  onImageUploadStart: v,
  onImageUploadComplete: k,
  onImageUploadError: x,
  showModeToggle: w = !0,
  // New props
  initialMode: E = "wysiwyg",
  onModeChange: S,
  onReady: C,
  onFocus: M,
  onBlur: O,
  onSelectionChange: q,
  onDestroy: K,
  onSave: j,
  onRecover: H,
  onWikiLinkClick: G,
  onLinkClick: V,
  findReplaceOpen: re,
  onFindReplaceChange: A,
  renderToolbar: $,
  renderFooter: _,
  disabledFeatures: z = {},
  minHeight: Q = "200px",
  maxHeight: ue,
  spellCheck: Me = !0,
  headingLevels: Oe = [1, 2, 3, 4, 5, 6],
  collapsibleHeadingLevels: je = [1, 2, 3],
  // TOC props
  showTableOfContents: me = !1,
  tocVisible: at = !0,
  onTocVisibilityChange: Ht,
  tocTitle: gt = "",
  tocMinLevel: jt = 1,
  tocMaxLevel: Ft = 4,
  tocShowLevelIndicators: an = !1,
  tocHighlightActive: mo = !0,
  tocTreeView: po = !1,
  tocWidth: Be = "240px",
  tocPosition: ln = "right",
  tocScrollOffset: Nn = 20,
  onTocItemClick: go,
  renderTocItem: hi,
  tocShowToggleButton: Cs = !0,
  // Performance profiler
  showPerformanceProfiler: _c = !1,
  onPerformanceProfilerClose: Ms
}, $n) {
  const [Yt] = J(() => _$()), [Xt, bo] = J(E), [As, _s] = J(""), Zt = fe(E), yo = fe(""), vo = fe(null), Rc = Xi(() => {
    const P = [
      hR.configure({
        heading: {
          levels: Oe
        },
        codeBlock: !1,
        // We use CodeBlockLowlight instead
        dropcursor: {
          color: "var(--primary)",
          width: 2
        },
        // Disable extensions that we configure separately to avoid duplicates
        link: !1,
        // We configure Link separately with custom options
        underline: !1,
        // We add Underline separately
        bold: {
          HTMLAttributes: {
            class: "font-bold"
          }
        },
        italic: {
          HTMLAttributes: {
            class: "italic"
          }
        }
      }),
      mR.configure({
        placeholder: i,
        emptyEditorClass: "is-editor-empty"
      }),
      gR.configure({
        types: ["heading", "paragraph"]
      }),
      wR.configure({
        multicolor: !0
      }),
      E_.configure({
        openOnClick: !1,
        autolink: !0,
        linkOnPaste: !0,
        HTMLAttributes: {
          rel: "noopener noreferrer",
          target: "_blank"
        }
      }),
      F_,
      ZR,
      QR,
      NO,
      jz,
      Zz,
      e3,
      Jz
    ];
    return z.tables || P.push(
      Mv.configure({
        resizable: !Yt,
        // Disable resize on mobile
        HTMLAttributes: {
          class: "editor-table"
        }
      }),
      _R,
      $R,
      HR,
      GR
    ), z.taskLists || P.push(
      jR.configure({
        HTMLAttributes: {
          class: "task-list"
        }
      }),
      YR.configure({
        nested: !0,
        HTMLAttributes: {
          class: "task-item"
        }
      })
    ), z.codeBlocks || P.push(B2), z.callouts || P.push(W2, Xz), z.collapsibleHeadings || P.push(
      Kz.configure({
        levels: je
      })
    ), z.images || P.push(
      G2.configure({
        allowBase64: !0,
        HTMLAttributes: {
          class: "editor-image"
        },
        onImageClick: (U) => {
          Br({
            isOpen: !0,
            src: U.src,
            alt: U.alt,
            pos: U.pos,
            position: { x: U.rect.left + U.rect.width / 2, y: U.rect.bottom }
          });
        }
      }),
      i3.configure({
        maxFileSize: b,
        onUploadStart: v,
        onUploadComplete: k,
        onUploadError: x
      })
    ), !Yt && !z.datePills && P.push(
      Q2.configure({
        HTMLAttributes: {
          class: "date-pill"
        }
      })
    ), z.wikiLinks || P.push(
      Hz.configure({
        onWikiLinkClick: (U) => {
          console.log("WikiLink clicked:", U), G?.(U);
        }
      })
    ), z.markdownPaste || P.push(
      Vz.configure({
        enableMarkdownPaste: !0
      })
    ), P;
  }, [i, Yt, b, v, k, x, Oe, je, z, G]), tr = fe(null), mi = fe(n), pi = fe(r), Oc = fe(o);
  mi.current = n, pi.current = r, Oc.current = o;
  const L = EA({
    /**
     * Performance: Render immediately without waiting for next tick
     */
    immediatelyRender: !0,
    /**
     * Performance: Prevent React re-renders on every ProseMirror transaction.
     * The editor DOM updates are handled by ProseMirror directly.
     * Only toolbar state and other React UI need selective re-renders via useEditorState.
     */
    shouldRerenderOnTransaction: !1,
    // @ts-ignore - Expose editor globally for debugging
    onCreate: ({ editor: P }) => {
      window.__tiptapEditor = P, C?.(P);
    },
    onDestroy: () => {
      K?.();
    },
    extensions: Rc,
    content: e,
    editable: s,
    autofocus: a,
    editorProps: {
      attributes: {
        class: "tiptap-editor outline-none min-h-full",
        spellcheck: Me ? "true" : "false"
      },
      handleClick: (P, U, we) => {
        if (V) {
          const be = we.target.closest("a");
          if (be) {
            const Ae = be.getAttribute("href");
            if (Ae && V(Ae, we) === !1)
              return we.preventDefault(), !0;
          }
        }
        return !1;
      }
    },
    onUpdate: ({ editor: P }) => {
      tr.current && clearTimeout(tr.current), tr.current = setTimeout(() => {
        if (!P.isDestroyed && (mi.current || pi.current)) {
          const U = P.getHTML();
          mi.current?.(U), pi.current?.(U);
        }
      }, 150);
    },
    onFocus: () => {
      M?.();
    },
    onBlur: () => {
      O?.();
    },
    onSelectionUpdate: ({ editor: P }) => {
      if (q) {
        const { from: U, to: we, empty: Le } = P.state.selection;
        q({ from: U, to: we, empty: Le });
      }
    }
  });
  ge(() => () => {
    tr.current && clearTimeout(tr.current);
  }, []);
  const [Rs, Pr] = J(!1), [nr, Br] = J(null), [rr, T] = J(!1), I = re !== void 0 ? re : rr, W = ie((P) => {
    T(P), A?.(P);
  }, [A]), [ye, Ye] = J(0), [Ze, oe] = J(""), X = Dz(L, {
    storageKey: h,
    debounceMs: m,
    enabled: f,
    onSave: (P) => {
      j?.(P);
    },
    onRecover: (P) => {
      H?.(P);
    }
  }), he = Xi(() => {
    const P = new Vl({
      headingStyle: "atx",
      codeBlockStyle: "fenced",
      bulletListMarker: "-",
      emDelimiter: "*",
      strongDelimiter: "**"
    });
    return P.use(q3), P.addRule("highlight", {
      filter: (U) => U.nodeName === "MARK",
      replacement: (U) => `==${U}==`
    }), P.addRule("resizableImage", {
      filter: "img",
      replacement: (U, we) => {
        const Le = we, be = Le.getAttribute("src") || "", Ae = Le.getAttribute("alt") || "", En = Le.getAttribute("width") || Le.style.width?.replace("px", "");
        return En ? `<img src="${be}" alt="${Ae}" width="${En}" />` : `![${Ae}](${be})`;
      }
    }), P.addRule("taskListItem", {
      filter: (U) => U.nodeName === "LI" && U.getAttribute("data-type") === "taskItem",
      replacement: (U, we) => {
        const Le = we.querySelector('input[type="checkbox"]');
        return `- [${Le?.hasAttribute("checked") || Le?.checked ? "x" : " "}] ${U.trim()}
`;
      }
    }), P.addRule("table", {
      filter: "table",
      replacement: function(U, we) {
        const Le = we, be = Array.from(Le.querySelectorAll("tr"));
        if (be.length === 0) return "";
        const Ae = [];
        return be.forEach((En, gi) => {
          const xo = Array.from(En.querySelectorAll("th, td")), Sn = xo.map((No) => (No.textContent?.trim() || "").replace(/\|/g, "\\|"));
          if (Ae.push("| " + Sn.join(" | ") + " |"), gi === 0) {
            const No = xo.map(() => "---").join(" | ");
            Ae.push("| " + No + " |");
          }
        }), `

` + Ae.join(`
`) + `

`;
      }
    }), P.addRule("tableCell", {
      filter: ["th", "td"],
      replacement: function(U) {
        return U;
      }
    }), P.addRule("callout", {
      filter: (U) => U.nodeName === "DIV" && U.hasAttribute("data-callout"),
      replacement: (U, we) => {
        const Le = we.getAttribute("data-type") || "info", be = U.trim().replace(/\n{3,}/g, `

`);
        return `

\`\`\`${Le}
${be}
\`\`\`

`;
      }
    }), P;
  }, []), He = ie((P) => {
    if (L) {
      if (P === "markdown" && Zt.current === "wysiwyg") {
        const U = L.getHTML(), we = he.turndown(U);
        _s(we), yo.current = we;
      } else if (P === "wysiwyg" && Zt.current === "markdown") {
        const U = ["info", "warning", "error", "success", "note"];
        let we = yo.current;
        U.forEach((be) => {
          const Ae = new RegExp(`\`\`\`${be}\\s*\\n([\\s\\S]*?)\`\`\``, "g");
          we = we.replace(Ae, (En, gi) => {
            const xo = $e.parse(gi.trim(), { async: !1 });
            return `<div data-callout="" data-type="${be}" class="callout callout-${be}">${xo}</div>`;
          });
        });
        const Le = $e.parse(we, { async: !1 });
        queueMicrotask(() => {
          L.isDestroyed || L.commands.setContent(Le);
        });
      }
      bo(P), Zt.current = P, S?.(P);
    }
  }, [L, he, S]), Je = ie((P) => {
    _s(P), yo.current = P, o?.(P);
  }, [o]), Bt = Pz(L, {
    debounceMs: 500,
    extendedStats: !1,
    enabled: u
  });
  if (Nx($n, () => ({
    getEditor: () => L,
    getHTML: () => L?.getHTML() || "",
    getMarkdown: () => L ? he.turndown(L.getHTML()) : "",
    getText: () => L?.getText() || "",
    setContent: (P) => {
      L && !L.isDestroyed && queueMicrotask(() => {
        L.commands.setContent(P);
      });
    },
    clearContent: () => {
      L && !L.isDestroyed && L.commands.clearContent();
    },
    focus: (P) => {
      L && !L.isDestroyed && L.commands.focus(P);
    },
    blur: () => {
      L && !L.isDestroyed && L.commands.blur();
    },
    isEmpty: () => L?.isEmpty || !0,
    isFocused: () => L?.isFocused || !1,
    getMode: () => Zt.current,
    setMode: (P) => He(P),
    toggleMode: () => {
      const P = Zt.current === "wysiwyg" ? "markdown" : "wysiwyg";
      return He(P), P;
    },
    getWordCount: () => ({
      words: Bt.words,
      characters: Bt.characters,
      charactersWithSpaces: Bt.charactersWithSpaces
    }),
    undo: () => L?.commands.undo(),
    redo: () => L?.commands.redo(),
    canUndo: () => L?.can().undo() || !1,
    canRedo: () => L?.can().redo() || !1,
    insertContent: (P) => L?.commands.insertContent(P),
    insertImage: (P, U = "") => L?.commands.setImage({ src: P, alt: U }),
    insertTable: (P = 3, U = 3) => L?.commands.insertTable({ rows: P, cols: U, withHeaderRow: !0 }),
    insertCodeBlock: (P) => {
      P ? L?.commands.setCodeBlock({ language: P }) : L?.commands.setCodeBlock();
    },
    insertCallout: (P = "info") => L?.commands.insertCallout?.({ type: P }),
    insertHorizontalRule: () => L?.commands.setHorizontalRule(),
    toggleBold: () => L?.commands.toggleBold(),
    toggleItalic: () => L?.commands.toggleItalic(),
    toggleUnderline: () => L?.commands.toggleUnderline(),
    toggleStrike: () => L?.commands.toggleStrike(),
    toggleCode: () => L?.commands.toggleCode(),
    toggleHighlight: () => L?.commands.toggleHighlight(),
    setHeading: (P) => {
      P === 0 ? L?.commands.setParagraph() : L?.commands.setHeading({ level: P });
    },
    toggleBulletList: () => L?.commands.toggleBulletList(),
    toggleOrderedList: () => L?.commands.toggleOrderedList(),
    toggleTaskList: () => L?.commands.toggleTaskList(),
    toggleBlockquote: () => L?.commands.toggleBlockquote(),
    setLink: (P) => L?.commands.setLink({ href: P }),
    unsetLink: () => L?.commands.unsetLink(),
    openFindReplace: () => {
      W(!0), Ye((P) => P + 1);
    },
    closeFindReplace: () => W(!1),
    save: () => X.save(),
    clearSavedContent: () => X.clear(),
    getSelectedText: () => {
      if (!L) return "";
      const { from: P, to: U } = L.state.selection;
      return L.state.doc.textBetween(P, U, " ");
    },
    isEditable: () => L?.isEditable || !1,
    setEditable: (P) => L?.setEditable(P),
    /** Get the table of contents headings */
    getTableOfContents: () => {
      if (!L) return [];
      const P = [];
      return L.state.doc.descendants((U, we) => {
        if (U.type.name === "heading") {
          const Le = U.attrs.level, be = U.textContent.trim();
          be && P.push({ id: `toc-heading-${we}`, text: be, level: Le, pos: we });
        }
      }), P;
    },
    /** Scroll to a heading by position */
    scrollToHeading: (P) => {
      if (!(!L || L.isDestroyed))
        try {
          const U = L.state.doc.resolve(P), we = L.view.nodeDOM(U.before(U.depth + 1));
          if (we instanceof HTMLElement) {
            const Le = L.view.dom.closest(".editor-content-wrapper");
            if (Le) {
              const be = Le.getBoundingClientRect(), En = we.getBoundingClientRect().top - be.top + Le.scrollTop;
              Le.scrollTo({ top: En - 20, behavior: "smooth" });
            } else
              we.scrollIntoView({ behavior: "smooth", block: "start" });
          }
          L.commands.setTextSelection(P + 1);
        } catch {
        }
    }
  }), [L, he, He, Bt, X, W]), ge(() => {
    const P = {
      /**
       * Get the current editor mode
       * @returns {'wysiwyg' | 'markdown'} The current mode
       */
      getMode: () => Zt.current,
      /**
       * Set the editor mode
       * @param mode {'wysiwyg' | 'markdown'} The mode to switch to
       */
      setMode: (U) => {
        if (U !== "wysiwyg" && U !== "markdown") {
          console.error('Invalid mode. Use "wysiwyg" or "markdown"');
          return;
        }
        He(U);
      },
      /**
       * Toggle between wysiwyg and markdown modes
       * @returns {'wysiwyg' | 'markdown'} The new mode after toggle
       */
      toggleMode: () => {
        const U = Zt.current === "wysiwyg" ? "markdown" : "wysiwyg";
        return He(U), U;
      },
      /**
       * Switch to visual (WYSIWYG) mode
       */
      switchToVisual: () => {
        He("wysiwyg");
      },
      /**
       * Switch to raw markdown mode
       */
      switchToMarkdown: () => {
        He("markdown");
      },
      /**
       * Check if currently in visual mode
       * @returns {boolean}
       */
      isVisualMode: () => Zt.current === "wysiwyg",
      /**
       * Check if currently in markdown mode
       * @returns {boolean}
       */
      isMarkdownMode: () => Zt.current === "markdown",
      /**
       * Get the raw markdown content (only available in markdown mode)
       * @returns {string | null} The raw markdown or null if in visual mode
       */
      getRawMarkdown: () => Zt.current === "markdown" ? yo.current : null,
      /**
       * Subscribe to mode changes
       * @param callback Function to call when mode changes
       * @returns Function to unsubscribe
       */
      onModeChange: (U) => {
        const we = (Le) => {
          U(Le.detail.mode);
        };
        return window.addEventListener("manus-editor-mode-change", we), () => window.removeEventListener("manus-editor-mode-change", we);
      }
    };
    return window.__manusEditorModeAPI = P, console.log("Manus Editor Mode API exposed globally as window.__manusEditorModeAPI"), console.log("Available methods: getMode(), setMode(mode), toggleMode(), switchToVisual(), switchToMarkdown(), isVisualMode(), isMarkdownMode(), getRawMarkdown(), onModeChange(callback)"), () => {
      delete window.__manusEditorModeAPI;
    };
  }, [He]), ge(() => {
    window.dispatchEvent(new CustomEvent("manus-editor-mode-change", { detail: { mode: Xt } }));
  }, [Xt]), ge(() => {
    if (!L || L.isDestroyed) return;
    const P = (U) => {
      if (!L.isDestroyed) {
        if ((U.metaKey || U.ctrlKey) && U.key === "k") {
          U.preventDefault(), Pr(!0);
          return;
        }
        if (!Yt && (U.metaKey || U.ctrlKey) && U.key === "f") {
          if (U.preventDefault(), L) {
            const { state: we } = L, { from: Le, to: be } = we.selection;
            if (Le !== be) {
              const Ae = we.doc.textBetween(Le, be, " ");
              Ae.trim() && oe(Ae.trim());
            }
          }
          W(!0), Ye((we) => we + 1);
          return;
        }
        if (!Yt && (U.metaKey || U.ctrlKey) && U.key === "h") {
          U.preventDefault(), W(!0);
          return;
        }
        if (U.key === " ")
          try {
            const { state: we } = L, { selection: Le } = we, { $from: be } = Le, Ae = be.nodeBefore?.textContent || "";
            if (Ae === "#") {
              U.preventDefault(), L.chain().focus().deleteRange({ from: be.pos - 1, to: be.pos }).setHeading({ level: 1 }).run();
              return;
            }
            if (Ae === "##") {
              U.preventDefault(), L.chain().focus().deleteRange({ from: be.pos - 2, to: be.pos }).setHeading({ level: 2 }).run();
              return;
            }
            if (Ae === "###") {
              U.preventDefault(), L.chain().focus().deleteRange({ from: be.pos - 3, to: be.pos }).setHeading({ level: 3 }).run();
              return;
            }
            if (Ae === "-" || Ae === "*") {
              U.preventDefault(), L.chain().focus().deleteRange({ from: be.pos - 1, to: be.pos }).toggleBulletList().run();
              return;
            }
            if (/^\d+\.$/.test(Ae)) {
              U.preventDefault(), L.chain().focus().deleteRange({ from: be.pos - Ae.length, to: be.pos }).toggleOrderedList().run();
              return;
            }
            if (Ae === "[]" || Ae === "[ ]") {
              U.preventDefault(), L.chain().focus().deleteRange({ from: be.pos - Ae.length, to: be.pos }).toggleTaskList().run();
              return;
            }
            if (Ae === ">") {
              U.preventDefault(), L.chain().focus().deleteRange({ from: be.pos - 1, to: be.pos }).toggleBlockquote().run();
              return;
            }
            if (Ae === "```") {
              U.preventDefault(), L.chain().focus().deleteRange({ from: be.pos - 3, to: be.pos }).toggleCodeBlock().run();
              return;
            }
            if (Ae === "---" || Ae === "***") {
              U.preventDefault(), L.chain().focus().deleteRange({ from: be.pos - 3, to: be.pos }).setHorizontalRule().run();
              return;
            }
          } catch (we) {
            console.warn("Space shortcut error:", we);
          }
      }
    };
    return document.addEventListener("keydown", P, !0), () => document.removeEventListener("keydown", P, !0);
  }, [L, Yt, W]), !L)
    return /* @__PURE__ */ y("div", { className: `markdown-editor-container ${l}`, "data-theme": d, children: /* @__PURE__ */ y("div", { className: "editor-loading", children: "Loading editor..." }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
      lineNumber: 1216,
      columnNumber: 9
    }, this) }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
      lineNumber: 1215,
      columnNumber: 7
    }, this);
  const wo = /* @__PURE__ */ y(
    Mz,
    {
      editor: L,
      onOpenLinkPopover: () => Pr(!0),
      className: "flex-1 border-b-0",
      onOpenFindReplace: () => {
        W(!0), Ye((P) => P + 1);
      },
      disabledFeatures: z
    },
    void 0,
    !1,
    {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
      lineNumber: 1223,
      columnNumber: 5
    },
    this
  ), ko = /* @__PURE__ */ y("div", { className: "editor-footer", children: [
    /* @__PURE__ */ y("div", { className: "word-count", children: [
      /* @__PURE__ */ y("span", { children: [
        Bt.words,
        " words"
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
        lineNumber: 1239,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ y("span", { children: [
        Bt.characters,
        " characters"
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
        lineNumber: 1240,
        columnNumber: 9
      }, this)
    ] }, void 0, !0, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
      lineNumber: 1238,
      columnNumber: 7
    }, this),
    f && /* @__PURE__ */ y(
      Bz,
      {
        status: X.status,
        lastSaved: X.lastSaved
      },
      void 0,
      !1,
      {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
        lineNumber: 1243,
        columnNumber: 9
      },
      this
    )
  ] }, void 0, !0, {
    fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
    lineNumber: 1237,
    columnNumber: 5
  }, this), Ic = {
    minHeight: Q,
    ...ue && { maxHeight: ue, overflowY: "auto" }
  };
  return /* @__PURE__ */ y("div", { className: `markdown-editor-container ${l}`, "data-theme": d, children: [
    f && p && X.hasRecoverableContent && /* @__PURE__ */ y(
      zz,
      {
        onRecover: () => {
          X.recover();
        },
        onDismiss: X.dismissRecovery
      },
      void 0,
      !1,
      {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
        lineNumber: 1261,
        columnNumber: 9
      },
      this
    ),
    c && /* @__PURE__ */ y("div", { className: "flex items-center border-b border-border bg-card/50", children: [
      $ ? $(L, wo) : wo,
      w && /* @__PURE__ */ y("div", { className: "editor-mode-toggle mr-2 sm:mr-3", children: [
        /* @__PURE__ */ y(
          "button",
          {
            onClick: () => He("wysiwyg"),
            className: `editor-mode-toggle-btn ${Xt === "wysiwyg" ? "active" : ""}`,
            title: "Visual Editor",
            children: /* @__PURE__ */ y(p2, {}, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
              lineNumber: 1280,
              columnNumber: 17
            }, this)
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
            lineNumber: 1275,
            columnNumber: 15
          },
          this
        ),
        /* @__PURE__ */ y(
          "button",
          {
            onClick: () => He("markdown"),
            className: `editor-mode-toggle-btn ${Xt === "markdown" ? "active" : ""}`,
            title: "Raw Markdown",
            children: /* @__PURE__ */ y(Vo, {}, void 0, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
              lineNumber: 1287,
              columnNumber: 17
            }, this)
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
            lineNumber: 1282,
            columnNumber: 15
          },
          this
        )
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
        lineNumber: 1274,
        columnNumber: 13
      }, this)
    ] }, void 0, !0, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
      lineNumber: 1271,
      columnNumber: 9
    }, this),
    !Yt && /* @__PURE__ */ y(
      Az,
      {
        editor: L,
        isOpen: I,
        onClose: () => W(!1),
        focusTrigger: ye,
        initialSearchQuery: Ze
      },
      void 0,
      !1,
      {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
        lineNumber: 1296,
        columnNumber: 9
      },
      this
    ),
    /* @__PURE__ */ y(Oz, { editor: L }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
      lineNumber: 1306,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ y("div", { className: `editor-main-area ${me ? "editor-with-toc" : ""}`, children: [
      me && ln === "left" && /* @__PURE__ */ y(
        Wg,
        {
          editor: L,
          visible: at,
          onVisibilityChange: Ht,
          title: gt,
          minLevel: jt,
          maxLevel: Ft,
          showLevelIndicators: an,
          highlightActive: mo,
          treeView: po,
          width: Be,
          position: ln,
          scrollOffset: Nn,
          onItemClick: go,
          renderItem: hi,
          showToggleButton: Cs,
          scrollContainerRef: vo
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
          lineNumber: 1312,
          columnNumber: 9
        },
        this
      ),
      /* @__PURE__ */ y("div", { className: "editor-content-wrapper", ref: vo, style: Ic, children: Xt === "wysiwyg" ? /* @__PURE__ */ y(fn, { children: [
        /* @__PURE__ */ y(F0, { editor: L, className: "editor-content" }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
          lineNumber: 1334,
          columnNumber: 13
        }, this),
        !z.images && !z.dragAndDrop && /* @__PURE__ */ y(s3, { containerRef: vo, enabled: s }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
          lineNumber: 1338,
          columnNumber: 15
        }, this),
        !Yt && g && /* @__PURE__ */ y(H2, { editor: L }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
          lineNumber: 1344,
          columnNumber: 50
        }, this),
        !z.slashCommands && /* @__PURE__ */ y(nD, { editor: L, disabledFeatures: z }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
          lineNumber: 1347,
          columnNumber: 49
        }, this),
        /* @__PURE__ */ y(
          z2,
          {
            editor: L,
            isOpen: Rs,
            onClose: () => Pr(!1)
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
            lineNumber: 1350,
            columnNumber: 13
          },
          this
        ),
        !Yt && /* @__PURE__ */ y(
          $2,
          {
            editor: L,
            onEditLink: () => Pr(!0)
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
            lineNumber: 1358,
            columnNumber: 15
          },
          this
        ),
        !z.images && nr?.isOpen && /* @__PURE__ */ y(
          a3,
          {
            src: nr.src,
            alt: nr.alt,
            position: nr.position,
            onSave: (P, U) => {
              L.chain().focus().setNodeSelection(nr.pos).updateAttributes("resizableImage", {
                src: P,
                alt: U
              }).run(), Br(null);
            },
            onDelete: () => {
              L.chain().focus().setNodeSelection(nr.pos).deleteSelection().run(), Br(null);
            },
            onClose: () => Br(null)
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
            lineNumber: 1366,
            columnNumber: 15
          },
          this
        )
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
        lineNumber: 1333,
        columnNumber: 11
      }, this) : /* @__PURE__ */ y(
        d3,
        {
          content: As,
          onChange: Je,
          placeholder: "Write your markdown here...",
          editable: s,
          autofocus: !0
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
          lineNumber: 1388,
          columnNumber: 11
        },
        this
      ) }, void 0, !1, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
        lineNumber: 1331,
        columnNumber: 7
      }, this),
      me && ln === "right" && /* @__PURE__ */ y(
        Wg,
        {
          editor: L,
          visible: at,
          onVisibilityChange: Ht,
          title: gt,
          minLevel: jt,
          maxLevel: Ft,
          showLevelIndicators: an,
          highlightActive: mo,
          treeView: po,
          width: Be,
          position: ln,
          scrollOffset: Nn,
          onItemClick: go,
          renderItem: hi,
          showToggleButton: Cs,
          scrollContainerRef: vo
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
          lineNumber: 1399,
          columnNumber: 9
        },
        this
      )
    ] }, void 0, !0, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
      lineNumber: 1309,
      columnNumber: 7
    }, this),
    u && (_ ? _(
      { words: Bt.words, characters: Bt.characters },
      X.status,
      ko
    ) : ko),
    /* @__PURE__ */ y(h3, { visible: _c, onClose: Ms, editor: L }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
      lineNumber: 1432,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/MarkdownEditor.tsx",
    lineNumber: 1258,
    columnNumber: 5
  }, this);
}), F$ = rt.create({
  name: "callout",
  addOptions() {
    return {
      HTMLAttributes: {},
      types: ["info", "warning", "error", "success", "note"]
    };
  },
  content: "block+",
  group: "block",
  defining: !0,
  addAttributes() {
    return {
      type: {
        default: "info",
        parseHTML: (t) => t.getAttribute("data-type") || "info",
        renderHTML: (t) => ({
          "data-type": t.type
        })
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "div[data-callout]"
      }
    ];
  },
  renderHTML({ node: t, HTMLAttributes: e }) {
    const n = t.attrs.type;
    return [
      "div",
      De(this.options.HTMLAttributes, e, {
        "data-callout": "",
        "data-type": n,
        class: `callout callout-${n}`
      }),
      0
    ];
  },
  addCommands() {
    return {
      setCallout: (t) => ({ commands: e }) => e.wrapIn(this.name, t),
      toggleCallout: (t) => ({ commands: e }) => e.toggleWrap(this.name, t),
      unsetCallout: () => ({ commands: t }) => t.lift(this.name),
      insertCallout: (t) => ({ chain: e }) => {
        const n = t?.type || "info";
        return e().insertContent({
          type: this.name,
          attrs: { type: n },
          content: [{ type: "paragraph" }]
        }).focus().run();
      }
    };
  },
  addKeyboardShortcuts() {
    return {
      "Mod-Shift-c": () => this.editor.commands.toggleCallout({ type: "info" })
    };
  }
}), cx = {
  name: "dark",
  description: "Dark theme inspired by VS Code and GitHub Dark",
  variables: {
    // Base colors
    "--editor-bg": "oklch(0.13 0.01 250)",
    "--editor-fg": "oklch(0.93 0.01 250)",
    "--editor-border": "oklch(0.28 0.01 250)",
    // Primary accent
    "--editor-primary": "oklch(0.7 0.15 220)",
    "--editor-primary-fg": "oklch(0.13 0.01 250)",
    // Secondary
    "--editor-secondary": "oklch(0.22 0.01 250)",
    "--editor-secondary-fg": "oklch(0.75 0.02 250)",
    // Muted
    "--editor-muted": "oklch(0.25 0.01 250)",
    "--editor-muted-fg": "oklch(0.6 0.02 250)",
    // Selection
    "--editor-selection": "oklch(0.35 0.08 220 / 0.4)",
    "--editor-cursor": "oklch(0.7 0.15 220)",
    // Code block
    "--editor-code-bg": "oklch(0.17 0.01 250)",
    "--editor-line-number": "oklch(0.45 0.02 250)",
    // Callouts
    "--editor-callout-info": "oklch(0.5 0.12 220)",
    "--editor-callout-warning": "oklch(0.6 0.15 70)",
    "--editor-callout-error": "oklch(0.5 0.15 25)",
    "--editor-callout-success": "oklch(0.5 0.12 160)",
    "--editor-callout-note": "oklch(0.5 0.12 280)",
    // Syntax highlighting
    "--syntax-keyword": "oklch(0.7 0.18 320)",
    "--syntax-string": "oklch(0.7 0.12 160)",
    "--syntax-number": "oklch(0.75 0.12 70)",
    "--syntax-comment": "oklch(0.5 0.02 250)",
    "--syntax-function": "oklch(0.75 0.15 280)",
    "--syntax-variable": "oklch(0.8 0.1 220)"
  }
}, R$ = {
  name: "light",
  description: "Light theme for bright environments",
  variables: {
    // Base colors
    "--editor-bg": "oklch(0.99 0.005 250)",
    "--editor-fg": "oklch(0.2 0.01 250)",
    "--editor-border": "oklch(0.88 0.01 250)",
    // Primary accent
    "--editor-primary": "oklch(0.55 0.2 220)",
    "--editor-primary-fg": "oklch(0.99 0.005 250)",
    // Secondary
    "--editor-secondary": "oklch(0.95 0.01 250)",
    "--editor-secondary-fg": "oklch(0.4 0.02 250)",
    // Muted
    "--editor-muted": "oklch(0.92 0.01 250)",
    "--editor-muted-fg": "oklch(0.5 0.02 250)",
    // Selection
    "--editor-selection": "oklch(0.7 0.12 220 / 0.3)",
    "--editor-cursor": "oklch(0.55 0.2 220)",
    // Code block
    "--editor-code-bg": "oklch(0.96 0.005 250)",
    "--editor-line-number": "oklch(0.6 0.02 250)",
    // Callouts
    "--editor-callout-info": "oklch(0.6 0.15 220)",
    "--editor-callout-warning": "oklch(0.7 0.18 70)",
    "--editor-callout-error": "oklch(0.6 0.18 25)",
    "--editor-callout-success": "oklch(0.6 0.15 160)",
    "--editor-callout-note": "oklch(0.6 0.15 280)",
    // Syntax highlighting
    "--syntax-keyword": "oklch(0.5 0.2 320)",
    "--syntax-string": "oklch(0.45 0.15 160)",
    "--syntax-number": "oklch(0.5 0.15 70)",
    "--syntax-comment": "oklch(0.55 0.02 250)",
    "--syntax-function": "oklch(0.5 0.18 280)",
    "--syntax-variable": "oklch(0.45 0.12 220)"
  }
}, O$ = {
  name: "sepia",
  description: "Warm sepia tones for comfortable reading",
  variables: {
    // Base colors
    "--editor-bg": "oklch(0.95 0.02 80)",
    "--editor-fg": "oklch(0.25 0.02 60)",
    "--editor-border": "oklch(0.85 0.03 70)",
    // Primary accent
    "--editor-primary": "oklch(0.55 0.15 50)",
    "--editor-primary-fg": "oklch(0.98 0.01 80)",
    // Secondary
    "--editor-secondary": "oklch(0.9 0.025 75)",
    "--editor-secondary-fg": "oklch(0.4 0.02 60)",
    // Muted
    "--editor-muted": "oklch(0.88 0.02 75)",
    "--editor-muted-fg": "oklch(0.5 0.02 60)",
    // Selection
    "--editor-selection": "oklch(0.7 0.1 50 / 0.3)",
    "--editor-cursor": "oklch(0.55 0.15 50)",
    // Code block
    "--editor-code-bg": "oklch(0.92 0.02 75)",
    "--editor-line-number": "oklch(0.6 0.02 60)",
    // Callouts
    "--editor-callout-info": "oklch(0.55 0.12 220)",
    "--editor-callout-warning": "oklch(0.65 0.15 50)",
    "--editor-callout-error": "oklch(0.55 0.15 25)",
    "--editor-callout-success": "oklch(0.55 0.12 160)",
    "--editor-callout-note": "oklch(0.55 0.12 280)",
    // Syntax highlighting
    "--syntax-keyword": "oklch(0.5 0.15 320)",
    "--syntax-string": "oklch(0.45 0.12 160)",
    "--syntax-number": "oklch(0.5 0.12 50)",
    "--syntax-comment": "oklch(0.55 0.02 60)",
    "--syntax-function": "oklch(0.5 0.15 280)",
    "--syntax-variable": "oklch(0.45 0.1 220)"
  }
}, I$ = {
  name: "nord",
  description: "Arctic, north-bluish color palette",
  variables: {
    // Base colors (Nord Polar Night)
    "--editor-bg": "oklch(0.23 0.02 240)",
    "--editor-fg": "oklch(0.9 0.01 230)",
    "--editor-border": "oklch(0.32 0.02 240)",
    // Primary accent (Nord Frost)
    "--editor-primary": "oklch(0.72 0.1 210)",
    "--editor-primary-fg": "oklch(0.23 0.02 240)",
    // Secondary
    "--editor-secondary": "oklch(0.28 0.02 240)",
    "--editor-secondary-fg": "oklch(0.75 0.01 230)",
    // Muted
    "--editor-muted": "oklch(0.35 0.02 240)",
    "--editor-muted-fg": "oklch(0.6 0.01 230)",
    // Selection
    "--editor-selection": "oklch(0.5 0.08 210 / 0.4)",
    "--editor-cursor": "oklch(0.72 0.1 210)",
    // Code block
    "--editor-code-bg": "oklch(0.26 0.02 240)",
    "--editor-line-number": "oklch(0.5 0.01 230)",
    // Callouts (Nord Aurora)
    "--editor-callout-info": "oklch(0.68 0.12 210)",
    "--editor-callout-warning": "oklch(0.75 0.12 80)",
    "--editor-callout-error": "oklch(0.65 0.15 15)",
    "--editor-callout-success": "oklch(0.7 0.12 150)",
    "--editor-callout-note": "oklch(0.7 0.1 280)",
    // Syntax highlighting
    "--syntax-keyword": "oklch(0.7 0.12 280)",
    "--syntax-string": "oklch(0.7 0.1 150)",
    "--syntax-number": "oklch(0.75 0.1 280)",
    "--syntax-comment": "oklch(0.55 0.01 230)",
    "--syntax-function": "oklch(0.72 0.1 210)",
    "--syntax-variable": "oklch(0.9 0.01 230)"
  }
}, Li = {
  dark: cx,
  light: R$,
  sepia: O$,
  nord: I$
};
function D$(t, e) {
  Object.entries(e.variables).forEach(([n, r]) => {
    t.style.setProperty(n, r);
  });
}
function U$(t, e, n, r) {
  const o = Li[t] || cx;
  return {
    name: e,
    description: n,
    variables: {
      ...o.variables,
      ...r
    }
  };
}
const ux = jl(null);
function W$({
  children: t,
  defaultTheme: e = "dark",
  containerRef: n
}) {
  const [r, o] = J(e), i = Li[r] || Li.dark, s = ie((l) => {
    Li[l] && o(l);
  }, []);
  ge(() => {
    n?.current && D$(n.current, i);
  }, [i, n]);
  const a = {
    theme: i,
    themeName: r,
    setTheme: s,
    availableThemes: Object.keys(Li)
  };
  return /* @__PURE__ */ y(ux.Provider, { value: a, children: t }, void 0, !1, {
    fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/ThemeProvider.tsx",
    lineNumber: 54,
    columnNumber: 5
  }, this);
}
function V$() {
  const t = Yl(ux);
  if (!t)
    throw new Error("useEditorTheme must be used within an EditorThemeProvider");
  return t;
}
const Qg = [
  { value: "plaintext", label: "Plain Text" },
  { value: "javascript", label: "JavaScript" },
  { value: "typescript", label: "TypeScript" },
  { value: "jsx", label: "JSX" },
  { value: "tsx", label: "TSX" },
  { value: "python", label: "Python" },
  { value: "java", label: "Java" },
  { value: "cpp", label: "C++" },
  { value: "c", label: "C" },
  { value: "csharp", label: "C#" },
  { value: "go", label: "Go" },
  { value: "rust", label: "Rust" },
  { value: "ruby", label: "Ruby" },
  { value: "php", label: "PHP" },
  { value: "swift", label: "Swift" },
  { value: "kotlin", label: "Kotlin" },
  { value: "html", label: "HTML" },
  { value: "css", label: "CSS" },
  { value: "scss", label: "SCSS" },
  { value: "json", label: "JSON" },
  { value: "yaml", label: "YAML" },
  { value: "markdown", label: "Markdown" },
  { value: "sql", label: "SQL" },
  { value: "bash", label: "Bash" },
  { value: "shell", label: "Shell" }
];
function K$({ node: t, updateAttributes: e }) {
  const [n, r] = J(!1), o = t.attrs.language || "plaintext";
  Qg.find((s) => s.value === o)?.label;
  const i = ie(() => {
    const s = t.textContent;
    navigator.clipboard.writeText(s).then(() => {
      r(!0), setTimeout(() => r(!1), 2e3);
    });
  }, [t.textContent]);
  return /* @__PURE__ */ y(pc, { className: "code-block-wrapper", children: [
    /* @__PURE__ */ y("div", { className: "code-block-controls", contentEditable: !1, children: [
      /* @__PURE__ */ y("div", { className: "code-block-language-wrapper", children: [
        /* @__PURE__ */ y(
          "select",
          {
            value: o,
            onChange: (s) => e({ language: s.target.value }),
            className: "code-block-language-select",
            children: Qg.map(({ value: s, label: a }) => /* @__PURE__ */ y("option", { value: s, children: a }, s, !1, {
              fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/CodeBlockComponent.tsx",
              lineNumber: 64,
              columnNumber: 15
            }, this))
          },
          void 0,
          !1,
          {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/CodeBlockComponent.tsx",
            lineNumber: 58,
            columnNumber: 11
          },
          this
        ),
        /* @__PURE__ */ y(vc, { size: 12, className: "code-block-language-chevron" }, void 0, !1, {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/CodeBlockComponent.tsx",
          lineNumber: 69,
          columnNumber: 11
        }, this)
      ] }, void 0, !0, {
        fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/CodeBlockComponent.tsx",
        lineNumber: 57,
        columnNumber: 9
      }, this),
      /* @__PURE__ */ y(
        "button",
        {
          onClick: i,
          className: `code-block-copy-btn ${n ? "copied" : ""}`,
          title: n ? "Copied!" : "Copy code",
          children: n ? /* @__PURE__ */ y(yc, { size: 14 }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/CodeBlockComponent.tsx",
            lineNumber: 76,
            columnNumber: 21
          }, this) : /* @__PURE__ */ y(eh, { size: 14 }, void 0, !1, {
            fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/CodeBlockComponent.tsx",
            lineNumber: 76,
            columnNumber: 43
          }, this)
        },
        void 0,
        !1,
        {
          fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/CodeBlockComponent.tsx",
          lineNumber: 71,
          columnNumber: 9
        },
        this
      )
    ] }, void 0, !0, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/CodeBlockComponent.tsx",
      lineNumber: 56,
      columnNumber: 7
    }, this),
    /* @__PURE__ */ y("pre", { className: "code-block-pre", children: /* @__PURE__ */ y("code", { children: /* @__PURE__ */ y(Bf, {}, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/CodeBlockComponent.tsx",
      lineNumber: 83,
      columnNumber: 11
    }, this) }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/CodeBlockComponent.tsx",
      lineNumber: 82,
      columnNumber: 9
    }, this) }, void 0, !1, {
      fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/CodeBlockComponent.tsx",
      lineNumber: 81,
      columnNumber: 7
    }, this)
  ] }, void 0, !0, {
    fileName: "/home/ubuntu/manus-markdown-editor/client/src/components/editor/CodeBlockComponent.tsx",
    lineNumber: 54,
    columnNumber: 5
  }, this);
}
export {
  Bz as AutoSaveIndicator,
  F$ as Callout,
  Xz as CalloutInputRule,
  K$ as CodeBlockComponent,
  Kz as CollapsibleHeading,
  Q2 as DatePill,
  W$ as EditorThemeProvider,
  Mz as EditorToolbar,
  Az as FindReplace,
  H2 as FloatingToolbar,
  s3 as ImageDropZone,
  i3 as ImageUpload,
  H$ as MarkdownEditor,
  jz as MarkdownLinkInputRule,
  Vz as MarkdownPasteSafe,
  zz as RecoveryBanner,
  G2 as ResizableImage,
  Zz as SearchHighlight,
  Oz as SelectAllActionBar,
  e3 as SelectAllOccurrences,
  nD as SlashCommands,
  Jz as TabIndent,
  Wg as TableOfContents,
  Hz as WikiLinkSafe,
  D$ as applyTheme,
  U$ as createCustomTheme,
  cx as darkTheme,
  R$ as lightTheme,
  I$ as nordTheme,
  O$ as sepiaTheme,
  Li as themes,
  Dz as useAutoSave,
  V$ as useEditorTheme,
  Pz as useWordCount
};
//# sourceMappingURL=manus-editor.js.map
